From 4245c1454f5ab416bc8c3a63f7e88ac6f6f6cb39 Mon Sep 17 00:00:00 2001
From: Liu Haitao <haitao.liu@windriver.com>
Date: Tue, 27 Dec 2022 23:57:47 -0800
Subject: [PATCH] nginx: merge test from nginx-tests repo

Signed-off-by: Liu Haitao <haitao.liu@windriver.com>
---
 tests/LICENSE                                 |   24 +
 tests/README                                  |   51 +
 tests/access.t                                |  108 ++
 tests/access_log.t                            |  278 ++++
 tests/access_log_variables.t                  |  127 ++
 tests/addition.t                              |  117 ++
 tests/addition_buffered.t                     |   67 +
 tests/auth_basic.t                            |  130 ++
 tests/auth_delay.t                            |   85 ++
 tests/auth_request.t                          |  256 ++++
 tests/auth_request_satisfy.t                  |  136 ++
 tests/auth_request_set.t                      |  144 ++
 tests/autoindex.t                             |  109 ++
 tests/autoindex_format.t                      |  175 +++
 tests/binary_upgrade.t                        |   56 +
 tests/body.t                                  |  220 +++
 tests/body_chunked.t                          |  236 ++++
 tests/charset.t                               |  102 ++
 tests/charset_gzip_static.t                   |  144 ++
 tests/config_dump.t                           |  112 ++
 tests/dav.t                                   |  272 ++++
 tests/dav_chunked.t                           |  102 ++
 tests/debug_connection.t                      |   73 +
 tests/debug_connection_syslog.t               |  100 ++
 tests/debug_connection_unix.t                 |   73 +
 tests/empty_gif.t                             |   96 ++
 tests/error_log.t                             |  196 +++
 tests/fastcgi.t                               |  114 ++
 tests/fastcgi_body.t                          |  183 +++
 tests/fastcgi_body2.t                         |  133 ++
 tests/fastcgi_buffering.t                     |  101 ++
 tests/fastcgi_cache.t                         |  106 ++
 tests/fastcgi_header_params.t                 |  115 ++
 tests/fastcgi_keepalive.t                     |  185 +++
 tests/fastcgi_merge_params.t                  |  138 ++
 tests/fastcgi_merge_params2.t                 |  122 ++
 tests/fastcgi_request_buffering.t             |  373 +++++
 tests/fastcgi_request_buffering_chunked.t     |  423 ++++++
 tests/fastcgi_split.t                         |   98 ++
 tests/fastcgi_unix.t                          |  119 ++
 tests/fastcgi_variables.t                     |   90 ++
 tests/geo.t                                   |  250 ++++
 tests/geo_binary.t                            |   84 ++
 tests/geo_ipv6.t                              |  122 ++
 tests/geo_unix.t                              |  103 ++
 tests/geoip.t                                 |  198 +++
 tests/grpc.t                                  |  724 ++++++++++
 tests/grpc_next_upstream.t                    |  146 ++
 tests/grpc_pass.t                             |  192 +++
 tests/grpc_request_buffering.t                |  196 +++
 tests/grpc_ssl.t                              |  303 ++++
 tests/gunzip.t                                |  114 ++
 tests/gunzip_memcached.t                      |   92 ++
 tests/gunzip_perl.t                           |   72 +
 tests/gunzip_ssi.t                            |   93 ++
 tests/gunzip_static.t                         |  104 ++
 tests/gzip.t                                  |   97 ++
 tests/gzip_flush.t                            |   72 +
 tests/h2.t                                    | 1232 +++++++++++++++++
 tests/h2_auth_request.t                       |   86 ++
 tests/h2_fastcgi_request_buffering.t          |  279 ++++
 tests/h2_headers.t                            | 1199 ++++++++++++++++
 tests/h2_limit_conn.t                         |   98 ++
 tests/h2_limit_req.t                          |  175 +++
 tests/h2_max_requests.t                       |   80 ++
 tests/h2_priority.t                           |  457 ++++++
 tests/h2_proxy_cache.t                        |  166 +++
 tests/h2_proxy_protocol.t                     |   80 ++
 tests/h2_proxy_request_buffering.t            |  281 ++++
 tests/h2_proxy_request_buffering_redirect.t   |   99 ++
 tests/h2_proxy_request_buffering_ssl.t        |  286 ++++
 tests/h2_proxy_ssl.t                          |   92 ++
 tests/h2_request_body.t                       |  475 +++++++
 tests/h2_request_body_preread.t               |  199 +++
 tests/h2_server_push.t                        |  446 ++++++
 tests/h2_server_tokens.t                      |  139 ++
 tests/h2_ssl.t                                |  131 ++
 tests/h2_ssl_proxy_cache.t                    |  150 ++
 tests/h2_ssl_variables.t                      |  213 +++
 tests/h2_ssl_verify_client.t                  |  159 +++
 tests/h2_trailers.t                           |  133 ++
 tests/h2_variables.t                          |  130 ++
 tests/headers.t                               |  182 +++
 tests/http_absolute_redirect.t                |  118 ++
 tests/http_disable_symlinks.t                 |  288 ++++
 tests/http_error_page.t                       |  153 ++
 tests/http_expect_100_continue.t              |  107 ++
 tests/http_header_buffers.t                   |  248 ++++
 tests/http_host.t                             |  201 +++
 tests/http_include.t                          |  102 ++
 tests/http_keepalive.t                        |  166 +++
 tests/http_listen.t                           |   97 ++
 tests/http_location.t                         |  132 ++
 tests/http_location_auto.t                    |   73 +
 tests/http_location_win32.t                   |  118 ++
 tests/http_resolver.t                         |  595 ++++++++
 tests/http_resolver_aaaa.t                    |  628 +++++++++
 tests/http_resolver_cleanup.t                 |  104 ++
 tests/http_resolver_cname.t                   |  282 ++++
 tests/http_server_name.t                      |  232 ++++
 tests/http_try_files.t                        |  123 ++
 tests/http_uri.t                              |   65 +
 tests/http_variables.t                        |   96 ++
 tests/ignore_invalid_headers.t                |  171 +++
 tests/image_filter.t                          |  343 +++++
 tests/image_filter_finalize.t                 |  151 ++
 tests/image_filter_webp.t                     |  129 ++
 tests/index.t                                 |  129 ++
 tests/js.t                                    |  355 +++++
 tests/js_async.t                              |  183 +++
 tests/js_dump.t                               |  122 ++
 tests/js_headers.t                            |  432 ++++++
 tests/js_import.t                             |  108 ++
 tests/js_internal_redirect.t                  |   94 ++
 tests/js_modules.t                            |   90 ++
 tests/js_object.t                             |  149 ++
 tests/js_paths.t                              |  116 ++
 tests/js_promise.t                            |  187 +++
 tests/js_request_body.t                       |  116 ++
 tests/js_return.t                             |   79 ++
 tests/js_subrequests.t                        |  645 +++++++++
 tests/js_variables.t                          |  101 ++
 tests/lib/Test/Nginx.pm                       |  868 ++++++++++++
 tests/lib/Test/Nginx/HTTP2.pm                 | 1103 +++++++++++++++
 tests/lib/Test/Nginx/IMAP.pm                  |  135 ++
 tests/lib/Test/Nginx/POP3.pm                  |  132 ++
 tests/lib/Test/Nginx/SMTP.pm                  |  148 ++
 tests/lib/Test/Nginx/Stream.pm                |  140 ++
 tests/limit_conn.t                            |  118 ++
 tests/limit_conn_complex.t                    |   99 ++
 tests/limit_conn_dry_run.t                    |   95 ++
 tests/limit_rate.t                            |  114 ++
 tests/limit_req.t                             |   97 ++
 tests/limit_req2.t                            |   97 ++
 tests/limit_req_delay.t                       |   65 +
 tests/limit_req_dry_run.t                     |   92 ++
 tests/mail_capability.t                       |  228 +++
 tests/mail_error_log.t                        |  267 ++++
 tests/mail_imap.t                             |  172 +++
 tests/mail_imap_ssl.t                         |  226 +++
 tests/mail_pop3.t                             |  212 +++
 tests/mail_resolver.t                         |  452 ++++++
 tests/mail_smtp.t                             |  268 ++++
 tests/mail_smtp_greeting_delay.t              |   59 +
 tests/mail_smtp_xclient.t                     |  141 ++
 tests/mail_ssl.t                              |  312 +++++
 tests/map.t                                   |  117 ++
 tests/map_complex.t                           |   71 +
 tests/map_volatile.t                          |   83 ++
 tests/memcached.t                             |   93 ++
 tests/memcached_fake.t                        |  106 ++
 tests/memcached_keepalive.t                   |  193 +++
 tests/memcached_keepalive_stale.t             |  121 ++
 tests/merge_slashes.t                         |   60 +
 tests/mirror.t                                |   86 ++
 tests/mirror_proxy.t                          |  128 ++
 tests/mp4.t                                   |  167 +++
 tests/mp4_ssi.t                               |   83 ++
 tests/msie_refresh.t                          |   96 ++
 tests/not_modified.t                          |  126 ++
 tests/not_modified_finalize.t                 |  107 ++
 tests/not_modified_proxy.t                    |  142 ++
 tests/perl.t                                  |  315 +++++
 tests/perl_gzip.t                             |   83 ++
 tests/perl_sleep.t                            |   76 +
 tests/perl_ssi.t                              |   65 +
 tests/post_action.t                           |   81 ++
 tests/proxy.t                                 |  292 ++++
 tests/proxy_bind.t                            |   98 ++
 tests/proxy_bind_transparent.t                |   71 +
 tests/proxy_bind_transparent_capability.t     |   72 +
 tests/proxy_cache.t                           |  144 ++
 tests/proxy_cache_bypass.t                    |   98 ++
 tests/proxy_cache_chunked.t                   |  102 ++
 tests/proxy_cache_convert_head.t              |   96 ++
 tests/proxy_cache_error.t                     |   86 ++
 tests/proxy_cache_lock.t                      |  164 +++
 tests/proxy_cache_lock_age.t                  |  151 ++
 tests/proxy_cache_lock_ssi.t                  |  105 ++
 tests/proxy_cache_manager.t                   |  119 ++
 tests/proxy_cache_max_range_offset.t          |  119 ++
 tests/proxy_cache_path.t                      |   87 ++
 tests/proxy_cache_range.t                     |  121 ++
 tests/proxy_cache_revalidate.t                |  168 +++
 tests/proxy_cache_use_stale.t                 |  297 ++++
 tests/proxy_cache_valid.t                     |  132 ++
 tests/proxy_cache_variables.t                 |   94 ++
 tests/proxy_cache_vary.t                      |  264 ++++
 tests/proxy_chunked.t                         |  111 ++
 tests/proxy_cookie.t                          |  112 ++
 tests/proxy_force_ranges.t                    |  133 ++
 tests/proxy_if.t                              |  241 ++++
 tests/proxy_keepalive.t                       |  356 +++++
 tests/proxy_limit_rate.t                      |   92 ++
 tests/proxy_merge_headers.t                   |  114 ++
 tests/proxy_method.t                          |   86 ++
 tests/proxy_next_upstream.t                   |  136 ++
 tests/proxy_next_upstream_tries.t             |  258 ++++
 tests/proxy_noclose.t                         |  151 ++
 tests/proxy_non_idempotent.t                  |  136 ++
 tests/proxy_pass_request.t                    |  138 ++
 tests/proxy_protocol.t                        |  141 ++
 tests/proxy_protocol2.t                       |  147 ++
 tests/proxy_protocol2_server.t                |  154 +++
 tests/proxy_protocol_ipv6.t                   |   78 ++
 tests/proxy_protocol_server.t                 |  147 ++
 tests/proxy_redirect.t                        |  153 ++
 tests/proxy_request_buffering.t               |  288 ++++
 tests/proxy_request_buffering_chunked.t       |  339 +++++
 tests/proxy_request_buffering_keepalive.t     |   87 ++
 tests/proxy_request_buffering_ssl.t           |  309 +++++
 tests/proxy_set_body.t                        |   81 ++
 tests/proxy_ssi_body.t                        |   84 ++
 tests/proxy_ssl.t                             |  188 +++
 tests/proxy_ssl_certificate.t                 |  147 ++
 tests/proxy_ssl_keepalive.t                   |  106 ++
 tests/proxy_ssl_name.t                        |  153 ++
 tests/proxy_ssl_verify.t                      |  168 +++
 tests/proxy_store.t                           |  102 ++
 tests/proxy_unfinished.t                      |  260 ++++
 tests/proxy_unix.t                            |  155 +++
 tests/proxy_upgrade.t                         |  344 +++++
 tests/proxy_upstream_cookie.t                 |  119 ++
 tests/proxy_variables.t                       |  134 ++
 tests/proxy_websocket.t                       |  302 ++++
 tests/proxy_xar.t                             |  124 ++
 tests/random_index.t                          |   64 +
 tests/range.t                                 |  170 +++
 tests/range_charset.t                         |  116 ++
 tests/range_flv.t                             |   92 ++
 tests/range_if_range.t                        |  108 ++
 tests/range_mp4.t                             |  115 ++
 tests/realip.t                                |  143 ++
 tests/realip_hostname.t                       |   85 ++
 tests/realip_remote_addr.t                    |   85 ++
 tests/realip_remote_port.t                    |   97 ++
 tests/referer.t                               |  210 +++
 tests/request_id.t                            |  110 ++
 tests/rewrite.t                               |  249 ++++
 tests/rewrite_if.t                            |  195 +++
 tests/rewrite_set.t                           |   98 ++
 tests/rewrite_unescape.t                      |  163 +++
 tests/scgi.t                                  |  144 ++
 tests/scgi_body.t                             |  133 ++
 tests/scgi_cache.t                            |  143 ++
 tests/scgi_gzip.t                             |   88 ++
 tests/scgi_merge_params.t                     |  143 ++
 tests/secure_link.t                           |  191 +++
 tests/server_tokens.t                         |  126 ++
 tests/slice.t                                 |  330 +++++
 tests/split_clients.t                         |   85 ++
 tests/ssi.t                                   |  193 +++
 tests/ssi_delayed.t                           |  118 ++
 tests/ssi_if.t                                |  273 ++++
 tests/ssi_include_big.t                       |   89 ++
 tests/ssi_waited.t                            |   62 +
 tests/ssl.t                                   |  371 +++++
 tests/ssl_certificate.t                       |  234 ++++
 tests/ssl_certificate_chain.t                 |  179 +++
 tests/ssl_certificate_perl.t                  |  134 ++
 tests/ssl_certificates.t                      |  155 +++
 tests/ssl_client_escaped_cert.t               |  126 ++
 tests/ssl_crl.t                               |  203 +++
 tests/ssl_engine_keys.t                       |  149 ++
 tests/ssl_password_file.t                     |  169 +++
 tests/ssl_proxy_protocol.t                    |  180 +++
 tests/ssl_proxy_upgrade.t                     |  367 +++++
 tests/ssl_sni.t                               |  216 +++
 tests/ssl_sni_reneg.t                         |  180 +++
 tests/ssl_sni_sessions.t                      |  219 +++
 tests/ssl_stapling.t                          |  406 ++++++
 tests/ssl_verify_client.t                     |  203 +++
 tests/ssl_verify_depth.t                      |  167 +++
 tests/stream_access.t                         |  227 +++
 tests/stream_access_log.t                     |  207 +++
 tests/stream_access_log_escape.t              |   68 +
 tests/stream_access_log_none.t                |   65 +
 tests/stream_error_log.t                      |  310 +++++
 tests/stream_geo.t                            |  253 ++++
 tests/stream_geo_binary.t                     |   72 +
 tests/stream_geo_ipv6.t                       |  103 ++
 tests/stream_geo_unix.t                       |   85 ++
 tests/stream_geoip.t                          |  193 +++
 tests/stream_js.t                             |  441 ++++++
 tests/stream_js_import.t                      |  115 ++
 tests/stream_js_object.t                      |  119 ++
 tests/stream_js_variables.t                   |   99 ++
 tests/stream_limit_conn.t                     |  136 ++
 tests/stream_limit_conn_complex.t             |   99 ++
 tests/stream_limit_conn_dry_run.t             |  110 ++
 tests/stream_limit_rate.t                     |  213 +++
 tests/stream_limit_rate2.t                    |  227 +++
 tests/stream_map.t                            |   72 +
 tests/stream_proxy.t                          |  118 ++
 tests/stream_proxy_bind.t                     |   77 ++
 tests/stream_proxy_complex.t                  |   79 ++
 tests/stream_proxy_next_upstream.t            |  122 ++
 tests/stream_proxy_protocol.t                 |  120 ++
 tests/stream_proxy_protocol_ipv6.t            |  127 ++
 tests/stream_proxy_protocol_ssl.t             |  181 +++
 tests/stream_proxy_ssl.t                      |  121 ++
 tests/stream_proxy_ssl_certificate.t          |  169 +++
 tests/stream_proxy_ssl_name.t                 |  149 ++
 tests/stream_proxy_ssl_name_complex.t         |   90 ++
 tests/stream_proxy_ssl_verify.t               |  174 +++
 tests/stream_realip.t                         |  170 +++
 tests/stream_realip_hostname.t                |  100 ++
 tests/stream_resolver.t                       |  193 +++
 tests/stream_split_clients.t                  |   77 ++
 tests/stream_ssl.t                            |  228 +++
 tests/stream_ssl_certificate.t                |  213 +++
 tests/stream_ssl_preread.t                    |  244 ++++
 tests/stream_ssl_preread_alpn.t               |  148 ++
 tests/stream_ssl_preread_protocol.t           |  101 ++
 tests/stream_ssl_realip.t                     |  153 ++
 tests/stream_ssl_variables.t                  |  145 ++
 tests/stream_ssl_verify_client.t              |  169 +++
 tests/stream_status_variable.t                |  108 ++
 tests/stream_tcp_nodelay.t                    |  123 ++
 tests/stream_udp_limit_conn.t                 |  135 ++
 tests/stream_udp_limit_rate.t                 |  123 ++
 tests/stream_udp_proxy.t                      |  101 ++
 tests/stream_udp_proxy_requests.t             |  212 +++
 tests/stream_udp_stream.t                     |   75 +
 tests/stream_udp_upstream.t                   |  147 ++
 tests/stream_udp_upstream_hash.t              |  121 ++
 tests/stream_udp_upstream_least_conn.t        |  127 ++
 tests/stream_udp_wildcard.t                   |   62 +
 tests/stream_unix.t                           |  111 ++
 tests/stream_upstream.t                       |  212 +++
 tests/stream_upstream_hash.t                  |  183 +++
 tests/stream_upstream_least_conn.t            |  156 +++
 tests/stream_upstream_max_conns.t             |  405 ++++++
 tests/stream_upstream_random.t                |  310 +++++
 tests/stream_upstream_zone.t                  |   87 ++
 tests/stream_upstream_zone_ssl.t              |  122 ++
 tests/stream_variables.t                      |  107 ++
 tests/stub_status.t                           |  187 +++
 tests/sub_filter.t                            |  154 +++
 tests/sub_filter_buffering.t                  |  103 ++
 tests/sub_filter_merge.t                      |   58 +
 tests/sub_filter_multi.t                      |  380 +++++
 tests/sub_filter_multi2.t                     |   82 ++
 tests/sub_filter_perl.t                       |  123 ++
 tests/sub_filter_slice.t                      |  103 ++
 tests/sub_filter_ssi.t                        |   85 ++
 tests/subrequest_output_buffer_size.t         |   85 ++
 tests/syslog.t                                |  352 +++++
 tests/trailers.t                              |  134 ++
 tests/upstream.t                              |  160 +++
 tests/upstream_hash.t                         |  261 ++++
 tests/upstream_hash_memcached.t               |  188 +++
 tests/upstream_ip_hash.t                      |  123 ++
 tests/upstream_ip_hash_ipv6.t                 |  153 ++
 tests/upstream_keepalive.t                    |   93 ++
 tests/upstream_least_conn.t                   |  141 ++
 tests/upstream_max_conns.t                    |  375 +++++
 tests/upstream_random.t                       |  267 ++++
 tests/upstream_zone.t                         |   84 ++
 tests/upstream_zone_ssl.t                     |  125 ++
 tests/userid.t                                |  295 ++++
 tests/uwsgi.t                                 |  127 ++
 tests/worker_shutdown_timeout.t               |   67 +
 tests/worker_shutdown_timeout_h2.t            |   93 ++
 tests/worker_shutdown_timeout_mail.t          |   92 ++
 tests/worker_shutdown_timeout_proxy_upgrade.t |  121 ++
 tests/worker_shutdown_timeout_stream.t        |   66 +
 tests/xslt.t                                  |  130 ++
 tests/xslt_params.t                           |  106 ++
 369 files changed, 63237 insertions(+)
 create mode 100644 tests/LICENSE
 create mode 100644 tests/README
 create mode 100644 tests/access.t
 create mode 100644 tests/access_log.t
 create mode 100644 tests/access_log_variables.t
 create mode 100644 tests/addition.t
 create mode 100644 tests/addition_buffered.t
 create mode 100644 tests/auth_basic.t
 create mode 100644 tests/auth_delay.t
 create mode 100644 tests/auth_request.t
 create mode 100644 tests/auth_request_satisfy.t
 create mode 100644 tests/auth_request_set.t
 create mode 100644 tests/autoindex.t
 create mode 100644 tests/autoindex_format.t
 create mode 100644 tests/binary_upgrade.t
 create mode 100644 tests/body.t
 create mode 100644 tests/body_chunked.t
 create mode 100644 tests/charset.t
 create mode 100644 tests/charset_gzip_static.t
 create mode 100644 tests/config_dump.t
 create mode 100644 tests/dav.t
 create mode 100644 tests/dav_chunked.t
 create mode 100644 tests/debug_connection.t
 create mode 100644 tests/debug_connection_syslog.t
 create mode 100644 tests/debug_connection_unix.t
 create mode 100644 tests/empty_gif.t
 create mode 100644 tests/error_log.t
 create mode 100644 tests/fastcgi.t
 create mode 100644 tests/fastcgi_body.t
 create mode 100644 tests/fastcgi_body2.t
 create mode 100644 tests/fastcgi_buffering.t
 create mode 100644 tests/fastcgi_cache.t
 create mode 100644 tests/fastcgi_header_params.t
 create mode 100644 tests/fastcgi_keepalive.t
 create mode 100644 tests/fastcgi_merge_params.t
 create mode 100644 tests/fastcgi_merge_params2.t
 create mode 100644 tests/fastcgi_request_buffering.t
 create mode 100644 tests/fastcgi_request_buffering_chunked.t
 create mode 100644 tests/fastcgi_split.t
 create mode 100644 tests/fastcgi_unix.t
 create mode 100644 tests/fastcgi_variables.t
 create mode 100644 tests/geo.t
 create mode 100644 tests/geo_binary.t
 create mode 100644 tests/geo_ipv6.t
 create mode 100644 tests/geo_unix.t
 create mode 100644 tests/geoip.t
 create mode 100644 tests/grpc.t
 create mode 100644 tests/grpc_next_upstream.t
 create mode 100644 tests/grpc_pass.t
 create mode 100644 tests/grpc_request_buffering.t
 create mode 100644 tests/grpc_ssl.t
 create mode 100644 tests/gunzip.t
 create mode 100644 tests/gunzip_memcached.t
 create mode 100644 tests/gunzip_perl.t
 create mode 100644 tests/gunzip_ssi.t
 create mode 100644 tests/gunzip_static.t
 create mode 100644 tests/gzip.t
 create mode 100644 tests/gzip_flush.t
 create mode 100644 tests/h2.t
 create mode 100644 tests/h2_auth_request.t
 create mode 100644 tests/h2_fastcgi_request_buffering.t
 create mode 100644 tests/h2_headers.t
 create mode 100644 tests/h2_limit_conn.t
 create mode 100644 tests/h2_limit_req.t
 create mode 100644 tests/h2_max_requests.t
 create mode 100644 tests/h2_priority.t
 create mode 100644 tests/h2_proxy_cache.t
 create mode 100644 tests/h2_proxy_protocol.t
 create mode 100644 tests/h2_proxy_request_buffering.t
 create mode 100644 tests/h2_proxy_request_buffering_redirect.t
 create mode 100644 tests/h2_proxy_request_buffering_ssl.t
 create mode 100644 tests/h2_proxy_ssl.t
 create mode 100644 tests/h2_request_body.t
 create mode 100644 tests/h2_request_body_preread.t
 create mode 100644 tests/h2_server_push.t
 create mode 100644 tests/h2_server_tokens.t
 create mode 100644 tests/h2_ssl.t
 create mode 100644 tests/h2_ssl_proxy_cache.t
 create mode 100644 tests/h2_ssl_variables.t
 create mode 100644 tests/h2_ssl_verify_client.t
 create mode 100644 tests/h2_trailers.t
 create mode 100644 tests/h2_variables.t
 create mode 100644 tests/headers.t
 create mode 100644 tests/http_absolute_redirect.t
 create mode 100644 tests/http_disable_symlinks.t
 create mode 100644 tests/http_error_page.t
 create mode 100644 tests/http_expect_100_continue.t
 create mode 100644 tests/http_header_buffers.t
 create mode 100644 tests/http_host.t
 create mode 100644 tests/http_include.t
 create mode 100644 tests/http_keepalive.t
 create mode 100644 tests/http_listen.t
 create mode 100644 tests/http_location.t
 create mode 100644 tests/http_location_auto.t
 create mode 100644 tests/http_location_win32.t
 create mode 100644 tests/http_resolver.t
 create mode 100644 tests/http_resolver_aaaa.t
 create mode 100644 tests/http_resolver_cleanup.t
 create mode 100644 tests/http_resolver_cname.t
 create mode 100644 tests/http_server_name.t
 create mode 100644 tests/http_try_files.t
 create mode 100644 tests/http_uri.t
 create mode 100644 tests/http_variables.t
 create mode 100644 tests/ignore_invalid_headers.t
 create mode 100644 tests/image_filter.t
 create mode 100644 tests/image_filter_finalize.t
 create mode 100644 tests/image_filter_webp.t
 create mode 100644 tests/index.t
 create mode 100644 tests/js.t
 create mode 100644 tests/js_async.t
 create mode 100644 tests/js_dump.t
 create mode 100644 tests/js_headers.t
 create mode 100644 tests/js_import.t
 create mode 100644 tests/js_internal_redirect.t
 create mode 100644 tests/js_modules.t
 create mode 100644 tests/js_object.t
 create mode 100644 tests/js_paths.t
 create mode 100644 tests/js_promise.t
 create mode 100644 tests/js_request_body.t
 create mode 100644 tests/js_return.t
 create mode 100644 tests/js_subrequests.t
 create mode 100644 tests/js_variables.t
 create mode 100644 tests/lib/Test/Nginx.pm
 create mode 100644 tests/lib/Test/Nginx/HTTP2.pm
 create mode 100644 tests/lib/Test/Nginx/IMAP.pm
 create mode 100644 tests/lib/Test/Nginx/POP3.pm
 create mode 100644 tests/lib/Test/Nginx/SMTP.pm
 create mode 100644 tests/lib/Test/Nginx/Stream.pm
 create mode 100644 tests/limit_conn.t
 create mode 100644 tests/limit_conn_complex.t
 create mode 100644 tests/limit_conn_dry_run.t
 create mode 100644 tests/limit_rate.t
 create mode 100644 tests/limit_req.t
 create mode 100644 tests/limit_req2.t
 create mode 100644 tests/limit_req_delay.t
 create mode 100644 tests/limit_req_dry_run.t
 create mode 100644 tests/mail_capability.t
 create mode 100644 tests/mail_error_log.t
 create mode 100644 tests/mail_imap.t
 create mode 100644 tests/mail_imap_ssl.t
 create mode 100644 tests/mail_pop3.t
 create mode 100644 tests/mail_resolver.t
 create mode 100644 tests/mail_smtp.t
 create mode 100644 tests/mail_smtp_greeting_delay.t
 create mode 100644 tests/mail_smtp_xclient.t
 create mode 100644 tests/mail_ssl.t
 create mode 100644 tests/map.t
 create mode 100644 tests/map_complex.t
 create mode 100644 tests/map_volatile.t
 create mode 100644 tests/memcached.t
 create mode 100644 tests/memcached_fake.t
 create mode 100644 tests/memcached_keepalive.t
 create mode 100644 tests/memcached_keepalive_stale.t
 create mode 100644 tests/merge_slashes.t
 create mode 100644 tests/mirror.t
 create mode 100644 tests/mirror_proxy.t
 create mode 100644 tests/mp4.t
 create mode 100644 tests/mp4_ssi.t
 create mode 100644 tests/msie_refresh.t
 create mode 100644 tests/not_modified.t
 create mode 100644 tests/not_modified_finalize.t
 create mode 100644 tests/not_modified_proxy.t
 create mode 100644 tests/perl.t
 create mode 100644 tests/perl_gzip.t
 create mode 100644 tests/perl_sleep.t
 create mode 100644 tests/perl_ssi.t
 create mode 100644 tests/post_action.t
 create mode 100644 tests/proxy.t
 create mode 100644 tests/proxy_bind.t
 create mode 100644 tests/proxy_bind_transparent.t
 create mode 100644 tests/proxy_bind_transparent_capability.t
 create mode 100644 tests/proxy_cache.t
 create mode 100644 tests/proxy_cache_bypass.t
 create mode 100644 tests/proxy_cache_chunked.t
 create mode 100644 tests/proxy_cache_convert_head.t
 create mode 100644 tests/proxy_cache_error.t
 create mode 100644 tests/proxy_cache_lock.t
 create mode 100644 tests/proxy_cache_lock_age.t
 create mode 100644 tests/proxy_cache_lock_ssi.t
 create mode 100644 tests/proxy_cache_manager.t
 create mode 100644 tests/proxy_cache_max_range_offset.t
 create mode 100644 tests/proxy_cache_path.t
 create mode 100644 tests/proxy_cache_range.t
 create mode 100644 tests/proxy_cache_revalidate.t
 create mode 100644 tests/proxy_cache_use_stale.t
 create mode 100644 tests/proxy_cache_valid.t
 create mode 100644 tests/proxy_cache_variables.t
 create mode 100644 tests/proxy_cache_vary.t
 create mode 100644 tests/proxy_chunked.t
 create mode 100644 tests/proxy_cookie.t
 create mode 100644 tests/proxy_force_ranges.t
 create mode 100644 tests/proxy_if.t
 create mode 100644 tests/proxy_keepalive.t
 create mode 100644 tests/proxy_limit_rate.t
 create mode 100644 tests/proxy_merge_headers.t
 create mode 100644 tests/proxy_method.t
 create mode 100644 tests/proxy_next_upstream.t
 create mode 100644 tests/proxy_next_upstream_tries.t
 create mode 100644 tests/proxy_noclose.t
 create mode 100644 tests/proxy_non_idempotent.t
 create mode 100644 tests/proxy_pass_request.t
 create mode 100644 tests/proxy_protocol.t
 create mode 100644 tests/proxy_protocol2.t
 create mode 100644 tests/proxy_protocol2_server.t
 create mode 100644 tests/proxy_protocol_ipv6.t
 create mode 100644 tests/proxy_protocol_server.t
 create mode 100644 tests/proxy_redirect.t
 create mode 100644 tests/proxy_request_buffering.t
 create mode 100644 tests/proxy_request_buffering_chunked.t
 create mode 100644 tests/proxy_request_buffering_keepalive.t
 create mode 100644 tests/proxy_request_buffering_ssl.t
 create mode 100644 tests/proxy_set_body.t
 create mode 100644 tests/proxy_ssi_body.t
 create mode 100644 tests/proxy_ssl.t
 create mode 100644 tests/proxy_ssl_certificate.t
 create mode 100644 tests/proxy_ssl_keepalive.t
 create mode 100644 tests/proxy_ssl_name.t
 create mode 100644 tests/proxy_ssl_verify.t
 create mode 100644 tests/proxy_store.t
 create mode 100644 tests/proxy_unfinished.t
 create mode 100644 tests/proxy_unix.t
 create mode 100644 tests/proxy_upgrade.t
 create mode 100644 tests/proxy_upstream_cookie.t
 create mode 100644 tests/proxy_variables.t
 create mode 100644 tests/proxy_websocket.t
 create mode 100644 tests/proxy_xar.t
 create mode 100644 tests/random_index.t
 create mode 100644 tests/range.t
 create mode 100644 tests/range_charset.t
 create mode 100644 tests/range_flv.t
 create mode 100644 tests/range_if_range.t
 create mode 100644 tests/range_mp4.t
 create mode 100644 tests/realip.t
 create mode 100644 tests/realip_hostname.t
 create mode 100644 tests/realip_remote_addr.t
 create mode 100644 tests/realip_remote_port.t
 create mode 100644 tests/referer.t
 create mode 100644 tests/request_id.t
 create mode 100644 tests/rewrite.t
 create mode 100644 tests/rewrite_if.t
 create mode 100644 tests/rewrite_set.t
 create mode 100644 tests/rewrite_unescape.t
 create mode 100644 tests/scgi.t
 create mode 100644 tests/scgi_body.t
 create mode 100644 tests/scgi_cache.t
 create mode 100644 tests/scgi_gzip.t
 create mode 100644 tests/scgi_merge_params.t
 create mode 100644 tests/secure_link.t
 create mode 100644 tests/server_tokens.t
 create mode 100644 tests/slice.t
 create mode 100644 tests/split_clients.t
 create mode 100644 tests/ssi.t
 create mode 100644 tests/ssi_delayed.t
 create mode 100644 tests/ssi_if.t
 create mode 100644 tests/ssi_include_big.t
 create mode 100644 tests/ssi_waited.t
 create mode 100644 tests/ssl.t
 create mode 100644 tests/ssl_certificate.t
 create mode 100644 tests/ssl_certificate_chain.t
 create mode 100644 tests/ssl_certificate_perl.t
 create mode 100644 tests/ssl_certificates.t
 create mode 100644 tests/ssl_client_escaped_cert.t
 create mode 100644 tests/ssl_crl.t
 create mode 100644 tests/ssl_engine_keys.t
 create mode 100644 tests/ssl_password_file.t
 create mode 100644 tests/ssl_proxy_protocol.t
 create mode 100644 tests/ssl_proxy_upgrade.t
 create mode 100644 tests/ssl_sni.t
 create mode 100644 tests/ssl_sni_reneg.t
 create mode 100644 tests/ssl_sni_sessions.t
 create mode 100644 tests/ssl_stapling.t
 create mode 100644 tests/ssl_verify_client.t
 create mode 100644 tests/ssl_verify_depth.t
 create mode 100644 tests/stream_access.t
 create mode 100644 tests/stream_access_log.t
 create mode 100644 tests/stream_access_log_escape.t
 create mode 100644 tests/stream_access_log_none.t
 create mode 100644 tests/stream_error_log.t
 create mode 100644 tests/stream_geo.t
 create mode 100644 tests/stream_geo_binary.t
 create mode 100644 tests/stream_geo_ipv6.t
 create mode 100644 tests/stream_geo_unix.t
 create mode 100644 tests/stream_geoip.t
 create mode 100644 tests/stream_js.t
 create mode 100644 tests/stream_js_import.t
 create mode 100644 tests/stream_js_object.t
 create mode 100644 tests/stream_js_variables.t
 create mode 100644 tests/stream_limit_conn.t
 create mode 100644 tests/stream_limit_conn_complex.t
 create mode 100644 tests/stream_limit_conn_dry_run.t
 create mode 100644 tests/stream_limit_rate.t
 create mode 100644 tests/stream_limit_rate2.t
 create mode 100644 tests/stream_map.t
 create mode 100644 tests/stream_proxy.t
 create mode 100644 tests/stream_proxy_bind.t
 create mode 100644 tests/stream_proxy_complex.t
 create mode 100644 tests/stream_proxy_next_upstream.t
 create mode 100644 tests/stream_proxy_protocol.t
 create mode 100644 tests/stream_proxy_protocol_ipv6.t
 create mode 100644 tests/stream_proxy_protocol_ssl.t
 create mode 100644 tests/stream_proxy_ssl.t
 create mode 100644 tests/stream_proxy_ssl_certificate.t
 create mode 100644 tests/stream_proxy_ssl_name.t
 create mode 100644 tests/stream_proxy_ssl_name_complex.t
 create mode 100644 tests/stream_proxy_ssl_verify.t
 create mode 100644 tests/stream_realip.t
 create mode 100644 tests/stream_realip_hostname.t
 create mode 100644 tests/stream_resolver.t
 create mode 100644 tests/stream_split_clients.t
 create mode 100644 tests/stream_ssl.t
 create mode 100644 tests/stream_ssl_certificate.t
 create mode 100644 tests/stream_ssl_preread.t
 create mode 100644 tests/stream_ssl_preread_alpn.t
 create mode 100644 tests/stream_ssl_preread_protocol.t
 create mode 100644 tests/stream_ssl_realip.t
 create mode 100644 tests/stream_ssl_variables.t
 create mode 100644 tests/stream_ssl_verify_client.t
 create mode 100644 tests/stream_status_variable.t
 create mode 100644 tests/stream_tcp_nodelay.t
 create mode 100644 tests/stream_udp_limit_conn.t
 create mode 100644 tests/stream_udp_limit_rate.t
 create mode 100644 tests/stream_udp_proxy.t
 create mode 100644 tests/stream_udp_proxy_requests.t
 create mode 100644 tests/stream_udp_stream.t
 create mode 100644 tests/stream_udp_upstream.t
 create mode 100644 tests/stream_udp_upstream_hash.t
 create mode 100644 tests/stream_udp_upstream_least_conn.t
 create mode 100644 tests/stream_udp_wildcard.t
 create mode 100644 tests/stream_unix.t
 create mode 100644 tests/stream_upstream.t
 create mode 100644 tests/stream_upstream_hash.t
 create mode 100644 tests/stream_upstream_least_conn.t
 create mode 100644 tests/stream_upstream_max_conns.t
 create mode 100644 tests/stream_upstream_random.t
 create mode 100644 tests/stream_upstream_zone.t
 create mode 100644 tests/stream_upstream_zone_ssl.t
 create mode 100644 tests/stream_variables.t
 create mode 100644 tests/stub_status.t
 create mode 100644 tests/sub_filter.t
 create mode 100644 tests/sub_filter_buffering.t
 create mode 100644 tests/sub_filter_merge.t
 create mode 100644 tests/sub_filter_multi.t
 create mode 100644 tests/sub_filter_multi2.t
 create mode 100644 tests/sub_filter_perl.t
 create mode 100644 tests/sub_filter_slice.t
 create mode 100644 tests/sub_filter_ssi.t
 create mode 100644 tests/subrequest_output_buffer_size.t
 create mode 100644 tests/syslog.t
 create mode 100644 tests/trailers.t
 create mode 100644 tests/upstream.t
 create mode 100644 tests/upstream_hash.t
 create mode 100644 tests/upstream_hash_memcached.t
 create mode 100644 tests/upstream_ip_hash.t
 create mode 100644 tests/upstream_ip_hash_ipv6.t
 create mode 100644 tests/upstream_keepalive.t
 create mode 100644 tests/upstream_least_conn.t
 create mode 100644 tests/upstream_max_conns.t
 create mode 100644 tests/upstream_random.t
 create mode 100644 tests/upstream_zone.t
 create mode 100644 tests/upstream_zone_ssl.t
 create mode 100644 tests/userid.t
 create mode 100644 tests/uwsgi.t
 create mode 100644 tests/worker_shutdown_timeout.t
 create mode 100644 tests/worker_shutdown_timeout_h2.t
 create mode 100644 tests/worker_shutdown_timeout_mail.t
 create mode 100644 tests/worker_shutdown_timeout_proxy_upgrade.t
 create mode 100644 tests/worker_shutdown_timeout_stream.t
 create mode 100644 tests/xslt.t
 create mode 100644 tests/xslt_params.t

diff --git a/tests/LICENSE b/tests/LICENSE
new file mode 100644
index 0000000..2b71e91
--- /dev/null
+++ b/tests/LICENSE
@@ -0,0 +1,24 @@
+/* 
+ * Copyright (C) 2008-2011 Maxim Dounin
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
diff --git a/tests/README b/tests/README
new file mode 100644
index 0000000..c18f544
--- /dev/null
+++ b/tests/README
@@ -0,0 +1,51 @@
+Test suite for nginx.
+
+Use prove to run tests as one usually do for perl tests.  Individual tests
+may be run as well.
+
+Note: tests run nginx (and backend daemons if needed) listening on localhost
+and may use various ports in 8000 .. 8999 range.
+
+Usage:
+
+    $ TEST_NGINX_BINARY=/path/to/nginx prove .
+
+By default tests expect nginx binary to be at ../nginx/objs/nginx.
+
+Environment variables:
+
+TEST_NGINX_BINARY
+
+    Sets path to nginx binary to be tested, defaults to "../nginx/objs/nginx".
+
+TEST_NGINX_MODULES
+
+    Sets path to modules directory, defaults to dirname of TEST_NGINX_BINARY.
+
+TEST_NGINX_VERBOSE
+
+    Be a bit more verbose (in particular, print requests sent and responses
+    got from nginx).  Note that this requires prove -v (or HARNESS_VERBOSE).
+
+TEST_NGINX_LEAVE
+
+    If set, temporary directory with configs and logs won't be deleted on test
+    completion.  Useful for debugging.
+
+TEST_NGINX_CATLOG
+
+    Cat error log to stdout after test completion.  Useful for debugging.
+
+TEST_NGINX_UNSAFE
+
+    Run unsafe tests.
+
+TEST_NGINX_GLOBALS
+
+    Sets additional directives in main context.
+
+TEST_NGINX_GLOBALS_HTTP
+
+    Sets additional directives in http context.
+
+Happy testing!
diff --git a/tests/access.t b/tests/access.t
new file mode 100644
index 0000000..ab26ec0
--- /dev/null
+++ b/tests/access.t
@@ -0,0 +1,108 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+
+# Tests for nginx access module.
+
+# At the moment only the new "unix:" syntax is tested (cf "all").
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy access unix/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /inet/ {
+            proxy_pass http://127.0.0.1:8081/;
+        }
+
+        location /inet6/ {
+            proxy_pass http://[::1]:%%PORT_8081%%/;
+        }
+
+        location /unix/ {
+            proxy_pass http://unix:%%TESTDIR%%/unix.sock:/;
+        }
+
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        listen       [::1]:%%PORT_8081%%;
+        listen       unix:%%TESTDIR%%/unix.sock;
+
+        location /allow_all {
+            allow all;
+        }
+
+        location /allow_unix {
+            allow unix:;
+        }
+
+        location /deny_all {
+            deny all;
+        }
+
+        location /deny_unix {
+            deny unix:;
+        }
+    }
+}
+
+EOF
+
+$t->try_run('no inet6 support')->plan(12);
+
+###############################################################################
+
+# tests with inet socket
+
+like(http_get('/inet/allow_all'), qr/404 Not Found/, 'inet allow all');
+like(http_get('/inet/allow_unix'), qr/404 Not Found/, 'inet allow unix');
+like(http_get('/inet/deny_all'), qr/403 Forbidden/, 'inet deny all');
+like(http_get('/inet/deny_unix'), qr/404 Not Found/, 'inet deny unix');
+
+# tests with inet6 socket
+
+like(http_get('/inet6/allow_all'), qr/404 Not Found/, 'inet6 allow all');
+like(http_get('/inet6/allow_unix'), qr/404 Not Found/, 'inet6 allow unix');
+like(http_get('/inet6/deny_all'), qr/403 Forbidden/, 'inet6 deny all');
+like(http_get('/inet6/deny_unix'), qr/404 Not Found/, 'inet6 deny unix');
+
+# tests with unix socket
+
+like(http_get('/unix/allow_all'), qr/404 Not Found/, 'unix allow all');
+like(http_get('/unix/allow_unix'), qr/404 Not Found/, 'unix allow unix');
+like(http_get('/unix/deny_all'), qr/403 Forbidden/, 'unix deny all');
+like(http_get('/unix/deny_unix'), qr/403 Forbidden/, 'unix deny unix');
+
+###############################################################################
diff --git a/tests/access_log.t b/tests/access_log.t
new file mode 100644
index 0000000..4401f51
--- /dev/null
+++ b/tests/access_log.t
@@ -0,0 +1,278 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for access_log.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http rewrite gzip/)->plan(18)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    log_format test "$uri:$status";
+    log_format long "long line $uri:$status";
+    log_format binary $binary_remote_addr;
+
+    log_format default  escape=default  $arg_a$arg_b$arg_c;
+    log_format none     escape=none     $arg_a$arg_b$arg_c;
+    log_format json     escape=json     $arg_a$arg_b$arg_c;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /combined {
+            access_log %%TESTDIR%%/combined.log;
+            return 200 OK;
+
+            location /combined/off {
+                access_log off;
+                return 200 OK;
+            }
+        }
+
+        location /filtered {
+            access_log %%TESTDIR%%/filtered.log test
+                       if=$arg_logme;
+            return 200 OK;
+        }
+
+        location /filtered/complex {
+            access_log %%TESTDIR%%/complex.log test
+                       if=$arg_logme$arg_logmetoo;
+            return 200 OK;
+        }
+
+        location /filtered/noreuse {
+            access_log %%TESTDIR%%/noreuse.log test buffer=16k
+                       if=$arg_a;
+            access_log %%TESTDIR%%/noreuse.log test buffer=16k
+                       if=$arg_b;
+            return 200 OK;
+        }
+
+        location /compressed {
+            access_log %%TESTDIR%%/compressed.log test
+                       gzip buffer=1m flush=100ms;
+            return 200 OK;
+        }
+
+        location /multi {
+            access_log %%TESTDIR%%/multi1.log test;
+            access_log %%TESTDIR%%/multi2.log test;
+            access_log %%TESTDIR%%/long.log long;
+            return 200 OK;
+        }
+
+        location /varlog {
+            access_log %%TESTDIR%%/varlog_${arg_logname} test;
+            return 200 OK;
+        }
+
+        location /cache {
+            open_log_file_cache max=3 inactive=20s valid=1m min_uses=2;
+            access_log %%TESTDIR%%/dir/cache_${arg_logname} test;
+            return 200 OK;
+        }
+
+        location /binary {
+            access_log %%TESTDIR%%/binary.log binary;
+        }
+
+        location /escape {
+            access_log %%TESTDIR%%/test.log default;
+            access_log %%TESTDIR%%/none.log none;
+            access_log %%TESTDIR%%/json.log json;
+        }
+    }
+}
+
+EOF
+
+my $d = $t->testdir();
+
+mkdir "$d/dir";
+
+$t->run();
+
+###############################################################################
+
+http_get('/combined');
+http_get('/combined/off');
+
+http_get('/filtered');
+http_get('/filtered/empty?logme=');
+http_get('/filtered/zero?logme=0');
+http_get('/filtered/good?logme=1');
+http_get('/filtered/work?logme=yes');
+
+http_get('/filtered/complex');
+http_get('/filtered/complex/one?logme=1');
+http_get('/filtered/complex/two?logmetoo=1');
+http_get('/filtered/complex/either1?logme=A&logmetoo=B');
+http_get('/filtered/complex/either2?logme=A');
+http_get('/filtered/complex/either3?logmetoo=B');
+http_get('/filtered/complex/either4?logme=0&logmetoo=0');
+http_get('/filtered/complex/neither?logme=&logmetoo=');
+
+http_get('/filtered/noreuse1/zero?a=0');
+http_get('/filtered/noreuse1/good?a=1');
+http_get('/filtered/noreuse2/zero?b=0');
+http_get('/filtered/noreuse2/good?b=1');
+
+http_get('/compressed');
+
+http_get('/multi');
+
+http_get('/varlog');
+http_get('/varlog?logname=');
+http_get('/varlog?logname=0');
+http_get('/varlog?logname=filename');
+
+http_get('/binary');
+
+http_get('/escape?a="1 \\ ' . pack("n", 0x1b1c) . ' "&c=2');
+
+http_get('/cache?logname=lru');
+http_get('/cache?logname=lru');
+http_get('/cache?logname=once');
+http_get('/cache?logname=first');
+http_get('/cache?logname=first');
+http_get('/cache?logname=second');
+http_get('/cache?logname=second');
+
+rename "$d/dir", "$d/dir_moved";
+
+http_get('/cache?logname=lru');
+http_get('/cache?logname=once');
+http_get('/cache?logname=first');
+http_get('/cache?logname=second');
+
+rename "$d/dir_moved",  "$d/dir";
+
+# wait for file to appear with nonzero size thanks to the flush parameter
+
+for (1 .. 10) {
+	last if -s "$d/compressed.log";
+	select undef, undef, undef, 0.1;
+}
+
+# verify that "gzip" parameter turns on compression
+
+my $log;
+
+SKIP: {
+	eval { require IO::Uncompress::Gunzip; };
+	skip("IO::Uncompress::Gunzip not installed", 1) if $@;
+
+	my $gzipped = $t->read_file('compressed.log');
+	IO::Uncompress::Gunzip::gunzip(\$gzipped => \$log);
+	like($log, qr!^/compressed:200!s, 'compressed log - flush time');
+}
+
+# now verify all other logs
+
+$t->stop();
+
+
+# verify that by default, 'combined' format is used, 'off' disables logging
+
+my $addr = IO::Socket::INET->new(LocalAddr => '127.0.0.1')->sockhost();
+
+like($t->read_file('combined.log'),
+	qr!^\Q$addr - - [\E .*
+		\Q] "GET /combined HTTP/1.0" 200 2 "-" "-"\E$!x,
+	'default log format');
+
+# verify that log filtering works
+
+$log = $t->read_file('filtered.log');
+is($log, "/filtered/good:200\n/filtered/work:200\n", 'log filtering');
+
+# verify "if=" argument works with complex value
+
+my $exp_complex = <<'EOF';
+/filtered/complex/one:200
+/filtered/complex/two:200
+/filtered/complex/either1:200
+/filtered/complex/either2:200
+/filtered/complex/either3:200
+/filtered/complex/either4:200
+EOF
+
+is($t->read_file('complex.log'), $exp_complex, 'if with complex value');
+
+# buffer created with false "if" is not reused among multiple access_log
+
+$log = $t->read_file('noreuse.log');
+is($log, "/filtered/noreuse1/good:200\n/filtered/noreuse2/good:200\n",
+	'log filtering with buffering');
+
+# multiple logs in a same location
+
+is($t->read_file('multi1.log'), "/multi:200\n", 'multiple logs 1');
+
+# same content in the second log
+
+is($t->read_file('multi2.log'), "/multi:200\n", 'multiple logs 2');
+
+is($t->read_file('long.log'), "long line /multi:200\n", 'long line format');
+
+# test log destinations with variables
+
+is($t->read_file('varlog_0'), "/varlog:200\n", 'varlog literal zero name');
+is($t->read_file('varlog_filename'), "/varlog:200\n", 'varlog good name');
+
+# binary data is escaped
+# that's "\\x7F\\x00\\x00\\x01\n" in $binary_remote_addr for "127.0.0.1"
+
+my $expected = join '', map { sprintf "\\x%02X", $_ } split /\./, $addr;
+
+is($t->read_file('binary.log'), "$expected\n", 'binary');
+
+# characters escaping
+
+is($t->read_file('test.log'),
+	'\x221 \x5C \x1B\x1C \x22-2' . "\n", 'escape - default');
+is($t->read_file('none.log'),
+	'"1 \\ ' . pack("n", 0x1b1c) . " \"2\n", 'escape - none');
+is($t->read_file('json.log'),
+	'\"1 \\\\ \u001B\u001C \"2' . "\n", 'escape - json');
+
+SKIP: {
+skip 'win32', 4 if $^O eq 'MSWin32';
+
+is(@{[$t->read_file('/dir/cache_lru') =~ /\//g]}, 2, 'cache - closed lru');
+is(@{[$t->read_file('/dir/cache_once') =~ /\//g]}, 1, 'cache - min_uses');
+is(@{[$t->read_file('/dir/cache_first') =~ /\//g]}, 3, 'cache - cached 1');
+is(@{[$t->read_file('/dir/cache_second') =~ /\//g]}, 3, 'cache - cached 2');
+
+}
+
+###############################################################################
diff --git a/tests/access_log_variables.t b/tests/access_log_variables.t
new file mode 100644
index 0000000..7fd5d66
--- /dev/null
+++ b/tests/access_log_variables.t
@@ -0,0 +1,127 @@
+#!/usr/bin/perl
+
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+
+# Tests for log module variables.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http rewrite/)->plan(6)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    log_format time_iso8601  '$uri $time_iso8601';
+    log_format time_local    '$uri $time_local';
+    log_format msec          '$uri $msec';
+    log_format request       '$uri $status $request_length $request_time';
+    log_format bytes         '$uri $bytes_sent $body_bytes_sent';
+    log_format pipe          '$uri $pipe';
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /iso8601 {
+            access_log %%TESTDIR%%/iso8601.log time_iso8601;
+            return 200;
+        }
+
+        location /local {
+            access_log %%TESTDIR%%/local.log time_local;
+            return 200;
+        }
+
+        location /msec {
+            access_log %%TESTDIR%%/msec.log msec;
+            return 200;
+        }
+
+        location /request {
+            access_log %%TESTDIR%%/request.log request;
+            return 200;
+        }
+
+        location /bytes {
+           access_log %%TESTDIR%%/bytes.log bytes;
+           return 200 OK;
+        }
+
+        location /pipe {
+            access_log %%TESTDIR%%/pipe.log pipe;
+            return 200;
+        }
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+http_get('/iso8601');
+http_get('/local');
+http_get('/msec');
+http_get('/request');
+my $bytes_sent = length http_get('/bytes');
+
+# pipelined requests
+
+http(<<EOF);
+GET /pipe HTTP/1.1
+Host: localhost
+
+GET /pipe HTTP/1.1
+Host: localhost
+Connection: close
+
+EOF
+
+$t->stop();
+
+my $log = $t->read_file('iso8601.log');
+like($log, qr!/iso8601 \d{4}-\d\d-\d\dT\d\d:\d\d:\d\d[+-]\d\d:\d\d!,
+	'time_iso8601');
+
+$log = $t->read_file('local.log');
+like($log, qr!/local \d\d/[A-Z][a-z]{2}/\d{4}:\d\d:\d\d:\d\d [+-]\d{4}!,
+	'time_local');
+
+$log = $t->read_file('msec.log');
+like($log, qr!/msec [\d\.]+!, 'msec');
+
+$log = $t->read_file('request.log');
+like($log, qr!/request 200 39 [\d\.]+!, 'request');
+
+$log = $t->read_file('bytes.log');
+is($log, "/bytes $bytes_sent 2\n", 'bytes sent');
+
+$log = $t->read_file('pipe.log');
+is($log, "/pipe .\n/pipe p\n", 'pipe');
+
+###############################################################################
diff --git a/tests/addition.t b/tests/addition.t
new file mode 100644
index 0000000..a5df712
--- /dev/null
+++ b/tests/addition.t
@@ -0,0 +1,117 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for addition module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http rewrite addition/)->plan(9);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /regular {
+            return 200 "body";
+        }
+
+        location /b.html {
+            add_before_body /add_before;
+            return 200 "body";
+        }
+
+        location /a.html {
+            add_after_body /add_after;
+            return 200 "body";
+        }
+
+        location /ba.html {
+            add_before_body /add_before;
+            add_after_body /add_after;
+            return 200 "body";
+        }
+
+        location /notype {
+            add_before_body /add_before;
+            add_after_body /add_after;
+            return 200 "body";
+        }
+
+        location /notype2 {
+            addition_types text/plain;
+            add_after_body /add_after;
+            return 200 "body";
+        }
+
+        location /notype.html {
+            types {}
+            add_before_body /add_before;
+            return 200 "body";
+        }
+
+        location /add_before {
+            return 200 "before";
+        }
+
+        location /add_after {
+            return 200 "after";
+        }
+
+        location /self.html {
+            add_after_body /self.html;
+            return 200 "self";
+        }
+
+        location /return202.html {
+            add_after_body /add_after;
+            return 202 "body";
+        }
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+like(http_get('/regular'), qr/^body$/ms, 'no addition');
+like(http_get('/b.html'), qr/^beforebody$/ms, 'add_before');
+like(http_get('/a.html'), qr/^bodyafter$/ms, 'add_after');
+like(http_get('/ba.html'), qr/^beforebodyafter$/ms, 'both');
+like(http_get('/notype'), qr/^body$/ms, 'no content type');
+like(http_get('/notype2'), qr/^bodyafter$/ms, 'addition_types');
+like(http_get('/notype.html'), qr/^body$/ms, 'empty content type');
+like(http_get('/self.html'), qr/^selfself$/ms, 'self');
+like(http_get('/return202.html'), qr/HTTP\/1.. 202.*^body$/ms, 'not 200');
+
+###############################################################################
diff --git a/tests/addition_buffered.t b/tests/addition_buffered.t
new file mode 100644
index 0000000..c0a294a
--- /dev/null
+++ b/tests/addition_buffered.t
@@ -0,0 +1,67 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for addition module with buffered data from other filters.
+
+# In particular, sub filter may have a partial match buffered.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy sub addition/)->plan(1);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / { }
+        location /proxy/ {
+            sub_filter foo bar;
+            add_after_body /after.html;
+            proxy_pass http://127.0.0.1:8080/;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('after.html', 'after');
+$t->write_file('body.html', 'XXXXX');
+
+$t->run();
+
+###############################################################################
+
+# if data is buffered, there should be no interleaved data in output
+
+like(http_get('/proxy/body.html'), qr/^XXXXXafter$/m, 'request');
+
+###############################################################################
diff --git a/tests/auth_basic.t b/tests/auth_basic.t
new file mode 100644
index 0000000..32f3b9e
--- /dev/null
+++ b/tests/auth_basic.t
@@ -0,0 +1,130 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for auth basic module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use MIME::Base64;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http auth_basic/)->plan(21)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            auth_basic           "closed site";
+            auth_basic_user_file %%TESTDIR%%/htpasswd;
+
+            location /inner {
+                auth_basic off;
+                alias %%TESTDIR%%/;
+            }
+        }
+    }
+}
+
+EOF
+
+$t->write_file('index.html', 'SEETHIS');
+
+$t->write_file(
+	'htpasswd',
+	'crypt:' . crypt('password', 'salt') . "\n" .
+	'crypt1:' . crypt('password', '$1$salt$') . "\n" .
+	'crypt2:' . '$1$' . "\n" .
+	'apr1:' . '$apr1$salt$Xxd1irWT9ycqoYxGFn4cb.' . "\n" .
+	'apr12:' . '$apr1$' . "\n" .
+	'plain:' . '{PLAIN}password' . "\n" .
+	'ssha:' . '{SSHA}yI6cZwQadOA1e+/f+T+H3eCQQhRzYWx0' . "\n" .
+	'ssha2:' . '{SSHA}_____wQadOA1e+/f+T+H3eCQQhRzYWx0' . "\n" .
+	'ssha3:' . '{SSHA}Zm9vCg==' . "\n" .
+	'sha:' . '{SHA}W6ph5Mm5Pz8GgiULbPgzG37mj9g=' . "\n" .
+	'sha2:' . '{SHA}_____Mm5Pz8GgiULbPgzG37mj9g=' . "\n" .
+	'sha3:' . '{SHA}Zm9vCg==' . "\n"
+);
+
+$t->run();
+
+###############################################################################
+
+like(http_get('/'), qr!401 Unauthorized!ms, 'rejects unathorized');
+
+SKIP: {
+
+skip 'no crypt on win32', 5 if $^O eq 'MSWin32';
+
+like(http_get_auth('/', 'crypt', 'password'), qr!SEETHIS!, 'normal crypt');
+unlike(http_get_auth('/', 'crypt', '123'), qr!SEETHIS!, 'normal wrong');
+
+like(http_get_auth('/', 'crypt1', 'password'), qr!SEETHIS!, 'crypt $1$ (md5)');
+unlike(http_get_auth('/', 'crypt1', '123'), qr!SEETHIS!, 'crypt $1$ wrong');
+
+like(http_get_auth('/', 'crypt2', '1'), qr!401 Unauthorized!,
+	'crypt $1$ broken');
+
+}
+
+like(http_get_auth('/', 'apr1', 'password'), qr!SEETHIS!, 'apr1 md5');
+like(http_get_auth('/', 'plain', 'password'), qr!SEETHIS!, 'plain password');
+like(http_get_auth('/', 'ssha', 'password'), qr!SEETHIS!, 'ssha');
+like(http_get_auth('/', 'sha', 'password'), qr!SEETHIS!, 'sha');
+
+unlike(http_get_auth('/', 'apr1', '123'), qr!SEETHIS!, 'apr1 md5 wrong');
+unlike(http_get_auth('/', 'plain', '123'), qr!SEETHIS!, 'plain wrong');
+unlike(http_get_auth('/', 'ssha', '123'), qr!SEETHIS!, 'ssha wrong');
+unlike(http_get_auth('/', 'sha', '123'), qr!SEETHIS!, 'sha wrong');
+
+like(http_get_auth('/', 'apr12', '1'), qr!401 Unauthorized!, 'apr1 md5 broken');
+like(http_get_auth('/', 'ssha2', '1'), qr!401 Unauthorized!, 'ssha broken 1');
+like(http_get_auth('/', 'ssha3', '1'), qr!401 Unauthorized!, 'ssha broken 2');
+like(http_get_auth('/', 'sha2', '1'), qr!401 Unauthorized!, 'sha broken 1');
+like(http_get_auth('/', 'sha3', '1'), qr!401 Unauthorized!, 'sha broken 2');
+
+like(http_get_auth('/', 'notfound', '1'), qr!401 Unauthorized!, 'not found');
+like(http_get('/inner/'), qr!SEETHIS!, 'inner off');
+
+###############################################################################
+
+sub http_get_auth {
+	my ($url, $user, $password) = @_;
+
+	my $auth = encode_base64($user . ':' . $password, '');
+
+	return http(<<EOF);
+GET $url HTTP/1.0
+Host: localhost
+Authorization: Basic $auth
+
+EOF
+}
+
+###############################################################################
diff --git a/tests/auth_delay.t b/tests/auth_delay.t
new file mode 100644
index 0000000..edc1d32
--- /dev/null
+++ b/tests/auth_delay.t
@@ -0,0 +1,85 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for auth_delay directive using auth basic module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use MIME::Base64;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http auth_basic/)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            auth_delay           2s;
+
+            auth_basic           "closed site";
+            auth_basic_user_file %%TESTDIR%%/htpasswd;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('index.html', '');
+$t->write_file('htpasswd', 'user:' . '{PLAIN}good' . "\n");
+
+$t->try_run('no auth_delay')->plan(4);
+
+###############################################################################
+
+my $t1 = time();
+like(http_get_auth('/', 'user', 'bad'), qr/401 Unauthorize/, 'not authorized');
+cmp_ok(time() - $t1, '>=', 2, 'auth delay');
+
+$t1 = time();
+like(http_get_auth('/', 'user', 'good'), qr/200 OK/, 'authorized');
+cmp_ok(time() - $t1, '<', 2, 'no delay');
+
+###############################################################################
+
+sub http_get_auth {
+	my ($url, $user, $password) = @_;
+
+	my $auth = encode_base64($user . ':' . $password, '');
+
+	return http(<<EOF);
+GET $url HTTP/1.0
+Host: localhost
+Authorization: Basic $auth
+
+EOF
+}
+
+###############################################################################
diff --git a/tests/auth_request.t b/tests/auth_request.t
new file mode 100644
index 0000000..d683166
--- /dev/null
+++ b/tests/auth_request.t
@@ -0,0 +1,256 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for auth request module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()
+	->has(qw/http rewrite proxy cache fastcgi auth_basic auth_request/)
+	->plan(19);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    proxy_cache_path   %%TESTDIR%%/cache  levels=1:2
+                       keys_zone=NAME:1m;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            return 444;
+        }
+
+        location /open {
+            auth_request /auth-open;
+        }
+        location = /auth-open {
+            return 204;
+        }
+
+        location /open-static {
+            auth_request /auth-open-static;
+        }
+        location = /auth-open-static {
+            # nothing, use static file
+        }
+
+        location /unauthorized {
+            auth_request /auth-unauthorized;
+        }
+        location = /auth-unauthorized {
+            return 401;
+        }
+
+        location /forbidden {
+            auth_request /auth-forbidden;
+        }
+        location = /auth-forbidden {
+            return 403;
+        }
+
+        location /error {
+            auth_request /auth-error;
+        }
+        location = /auth-error {
+            return 404;
+        }
+
+        location /off {
+            auth_request off;
+        }
+
+        location /proxy {
+            auth_request /auth-proxy;
+        }
+        location = /auth-proxy {
+            proxy_pass http://127.0.0.1:8080/auth-basic;
+            proxy_pass_request_body off;
+            proxy_set_header Content-Length "";
+        }
+        location = /auth-basic {
+            auth_basic "restricted";
+            auth_basic_user_file %%TESTDIR%%/htpasswd;
+        }
+
+        location = /proxy-double {
+            proxy_pass http://127.0.0.1:8080/auth-error;
+            proxy_intercept_errors on;
+            error_page 404 = /proxy-double-fallback;
+            client_body_buffer_size 4k;
+        }
+        location = /proxy-double-fallback {
+            auth_request /auth-proxy-double;
+            proxy_pass http://127.0.0.1:8080/auth-open;
+        }
+        location = /auth-proxy-double {
+            proxy_pass http://127.0.0.1:8080/auth-open;
+            proxy_pass_request_body off;
+            proxy_set_header Content-Length "";
+        }
+
+        location /proxy-cache {
+            auth_request /auth-proxy-cache;
+        }
+        location = /auth-proxy-cache {
+            proxy_pass http://127.0.0.1:8080/auth-basic;
+            proxy_pass_request_body off;
+            proxy_set_header Content-Length "";
+            proxy_cache NAME;
+            proxy_cache_valid 1m;
+        }
+
+        location /fastcgi {
+            auth_request /auth-fastcgi;
+        }
+        location = /auth-fastcgi {
+            fastcgi_pass 127.0.0.1:8081;
+            fastcgi_pass_request_body off;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('htpasswd', 'user:{PLAIN}secret' . "\n");
+$t->write_file('auth-basic', 'INVISIBLE');
+$t->write_file('auth-open-static', 'INVISIBLE');
+$t->run();
+
+###############################################################################
+
+like(http_get('/open'), qr/ 404 /, 'auth open');
+like(http_get('/unauthorized'), qr/ 401 /, 'auth unauthorized');
+like(http_get('/forbidden'), qr/ 403 /, 'auth forbidden');
+like(http_get('/error'), qr/ 500 /, 'auth error');
+like(http_get('/off'), qr/ 404 /, 'auth off');
+
+like(http_post('/open'), qr/ 404 /, 'auth post open');
+like(http_post('/unauthorized'), qr/ 401 /, 'auth post unauthorized');
+
+like(http_get('/open-static'), qr/ 404 /, 'auth open static');
+unlike(http_get('/open-static'), qr/INVISIBLE/, 'auth static no content');
+
+like(http_get('/proxy'), qr/ 401 /, 'proxy auth unauthorized');
+like(http_get('/proxy'), qr/WWW-Authenticate: Basic realm="restricted"/,
+	'proxy auth has www-authenticate');
+like(http_get_auth('/proxy'), qr/ 404 /, 'proxy auth pass');
+unlike(http_get_auth('/proxy'), qr/INVISIBLE/, 'proxy auth no content');
+
+like(http_post('/proxy'), qr/ 401 /, 'proxy auth post');
+
+like(http_get_auth('/proxy-cache'), qr/ 404 /, 'proxy auth with cache');
+like(http_get('/proxy-cache'), qr/ 404 /, 'proxy auth cached');
+
+# Consider the following scenario:
+#
+# 1. proxy_pass reads request body, then goes to fallback via error_page
+# 2. auth request uses proxy_pass, and upstream module closes request body file
+#    in ngx_http_upstream_send_response()
+# 3. oops: fallback has no body
+#
+# To prevent this we always allocate fake request body for auth request.
+#
+# Note that this doesn't happen when using header_only as relevant code
+# in ngx_http_upstream_send_response() isn't reached.  It may be reached
+# with proxy_cache or proxy_store, but they will shutdown client connection
+# in case of header_only and hence do not work for us at all.
+
+like(http_post_big('/proxy-double'), qr/ 204 /, 'proxy auth with body read');
+
+SKIP: {
+	eval { require FCGI; };
+	skip 'FCGI not installed', 2 if $@;
+	skip 'win32', 2 if $^O eq 'MSWin32';
+
+	$t->run_daemon(\&fastcgi_daemon);
+	$t->waitforsocket('127.0.0.1:' . port(8081));
+
+	like(http_get('/fastcgi'), qr/ 404 /, 'fastcgi auth open');
+	unlike(http_get('/fastcgi'), qr/INVISIBLE/, 'fastcgi auth no content');
+}
+
+###############################################################################
+
+sub http_get_auth {
+	my ($url, %extra) = @_;
+	return http(<<EOF, %extra);
+GET $url HTTP/1.0
+Host: localhost
+Authorization: Basic dXNlcjpzZWNyZXQ=
+
+EOF
+}
+
+sub http_post {
+	my ($url, %extra) = @_;
+
+	my $p = "POST $url HTTP/1.0" . CRLF .
+		"Host: localhost" . CRLF .
+		"Content-Length: 10" . CRLF .
+		CRLF .
+		"1234567890";
+
+	return http($p, %extra);
+}
+
+sub http_post_big {
+	my ($url, %extra) = @_;
+
+	my $p = "POST $url HTTP/1.0" . CRLF .
+		"Host: localhost" . CRLF .
+		"Content-Length: 10240" . CRLF .
+		CRLF .
+		("1234567890" x 1024);
+
+	return http($p, %extra);
+}
+
+###############################################################################
+
+sub fastcgi_daemon {
+	my $socket = FCGI::OpenSocket('127.0.0.1:' . port(8081), 5);
+	my $request = FCGI::Request(\*STDIN, \*STDOUT, \*STDERR, \%ENV,
+		$socket);
+
+	while ($request->Accept() >= 0) {
+		print <<EOF;
+Content-Type: text/html
+
+INVISIBLE
+EOF
+	}
+
+	FCGI::CloseSocket($socket);
+}
+
+###############################################################################
diff --git a/tests/auth_request_satisfy.t b/tests/auth_request_satisfy.t
new file mode 100644
index 0000000..d512212
--- /dev/null
+++ b/tests/auth_request_satisfy.t
@@ -0,0 +1,136 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for auth request module with satisfy directive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()
+	->has(qw/http rewrite access auth_basic auth_request/)
+	->plan(18);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            return 444;
+        }
+
+        location /all/allow {
+            satisfy all;
+            allow all;
+            auth_request /auth;
+        }
+
+        location /all/deny {
+            satisfy all;
+            deny all;
+            auth_request /auth;
+        }
+
+        location /all/basic {
+            satisfy all;
+            auth_basic "restricted";
+            auth_basic_user_file %%TESTDIR%%/htpasswd;
+            auth_request /auth;
+        }
+
+        location /any/allow {
+            satisfy any;
+            allow all;
+            auth_request /auth;
+        }
+
+        location /any/deny {
+            satisfy any;
+            deny all;
+            auth_request /auth;
+        }
+
+        location /any/basic {
+            satisfy any;
+            auth_basic "restricted";
+            auth_basic_user_file %%TESTDIR%%/htpasswd;
+            auth_request /auth;
+        }
+
+        location = /auth {
+            if ($request_uri ~ "open$") {
+                return 204;
+            }
+            if ($request_uri ~ "unauthorized$") {
+                return 401;
+            }
+            if ($request_uri ~ "forbidden$") {
+                return 403;
+            }
+        }
+    }
+}
+
+EOF
+
+$t->write_file('htpasswd', 'user:{PLAIN}secret' . "\n");
+$t->run();
+
+###############################################################################
+
+# satisfy all - first 401/403 wins
+
+like(http_get('/all/allow+open'), qr/ 404 /, 'all allow+open');
+like(http_get('/all/allow+unauthorized'), qr/ 401 /, 'all allow+unauthorized');
+like(http_get('/all/allow+forbidden'), qr/ 403 /, 'all allow+forbidden');
+
+like(http_get('/all/deny+open'), qr/ 403 /, 'all deny+open');
+like(http_get('/all/deny+unauthorized'), qr/ 403 /, 'all deny+unauthorized');
+like(http_get('/all/deny+forbidden'), qr/ 403 /, 'all deny+forbidden');
+
+like(http_get('/all/basic+open'), qr/ 401 /, 'all basic+open');
+like(http_get('/all/basic+unauthorized'), qr/ 401 /, 'all basic+unauthorized');
+like(http_get('/all/basic+forbidden'), qr/ 401 /, 'all basic+forbidden');
+
+# satisfy any - first ok wins
+# additionally, 403 shouldn't override 401 status
+
+like(http_get('/any/allow+open'), qr/ 404 /, 'any allow+open');
+like(http_get('/any/allow+unauthorized'), qr/ 404 /, 'any allow+unauthorized');
+like(http_get('/any/allow+forbidden'), qr/ 404 /, 'any allow+forbidden');
+
+like(http_get('/any/deny+open'), qr/ 404 /, 'any deny+open');
+like(http_get('/any/deny+unauthorized'), qr/ 401 /, 'any deny+unauthorized');
+like(http_get('/any/deny+forbidden'), qr/ 403 /, 'any deny+forbidden');
+
+like(http_get('/any/basic+open'), qr/ 404 /, 'any basic+open');
+like(http_get('/any/basic+unauthorized'), qr/ 401 /, 'any basic+unauthorized');
+like(http_get('/any/basic+forbidden'), qr/ 401 /, 'any basic+forbidden');
+
+###############################################################################
diff --git a/tests/auth_request_set.t b/tests/auth_request_set.t
new file mode 100644
index 0000000..2144b87
--- /dev/null
+++ b/tests/auth_request_set.t
@@ -0,0 +1,144 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for auth request module, auth_request_set.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http rewrite proxy auth_request/)
+	->plan(6);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location = /t1.html {
+            auth_request /auth;
+            auth_request_set $username $upstream_http_x_username;
+            add_header X-Set-Username $username;
+        }
+
+        location = /t2.html {
+            auth_request /auth;
+            auth_request_set $username $upstream_http_x_username;
+            error_page 404 = /fallback;
+        }
+        location = /fallback {
+            add_header X-Set-Username $username;
+            return 204;
+        }
+
+        location = /t3.html {
+            auth_request /auth;
+            auth_request_set $username $upstream_http_x_username;
+            error_page 404 = @fallback;
+        }
+        location @fallback {
+            add_header X-Set-Username $username;
+            return 204;
+        }
+
+        location = /t4.html {
+            auth_request /auth;
+            auth_request_set $username $upstream_http_x_username;
+            error_page 404 = /t4-fallback.html;
+        }
+        location = /t4-fallback.html {
+            auth_request /auth2;
+            auth_request_set $username $upstream_http_x_username;
+            add_header X-Set-Username $username;
+        }
+
+        location = /t5.html {
+            auth_request /auth;
+            auth_request_set $args "setargs";
+            proxy_pass http://127.0.0.1:8081/t5.html;
+        }
+
+        location = /t6.html {
+            add_header X-Unset-Username "x${username}x";
+            return 204;
+        }
+
+        location = /auth {
+            proxy_pass http://127.0.0.1:8081;
+        }
+        location = /auth2 {
+            proxy_pass http://127.0.0.1:8081;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location = /auth {
+            add_header X-Username "username";
+            return 204;
+        }
+
+        location = /auth2 {
+            add_header X-Username "username2";
+            return 204;
+        }
+
+        location = /t5.html {
+            add_header X-Args $args;
+            return 204;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('t1.html', '');
+$t->write_file('t4-fallback.html', '');
+$t->run();
+
+###############################################################################
+
+like(http_get('/t1.html'), qr/X-Set-Username: username/, 'set normal');
+like(http_get('/t2.html'), qr/X-Set-Username: username/, 'set after redirect');
+like(http_get('/t3.html'), qr/X-Set-Username: username/,
+	'set after named location');
+like(http_get('/t4.html'), qr/X-Set-Username: username2/,
+	'set on second auth');
+
+# there are two variables with set_handler: $args and $limit_rate
+# we do test $args as it's a bit more simple thing to do
+
+like(http_get('/t5.html'), qr/X-Args: setargs/, 'variable with set_handler');
+
+# check that using variable without setting it returns empty content
+
+like(http_get('/t6.html'), qr/X-Unset-Username: xx/, 'unset variable');
+
+###############################################################################
diff --git a/tests/autoindex.t b/tests/autoindex.t
new file mode 100644
index 0000000..a9b2eed
--- /dev/null
+++ b/tests/autoindex.t
@@ -0,0 +1,109 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for autoindex module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http autoindex charset symlink/)->plan(16)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            autoindex on;
+        }
+        location /utf8/ {
+            autoindex on;
+            charset utf-8;
+        }
+    }
+}
+
+EOF
+
+my $d = $t->testdir();
+
+mkdir("$d/test-dir");
+symlink("$d/test-dir", "$d/test-dir-link");
+
+$t->write_file('test-file', '');
+symlink("$d/test-file", "$d/test-file-link");
+
+$t->write_file('test-colon:blah', '');
+$t->write_file('test-long-' . ('0' x 50), '');
+$t->write_file('test-long-' . ('>' x 50), '');
+$t->write_file('test-escape-url-%', '');
+$t->write_file('test-escape-url2-?', '');
+$t->write_file('test-escape-html-<>&', '');
+
+mkdir($d . '/utf8');
+$t->write_file('utf8/test-utf8-' . ("\xd1\x84" x 3), '');
+$t->write_file('utf8/test-utf8-' . ("\xd1\x84" x 45), '');
+$t->write_file('utf8/test-utf8-<>&-' . "\xd1\x84", '');
+$t->write_file('utf8/test-utf8-<>&-' . ("\xd1\x84" x 45), '');
+$t->write_file('utf8/test-utf8-' . ("\xd1\x84" x 3) . '-' . ('>' x 45), '');
+
+mkdir($d . '/test-dir-escape-<>&');
+
+$t->run();
+
+###############################################################################
+
+my $r = http_get('/');
+
+like($r, qr!href="test-file"!ms, 'file');
+like($r, qr!href="test-file-link"!ms, 'symlink to file');
+like($r, qr!href="test-dir/"!ms, 'directory');
+like($r, qr!href="test-dir-link/"!ms, 'symlink to directory');
+
+unlike($r, qr!href="test-colon:blah"!ms, 'colon not scheme');
+like($r, qr!test-long-0{37}\.\.&gt;!ms, 'long name');
+
+like($r, qr!href="test-escape-url-%25"!ms, 'escaped url');
+like($r, qr!href="test-escape-url2-%3f"!msi, 'escaped ? in url');
+like($r, qr!test-escape-html-&lt;&gt;&amp;!ms, 'escaped html');
+like($r, qr!test-long-(&gt;){37}\.\.&gt;!ms, 'long escaped html');
+
+$r = http_get('/utf8/');
+
+like($r, qr!test-utf8-(\xd1\x84){3}</a>!ms, 'utf8');
+like($r, qr!test-utf8-(\xd1\x84){37}\.\.!ms, 'utf8 long');
+
+like($r, qr!test-utf8-&lt;&gt;&amp;-\xd1\x84</a>!ms, 'utf8 escaped');
+like($r, qr!test-utf8-&lt;&gt;&amp;-(\xd1\x84){33}\.\.!ms,
+	'utf8 escaped long');
+like($r, qr!test-utf8-(\xd1\x84){3}-(&gt;){33}\.\.!ms, 'utf8 long escaped');
+
+like(http_get('/test-dir-escape-<>&/'), qr!test-dir-escape-&lt;&gt;&amp;!ms,
+	'escaped title');
+
+###############################################################################
diff --git a/tests/autoindex_format.t b/tests/autoindex_format.t
new file mode 100644
index 0000000..b89950c
--- /dev/null
+++ b/tests/autoindex_format.t
@@ -0,0 +1,175 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for autoindex module with autoindex_format directive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http autoindex symlink/)->plan(37)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        autoindex on;
+
+        location /xml/ {
+            autoindex_format xml;
+            alias %%TESTDIR%%/;
+        }
+        location /json/ {
+            autoindex_format json;
+            alias %%TESTDIR%%/;
+        }
+        location /jsonp/ {
+            autoindex_format jsonp;
+            alias %%TESTDIR%%/;
+        }
+    }
+}
+
+EOF
+
+my $d = $t->testdir();
+
+mkdir("$d/test-dir");
+symlink("$d/test-dir", "$d/test-dir-link");
+
+$t->write_file('test-file', 'x' x 42);
+symlink("$d/test-file", "$d/test-file-link");
+
+$t->write_file('test-\'-quote', '');
+$t->write_file('test-"-double', '');
+$t->write_file('test-<>-angle', '');
+
+mkdir($d . '/utf8');
+$t->write_file('utf8/test-utf8-' . ("\xd1\x84" x 3), '');
+$t->write_file('utf8/test-utf8-' . ("\xd1\x84" x 45), '');
+
+$t->run();
+
+###############################################################################
+
+my ($r, $mtime, $data);
+
+$r = http_get('/xml/');
+$mtime = qr/mtime="\d{4}-\d\d-\d\dT\d\d:\d\d:\d\dZ"/;
+
+like($r, qr!Content-Type: text/xml; charset=utf-8!, 'xml content type');
+like($r, qr!<file(\s+\w+="[^=]*?")+\s*>test-file</file>!,
+	'xml file format');
+like($r, qr!<directory(\s+\w+="[^=]*?")+\s*>test-dir</directory>!,
+	'xml dir format');
+
+($data) = $r =~ qr!<file\s+(.*?)>test-file</file>!;
+like($data, $mtime, 'xml file mtime');
+like($data, qr!size="42"!, 'xml file size');
+
+($data) = $r =~ qr!<file\s+(.*?)>test-file-link</file>!;
+like($data, $mtime, 'xml file link mtime');
+like($data, qr!size="42"!, 'xml file link size');
+
+($data) = $r =~ qr!<directory\s+(.*?)>test-dir</directory>!;
+like($data, $mtime, 'xml dir mtime');
+unlike($data, qr!size="\d+"!, 'xml dir size');
+
+($data) = $r =~ qr!<directory\s+(.*?)>test-dir-link</directory>!;
+like($data, $mtime, 'xml dir link mtime');
+unlike($data, qr!size="\d+"!, 'xml dir link size');
+
+like($r, qr!<file.*?>test-\'-quote</file>!, 'xml quote');
+like($r, qr!<file.*?>test-\&quot;-double</file>!, 'xml double');
+like($r, qr!<file.*?>test-&lt;&gt;-angle</file>!, 'xml angle');
+
+
+$r = http_get('/json/');
+$mtime = qr/"mtime"\s*:\s*"\w{3}, \d\d \w{3} \d{4} \d\d:\d\d:\d\d \w{3}"/;
+
+my $string = qr!"(?:[^\\"]+|\\["\\/bfnrt])*"!;
+my $number = qr!-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][-+]?\d+)?!;
+my $kv = qr!\s*$string\s*:\s*($string|$number)\s*!;
+
+like($r, qr!Content-Type: application/json!, 'json content type');
+like($r, qr!{$kv(,$kv)*}!, 'json format');
+
+($data) = $r =~ qr!(\{[^}]*?"name"\s*:\s*"test-file".*?})!;
+like($data, qr!"type"\s*:\s*"file"!, 'json file');
+like($data, $mtime, 'json file mtime');
+like($data, qr!"size"\s*:\s*42!, 'json file size');
+
+($data) = $r =~ qr!(\{[^}]*?"name"\s*:\s*"test-file-link".*?})!;
+like($data, qr!"type"\s*:\s*"file"!, 'json file link');
+like($data, $mtime, 'json file link mtime');
+like($data, qr!"size"\s*:\s*42!, 'json file link size');
+
+($data) = $r =~ qr!(\{[^}]*?"name"\s*:\s*"test-dir".*?})!;
+like($data, qr!"type"\s*:\s*"directory"!, 'json dir');
+like($data, $mtime, 'json dir mtime');
+unlike($data, qr!"size"\s*:\s*$number!, 'json dir size');
+
+($data) = $r =~ qr!(\{[^}]*?"name"\s*:\s*"test-dir-link".*?})!;
+like($data, qr!"type"\s*:\s*"directory"!, 'json dir link');
+like($data, $mtime, 'json dir link mtime');
+unlike($data, qr!"size"\s*:\s*$number!, 'json dir link size');
+
+like($r, qr!"name"\s*:\s*"test-'-quote"!, 'json quote');
+like($r, qr!"name"\s*:\s*"test-\\\"-double"!, 'json double');
+like($r, qr!"name"\s*:\s*"test-<>-angle"!, 'json angle');
+
+like(http_get_body('/jsonp/test-dir/?callback=foo'),
+	qr/^\s*foo\s*\(\s*\[\s*\]\s*\)\s*;\s*$/ms, 'jsonp callback');
+like(http_get_body('/jsonp/test-dir/?callback='),
+	qr/^\s*\[\s*\s*\]\s*$/ms, 'jsonp callback empty');
+
+# utf8 tests
+
+$r = http_get('/xml/utf8/');
+like($r, qr!test-utf8-(\xd1\x84){3}</file>!ms, 'xml utf8');
+like($r, qr!test-utf8-(\xd1\x84){45}</file>!ms, 'xml utf8 long');
+
+$r = http_get('/json/utf8/');
+like($r, qr!test-utf8-(\xd1\x84){3}"!ms, 'json utf8');
+like($r, qr!test-utf8-(\xd1\x84){45}"!ms, 'json utf8 long');
+
+###############################################################################
+
+sub http_get_body {
+	my ($uri) = @_;
+
+	return undef if !defined $uri;
+
+	http_get($uri) =~ /(.*?)\x0d\x0a?\x0d\x0a?(.*)/ms;
+
+	return $2;
+}
+
+###############################################################################
diff --git a/tests/binary_upgrade.t b/tests/binary_upgrade.t
new file mode 100644
index 0000000..3aedd63
--- /dev/null
+++ b/tests/binary_upgrade.t
@@ -0,0 +1,56 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for binary upgrade.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+plan(skip_all => 'can leave orphaned process group')
+	unless $ENV{TEST_NGINX_UNSAFE};
+
+my $t = Test::Nginx->new()->plan(2)->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+events {
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+my $pid = $t->read_file('nginx.pid');
+ok($pid, 'master pid');
+
+kill 'USR2', $pid;
+
+for (1 .. 30) {
+	last if -e $t->testdir() . '/nginx.pid'
+		&& -e $t->testdir() . '/nginx.pid.oldbin';
+	select undef, undef, undef, 0.2
+}
+
+isnt($t->read_file('nginx.pid'), $pid, 'master pid changed');
+
+kill 'QUIT', $pid;
+
+###############################################################################
diff --git a/tests/body.t b/tests/body.t
new file mode 100644
index 0000000..0e3561d
--- /dev/null
+++ b/tests/body.t
@@ -0,0 +1,220 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for nginx request body reading.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy rewrite/)->plan(15);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    upstream u {
+        server 127.0.0.1:8082;
+        server 127.0.0.1:8080 backup;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        client_header_buffer_size 1k;
+
+        location / {
+            client_body_buffer_size 2k;
+            add_header X-Body "$request_body";
+            add_header X-Body-File "$request_body_file";
+            proxy_pass http://127.0.0.1:8081;
+        }
+        location /b {
+            client_body_buffer_size 2k;
+            client_body_in_file_only on;
+            add_header X-Body "$request_body";
+            add_header X-Body-File "$request_body_file";
+            proxy_pass http://127.0.0.1:8081;
+        }
+        location /small {
+            client_body_in_file_only on;
+            add_header X-Original-Uri "$request_uri";
+            proxy_pass http://127.0.0.1:8080/;
+        }
+        location /single {
+            client_body_in_single_buffer on;
+            add_header X-Body "$request_body";
+            add_header X-Body-File "$request_body_file";
+            proxy_pass http://127.0.0.1:8081;
+        }
+        location /large {
+            client_max_body_size 1k;
+            proxy_pass http://127.0.0.1:8081;
+        }
+        location /discard {
+            return 200 "TEST\n";
+        }
+        location /next {
+            proxy_pass http://u/;
+        }
+        location /redirect {
+            error_page 404 http://example.com/;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location / {
+            return 200 "TEST\n";
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8082;
+        server_name  localhost;
+
+        location / {
+            return 444;
+        }
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+unlike(http_get('/'), qr/X-Body:/ms, 'no body');
+
+like(http_get_body('/', '0123456789'),
+	qr/X-Body: 0123456789\x0d?$/ms, 'body');
+
+like(http_get_body('/', '0123456789' x 128),
+	qr/X-Body: (0123456789){128}\x0d?$/ms, 'body in two buffers');
+
+like(http_get_body('/', '0123456789' x 512),
+	qr/X-Body-File/ms, 'body in file');
+
+like(read_body_file(http_get_body('/b', '0123456789' x 512)),
+	qr/^(0123456789){512}$/s, 'body in file only');
+
+like(http_get_body('/single', '0123456789' x 128),
+	qr/X-Body: (0123456789){128}\x0d?$/ms, 'body in single buffer');
+
+like(http_get_body('/large', '0123456789' x 128), qr/ 413 /, 'body too large');
+
+# pipelined requests
+
+like(http_get_body('/', '0123456789', '0123456789' x 128, '0123456789' x 512,
+	'foobar'), qr/X-Body: foobar\x0d?$/ms, 'body pipelined');
+like(http_get_body('/', '0123456789' x 128, '0123456789' x 512, '0123456789',
+	'foobar'), qr/X-Body: foobar\x0d?$/ms, 'body pipelined 2');
+
+like(http_get_body('/discard', '0123456789', '0123456789' x 128,
+	'0123456789' x 512, 'foobar'), qr/(TEST.*){4}/ms,
+	'body discard');
+like(http_get_body('/discard', '0123456789' x 128, '0123456789' x 512,
+	'0123456789', 'foobar'), qr/(TEST.*){4}/ms,
+	'body discard 2');
+
+# proxy with file only
+
+like(http_get_body('/small', '0123456789'),
+	qr/X-Body: 0123456789\x0d?$/ms, 'small body in file only');
+
+# proxy with file only - reuse of r->header_in
+
+like(
+	http(
+		'GET /small HTTP/1.0' . CRLF
+		. 'Content-Length: 10' . CRLF . CRLF
+		. '01234',
+		sleep => 0.1,
+		body => '56789'
+	),
+	qr!X-Body: 0123456789\x0d?\x0a.*X-Original-Uri: /small!ms,
+	'small body in file only, not preread'
+);
+
+# proxy_next_upstream
+
+like(http_get_body('/next', '0123456789'),
+	qr/X-Body: 0123456789\x0d?$/ms, 'body next upstream');
+
+# discarded request body in redirect via error_page
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.17.7');
+
+unlike(
+	http(
+		'POST /redirect HTTP/1.1' . CRLF
+		. 'Host: localhost' . CRLF
+		. 'Content-Length: 10' . CRLF . CRLF
+		. '0123456789' .
+		'GET /next HTTP/1.0' . CRLF . CRLF
+	),
+	qr/400 Bad Request/ms, 'redirect - discard request body'
+);
+
+}
+
+###############################################################################
+
+sub read_body_file {
+	my ($r) = @_;
+	return '' unless $r =~ m/X-Body-File: (.*)/;
+	open FILE, $1
+		or return "$!";
+	local $/;
+	my $content = <FILE>;
+	close FILE;
+	return $content;
+}
+
+sub http_get_body {
+	my $uri = shift;
+	my $last = pop;
+	return http( join '', (map {
+		my $body = $_;
+		"GET $uri HTTP/1.1" . CRLF
+		. "Host: localhost" . CRLF
+		. "Content-Length: " . (length $body) . CRLF . CRLF
+		. $body
+	} @_),
+		"GET $uri HTTP/1.1" . CRLF
+		. "Host: localhost" . CRLF
+		. "Connection: close" . CRLF
+		. "Content-Length: " . (length $last) . CRLF . CRLF
+		. $last
+	);
+}
+
+###############################################################################
diff --git a/tests/body_chunked.t b/tests/body_chunked.t
new file mode 100644
index 0000000..549d4cc
--- /dev/null
+++ b/tests/body_chunked.t
@@ -0,0 +1,236 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for nginx request body reading, with chunked transfer-coding.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy rewrite/)->plan(16);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    upstream u {
+        server 127.0.0.1:8082;
+        server 127.0.0.1:8080 backup;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        client_header_buffer_size 1k;
+
+        location / {
+            client_body_buffer_size 2k;
+            add_header X-Body "$request_body";
+            add_header X-Body-File "$request_body_file";
+            proxy_pass http://127.0.0.1:8081;
+        }
+        location /b {
+            client_body_buffer_size 2k;
+            client_body_in_file_only on;
+            add_header X-Body "$request_body";
+            add_header X-Body-File "$request_body_file";
+            proxy_pass http://127.0.0.1:8081;
+        }
+        location /single {
+            client_body_in_single_buffer on;
+            add_header X-Body "$request_body";
+            add_header X-Body-File "$request_body_file";
+            proxy_pass http://127.0.0.1:8081;
+        }
+        location /large {
+            client_max_body_size 1k;
+            proxy_pass http://127.0.0.1:8081;
+        }
+        location /discard {
+            return 200 "TEST\n";
+        }
+        location /next {
+            proxy_pass http://u/;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location / {
+            return 200 "TEST\n";
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8082;
+        server_name  localhost;
+
+        location / {
+            return 444;
+        }
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+like(http_get_body('/', '0123456789'),
+	qr/X-Body: 0123456789\x0d?$/ms, 'body');
+
+like(http_get_body('/', '0123456789' x 128),
+	qr/X-Body: (0123456789){128}\x0d?$/ms, 'body in two buffers');
+
+like(http_get_body('/', '0123456789' x 512),
+	qr/X-Body-File/ms, 'body in file');
+
+like(read_body_file(http_get_body('/b', '0123456789' x 512)),
+	qr/^(0123456789){512}$/s, 'body in file only');
+
+like(http_get_body('/single', '0123456789' x 128),
+	qr/X-Body: (0123456789){128}\x0d?$/ms, 'body in single buffer');
+
+like(http_get_body('/large', '0123456789' x 128), qr/ 413 /, 'body too large');
+
+# pipelined requests
+
+like(http_get_body('/', '0123456789', '0123456789' x 128, '0123456789' x 512,
+	'foobar'), qr/X-Body: foobar\x0d?$/ms, 'chunked body pipelined');
+like(http_get_body('/', '0123456789' x 128, '0123456789' x 512, '0123456789',
+	'foobar'), qr/X-Body: foobar\x0d?$/ms, 'chunked body pipelined 2');
+
+like(http_get_body('/discard', '0123456789', '0123456789' x 128,
+	'0123456789' x 512, 'foobar'), qr/(TEST.*){4}/ms,
+	'chunked body discard');
+like(http_get_body('/discard', '0123456789' x 128, '0123456789' x 512,
+	'0123456789', 'foobar'), qr/(TEST.*){4}/ms,
+	'chunked body discard 2');
+
+# invalid chunks
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.17.4');
+
+like(
+	http(
+		'GET / HTTP/1.1' . CRLF
+		. 'Host: localhost' . CRLF
+		. 'Connection: close' . CRLF
+		. 'Transfer-Encoding: chunked' . CRLF . CRLF
+		. '4' . CRLF
+		. 'SEE-THIS' . CRLF
+		. '0' . CRLF . CRLF
+	),
+	qr/400 Bad/, 'runaway chunk'
+);
+
+like(
+	http(
+		'GET /discard HTTP/1.1' . CRLF
+		. 'Host: localhost' . CRLF
+		. 'Connection: close' . CRLF
+		. 'Transfer-Encoding: chunked' . CRLF . CRLF
+		. '4' . CRLF
+		. 'SEE-THIS' . CRLF
+		. '0' . CRLF . CRLF
+	),
+	qr/400 Bad/, 'runaway chunk discard'
+);
+
+}
+
+# proxy_next_upstream
+
+like(http_get_body('/next', '0123456789'),
+	qr/X-Body: 0123456789\x0d?$/ms, 'body chunked next upstream');
+
+# invalid Transfer-Encoding
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.17.9');
+
+like(http_transfer_encoding('identity'), qr/501 Not Implemented/,
+	'transfer encoding identity');
+
+like(http_transfer_encoding("chunked\nTransfer-Encoding: chunked"),
+	qr/400 Bad/, 'transfer encoding repeat');
+
+}
+
+like(http_transfer_encoding('chunked, identity'), qr/501 Not Implemented/,
+	'transfer encoding list');
+
+###############################################################################
+
+sub read_body_file {
+	my ($r) = @_;
+	return '' unless $r =~ m/X-Body-File: (.*)/;
+	open FILE, $1
+		or return "$!";
+	local $/;
+	my $content = <FILE>;
+	close FILE;
+	return $content;
+}
+
+sub http_get_body {
+	my $uri = shift;
+	my $last = pop;
+	return http( join '', (map {
+		my $body = $_;
+		"GET $uri HTTP/1.1" . CRLF
+		. "Host: localhost" . CRLF
+		. "Transfer-Encoding: chunked" . CRLF . CRLF
+		. sprintf("%x", length $body) . CRLF
+		. $body . CRLF
+		. "0" . CRLF . CRLF
+	} @_),
+		"GET $uri HTTP/1.1" . CRLF
+		. "Host: localhost" . CRLF
+		. "Connection: close" . CRLF
+		. "Transfer-Encoding: chunked" . CRLF . CRLF
+		. sprintf("%x", length $last) . CRLF
+		. $last . CRLF
+		. "0" . CRLF . CRLF
+	);
+}
+
+sub http_transfer_encoding {
+	my ($encoding) = @_;
+
+	http("GET / HTTP/1.1" . CRLF
+		. "Host: localhost" . CRLF
+		. "Connection: close" . CRLF
+		. "Transfer-Encoding: $encoding" . CRLF . CRLF
+		. "0" . CRLF . CRLF);
+}
+
+###############################################################################
diff --git a/tests/charset.t b/tests/charset.t
new file mode 100644
index 0000000..203c158
--- /dev/null
+++ b/tests/charset.t
@@ -0,0 +1,102 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+# (C) Nginx, Inc.
+
+# Tests for charset filter.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http charset proxy/)->plan(7)
+	->write_file_expand('nginx.conf', <<'EOF')->run();
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    types {
+        text/html html;
+        text/foo  foo;
+    }
+
+    charset_map B A {
+        58 59; # X -> Y
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            charset utf-8;
+        }
+
+        location /t3.foo {
+            charset utf-8;
+            charset_types text/foo;
+        }
+
+        location /t4.any {
+            charset utf-8;
+            charset_types *;
+        }
+
+        location /t5.html {
+            charset $arg_c;
+        }
+
+        location /t.html {
+            charset A;
+            source_charset B;
+        }
+
+        location /proxy/ {
+            charset B;
+            override_charset on;
+            proxy_pass http://127.0.0.1:8080/;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('t1.html', '');
+$t->write_file('t2.foo', '');
+$t->write_file('t3.foo', '');
+$t->write_file('t4.any', '');
+$t->write_file('t5.html', '');
+$t->write_file('t.html', 'X' x 99);
+
+###############################################################################
+
+like(http_get('/t1.html'), qr!text/html; charset=utf-8!, 'charset indicated');
+like(http_get('/t2.foo'), qr!text/foo\x0d!, 'wrong type');
+like(http_get('/t3.foo'), qr!text/foo; charset=utf-8!, 'charset_types');
+like(http_get('/t4.any'), qr!text/plain; charset=utf-8!, 'charset_types any');
+like(http_get('/t5.html?c=utf-8'), qr!text/html; charset=utf-8!, 'variables');
+
+like(http_get('/t.html'), qr!Y{99}!, 'recode');
+like(http_get('/proxy/t.html'), qr!X{99}!, 'override charset');
+
+###############################################################################
diff --git a/tests/charset_gzip_static.t b/tests/charset_gzip_static.t
new file mode 100644
index 0000000..a6a6e4a
--- /dev/null
+++ b/tests/charset_gzip_static.t
@@ -0,0 +1,144 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+# (C) Nginx, Inc.
+
+# Tests for charset filter.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx qw/ :DEFAULT :gzip /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy charset gzip_static/)->plan(13)
+	->write_file_expand('nginx.conf', <<'EOF')->run();
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    types {
+        text/html html;
+    }
+
+    charset_map B A {
+        58 59; # X -> Y
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /t1 {
+            charset utf-8;
+            gzip_static on;
+        }
+
+        location /t2 {
+            gzip_static on;
+            charset A;
+            source_charset B;
+        }
+
+        location /t {
+            gzip_static on;
+        }
+
+        location /p/ {
+            charset utf-8;
+            proxy_pass http://127.0.0.1:8080/;
+            proxy_http_version 1.1;
+        }
+
+        location /p.ab/ {
+            charset A;
+            source_charset B;
+            proxy_pass http://127.0.0.1:8080/;
+            proxy_http_version 1.1;
+        }
+
+        location /p.aa/ {
+            charset A;
+            source_charset A;
+            proxy_pass http://127.0.0.1:8080/;
+            proxy_http_version 1.1;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('t1.html', '');
+$t->write_file('t1.html.gz', '');
+
+my $in = 'X' x 99;
+my $out = '';
+
+eval {
+	require IO::Compress::Gzip;
+	IO::Compress::Gzip::gzip(\$in => \$out);
+};
+
+$t->write_file('t2.html', $in);
+$t->write_file('t2.html.gz', $out);
+
+$t->write_file('t.html', '');
+$t->write_file('t.html.gz', '');
+
+###############################################################################
+
+# charset filter currently ignores responses with Content-Encoding set
+# (except ones with r->ignore_content_encoding used by gzip_static)
+# as it can't convert such content; there are two problems though:
+#
+# - it make sense to indicate charset
+#   if conversion isn't needed
+#
+# - gzip_static may need conversion, too
+#
+# proper solution seems to be to always allow charset indication, but
+# don't try to do anything if recoding is needed
+
+like(http_get('/t1.html'), qr!text/html; charset=!, 'plain');
+like(http_gzip_request('/t1.html'), qr!text/html; charset=.*gzip!ms, 'gzip');
+
+like(http_get('/t2.html'), qr!text/html; charset=A.*Y{99}!ms, 'recode plain');
+like(http_gzip_request('/t2.html'), qr!text/html\x0d.*gzip!ms, 'recode gzip');
+http_gzip_like(http_gzip_request('/t2.html'), qr!X{99}!, 'recode content');
+
+like(http_get('/t.html'), qr!text/html\x0d!, 'nocharset plain');
+like(http_gzip_request('/t.html'), qr!text/html\x0d.*gzip!ms, 'nocharset gzip');
+
+like(http_get('/p/t.html'), qr!text/html; charset=!, 'proxy plain');
+like(http_gzip_request('/p/t.html'), qr!text/html; charset=.*gzip!ms,
+	'proxy gzip');
+
+like(http_get('/p.ab/t.html'), qr!text/html; charset=A!ms,
+	'proxy recode plain');
+like(http_gzip_request('/p.ab/t.html'), qr!text/html\x0d.*gzip!ms,
+	'proxy recode gzip');
+
+like(http_get('/p.aa/t.html'), qr!text/html; charset=A!ms,
+	'proxy nullrecode plain');
+like(http_gzip_request('/p.aa/t.html'), qr!text/html; charset=A.*gzip!ms,
+	'proxy nullrecode gzip');
+
+###############################################################################
diff --git a/tests/config_dump.t b/tests/config_dump.t
new file mode 100644
index 0000000..2d50c04
--- /dev/null
+++ b/tests/config_dump.t
@@ -0,0 +1,112 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for dumped nginx configuration (nginx -T).
+# Among other things, test that configuration blocks are properly processed.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http map/);
+
+$t->plan(13)->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+include %%TESTDIR%%/inc.conf;
+include %%TESTDIR%%/inc.conf;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    map $args $x {
+        default  0;
+        foo      bar;
+        include  map.conf;
+        include  map.conf;
+    }
+
+    upstream u {
+        server 127.0.0.1:8081;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / { }
+    }
+}
+
+EOF
+
+$t->write_file('inc.conf', 'include inc2.conf;');
+$t->write_file('inc2.conf', '#inc2.conf');
+$t->write_file('map.conf', '#map.conf;');
+
+$t->run();
+
+###############################################################################
+
+my $d = $t->testdir;
+
+my $dump = $t->dump_config();
+like($dump, qr!^# configuration file $d/nginx.conf:$!m, 'nginx.conf found');
+like($dump, qr!^# configuration file $d/inc.conf:$!m, 'inc.conf found');
+like($dump, qr!^# configuration file $d/inc2.conf:$!m, 'inc2.conf found');
+like($dump, qr!^# configuration file $d/map.conf:$!m, 'map.conf found');
+
+unlike($dump, qr!(# configuration file $d/inc.conf:).*\1!s, 'inc.conf uniq');
+unlike($dump, qr!(# configuration file $d/inc2.conf:).*\1!s, 'inc2.conf uniq');
+unlike($dump, qr!(# configuration file $d/map.conf:).*\1!s, 'map.conf uniq');
+
+is(getconf($t, $dump, 'nginx.conf'), $t->read_file('nginx.conf'), 'content');
+is(getconf($t, $dump, 'inc.conf'), $t->read_file('inc.conf'), 'content inc');
+is(getconf($t, $dump, 'map.conf'), $t->read_file('map.conf'), 'content inc 2');
+
+unlink($t->testdir . "/inc.conf");
+unlink($t->testdir . "/map.conf");
+
+$dump = $t->dump_config();
+unlike($dump, qr!file $d/inc.conf!, 'missing inc.conf');
+unlike($dump, qr!file $d/map.conf!, 'missing map.conf');
+like($dump, qr!file $d/nginx.conf test failed!, 'test failed');
+
+$t->write_file('inc.conf', 'include inc2.conf;');
+$t->write_file('inc2.conf', '#inc2.conf');
+$t->write_file('map.conf', '#map.conf;');
+
+###############################################################################
+
+sub getconf {
+	my ($t, $string, $conf) = @_;
+	my $prefix = "# configuration file $d/$conf:\n";
+	my $offset = index($string, $prefix) + length($prefix);
+	my $len = length($t->read_file($conf));
+	my $s = substr($string, $offset, $len);
+	$s =~ tr/\r//d;
+	return $s;
+}
+
+###############################################################################
diff --git a/tests/dav.t b/tests/dav.t
new file mode 100644
index 0000000..f01624a
--- /dev/null
+++ b/tests/dav.t
@@ -0,0 +1,272 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for nginx dav module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http dav/)->plan(27);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        absolute_redirect off;
+
+        location / {
+            dav_methods PUT DELETE MKCOL COPY MOVE;
+        }
+
+        location /i/ {
+            alias %%TESTDIR%%/;
+            dav_methods PUT DELETE MKCOL COPY MOVE;
+        }
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+my $r;
+
+$r = http(<<EOF . '0123456789');
+PUT /file HTTP/1.1
+Host: localhost
+Connection: close
+Content-Length: 10
+
+EOF
+
+like($r, qr/201 Created.*(Content-Length|\x0d\0a0\x0d\x0a)/ms, 'put file');
+is(-s $t->testdir() . '/file', 10, 'put file size');
+
+$r = http(<<EOF);
+PUT /file HTTP/1.1
+Host: localhost
+Connection: close
+Content-Length: 0
+
+EOF
+
+like($r, qr/204 No Content/, 'put file again');
+unlike($r, qr/Content-Length|Transfer-Encoding/, 'no length in 204');
+is(-s $t->testdir() . '/file', 0, 'put file again size');
+
+$r = http(<<EOF);
+DELETE /file HTTP/1.1
+Host: localhost
+Connection: close
+Content-Length: 0
+
+EOF
+
+like($r, qr/204 No Content/, 'delete file');
+unlike($r, qr/Content-Length|Transfer-Encoding/, 'no length in 204');
+ok(!-f $t->testdir() . '/file', 'file deleted');
+
+$r = http(<<EOF . '0123456789' . 'extra');
+PUT /file HTTP/1.1
+Host: localhost
+Connection: close
+Content-Length: 10
+
+EOF
+
+like($r, qr/201 Created.*(Content-Length|\x0d\0a0\x0d\x0a)/ms,
+	'put file extra data');
+is(-s $t->testdir() . '/file', 10,
+	'put file extra data size');
+
+# 201 replies contain body, response should indicate it's empty
+
+$r = http(<<EOF);
+MKCOL /test/ HTTP/1.1
+Host: localhost
+Connection: close
+
+EOF
+
+like($r, qr/201 Created.*(Content-Length|\x0d\0a0\x0d\x0a)/ms, 'mkcol');
+
+SKIP: {
+skip 'perl too old', 1 if !$^V or $^V lt v5.12.0;
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.17.7');
+
+like($r, qr!(?(?{ $r =~ /Location/ })Location: /test/)!, 'mkcol location');
+
+}
+
+}
+
+$r = http(<<EOF);
+COPY /test/ HTTP/1.1
+Host: localhost
+Destination: /test-moved/
+Connection: close
+
+EOF
+
+like($r, qr/201 Created.*(Content-Length|\x0d\0a0\x0d\x0a)/ms, 'copy dir');
+
+$r = http(<<EOF);
+MOVE /test/ HTTP/1.1
+Host: localhost
+Destination: /test-moved/
+Connection: close
+
+EOF
+
+like($r, qr/201 Created.*(Content-Length|\x0d\0a0\x0d\x0a)/ms, 'move dir');
+
+$r = http(<<EOF);
+COPY /file HTTP/1.1
+Host: localhost
+Destination: /file-moved%20escape
+Connection: close
+
+EOF
+
+like($r, qr/204 No Content/, 'copy file escaped');
+is(-s $t->testdir() . '/file-moved escape', 10, 'file copied unescaped');
+
+$t->write_file('file.exist', join '', (1 .. 42));
+
+$r = http(<<EOF);
+COPY /file HTTP/1.1
+Host: localhost
+Destination: /file.exist
+Connection: close
+
+EOF
+
+like($r, qr/204 No Content/, 'copy file overwrite');
+is(-s $t->testdir() . '/file.exist', 10, 'target file truncated');
+
+$r = http(<<EOF . '0123456789');
+PUT /i/alias HTTP/1.1
+Host: localhost
+Connection: close
+Content-Length: 10
+
+EOF
+
+like($r, qr/201 Created.*(Content-Length|\x0d\0a0\x0d\x0a)/ms, 'put alias');
+like($r, qr!Location: /i/alias\x0d?$!ms, 'location alias');
+is(-s $t->testdir() . '/alias', 10, 'put alias size');
+
+# request methods with unsupported request body
+
+$r = http(<<EOF . '0123456789');
+MKCOL /test/ HTTP/1.1
+Host: localhost
+Connection: close
+Content-Length: 10
+
+EOF
+
+like($r, qr/415 Unsupported/, 'mkcol body');
+
+$r = http(<<EOF . '0123456789');
+COPY /file HTTP/1.1
+Host: localhost
+Destination: /file.exist
+Connection: close
+Content-Length: 10
+
+EOF
+
+like($r, qr/415 Unsupported/, 'copy body');
+
+
+$r = http(<<EOF . '0123456789');
+DELETE /file HTTP/1.1
+Host: localhost
+Connection: close
+Content-Length: 10
+
+EOF
+
+like($r, qr/415 Unsupported/, 'delete body');
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.17.7');
+
+$r = http(<<EOF);
+MKCOL /test/ HTTP/1.1
+Host: localhost
+Connection: close
+Transfer-Encoding: chunked
+
+a
+0123456789
+0
+
+EOF
+
+like($r, qr/415 Unsupported/, 'mkcol body chunked');
+
+$r = http(<<EOF);
+COPY /file HTTP/1.1
+Host: localhost
+Destination: /file.exist
+Connection: close
+Transfer-Encoding: chunked
+
+a
+0123456789
+0
+
+EOF
+
+like($r, qr/415 Unsupported/, 'copy body chunked');
+
+$r = http(<<EOF);
+DELETE /file HTTP/1.1
+Host: localhost
+Connection: close
+Transfer-Encoding: chunked
+
+a
+0123456789
+0
+
+EOF
+
+like($r, qr/415 Unsupported/, 'delete body chunked');
+
+}
+
+###############################################################################
diff --git a/tests/dav_chunked.t b/tests/dav_chunked.t
new file mode 100644
index 0000000..3c63ad2
--- /dev/null
+++ b/tests/dav_chunked.t
@@ -0,0 +1,102 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for nginx dav module with chunked request body.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http dav/)->plan(6);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        client_header_buffer_size 1k;
+        client_body_buffer_size 2k;
+
+        location / {
+            dav_methods PUT;
+        }
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+my $r;
+
+$r = http(<<EOF);
+PUT /file HTTP/1.1
+Host: localhost
+Connection: close
+Transfer-Encoding: chunked
+
+a
+1234567890
+0
+
+EOF
+
+like($r, qr/201 Created.*(Content-Length|\x0d\0a0\x0d\x0a)/ms, 'put chunked');
+is($t->read_file('file'), '1234567890', 'put content');
+
+$r = http(<<EOF);
+PUT /file HTTP/1.1
+Host: localhost
+Connection: close
+Transfer-Encoding: chunked
+
+0
+
+EOF
+
+like($r, qr/204 No Content/, 'put chunked empty');
+is($t->read_file('file'), '', 'put empty content');
+
+my $body = ('a' . CRLF . '1234567890' . CRLF) x 1024 . '0' . CRLF . CRLF;
+
+$r = http(<<EOF);
+PUT /file HTTP/1.1
+Host: localhost
+Connection: close
+Transfer-Encoding: chunked
+
+$body
+EOF
+
+like($r, qr/204 No Content/, 'put chunked big');
+is($t->read_file('file'), '1234567890' x 1024, 'put big content');
+
+###############################################################################
diff --git a/tests/debug_connection.t b/tests/debug_connection.t
new file mode 100644
index 0000000..95e1bd5
--- /dev/null
+++ b/tests/debug_connection.t
@@ -0,0 +1,73 @@
+#!/usr/bin/perl
+
+# (C) Nginx, Inc.
+
+# Tests for debug_connection.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http --with-debug proxy/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+    debug_connection ::1;
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    error_log %%TESTDIR%%/debug1.log alert;
+    error_log %%TESTDIR%%/debug2.log alert;
+
+    server {
+        listen       127.0.0.1:8080;
+        listen       [::1]:%%PORT_8080%%;
+        server_name  localhost;
+
+        location /debug {
+            proxy_pass http://[::1]:%%PORT_8080%%/;
+        }
+    }
+}
+
+EOF
+
+$t->try_run('no inet6 support')->plan(5);
+
+###############################################################################
+
+http_get('/');
+
+select undef, undef, undef, 0.1;
+is($t->read_file('debug1.log'), '', 'no debug_connection file 1');
+is($t->read_file('debug2.log'), '', 'no debug_connection file 2');
+
+http_get('/debug');
+
+select undef, undef, undef, 0.1;
+like($t->read_file('debug1.log'), qr/\[debug\]/, 'debug_connection file 1');
+like($t->read_file('debug2.log'), qr/\[debug\]/, 'debug_connection file 2');
+is($t->read_file('debug1.log'), $t->read_file('debug2.log'),
+	'debug_connection file1 file2 match');
+
+###############################################################################
diff --git a/tests/debug_connection_syslog.t b/tests/debug_connection_syslog.t
new file mode 100644
index 0000000..5b28d7a
--- /dev/null
+++ b/tests/debug_connection_syslog.t
@@ -0,0 +1,100 @@
+#!/usr/bin/perl
+
+# (C) Nginx, Inc.
+
+# Tests for debug_connection with syslog.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use IO::Select;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http --with-debug proxy/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+    debug_connection ::1;
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    error_log syslog:server=127.0.0.1:%%PORT_8981_UDP%% alert;
+    error_log syslog:server=127.0.0.1:%%PORT_8982_UDP%% alert;
+
+    server {
+        listen       127.0.0.1:8080;
+        listen       [::1]:%%PORT_8080%%;
+        server_name  localhost;
+
+        location /debug {
+            proxy_pass http://[::1]:%%PORT_8080%%/;
+        }
+    }
+}
+
+EOF
+
+$t->try_run('no inet6 support')->plan(5);
+
+###############################################################################
+
+my ($s1, $s2) = map {
+	IO::Socket::INET->new(
+		Proto => 'udp',
+		LocalAddr => "127.0.0.1:$_"
+	)
+		or die "Can't open syslog socket $_: $!";
+} port(8981), port(8982);
+
+is(get_syslog('/', $s1), '', 'no debug_connection syslog 1');
+is(get_syslog('/', $s2), '', 'no debug_connection syslog 2');
+
+my @msgs = get_syslog('/debug', $s1, $s2);
+like($msgs[0], qr/\[debug\]/, 'debug_connection syslog 1');
+like($msgs[1], qr/\[debug\]/, 'debug_connection syslog 2');
+is($msgs[0], $msgs[1], 'debug_connection syslog1 syslog2 match');
+
+###############################################################################
+
+sub get_syslog {
+	my ($uri, @s) = @_;
+	my @data;
+
+	http_get($uri);
+
+	map {
+		my $data = '';
+		IO::Select->new($_)->can_read(1);
+		while (IO::Select->new($_)->can_read(0.1)) {
+			my ($buffer);
+			sysread($_, $buffer, 4096);
+			$data .= $buffer;
+		}
+		push @data, $data;
+	} (@s);
+
+	return $data[0] if scalar @data == 1;
+	return @data;
+}
+
+###############################################################################
diff --git a/tests/debug_connection_unix.t b/tests/debug_connection_unix.t
new file mode 100644
index 0000000..72fce14
--- /dev/null
+++ b/tests/debug_connection_unix.t
@@ -0,0 +1,73 @@
+#!/usr/bin/perl
+
+# (C) Nginx, Inc.
+
+# Tests for debug_connection with unix socket.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http --with-debug unix proxy/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+    debug_connection unix:;
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    error_log %%TESTDIR%%/debug1.log alert;
+    error_log %%TESTDIR%%/debug2.log alert;
+
+    server {
+        listen       127.0.0.1:8080;
+        listen       unix:%%TESTDIR%%/unix.sock;
+        server_name  localhost;
+
+        location /debug {
+            proxy_pass http://unix:%%TESTDIR%%/unix.sock:/;
+        }
+    }
+}
+
+EOF
+
+$t->try_run('no unix support')->plan(5);
+
+###############################################################################
+
+http_get('/');
+
+select undef, undef, undef, 0.1;
+is($t->read_file('debug1.log'), '', 'no debug_connection file 1');
+is($t->read_file('debug2.log'), '', 'no debug_connection file 2');
+
+http_get('/debug');
+
+select undef, undef, undef, 0.1;
+like($t->read_file('debug1.log'), qr/\[debug\]/, 'debug_connection file 1');
+like($t->read_file('debug2.log'), qr/\[debug\]/, 'debug_connection file 2');
+is($t->read_file('debug1.log'), $t->read_file('debug2.log'),
+	'debug_connection file1 file2 match');
+
+###############################################################################
diff --git a/tests/empty_gif.t b/tests/empty_gif.t
new file mode 100644
index 0000000..f87db6f
--- /dev/null
+++ b/tests/empty_gif.t
@@ -0,0 +1,96 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+
+# Tests for empty gif module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http empty_gif/)->plan(4);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            empty_gif;
+        }
+    }
+}
+
+EOF
+
+$t->run();
+
+my $gif = unhex(<<'EOF');
+0x0000:  47 49 46 38 39 61 01 00  01 00 80 01 00 00 00 00  |GIF89a.. ........|
+0x0010:  ff ff ff 21 f9 04 01 00  00 01 00 2c 00 00 00 00  |...!.... ...,....|
+0x0020:  01 00 01 00 00 02 02 4c  01 00 3b                 |.......L ..;|
+EOF
+
+###############################################################################
+
+is(http_get_body('/'), $gif, 'empty gif');
+like(http_get('/'), qr!Content-Type: image/gif!i, 'get content type');
+like(http_head('/'), qr!Content-Type: image/gif!i, 'head content type');
+like(http('PUT / HTTP/1.0' . CRLF . CRLF), qr!405 Not Allowed!i, 'put');
+
+###############################################################################
+
+sub unhex {
+	my ($input) = @_;
+	my $buffer = '';
+
+	for my $l ($input =~ m/:  +((?:[0-9a-f]{2,4} +)+) /gms) {
+		for my $v ($l =~ m/[0-9a-f]{2}/g) {
+			$buffer .= chr(hex($v));
+		}
+	}
+
+	return $buffer;
+}
+
+sub http_get_body {
+	my ($uri) = @_;
+
+	return undef if !defined $uri;
+
+	my $text = http_get($uri);
+
+	if ($text !~ /(.*?)\x0d\x0a?\x0d\x0a?(.*)/ms) {
+		return undef;
+	}
+
+	return $2;
+}
+
+###############################################################################
diff --git a/tests/error_log.t b/tests/error_log.t
new file mode 100644
index 0000000..d7516c8
--- /dev/null
+++ b/tests/error_log.t
@@ -0,0 +1,196 @@
+#!/usr/bin/perl
+
+# (C) Nginx, Inc.
+
+# Tests for error_log.
+# Various log levels emitted with limit_req_log_level.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+plan(skip_all => 'win32') if $^O eq 'MSWin32';
+
+my $t = Test::Nginx->new()->has(qw/http limit_req/)
+	->plan(25)->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    limit_req_zone $binary_remote_addr zone=one:1m rate=1r/m;
+    limit_req zone=one;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /debug {
+            error_log %%TESTDIR%%/e_debug_debug.log debug;
+            error_log %%TESTDIR%%/e_debug_info.log info;
+            error_log stderr debug;
+        }
+        location /info {
+            limit_req_log_level info;
+            error_log %%TESTDIR%%/e_info_debug.log debug;
+            error_log %%TESTDIR%%/e_info_info.log info;
+            error_log %%TESTDIR%%/e_info_notice.log notice;
+            error_log stderr info;
+        }
+        location /notice {
+            limit_req_log_level notice;
+            error_log %%TESTDIR%%/e_notice_info.log info;
+            error_log %%TESTDIR%%/e_notice_notice.log notice;
+            error_log %%TESTDIR%%/e_notice_warn.log warn;
+            error_log stderr notice;
+        }
+        location /warn {
+            limit_req_log_level warn;
+            error_log %%TESTDIR%%/e_warn_notice.log notice;
+            error_log %%TESTDIR%%/e_warn_warn.log warn;
+            error_log %%TESTDIR%%/e_warn_error.log error;
+            error_log stderr warn;
+        }
+        location /error {
+            error_log %%TESTDIR%%/e_error_warn.log warn;
+            error_log %%TESTDIR%%/e_error_error.log;
+            error_log %%TESTDIR%%/e_error_alert.log alert;
+            error_log stderr;
+        }
+
+        location /file_low {
+            error_log %%TESTDIR%%/e_multi_low.log warn;
+            error_log %%TESTDIR%%/e_multi_low.log;
+        }
+        location /file_dup {
+            error_log %%TESTDIR%%/e_multi.log;
+            error_log %%TESTDIR%%/e_multi.log;
+        }
+        location /file_high {
+            error_log %%TESTDIR%%/e_multi_high.log emerg;
+            error_log %%TESTDIR%%/e_multi_high.log;
+        }
+
+        location /stderr_low {
+            error_log stderr warn;
+            error_log stderr;
+        }
+        location /stderr_dup {
+            error_log stderr;
+            error_log stderr;
+        }
+        location /stderr_high {
+            error_log stderr emerg;
+            error_log stderr;
+        }
+    }
+}
+
+EOF
+
+open OLDERR, ">&", \*STDERR;
+open STDERR, '>', $t->testdir() . '/stderr' or die "Can't reopen STDERR: $!";
+open my $stderr, '<', $t->testdir() . '/stderr'
+	or die "Can't open stderr file: $!";
+
+$t->run();
+
+open STDERR, ">&", \*OLDERR;
+
+###############################################################################
+
+# charge limit_req
+
+http_get('/');
+
+SKIP: {
+
+skip "no --with-debug", 3 unless $t->has_module('--with-debug');
+
+http_get('/debug');
+isnt(lines($t, 'e_debug_debug.log', '[debug]'), 0, 'file debug debug');
+is(lines($t, 'e_debug_info.log', '[debug]'), 0, 'file debug info');
+isnt(lines($t, 'stderr', '[debug]'), 0, 'stderr debug');
+
+}
+
+http_get('/info');
+is(lines($t, 'e_info_debug.log', '[info]'), 1, 'file info debug');
+is(lines($t, 'e_info_info.log', '[info]'), 1, 'file info info');
+is(lines($t, 'e_info_notice.log', '[info]'), 0, 'file info notice');
+is(lines($t, 'stderr', '[info]'), 1, 'stderr info');
+
+http_get('/notice');
+is(lines($t, 'e_notice_info.log', '[notice]'), 1, 'file notice info');
+is(lines($t, 'e_notice_notice.log', '[notice]'), 1, 'file notice notice');
+is(lines($t, 'e_notice_warn.log', '[notice]'), 0, 'file notice warn');
+is(lines($t, 'stderr', '[notice]'), 1, 'stderr notice');
+
+http_get('/warn');
+is(lines($t, 'e_warn_notice.log', '[warn]'), 1, 'file warn notice');
+is(lines($t, 'e_warn_warn.log', '[warn]'), 1, 'file warn warn');
+is(lines($t, 'e_warn_error.log', '[warn]'), 0, 'file warn error');
+is(lines($t, 'stderr', '[warn]'), 1, 'stderr warn');
+
+http_get('/error');
+is(lines($t, 'e_error_warn.log', '[error]'), 1, 'file error warn');
+is(lines($t, 'e_error_error.log', '[error]'), 1, 'file error error');
+is(lines($t, 'e_error_alert.log', '[error]'), 0, 'file error alert');
+is(lines($t, 'stderr', '[error]'), 1, 'stderr error');
+
+# count log messages emitted with various error_log levels
+
+http_get('/file_low');
+is(lines($t, 'e_multi_low.log', '[error]'), 2, 'file low');
+
+http_get('/file_dup');
+is(lines($t, 'e_multi.log', '[error]'), 2, 'file dup');
+
+http_get('/file_high');
+is(lines($t, 'e_multi_high.log', '[error]'), 1, 'file high');
+
+http_get('/stderr_low');
+is(lines($t, 'stderr', '[error]'), 2, 'stderr low');
+
+http_get('/stderr_dup');
+is(lines($t, 'stderr', '[error]'), 2, 'stderr dup');
+
+http_get('/stderr_high');
+is(lines($t, 'stderr', '[error]'), 1, 'stderr high');
+
+###############################################################################
+
+sub lines {
+	my ($t, $file, $pattern) = @_;
+
+	if ($file eq 'stderr') {
+		return map { $_ =~ /\Q$pattern\E/ } (<$stderr>);
+	}
+
+	my $path = $t->testdir() . '/' . $file;
+	open my $fh, '<', $path or return "$!";
+	my $value = map { $_ =~ /\Q$pattern\E/ } (<$fh>);
+	close $fh;
+	return $value;
+}
+
+###############################################################################
diff --git a/tests/fastcgi.t b/tests/fastcgi.t
new file mode 100644
index 0000000..9103311
--- /dev/null
+++ b/tests/fastcgi.t
@@ -0,0 +1,114 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Test for fastcgi backend.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require FCGI; };
+plan(skip_all => 'FCGI not installed') if $@;
+plan(skip_all => 'win32') if $^O eq 'MSWin32';
+
+my $t = Test::Nginx->new()->has(qw/http fastcgi/)->plan(8)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    upstream u {
+        server 127.0.0.1:8081;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            fastcgi_pass 127.0.0.1:8081;
+            fastcgi_param REQUEST_URI $request_uri;
+        }
+
+        location /catch {
+            fastcgi_pass 127.0.0.1:8081;
+            fastcgi_param REQUEST_URI "/stderr";
+            fastcgi_catch_stderr sample;
+        }
+
+        location /var {
+            fastcgi_pass $arg_b;
+            fastcgi_param REQUEST_URI $request_uri;
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&fastcgi_daemon);
+$t->run()->waitforsocket('127.0.0.1:' . port(8081));
+
+###############################################################################
+
+like(http_get('/'), qr/SEE-THIS/, 'fastcgi request');
+like(http_get('/redir'), qr/ 302 /, 'fastcgi redirect');
+like(http_get('/'), qr/^3$/m, 'fastcgi third request');
+
+unlike(http_head('/'), qr/SEE-THIS/, 'no data in HEAD');
+
+like(http_get('/stderr'), qr/SEE-THIS/, 'large stderr handled');
+like(http_get('/catch'), qr/502 Bad/, 'catch stderr');
+
+like(http_get('/var?b=127.0.0.1:' . port(8081)), qr/SEE-THIS/,
+	'fastcgi with variables');
+like(http_get('/var?b=u'), qr/SEE-THIS/, 'fastcgi with variables to upstream');
+
+###############################################################################
+
+sub fastcgi_daemon {
+	my $socket = FCGI::OpenSocket('127.0.0.1:' . port(8081), 5);
+	my $request = FCGI::Request(\*STDIN, \*STDOUT, \*STDERR, \%ENV,
+		$socket);
+
+	my $count;
+	while( $request->Accept() >= 0 ) {
+		$count++;
+
+		if ($ENV{REQUEST_URI} eq '/stderr') {
+			warn "sample stderr text" x 512;
+		}
+
+		print <<EOF;
+Location: http://localhost/redirect
+Content-Type: text/html
+
+SEE-THIS
+$count
+EOF
+	}
+
+	FCGI::CloseSocket($socket);
+}
+
+###############################################################################
diff --git a/tests/fastcgi_body.t b/tests/fastcgi_body.t
new file mode 100644
index 0000000..d94916a
--- /dev/null
+++ b/tests/fastcgi_body.t
@@ -0,0 +1,183 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Test for fastcgi backend with chunked request body.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http fastcgi/)->plan(5)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            fastcgi_pass 127.0.0.1:8081;
+            fastcgi_param REQUEST_URI $request_uri;
+            fastcgi_param CONTENT_LENGTH $content_length;
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&fastcgi_daemon);
+$t->run()->waitforsocket('127.0.0.1:' . port(8081));
+
+###############################################################################
+
+like(http_get('/'), qr/X-Body: _eos\x0d?$/ms, 'fastcgi no body');
+
+like(http_get_length('/', ''), qr/X-Body: _eos\x0d?$/ms, 'fastcgi empty body');
+like(http_get_length('/', 'foobar'), qr/X-Body: foobar_eos\x0d?$/ms,
+	'fastcgi body');
+
+like(http(<<EOF), qr/X-Body: foobar_eos\x0d?$/ms, 'fastcgi chunked');
+GET / HTTP/1.1
+Host: localhost
+Connection: close
+Transfer-Encoding: chunked
+
+6
+foobar
+0
+
+EOF
+
+like(http(<<EOF), qr/X-Body: _eos\x0d?$/ms, 'fastcgi empty chunked');
+GET / HTTP/1.1
+Host: localhost
+Connection: close
+Transfer-Encoding: chunked
+
+0
+
+EOF
+
+###############################################################################
+
+sub http_get_length {
+	my ($url, $body) = @_;
+	my $length = length $body;
+	return http(<<EOF);
+GET $url HTTP/1.1
+Host: localhost
+Connection: close
+Content-Length: $length
+
+$body
+EOF
+}
+
+###############################################################################
+
+# Simple FastCGI responder implementation.
+
+# http://www.fastcgi.com/devkit/doc/fcgi-spec.html
+
+sub fastcgi_read_record($) {
+	my ($buf) = @_;
+	my $h;
+
+	return undef unless length $$buf;
+
+	@{$h}{qw/ version type id clen plen /} = unpack("CCnnC", $$buf);
+
+	$h->{content} = substr $$buf, 8, $h->{clen};
+	$h->{padding} = substr $$buf, 8 + $h->{clen}, $h->{plen};
+
+	$$buf = substr $$buf, 8 + $h->{clen} + $h->{plen};
+
+	return $h;
+}
+
+sub fastcgi_respond($$$$) {
+	my ($socket, $version, $id, $body) = @_;
+
+	# stdout
+	$socket->write(pack("CCnnCx", $version, 6, $id, length($body), 0));
+	$socket->write($body);
+
+	# close stdout
+	$socket->write(pack("CCnnCx", $version, 6, $id, 0, 0));
+
+	# end request
+	$socket->write(pack("CCnnCx", $version, 3, $id, 8, 0));
+	$socket->write(pack("NCxxx", 0, 0));
+}
+
+sub fastcgi_daemon {
+	my $server = IO::Socket::INET->new(
+		Proto => 'tcp',
+		LocalAddr => '127.0.0.1:' . port(8081),
+		Listen => 5,
+		Reuse => 1
+	)
+		or die "Can't create listening socket: $!\n";
+
+	local $SIG{PIPE} = 'IGNORE';
+
+	while (my $client = $server->accept()) {
+		$client->autoflush(1);
+		Test::Nginx::log_core('||', "fastcgi connection");
+
+		$client->sysread(my $buf, 1024) or next;
+
+		my ($version, $id);
+		my $body = '';
+
+		while (my $h = fastcgi_read_record(\$buf)) {
+			$version = $h->{version};
+			$id = $h->{id};
+
+			Test::Nginx::log_core('||', "fastcgi record: "
+				. " $h->{version}, $h->{type}, $h->{id}, "
+				. "'$h->{content}'");
+
+			if ($h->{type} == 5) {
+				$body .= $h->{content} if $h->{clen} > 0;
+
+				# count stdin end-of-stream
+				$body .= '_eos' if $h->{clen} == 0;
+			}
+		}
+
+		# respond
+		fastcgi_respond($client, $version, $id, <<EOF);
+Location: http://localhost/redirect
+Content-Type: text/html
+X-Body: $body
+
+SEE-THIS
+EOF
+	}
+}
+
+###############################################################################
diff --git a/tests/fastcgi_body2.t b/tests/fastcgi_body2.t
new file mode 100644
index 0000000..06216d5
--- /dev/null
+++ b/tests/fastcgi_body2.t
@@ -0,0 +1,133 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Test for fastcgi backend with large request body,
+# with fastcgi_next_upstream directive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require FCGI; };
+plan(skip_all => 'FCGI not installed') if $@;
+plan(skip_all => 'win32') if $^O eq 'MSWin32';
+
+my $t = Test::Nginx->new()->has(qw/http fastcgi/)->plan(2)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    upstream u {
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8082 backup;
+    }
+
+    upstream u2 {
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8082 backup;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            fastcgi_pass u;
+            fastcgi_param REQUEST_URI $request_uri;
+            fastcgi_param CONTENT_LENGTH $content_length;
+            # fastcgi_next_upstream error timeout;
+            fastcgi_read_timeout 1s;
+        }
+
+        location /in_memory {
+            fastcgi_pass u2;
+            fastcgi_param REQUEST_URI $request_uri;
+            fastcgi_param CONTENT_LENGTH $content_length;
+            # fastcgi_next_upstream error timeout;
+            fastcgi_read_timeout 1s;
+            client_body_buffer_size 128k;
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&fastcgi_daemon, port(8081));
+$t->run_daemon(\&fastcgi_daemon, port(8082));
+$t->run();
+
+$t->waitforsocket('127.0.0.1:' . port(8081));
+$t->waitforsocket('127.0.0.1:' . port(8082));
+
+###############################################################################
+
+like(http_get_length('/', 'x' x 102400), qr/X-Length: 102400/,
+	'body length - in file');
+
+like(http_get_length('/in_memory', 'x' x 102400), qr/X-Length: 102400/,
+	'body length - in memory');
+
+###############################################################################
+
+sub http_get_length {
+	my ($url, $body) = @_;
+	my $length = length $body;
+	return http(<<EOF);
+GET $url HTTP/1.0
+Host: localhost
+Content-Length: $length
+
+$body
+EOF
+}
+
+###############################################################################
+
+sub fastcgi_daemon {
+	my ($port) = @_;
+	my $socket = FCGI::OpenSocket("127.0.0.1:$port", 5);
+	my $request = FCGI::Request(\*STDIN, \*STDOUT, \*STDERR, \%ENV,
+		$socket);
+
+	while( $request->Accept() >= 0 ) {
+		read(STDIN, my $body, $ENV{'CONTENT_LENGTH'});
+		my $len = length $body;
+
+		sleep 3 if $port == port(8081);
+
+		print <<EOF;
+Location: http://localhost/redirect
+Content-Type: text/html
+X-Length: $len
+
+EOF
+	}
+
+	FCGI::CloseSocket($socket);
+}
+
+###############################################################################
diff --git a/tests/fastcgi_buffering.t b/tests/fastcgi_buffering.t
new file mode 100644
index 0000000..d772151
--- /dev/null
+++ b/tests/fastcgi_buffering.t
@@ -0,0 +1,101 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Test for fastcgi backend with fastcgi_buffering off.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require FCGI; };
+plan(skip_all => 'FCGI not installed') if $@;
+plan(skip_all => 'win32') if $^O eq 'MSWin32';
+
+my $t = Test::Nginx->new()->has(qw/http fastcgi ssi/)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            fastcgi_pass 127.0.0.1:8081;
+            fastcgi_param REQUEST_URI $request_uri;
+            fastcgi_buffering off;
+        }
+
+        location /inmemory.html {
+            ssi on;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('inmemory.html',
+	'<!--#include virtual="/include$request_uri" set="x" -->' .
+	'set: <!--#echo var="x" -->');
+
+$t->run()->plan(2);
+
+$t->run_daemon(\&fastcgi_daemon)->waitforsocket('127.0.0.1:' . port(8081));
+
+###############################################################################
+
+like(http_get('/'), qr/SEE-THIS/, 'fastcgi unbuffered');
+like(http_get('/inmemory.html'), qr/set: SEE-THIS/, 'fastcgi inmemory');
+
+###############################################################################
+
+sub fastcgi_daemon {
+	my $socket = FCGI::OpenSocket('127.0.0.1:' . port(8081), 5);
+	my $request = FCGI::Request(\*STDIN, \*STDOUT, \*STDERR, \%ENV,
+		$socket);
+
+	my $count;
+	while( $request->Accept() >= 0 ) {
+		$count++;
+
+		# this intentionally uses multiple print()'s to test
+		# parsing of multiple records
+
+		print(
+			"Status: 200 OK" . CRLF .
+			"Content-Type: text/plain" . CRLF . CRLF
+		);
+
+		print "SEE";
+		print "-THIS" . CRLF;
+		print "$count" . CRLF;
+	}
+
+	FCGI::CloseSocket($socket);
+}
+
+###############################################################################
diff --git a/tests/fastcgi_cache.t b/tests/fastcgi_cache.t
new file mode 100644
index 0000000..df4f50d
--- /dev/null
+++ b/tests/fastcgi_cache.t
@@ -0,0 +1,106 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Test for fastcgi backend with cache.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require FCGI; };
+plan(skip_all => 'FCGI not installed') if $@;
+plan(skip_all => 'win32') if $^O eq 'MSWin32';
+
+my $t = Test::Nginx->new()->has(qw/http fastcgi cache/)->plan(5)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    fastcgi_cache_path   %%TESTDIR%%/cache  levels=1:2
+                         keys_zone=NAME:1m;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            fastcgi_pass 127.0.0.1:8081;
+            fastcgi_param REQUEST_URI $request_uri;
+            fastcgi_cache NAME;
+            fastcgi_cache_key $request_uri;
+            fastcgi_cache_valid 302 1m;
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&fastcgi_daemon);
+$t->run()->waitforsocket('127.0.0.1:' . port(8081));
+
+###############################################################################
+
+like(http_get('/'), qr/SEE-THIS.*^1$/ms, 'fastcgi request');
+like(http_get('/'), qr/SEE-THIS.*^1$/ms, 'fastcgi request cached');
+
+unlike(http_head('/'), qr/SEE-THIS/, 'no data in cached HEAD');
+
+SKIP: {
+skip 'broken with header crossing buffer boundary', 2
+	unless $ENV{TEST_NGINX_UNSAFE};
+
+like(http_get('/stderr'), qr/SEE-THIS.*^2$/ms, 'large stderr handled');
+like(http_get('/stderr'), qr/SEE-THIS.*^2$/ms, 'large stderr cached');
+
+}
+
+###############################################################################
+
+sub fastcgi_daemon {
+	my $socket = FCGI::OpenSocket('127.0.0.1:' . port(8081), 5);
+	my $request = FCGI::Request(\*STDIN, \*STDOUT, \*STDERR, \%ENV,
+		$socket);
+
+	my $count;
+	while( $request->Accept() >= 0 ) {
+		$count++;
+
+		if ($ENV{REQUEST_URI} eq '/stderr') {
+			warn "sample stderr text" x 512;
+		}
+
+		print <<EOF;
+Location: http://localhost/redirect
+Content-Type: text/html
+
+SEE-THIS
+$count
+EOF
+	}
+
+	FCGI::CloseSocket($socket);
+}
+
+###############################################################################
diff --git a/tests/fastcgi_header_params.t b/tests/fastcgi_header_params.t
new file mode 100644
index 0000000..1ebf700
--- /dev/null
+++ b/tests/fastcgi_header_params.t
@@ -0,0 +1,115 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Test for fastcgi header params.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require FCGI; };
+plan(skip_all => 'FCGI not installed') if $@;
+plan(skip_all => 'win32') if $^O eq 'MSWin32';
+
+my $t = Test::Nginx->new()->has(qw/http fastcgi/)->plan(1)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            fastcgi_pass 127.0.0.1:8081;
+            fastcgi_param HTTP_X_BLAH "blah";
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&fastcgi_daemon);
+$t->run()->waitforsocket('127.0.0.1:' . port(8081));
+
+###############################################################################
+
+like(http_get_headers('/'), qr/SEE-THIS/,
+	'fastcgi request with many ignored headers');
+
+###############################################################################
+
+sub http_get_headers {
+	my ($url, %extra) = @_;
+	return http(<<EOF, %extra);
+GET $url HTTP/1.0
+Host: localhost
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+
+EOF
+}
+
+###############################################################################
+
+sub fastcgi_daemon {
+	my $socket = FCGI::OpenSocket('127.0.0.1:' . port(8081), 5);
+	my $request = FCGI::Request(\*STDIN, \*STDOUT, \*STDERR, \%ENV,
+		$socket);
+
+	my $count;
+	while( $request->Accept() >= 0 ) {
+		$count++;
+
+		print <<EOF;
+Location: http://localhost/redirect
+Content-Type: text/html
+
+SEE-THIS
+$count
+EOF
+	}
+
+	FCGI::CloseSocket($socket);
+}
+
+###############################################################################
diff --git a/tests/fastcgi_keepalive.t b/tests/fastcgi_keepalive.t
new file mode 100644
index 0000000..ba9591f
--- /dev/null
+++ b/tests/fastcgi_keepalive.t
@@ -0,0 +1,185 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Test for fastcgi backend with keepalive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http fastcgi upstream_keepalive/)->plan(6)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    upstream backend {
+        server 127.0.0.1:8081;
+        keepalive 1;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            fastcgi_pass backend;
+            fastcgi_keep_conn on;
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&fastcgi_test_daemon);
+$t->run()->waitforsocket('127.0.0.1:' . port(8081));
+
+###############################################################################
+
+like(http_get('/'), qr/SEE-THIS/, 'fastcgi request');
+like(http_get('/redir'), qr/ 302 /, 'fastcgi redirect');
+like(http_get('/'), qr/^request: 3$/m, 'fastcgi third request');
+
+like(http_get('/single'), qr/^connection: 1$/m, 'single connection used');
+
+# New connection to fastcgi application should be established after HEAD
+# requests since nginx doesn't read whole response (as it doesn't need
+# body).
+
+unlike(http_head('/head'), qr/SEE-THIS/, 'no data in HEAD');
+
+like(http_get('/after'), qr/^connection: 2$/m, 'new connection after HEAD');
+
+###############################################################################
+
+# Simple FastCGI responder implementation.  Unlike FCGI and FCGI::Async it's
+# able to count connections.
+
+# http://www.fastcgi.com/devkit/doc/fcgi-spec.html
+
+sub fastcgi_read_record($) {
+	my ($socket) = @_;
+
+	my ($n, $h, $header);
+
+	$n = $socket->read($header, 8);
+	return undef if !defined $n or $n != 8;
+
+	@{$h}{qw/ version type id clen plen /} = unpack("CCnnC", $header);
+
+	$n = $socket->read($h->{content}, $h->{clen});
+	return undef if $n != $h->{clen};
+
+	$n = $socket->read($h->{padding}, $h->{plen});
+	return undef if $n != $h->{plen};
+
+	$h->{socket} = $socket;
+	return $h;
+}
+
+sub fastcgi_respond($$) {
+	my ($h, $body) = @_;
+
+	# stdout
+	$h->{socket}->write(pack("CCnnCx", $h->{version}, 6, $h->{id},
+		length($body), 8));
+	$h->{socket}->write($body);
+	select(undef, undef, undef, 0.1);
+	$h->{socket}->write(pack("xxxxxxxx"));
+	select(undef, undef, undef, 0.1);
+
+	# write some text to stdout and stderr split over multiple network
+	# packets to test if we correctly set pipe length in various places
+
+	my $tt = "test text, just for test";
+
+	$h->{socket}->write(pack("CCnnCx", $h->{version}, 6, $h->{id},
+		length($tt . $tt), 0) . $tt);
+	select(undef, undef, undef, 0.1);
+	$h->{socket}->write($tt . pack("CC", $h->{version}, 7));
+	select(undef, undef, undef, 0.1);
+	$h->{socket}->write(pack("nnCx", $h->{id}, length($tt), 0));
+	select(undef, undef, undef, 0.1);
+	$h->{socket}->write($tt);
+	select(undef, undef, undef, 0.1);
+
+	# close stdout
+	$h->{socket}->write(pack("CCnnCx", $h->{version}, 6, $h->{id}, 0, 0));
+
+	select(undef, undef, undef, 0.1);
+
+	# end request
+	$h->{socket}->write(pack("CCnnCx", $h->{version}, 3, $h->{id}, 8, 0));
+	select(undef, undef, undef, 0.1);
+	$h->{socket}->write(pack("NCxxx", 0, 0));
+}
+
+sub fastcgi_test_daemon {
+	my $server = IO::Socket::INET->new(
+		Proto => 'tcp',
+		LocalAddr => '127.0.0.1:' . port(8081),
+		Listen => 5,
+		Reuse => 1
+	)
+		or die "Can't create listening socket: $!\n";
+
+	local $SIG{PIPE} = 'IGNORE';
+
+	my $ccount = 0;
+	my $rcount = 0;
+
+	while (my $client = $server->accept()) {
+		$client->autoflush(1);
+		Test::Nginx::log_core('||', "fastcgi connection");
+
+		$ccount++;
+
+		while (my $h = fastcgi_read_record($client)) {
+			Test::Nginx::log_core('||', "fastcgi record: "
+				. " $h->{version}, $h->{type}, $h->{id}, "
+				. "'$h->{content}'");
+
+			# skip everything unless stdin, then respond
+			next if $h->{type} != 5;
+
+			$rcount++;
+
+			# respond
+			fastcgi_respond($h, <<EOF);
+Location: http://localhost/redirect
+Content-Type: text/html
+
+SEE-THIS
+request: $rcount
+connection: $ccount
+EOF
+		}
+
+		$ccount-- unless $rcount;
+
+		close $client;
+	}
+}
+
+###############################################################################
diff --git a/tests/fastcgi_merge_params.t b/tests/fastcgi_merge_params.t
new file mode 100644
index 0000000..8a6f79b
--- /dev/null
+++ b/tests/fastcgi_merge_params.t
@@ -0,0 +1,138 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for fastcgi_param inheritance.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require FCGI; };
+plan(skip_all => 'FCGI not installed') if $@;
+plan(skip_all => 'win32') if $^O eq 'MSWin32';
+
+my $t = Test::Nginx->new()->has(qw/http fastcgi cache/)->plan(9)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    fastcgi_cache_path  %%TESTDIR%%/cache  levels=1:2
+                        keys_zone=NAME:1m;
+
+    fastcgi_cache_key   stub;
+
+    fastcgi_param       HTTP_X_BLAH  "blah";
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        fastcgi_cache  NAME;
+
+        location / {
+            fastcgi_pass    127.0.0.1:8081;
+        }
+
+        location /no/ {
+            fastcgi_pass    127.0.0.1:8081;
+            fastcgi_cache   off;
+        }
+
+        location /custom/ {
+            fastcgi_pass    127.0.0.1:8081;
+            fastcgi_param   HTTP_X_BLAH  "custom";
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&fastcgi_daemon);
+$t->run()->waitforsocket('127.0.0.1:' . port(8081));
+
+###############################################################################
+
+like(http_get_ims('/'), qr/ims=;/,
+	'if-modified-since cleared with cache');
+like(http_get_ims('/'), qr/iums=;/,
+	'if-unmodified-since cleared with cache');
+like(http_get_ims('/'), qr/blah=blah;/,
+	'custom params with cache');
+
+like(http_get_ims('/no/'), qr/ims=blah;/,
+	'if-modified-since preserved without cache');
+like(http_get_ims('/no/'), qr/iums=blah;/,
+	'if-unmodified-since preserved without cache');
+like(http_get_ims('/'), qr/blah=blah;/,
+	'custom params without cache');
+
+like(http_get_ims('/custom/'), qr/ims=;/,
+	'if-modified-since cleared with cache custom');
+like(http_get_ims('/custom/'), qr/iums=;/,
+	'if-unmodified-since cleared with cache custom');
+like(http_get_ims('/custom/'), qr/blah=custom;/,
+	'custom params with cache custom');
+
+###############################################################################
+
+sub http_get_ims {
+	my ($url) = @_;
+	return http(<<EOF);
+GET $url HTTP/1.0
+Host: localhost
+Connection: close
+If-Modified-Since: blah
+If-Unmodified-Since: blah
+
+EOF
+}
+
+###############################################################################
+
+sub fastcgi_daemon {
+	my $socket = FCGI::OpenSocket('127.0.0.1:' . port(8081), 5);
+	my $request = FCGI::Request(\*STDIN, \*STDOUT, \*STDERR, \%ENV,
+		$socket);
+
+	my $count;
+	while( $request->Accept() >= 0 ) {
+		$count++;
+
+		my $ims = $ENV{HTTP_IF_MODIFIED_SINCE};
+		my $iums = $ENV{HTTP_IF_UNMODIFIED_SINCE};
+		my $blah = $ENV{HTTP_X_BLAH};
+
+		print <<EOF;
+Location: http://localhost/redirect
+Content-Type: text/html
+
+ims=$ims;iums=$iums;blah=$blah;
+EOF
+	}
+
+	FCGI::CloseSocket($socket);
+}
+
+###############################################################################
diff --git a/tests/fastcgi_merge_params2.t b/tests/fastcgi_merge_params2.t
new file mode 100644
index 0000000..9022c2f
--- /dev/null
+++ b/tests/fastcgi_merge_params2.t
@@ -0,0 +1,122 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for fastcgi_param inheritance.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require FCGI; };
+plan(skip_all => 'FCGI not installed') if $@;
+plan(skip_all => 'win32') if $^O eq 'MSWin32';
+
+my $t = Test::Nginx->new()->has(qw/http fastcgi cache/)->plan(4)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    fastcgi_cache_path  %%TESTDIR%%/cache  levels=1:2
+                        keys_zone=NAME:1m;
+
+    fastcgi_cache_key   stub;
+
+    # no fastcgi_param at all, cache switched on at server level
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        fastcgi_cache  NAME;
+
+        location / {
+            fastcgi_pass    127.0.0.1:8081;
+        }
+
+        location /no/ {
+            fastcgi_pass    127.0.0.1:8081;
+            fastcgi_cache   off;
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&fastcgi_daemon);
+$t->run()->waitforsocket('127.0.0.1:' . port(8081));
+
+###############################################################################
+
+like(http_get_ims('/'), qr/ims=;/,
+	'if-modified-since cleared with cache');
+like(http_get_ims('/'), qr/iums=;/,
+	'if-unmodified-since cleared with cache');
+
+like(http_get_ims('/no/'), qr/ims=blah;/,
+	'if-modified-since preserved without cache');
+like(http_get_ims('/no/'), qr/iums=blah;/,
+	'if-unmodified-since preserved without cache');
+
+###############################################################################
+
+sub http_get_ims {
+	my ($url) = @_;
+	return http(<<EOF);
+GET $url HTTP/1.0
+Host: localhost
+Connection: close
+If-Modified-Since: blah
+If-Unmodified-Since: blah
+
+EOF
+}
+
+###############################################################################
+
+sub fastcgi_daemon {
+	my $socket = FCGI::OpenSocket('127.0.0.1:' . port(8081), 5);
+	my $request = FCGI::Request(\*STDIN, \*STDOUT, \*STDERR, \%ENV,
+		$socket);
+
+	my $count;
+	while( $request->Accept() >= 0 ) {
+		$count++;
+
+		my $ims = $ENV{HTTP_IF_MODIFIED_SINCE};
+		my $iums = $ENV{HTTP_IF_UNMODIFIED_SINCE};
+		my $blah = $ENV{HTTP_X_BLAH};
+
+		print <<EOF;
+Location: http://localhost/redirect
+Content-Type: text/html
+
+ims=$ims;iums=$iums;blah=$blah;
+EOF
+	}
+
+	FCGI::CloseSocket($socket);
+}
+
+###############################################################################
diff --git a/tests/fastcgi_request_buffering.t b/tests/fastcgi_request_buffering.t
new file mode 100644
index 0000000..a4b6f40
--- /dev/null
+++ b/tests/fastcgi_request_buffering.t
@@ -0,0 +1,373 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for unbuffered request body with fastcgi backend.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require FCGI; };
+plan(skip_all => 'FCGI not installed') if $@;
+plan(skip_all => 'win32') if $^O eq 'MSWin32';
+
+my $t = Test::Nginx->new()->has(qw/http fastcgi rewrite/)->plan(15);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        client_header_buffer_size 1k;
+        fastcgi_request_buffering off;
+        fastcgi_param REQUEST_URI $request_uri;
+        fastcgi_param CONTENT_LENGTH $content_length;
+
+        location / {
+            client_body_buffer_size 2k;
+            fastcgi_pass 127.0.0.1:8081;
+        }
+        location /single {
+            client_body_in_single_buffer on;
+            fastcgi_pass 127.0.0.1:8081;
+        }
+        location /preread {
+            fastcgi_pass 127.0.0.1:8082;
+        }
+        location /error_page {
+            fastcgi_pass 127.0.0.1:8081;
+            error_page 404 /404;
+            fastcgi_intercept_errors on;
+        }
+        location /404 {
+            return 200 "$request_body\n";
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&fastcgi_daemon);
+$t->run()->waitforsocket('127.0.0.1:' . port(8081));
+
+###############################################################################
+
+like(http_get('/'), qr/X-Body: \x0d\x0a?/ms, 'no body');
+
+like(http_get_body('/', '0123456789'),
+	qr/X-Body: 0123456789\x0d?$/ms, 'body');
+
+like(http_get_body('/', '0123456789' x 128),
+	qr/X-Body: (0123456789){128}\x0d?$/ms, 'body in two buffers');
+
+like(http_get_body('/single', '0123456789' x 128),
+	qr/X-Body: (0123456789){128}\x0d?$/ms, 'body in single buffer');
+
+like(http_get_body('/error_page', '0123456789'),
+	qr/^0123456789$/m, 'body in error page');
+
+# pipelined requests
+
+like(http_get_body('/', '0123456789', '0123456789' x 128, '0123456789' x 512,
+	'foobar'), qr/X-Body: foobar\x0d?$/ms, 'body pipelined');
+like(http_get_body('/', '0123456789' x 128, '0123456789' x 512, '0123456789',
+	'foobar'), qr/X-Body: foobar\x0d?$/ms, 'body pipelined 2');
+
+# interactive tests
+
+my $s = get_body('/preread', port(8082), 10);
+ok($s, 'no preread');
+
+SKIP: {
+skip 'no preread failed', 3 unless $s;
+
+is($s->{upload}('01234'), '01234', 'no preread - body part');
+is($s->{upload}('56789'), '56789', 'no preread - body part 2');
+
+like($s->{http_end}(), qr/200 OK/, 'no preread - response');
+
+}
+
+$s = get_body('/preread', port(8082), 10, '01234');
+ok($s, 'preread');
+
+SKIP: {
+skip 'preread failed', 3 unless $s;
+
+is($s->{preread}, '01234', 'preread - preread');
+is($s->{upload}('56789'), '56789', 'preread - body');
+
+like($s->{http_end}(), qr/200 OK/, 'preread - response');
+
+}
+
+###############################################################################
+
+sub http_get_body {
+	my $uri = shift;
+	my $last = pop;
+	return http( join '', (map {
+		my $body = $_;
+		"GET $uri HTTP/1.1" . CRLF
+		. "Host: localhost" . CRLF
+		. "Content-Length: " . (length $body) . CRLF . CRLF
+		. $body
+	} @_),
+		"GET $uri HTTP/1.1" . CRLF
+		. "Host: localhost" . CRLF
+		. "Connection: close" . CRLF
+		. "Content-Length: " . (length $last) . CRLF . CRLF
+		. $last
+	);
+}
+
+# Simple FastCGI responder implementation.
+
+# http://www.fastcgi.com/devkit/doc/fcgi-spec.html
+
+sub fastcgi_read_record($) {
+	my ($buf) = @_;
+	my $h;
+
+	return undef unless length $$buf;
+
+	@{$h}{qw/ version type id clen plen /} = unpack("CCnnC", $$buf);
+
+	$h->{content} = substr $$buf, 8, $h->{clen};
+	$h->{padding} = substr $$buf, 8 + $h->{clen}, $h->{plen};
+
+	$$buf = substr $$buf, 8 + $h->{clen} + $h->{plen};
+
+	return $h;
+}
+
+sub fastcgi_respond($$$$) {
+	my ($socket, $version, $id, $body) = @_;
+
+	# stdout
+	$socket->write(pack("CCnnCx", $version, 6, $id, length($body), 8));
+	$socket->write($body);
+	select(undef, undef, undef, 0.1);
+	$socket->write(pack("xxxxxxxx"));
+	select(undef, undef, undef, 0.1);
+
+	# write some text to stdout and stderr split over multiple network
+	# packets to test if we correctly set pipe length in various places
+
+	my $tt = "test text, just for test";
+
+	$socket->write(pack("CCnnCx", $version, 6, $id,
+		length($tt . $tt), 0) . $tt);
+	select(undef, undef, undef, 0.1);
+	$socket->write($tt . pack("CC", $version, 7));
+	select(undef, undef, undef, 0.1);
+	$socket->write(pack("nnCx", $id, length($tt), 0));
+	select(undef, undef, undef, 0.1);
+	$socket->write($tt);
+	select(undef, undef, undef, 0.1);
+
+	# close stdout
+	$socket->write(pack("CCnnCx", $version, 6, $id, 0, 0));
+
+	select(undef, undef, undef, 0.1);
+
+	# end request
+	$socket->write(pack("CCnnCx", $version, 3, $id, 8, 0));
+	select(undef, undef, undef, 0.1);
+	$socket->write(pack("NCxxx", 0, 0));
+}
+
+sub get_body {
+	my ($url, $port, $length, $body) = @_;
+	my ($server, $client, $s);
+	my ($version, $id);
+
+	$server = IO::Socket::INET->new(
+		Proto => 'tcp',
+		LocalHost => '127.0.0.1',
+		LocalPort => $port,
+		Listen => 5,
+		Reuse => 1
+	)
+		or die "Can't create listening socket: $!\n";
+
+	my $r = <<EOF;
+GET $url HTTP/1.1
+Host: localhost
+Connection: close
+Content-Length: $length
+
+EOF
+
+	if (defined $body) {
+		$r .= $body;
+	}
+
+	$s = http($r, start => 1);
+
+	eval {
+		local $SIG{ALRM} = sub { die "timeout\n" };
+		local $SIG{PIPE} = sub { die "sigpipe\n" };
+		alarm(5);
+
+		$client = $server->accept();
+
+		log2c("(new connection $client)");
+
+		alarm(0);
+	};
+	alarm(0);
+	if ($@) {
+		log_in("died: $@");
+		return undef;
+	}
+
+	$client->sysread(my $buf, 1024);
+	log2i($buf);
+
+	$body = '';
+
+	while (my $h = fastcgi_read_record(\$buf)) {
+		$version = $h->{version};
+		$id = $h->{id};
+
+		# skip everything unless stdin
+		next if $h->{type} != 5;
+
+		$body .= $h->{content};
+	}
+
+	my $f = { preread => $body };
+	$f->{upload} = sub {
+		my $buf = shift;
+
+		eval {
+			local $SIG{ALRM} = sub { die "timeout\n" };
+			local $SIG{PIPE} = sub { die "sigpipe\n" };
+			alarm(5);
+
+			log_out($buf);
+			$s->write($buf);
+
+			$client->sysread($buf, 1024);
+			log2i($buf);
+
+			$body = '';
+
+			while (my $h = fastcgi_read_record(\$buf)) {
+
+				# skip everything unless stdin
+				next if $h->{type} != 5;
+
+				$body .= $h->{content};
+			}
+
+			alarm(0);
+		};
+		alarm(0);
+		if ($@) {
+			log_in("died: $@");
+			return undef;
+		}
+
+		return $body;
+	};
+	$f->{http_end} = sub {
+		my $buf = '';
+
+		eval {
+			local $SIG{ALRM} = sub { die "timeout\n" };
+			local $SIG{PIPE} = sub { die "sigpipe\n" };
+			alarm(5);
+
+			fastcgi_respond($client, $version, $id, <<EOF);
+Status: 200 OK
+Connection: close
+X-Port: $port
+
+OK
+EOF
+
+			$client->close;
+
+			$s->sysread($buf, 1024);
+			log_in($buf);
+
+			alarm(0);
+		};
+		alarm(0);
+		if ($@) {
+			log_in("died: $@");
+			return undef;
+		}
+
+		return $buf;
+	};
+	return $f;
+}
+
+sub log2i { Test::Nginx::log_core('|| <<', @_); }
+sub log2o { Test::Nginx::log_core('|| >>', @_); }
+sub log2c { Test::Nginx::log_core('||', @_); }
+
+###############################################################################
+
+sub fastcgi_daemon {
+	my $socket = FCGI::OpenSocket('127.0.0.1:' . port(8081), 5);
+	my $request = FCGI::Request(\*STDIN, \*STDOUT, \*STDERR, \%ENV,
+		$socket);
+
+	my $count;
+	my $body;
+
+	while( $request->Accept() >= 0 ) {
+		$count++;
+		read(STDIN, $body, $ENV{'CONTENT_LENGTH'});
+
+		if ($ENV{REQUEST_URI} eq '/error_page') {
+			print "Status: 404 Not Found" . CRLF . CRLF;
+			next;
+		}
+
+		print <<EOF;
+Location: http://localhost/redirect
+Content-Type: text/html
+X-Body: $body
+
+SEE-THIS
+$count
+EOF
+	}
+
+	FCGI::CloseSocket($socket);
+}
+
+###############################################################################
diff --git a/tests/fastcgi_request_buffering_chunked.t b/tests/fastcgi_request_buffering_chunked.t
new file mode 100644
index 0000000..51d4389
--- /dev/null
+++ b/tests/fastcgi_request_buffering_chunked.t
@@ -0,0 +1,423 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for unbuffered request body with fastcgi backend,
+# chunked transfer-encoding.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require FCGI; };
+plan(skip_all => 'FCGI not installed') if $@;
+plan(skip_all => 'win32') if $^O eq 'MSWin32';
+
+my $t = Test::Nginx->new()->has(qw/http fastcgi rewrite/)->plan(19);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        client_header_buffer_size 1k;
+        fastcgi_request_buffering off;
+        fastcgi_param REQUEST_URI $request_uri;
+
+        location / {
+            client_body_buffer_size 2k;
+            fastcgi_pass 127.0.0.1:8081;
+        }
+        location /single {
+            client_body_in_single_buffer on;
+            fastcgi_pass 127.0.0.1:8081;
+        }
+        location /preread {
+            fastcgi_pass 127.0.0.1:8082;
+        }
+        location /error_page {
+            fastcgi_pass 127.0.0.1:8081;
+            error_page 404 /404;
+            fastcgi_intercept_errors on;
+        }
+        location /404 {
+            return 200 "$request_body\n";
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&fastcgi_daemon);
+$t->run()->waitforsocket('127.0.0.1:' . port(8081));
+
+###############################################################################
+
+like(http_get('/'), qr/X-Body: \x0d\x0a?/ms, 'no body');
+
+like(http_get_body('/', '0123456789'),
+	qr/X-Body: 0123456789\x0d?$/ms, 'body');
+
+like(http_get_body('/', '0123456789' x 128),
+	qr/X-Body: (0123456789){128}\x0d?$/ms, 'body in two buffers');
+
+like(http_get_body('/single', '0123456789' x 128),
+	qr/X-Body: (0123456789){128}\x0d?$/ms, 'body in single buffer');
+
+like(http_get_body('/error_page', '0123456789'),
+	qr/^0123456789$/m, 'body in error page');
+
+# pipelined requests
+
+like(http_get_body('/', '0123456789', '0123456789' x 128, '0123456789' x 512,
+	'foobar'), qr/X-Body: foobar\x0d?$/ms, 'body pipelined');
+like(http_get_body('/', '0123456789' x 128, '0123456789' x 512, '0123456789',
+	'foobar'), qr/X-Body: foobar\x0d?$/ms, 'body pipelined 2');
+
+# interactive tests
+
+my $s = get_body('/preread', port(8082));
+ok($s, 'no preread');
+
+SKIP: {
+skip 'no preread failed', 3 unless $s;
+
+is($s->{upload}('01234'), '01234', 'no preread - body part');
+is($s->{upload}('56789', last => 1), '56789', 'no preread - body part 2');
+
+like($s->{http_end}(), qr/200 OK/, 'no preread - response');
+
+}
+
+$s = get_body('/preread', port(8082), '01234');
+ok($s, 'preread');
+
+SKIP: {
+skip 'preread failed', 3 unless $s;
+
+is($s->{preread}, '01234', 'preread - preread');
+is($s->{upload}('56789', last => 1), '56789', 'preread - body');
+
+like($s->{http_end}(), qr/200 OK/, 'preread - response');
+
+}
+
+$s = get_body('/preread', port(8082), '01234', many => 1);
+ok($s, 'chunks');
+
+SKIP: {
+skip 'chunks failed', 3 unless $s;
+
+is($s->{preread}, '01234many', 'chunks - preread');
+is($s->{upload}('56789', many => 1, last => 1), '56789many', 'chunks - body');
+
+like($s->{http_end}(), qr/200 OK/, 'chunks - response');
+
+}
+
+###############################################################################
+
+sub http_get_body {
+	my $uri = shift;
+	my $last = pop;
+	return http( join '', (map {
+		my $body = $_;
+		"GET $uri HTTP/1.1" . CRLF
+		. "Host: localhost" . CRLF
+		. "Transfer-Encoding: chunked" . CRLF . CRLF
+		. sprintf("%x", length $body) . CRLF
+		. $body . CRLF
+		. "0" . CRLF . CRLF
+	} @_),
+		"GET $uri HTTP/1.1" . CRLF
+		. "Host: localhost" . CRLF
+		. "Connection: close" . CRLF
+		. "Transfer-Encoding: chunked" . CRLF . CRLF
+		. sprintf("%x", length $last) . CRLF
+		. $last . CRLF
+		. "0" . CRLF . CRLF
+	);
+}
+
+# Simple FastCGI responder implementation.
+
+# http://www.fastcgi.com/devkit/doc/fcgi-spec.html
+
+sub fastcgi_read_record($) {
+	my ($buf) = @_;
+	my $h;
+
+	return undef unless length $$buf;
+
+	@{$h}{qw/ version type id clen plen /} = unpack("CCnnC", $$buf);
+
+	$h->{content} = substr $$buf, 8, $h->{clen};
+	$h->{padding} = substr $$buf, 8 + $h->{clen}, $h->{plen};
+
+	$$buf = substr $$buf, 8 + $h->{clen} + $h->{plen};
+
+	return $h;
+}
+
+sub fastcgi_respond($$$$) {
+	my ($socket, $version, $id, $body) = @_;
+
+	# stdout
+	$socket->write(pack("CCnnCx", $version, 6, $id, length($body), 8));
+	$socket->write($body);
+	select(undef, undef, undef, 0.1);
+	$socket->write(pack("xxxxxxxx"));
+	select(undef, undef, undef, 0.1);
+
+	# write some text to stdout and stderr split over multiple network
+	# packets to test if we correctly set pipe length in various places
+
+	my $tt = "test text, just for test";
+
+	$socket->write(pack("CCnnCx", $version, 6, $id,
+		length($tt . $tt), 0) . $tt);
+	select(undef, undef, undef, 0.1);
+	$socket->write($tt . pack("CC", $version, 7));
+	select(undef, undef, undef, 0.1);
+	$socket->write(pack("nnCx", $id, length($tt), 0));
+	select(undef, undef, undef, 0.1);
+	$socket->write($tt);
+	select(undef, undef, undef, 0.1);
+
+	# close stdout
+	$socket->write(pack("CCnnCx", $version, 6, $id, 0, 0));
+
+	select(undef, undef, undef, 0.1);
+
+	# end request
+	$socket->write(pack("CCnnCx", $version, 3, $id, 8, 0));
+	select(undef, undef, undef, 0.1);
+	$socket->write(pack("NCxxx", 0, 0));
+}
+
+sub get_body {
+	my ($url, $port, $body, %extra) = @_;
+	my ($server, $client, $s);
+	my ($last, $many) = (0, 0);
+	my ($version, $id);
+
+	$last = $extra{last} if defined $extra{last};
+	$many = $extra{many} if defined $extra{many};
+
+	$server = IO::Socket::INET->new(
+		Proto => 'tcp',
+		LocalHost => '127.0.0.1',
+		LocalPort => $port,
+		Listen => 5,
+		Reuse => 1
+	)
+		or die "Can't create listening socket: $!\n";
+
+	my $r = <<EOF;
+GET $url HTTP/1.1
+Host: localhost
+Connection: close
+Transfer-Encoding: chunked
+
+EOF
+
+	if (defined $body) {
+		$r .= sprintf("%x", length $body) . CRLF;
+		$r .= $body . CRLF;
+	}
+	if (defined $body && $many) {
+		$r .= sprintf("%x", length 'many') . CRLF;
+		$r .= 'many' . CRLF;
+	}
+	if ($last) {
+		$r .= "0" . CRLF . CRLF;
+	}
+
+	$s = http($r, start => 1);
+
+	eval {
+		local $SIG{ALRM} = sub { die "timeout\n" };
+		local $SIG{PIPE} = sub { die "sigpipe\n" };
+		alarm(5);
+
+		$client = $server->accept();
+
+		log2c("(new connection $client)");
+
+		alarm(0);
+	};
+	alarm(0);
+	if ($@) {
+		log_in("died: $@");
+		return undef;
+	}
+
+	$client->sysread(my $buf, 1024);
+	log2i($buf);
+
+	$body = '';
+
+	while (my $h = fastcgi_read_record(\$buf)) {
+		$version = $h->{version};
+		$id = $h->{id};
+
+		# skip everything unless stdin
+		next if $h->{type} != 5;
+
+		$body .= $h->{content};
+	}
+
+	my $f = { preread => $body };
+	$f->{upload} = sub {
+		my ($body, %extra) = @_;
+		my ($last, $many) = (0, 0);
+
+		$last = $extra{last} if defined $extra{last};
+		$many = $extra{many} if defined $extra{many};
+
+		my $buf = sprintf("%x", length $body) . CRLF;
+		$buf .= $body . CRLF;
+		if ($many) {
+			$buf .= sprintf("%x", length 'many') . CRLF;
+			$buf .= 'many' . CRLF;
+		}
+		if ($last) {
+			$buf .= "0" . CRLF . CRLF;
+		}
+
+		eval {
+			local $SIG{ALRM} = sub { die "timeout\n" };
+			local $SIG{PIPE} = sub { die "sigpipe\n" };
+			alarm(5);
+
+			log_out($buf);
+			$s->write($buf);
+
+			$client->sysread($buf, 1024);
+			log2i($buf);
+
+			$body = '';
+
+			while (my $h = fastcgi_read_record(\$buf)) {
+
+				# skip everything unless stdin
+				next if $h->{type} != 5;
+
+				$body .= $h->{content};
+			}
+
+			alarm(0);
+		};
+		alarm(0);
+		if ($@) {
+			log_in("died: $@");
+			return undef;
+		}
+
+		return $body;
+	};
+	$f->{http_end} = sub {
+		my $buf = '';
+
+		eval {
+			local $SIG{ALRM} = sub { die "timeout\n" };
+			local $SIG{PIPE} = sub { die "sigpipe\n" };
+			alarm(5);
+
+			fastcgi_respond($client, $version, $id, <<EOF);
+Status: 200 OK
+Connection: close
+X-Port: $port
+
+OK
+EOF
+
+			$client->close;
+
+			$s->sysread($buf, 1024);
+			log_in($buf);
+
+			$s->close();
+
+			alarm(0);
+		};
+		alarm(0);
+		if ($@) {
+			log_in("died: $@");
+			return undef;
+		}
+
+		return $buf;
+	};
+	return $f;
+}
+
+sub log2i { Test::Nginx::log_core('|| <<', @_); }
+sub log2o { Test::Nginx::log_core('|| >>', @_); }
+sub log2c { Test::Nginx::log_core('||', @_); }
+
+###############################################################################
+
+sub fastcgi_daemon {
+	my $socket = FCGI::OpenSocket('127.0.0.1:' . port(8081), 5);
+	my $request = FCGI::Request(\*STDIN, \*STDOUT, \*STDERR, \%ENV,
+		$socket);
+
+	my $count;
+	my ($body, $buf);
+
+	while( $request->Accept() >= 0 ) {
+		$count++;
+		$body = '';
+
+		do {
+			read(STDIN, $buf, 1024);
+			$body .= $buf;
+		} while (length $buf);
+
+		if ($ENV{REQUEST_URI} eq '/error_page') {
+			print "Status: 404 Not Found" . CRLF . CRLF;
+			next;
+		}
+
+		print <<EOF;
+Location: http://localhost/redirect
+Content-Type: text/html
+X-Body: $body
+
+SEE-THIS
+$count
+EOF
+	}
+
+	FCGI::CloseSocket($socket);
+}
+
+###############################################################################
diff --git a/tests/fastcgi_split.t b/tests/fastcgi_split.t
new file mode 100644
index 0000000..97fde45
--- /dev/null
+++ b/tests/fastcgi_split.t
@@ -0,0 +1,98 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Test for fastcgi backend.
+# Incorrect split headers handling after switching to next server,
+# as reported by Lucas Molas.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+use Socket qw/ CR LF CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require FCGI; };
+plan(skip_all => 'FCGI not installed') if $@;
+plan(skip_all => 'win32') if $^O eq 'MSWin32';
+
+my $t = Test::Nginx->new()->has(qw/http fastcgi/)->plan(1)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    upstream u {
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8082;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            fastcgi_pass u;
+            fastcgi_param REQUEST_URI $request_uri;
+            fastcgi_next_upstream invalid_header;
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&fastcgi_daemon, port(8081));
+$t->run_daemon(\&fastcgi_daemon, port(8082));
+
+$t->run();
+
+$t->waitforsocket('127.0.0.1:' . port(8081));
+$t->waitforsocket('127.0.0.1:' . port(8082));
+
+###############################################################################
+
+like(http_get('/'), qr/^Good: header/ms, 'fastcgi next upstream');
+
+###############################################################################
+
+sub fastcgi_daemon {
+	my ($port) = @_;
+	my $socket = FCGI::OpenSocket("127.0.0.1:$port", 5);
+	my $request = FCGI::Request(\*STDIN, \*STDOUT, \*STDERR, \%ENV,
+		$socket);
+
+	my $count;
+	while( $request->Accept() >= 0 ) {
+		$count++;
+
+		if ($port == port(8081)) {
+			print 'BAD';
+		}
+		if ($port == port(8082)) {
+			print 'Good: header' . CRLF . CRLF;
+		}
+	}
+
+	FCGI::CloseSocket($socket);
+}
+
+###############################################################################
diff --git a/tests/fastcgi_unix.t b/tests/fastcgi_unix.t
new file mode 100644
index 0000000..0ff7b90
--- /dev/null
+++ b/tests/fastcgi_unix.t
@@ -0,0 +1,119 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Test for fastcgi backend with unix socket.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require FCGI; };
+plan(skip_all => 'FCGI not installed') if $@;
+plan(skip_all => 'win32') if $^O eq 'MSWin32';
+
+eval { require IO::Socket::UNIX; };
+plan(skip_all => 'IO::Socket::UNIX not installed') if $@;
+
+my $t = Test::Nginx->new()->has(qw/http fastcgi unix/)->plan(6)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    upstream u {
+        server 127.0.0.1:8081;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            fastcgi_pass unix:%%TESTDIR%%/unix.sock;
+            fastcgi_param REQUEST_URI $request_uri;
+        }
+
+        location /var {
+            fastcgi_pass $arg_b;
+            fastcgi_param REQUEST_URI $request_uri;
+        }
+    }
+}
+
+EOF
+
+my $path = $t->testdir() . '/unix.sock';
+
+$t->run_daemon(\&fastcgi_daemon, $path);
+$t->run();
+
+# wait for unix socket to appear
+
+for (1 .. 50) {
+	last if -S $path;
+	select undef, undef, undef, 0.1;
+}
+
+###############################################################################
+
+like(http_get('/'), qr/SEE-THIS/, 'fastcgi request');
+like(http_get('/redir'), qr/ 302 /, 'fastcgi redirect');
+like(http_get('/'), qr/^3$/m, 'fastcgi third request');
+
+unlike(http_head('/'), qr/SEE-THIS/, 'no data in HEAD');
+
+like(http_get('/stderr'), qr/SEE-THIS/, 'large stderr handled');
+
+like(http_get("/var?b=unix:$path"), qr/SEE-THIS/, 'fastcgi with variables');
+
+###############################################################################
+
+sub fastcgi_daemon {
+	my $socket = FCGI::OpenSocket(shift, 5);
+	my $request = FCGI::Request(\*STDIN, \*STDOUT, \*STDERR, \%ENV,
+		$socket);
+
+	my $count;
+	while( $request->Accept() >= 0 ) {
+		$count++;
+
+		if ($ENV{REQUEST_URI} eq '/stderr') {
+			warn "sample stderr text" x 512;
+		}
+
+		print <<EOF;
+Location: http://localhost/redirect
+Content-Type: text/html
+
+SEE-THIS
+$count
+EOF
+	}
+
+	FCGI::CloseSocket($socket);
+}
+
+###############################################################################
diff --git a/tests/fastcgi_variables.t b/tests/fastcgi_variables.t
new file mode 100644
index 0000000..3fad44c
--- /dev/null
+++ b/tests/fastcgi_variables.t
@@ -0,0 +1,90 @@
+#!/usr/bin/perl
+
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+
+# Test for fastcgi variables.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require FCGI; };
+plan(skip_all => 'FCGI not installed') if $@;
+plan(skip_all => 'win32') if $^O eq 'MSWin32';
+
+my $t = Test::Nginx->new()->has(qw/http fastcgi rewrite/)->plan(3)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        add_header X-Script-Name $fastcgi_script_name;
+        add_header X-Path-Info $fastcgi_path_info;
+
+        location / {
+            fastcgi_pass 127.0.0.1:8081;
+            fastcgi_index index.php;
+        }
+
+        location /info {
+            fastcgi_pass 127.0.0.1:8081;
+            fastcgi_split_path_info ^(.+\.php)(.*)$;
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&fastcgi_daemon);
+$t->run()->waitforsocket('127.0.0.1:' . port(8081));
+
+###############################################################################
+
+like(http_get('/'), qr/X-Script-Name: \/index\.php/ms, 'script name');
+like(http_get('/info.php/path/info'), qr/X-Script-Name: \/info\.php/ms,
+	'info script name');
+like(http_get('/info.php/path/info'), qr/X-Path-Info: \/path\/info/ms,
+	'info path');
+
+###############################################################################
+
+sub fastcgi_daemon {
+	my $socket = FCGI::OpenSocket('127.0.0.1:' . port(8081), 5);
+	my $request = FCGI::Request(\*STDIN, \*STDOUT, \*STDERR, \%ENV,
+		$socket);
+
+	while( $request->Accept() >= 0 ) {
+		print CRLF . CRLF;
+	}
+
+	FCGI::CloseSocket($socket);
+}
+
+###############################################################################
diff --git a/tests/geo.t b/tests/geo.t
new file mode 100644
index 0000000..47956ed
--- /dev/null
+++ b/tests/geo.t
@@ -0,0 +1,250 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+
+# Tests for nginx geo module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http geo/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    geo $geo {
+        127.0.0.0/8   loopback;
+        192.0.2.0/24  test;
+        0.0.0.0/0     world;
+    }
+
+    geo $geo_include {
+        include       geo.conf;
+        192.0.2.0/24  test;
+        0.0.0.0/0     world;
+    }
+
+    geo $geo_delete {
+        127.0.0.0/8   loopback;
+        192.0.2.0/24  test;
+        0.0.0.0/0     world;
+        delete        127.0.0.0/8;
+    }
+
+    geo $arg_ip $geo_from_arg {
+        default       default;
+        127.0.0.0/8   loopback;
+        192.0.2.0/24  test;
+    }
+
+    geo $arg_ip $geo_arg_ranges {
+        ranges;
+        default                default;
+        127.0.0.0-127.0.0.1    loopback;
+
+        # ranges with two /16 networks
+        # the latter network has greater two least octets
+        # (see 1301a58b5dac for details)
+        10.10.3.0-10.11.2.255  foo;
+        10.12.3.0-10.13.2.255  foo2;
+        delete                 10.10.3.0-10.11.2.255;
+    }
+
+    geo $geo_proxy {
+        default       default;
+        proxy         127.0.0.1;
+        127.0.0.0/8   loopback;
+        192.0.2.0/24  test;
+    }
+
+    geo $geo_proxy_recursive {
+        proxy_recursive;
+        default       default;
+        proxy         127.0.0.1;
+        127.0.0.0/8   loopback;
+        192.0.2.0/24  test;
+    }
+
+    geo $geo_ranges {
+        ranges;
+        default                    default;
+        127.0.0.0-127.255.255.255  loopback;
+        192.0.2.0-192.0.2.255      test;
+    }
+
+    geo $geo_ranges_include {
+        ranges;
+        default                default;
+        include                geo-ranges.conf;
+        192.0.2.0-192.0.2.255  test;
+    }
+
+    geo $geo_ranges_delete {
+        ranges;
+        default                default;
+        127.0.0.0-127.0.0.255  test;
+        127.0.0.1-127.0.0.1    loopback;
+        delete                 127.0.0.0-127.0.0.0;
+        delete                 127.0.0.2-127.0.0.255;
+        delete                 127.0.0.1-127.0.0.1;
+    }
+
+    # delete range with two /16
+    geo $geo_ranges_delete_2 {
+        ranges;
+        default              default;
+        127.0.0.0-127.1.0.0  loopback;
+        delete               127.0.0.0-127.1.0.0;
+    }
+
+    geo $geo_before {
+        ranges;
+        default                default;
+        127.0.0.1-127.0.0.255  loopback;
+        127.0.0.0-127.0.0.0    test;
+    }
+
+    geo $geo_after {
+        ranges;
+        default                default;
+        127.0.0.0-127.0.0.1    loopback;
+        127.0.0.2-127.0.0.255  test;
+    }
+
+    geo $geo_insert {
+        ranges;
+        default                default;
+        127.0.0.0-127.0.0.255  test;
+        127.0.0.1-127.0.0.2    test2;
+        127.0.0.1-127.0.0.1    loopback;
+    }
+
+    geo $geo_insert_before {
+        ranges;
+        default                default;
+        127.0.0.0-127.0.0.255  test;
+        127.0.0.0-127.0.0.1    loopback;
+    }
+
+    geo $geo_insert_after {
+        ranges;
+        default                default;
+        127.0.0.0-127.0.0.255  test;
+        127.0.0.1-127.0.0.255  loopback;
+     }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            add_header X-IP   $remote_addr;
+            add_header X-Geo  $geo;
+            add_header X-Inc  $geo_include;
+            add_header X-Del  $geo_delete;
+            add_header X-Ran  $geo_ranges;
+            add_header X-RIn  $geo_ranges_include;
+            add_header X-ABe  $geo_before;
+            add_header X-AAf  $geo_after;
+            add_header X-Ins  $geo_insert;
+            add_header X-IBe  $geo_insert_before;
+            add_header X-IAf  $geo_insert_after;
+            add_header X-Arg  $geo_from_arg;
+            add_header X-ARa  $geo_arg_ranges;
+            add_header X-XFF  $geo_proxy;
+            add_header X-XFR  $geo_proxy_recursive;
+        }
+
+        location /2 {
+            add_header X-RDe  $geo_ranges_delete;
+            add_header X-RD2  $geo_ranges_delete_2;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('1', '');
+$t->write_file('2', '');
+$t->write_file('geo.conf', '127.0.0.0/8  loopback;');
+$t->write_file('geo-ranges.conf', '127.0.0.0-127.255.255.255  loopback;');
+
+$t->run();
+
+plan(skip_all => 'no 127.0.0.1 on host')
+	if http_get('/1') !~ /X-IP: 127.0.0.1/m;
+
+$t->plan(22);
+
+###############################################################################
+
+my $r = http_get('/1');
+like($r, qr/^X-Geo: loopback/m, 'geo');
+like($r, qr/^X-Inc: loopback/m, 'geo include');
+like($r, qr/^X-Del: world/m, 'geo delete');
+like($r, qr/^X-Ran: loopback/m, 'geo ranges');
+like($r, qr/^X-RIn: loopback/m, 'geo ranges include');
+
+like(http_get('/2'), qr/^X-RDe: default/m, 'geo ranges delete');
+like(http_get('/2'), qr/^X-RD2: default/m, 'geo ranges delete 2');
+
+like($r, qr/^X-ABe: loopback/m, 'geo ranges add before');
+like($r, qr/^X-AAf: loopback/m, 'geo ranges add after');
+like($r, qr/^X-Ins: loopback/m, 'geo ranges insert');
+like($r, qr/^X-IBe: loopback/m, 'geo ranges insert before');
+like($r, qr/^X-IAf: loopback/m, 'geo ranges insert after');
+
+like(http_get('/1?ip=192.0.2.1'), qr/^X-Arg: test/m, 'geo from variable');
+like(http_get('/1?ip=10.0.0.1'), qr/^X-Arg: default/m, 'geo default');
+like(http_get('/1?ip=10.0.0.1'), qr/^X-ARa: default/m, 'geo ranges default');
+like(http_get('/1?ip=10.13.2.1'), qr/^X-ARa: foo2/m, 'geo ranges add');
+like(http_get('/1?ip=10.11.2.1'), qr/^X-ARa: default/m,
+	'geo delete range from variable');
+
+like(http_xff('192.0.2.1'), qr/^X-XFF: test/m, 'geo proxy');
+like(http_xff('10.0.0.1'), qr/^X-XFF: default/m, 'geo proxy default');
+like(http_xff('10.0.0.1, 192.0.2.1'), qr/^X-XFF: test/m, 'geo proxy long');
+
+like(http_xff('192.0.2.1, 127.0.0.1'), qr/^X-XFF: loopback/m,
+	'geo proxy_recursive off');
+like(http_xff('192.0.2.1, 127.0.0.1'), qr/^X-XFR: test/m,
+	'geo proxy_recursive on');
+
+###############################################################################
+
+sub http_xff {
+	my ($xff) = @_;
+	return http(<<EOF);
+GET /1 HTTP/1.0
+Host: localhost
+X-Forwarded-For: $xff
+
+EOF
+}
+
+###############################################################################
diff --git a/tests/geo_binary.t b/tests/geo_binary.t
new file mode 100644
index 0000000..52dd58f
--- /dev/null
+++ b/tests/geo_binary.t
@@ -0,0 +1,84 @@
+#!/usr/bin/perl
+
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+
+# Tests for nginx geo module with binary base.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+plan(skip_all => 'long configuration parsing') unless $ENV{TEST_NGINX_UNSAFE};
+
+my $t = Test::Nginx->new()->has(qw/http geo/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    geo $geo_base_create {
+        ranges;
+        include  base.conf;
+    }
+
+    geo $geo_base_include {
+        ranges;
+        include  base.conf;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            add_header X-IP   $remote_addr;
+            add_header X-GBc  $geo_base_create;
+            add_header X-GBi  $geo_base_include;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('1', '');
+$t->write_file('base.conf', join('', map {
+	"127." . $_/256/256 % 256 . "." . $_/256 % 256 . "." . $_ % 256 .
+	"-127." . $_/256/256 % 256 . "." . $_/256 % 256 . "." .$_ % 256 . " " .
+	($_ == 1 ? "loopback" : "range$_") . ";" } (0 .. 100000)));
+
+$t->run();
+
+plan(skip_all => 'no 127.0.0.1 on host')
+	if http_get('/1') !~ /X-IP: 127.0.0.1/m;
+
+$t->plan(2);
+
+###############################################################################
+
+my $r = http_get('/1');
+like($r, qr/^X-GBc: loopback/m, 'geo binary base create');
+like($r, qr/^X-GBi: loopback/m, 'geo binary base include');
+
+###############################################################################
diff --git a/tests/geo_ipv6.t b/tests/geo_ipv6.t
new file mode 100644
index 0000000..ace28db
--- /dev/null
+++ b/tests/geo_ipv6.t
@@ -0,0 +1,122 @@
+#!/usr/bin/perl
+
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+
+# Tests for geo module with IPv6.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http geo proxy/)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    geo $geo {
+        ::1/128         loopback;
+        2001:0db8::/32  test;
+        ::/0            world;
+    }
+
+    geo $geo_delete {
+        ::1/128         loopback;
+        2001:0db8::/32  test;
+        ::/0            world;
+        delete          ::1/128;
+    }
+
+    geo $geo_proxy {
+        ranges;
+        proxy                ::1;
+        default              default;
+        192.0.2.1-192.0.2.1  test;
+    }
+
+    geo $arg_ip $geo_arg {
+        default       default;
+        ::1/128       loopback;
+        192.0.2.0/24  test;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            proxy_pass http://[::1]:%%PORT_8080%%/;
+        }
+    }
+
+    server {
+        listen       [::1]:%%PORT_8080%%;
+        server_name  localhost;
+
+        location / {
+            add_header X-Geo  $geo;
+            add_header X-Del  $geo_delete;
+            add_header X-XFF  $geo_proxy;
+            add_header X-Arg  $geo_arg;
+        }
+
+        location /addr {
+            add_header X-IP   $remote_addr;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('index.html', '');
+$t->write_file('addr', '');
+$t->try_run('no inet6 support');
+
+plan(skip_all => 'no ::1 on host')
+	if http_get('/addr') !~ /X-IP: ::1/m;
+
+$t->plan(4);
+
+###############################################################################
+
+like(http_get('/'), qr/^X-Geo: loopback/m, 'geo ipv6');
+like(http_get('/'), qr/^X-Del: world/m, 'geo ipv6 delete');
+
+like(http_xff('::ffff:192.0.2.1'), qr/^X-XFF: test/m, 'geo ipv6 ipv4-mapped');
+like(http_get('/?ip=::ffff:192.0.2.1'), qr/^X-Arg: test/m,
+	'geo ipv6 ipv4-mapped from variable');
+
+###############################################################################
+
+sub http_xff {
+	my ($xff) = @_;
+	return http(<<EOF);
+GET / HTTP/1.0
+Host: localhost
+X-Forwarded-For: $xff
+
+EOF
+}
+
+###############################################################################
diff --git a/tests/geo_unix.t b/tests/geo_unix.t
new file mode 100644
index 0000000..4d1a861
--- /dev/null
+++ b/tests/geo_unix.t
@@ -0,0 +1,103 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http geo module with unix socket.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http geo proxy unix/)->plan(5);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    geo $geo {
+        default                  default;
+        255.255.255.255          none;
+    }
+
+    geo $remote_addr $geora {
+        default                  default;
+        255.255.255.255          none;
+    }
+
+    geo $geor {
+        ranges;
+        0.0.0.0-255.255.255.254  test;
+        default                  none;
+    }
+
+    geo $remote_addr $georra {
+        ranges;
+        0.0.0.0-255.255.255.254  test;
+        default                  none;
+    }
+
+    geo $arg_ip $geo_arg {
+        default                  default;
+        192.0.2.0/24             test;
+    }
+
+    server {
+        listen       unix:%%TESTDIR%%/unix.sock;
+        server_name  localhost;
+
+        location / {
+            add_header X-Geo          $geo;
+            add_header X-Addr         $geora;
+            add_header X-Ranges       $geor;
+            add_header X-Ranges-Addr  $georra;
+            add_header X-Arg          $geo_arg;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+
+        location / {
+            proxy_pass http://unix:%%TESTDIR%%/unix.sock;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('index.html', '');
+$t->run();
+
+###############################################################################
+
+my $r = http_get('/');
+like($r, qr/^X-Geo: none/m, 'geo unix');
+like($r, qr/^X-Ranges: none/m, 'geo unix ranges');
+like($r, qr/^X-Addr: none/m, 'geo unix remote addr');
+like($r, qr/^X-Ranges-Addr: none/m, 'geo unix ranges remote addr');
+
+like(http_get('/?ip=192.0.2.1'), qr/^X-Arg: test/m, 'geo unix variable');
+
+###############################################################################
diff --git a/tests/geoip.t b/tests/geoip.t
new file mode 100644
index 0000000..fa65a17
--- /dev/null
+++ b/tests/geoip.t
@@ -0,0 +1,198 @@
+#!/usr/bin/perl
+
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+
+# Tests for geoip module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http http_geoip/)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    geoip_proxy    127.0.0.1/32;
+
+    geoip_country  %%TESTDIR%%/country.dat;
+    geoip_city     %%TESTDIR%%/city.dat;
+    geoip_org      %%TESTDIR%%/org.dat;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            add_header X-Country-Code      $geoip_country_code;
+            add_header X-Country-Code3     $geoip_country_code3;
+            add_header X-Country-Name      $geoip_country_name;
+
+            add_header X-Area-Code         $geoip_area_code;
+            add_header X-C-Continent-Code  $geoip_city_continent_code;
+            add_header X-C-Country-Code    $geoip_city_country_code;
+            add_header X-C-Country-Code3   $geoip_city_country_code3;
+            add_header X-C-Country-Name    $geoip_city_country_name;
+            add_header X-Dma-Code          $geoip_dma_code;
+            add_header X-Latitude          $geoip_latitude;
+            add_header X-Longitude         $geoip_longitude;
+            add_header X-Region            $geoip_region;
+            add_header X-Region-Name       $geoip_region_name;
+            add_header X-City              $geoip_city;
+            add_header X-Postal-Code       $geoip_postal_code;
+
+            add_header X-Org               $geoip_org;
+        }
+    }
+}
+
+EOF
+
+my $d = $t->testdir();
+
+# country database:
+#
+# "10.0.0.1","10.0.0.1","RU","Russian Federation"
+# "2001:db8::","2001:db8::","US","United States"
+
+my $data = '';
+
+for my $i (0 .. 156) {
+	# skip to offset 32 if 1st bit set in ipv6 address wins
+	$data .= pack_node($i + 1) . pack_node(32), next if $i == 2;
+	# otherwise default to RU
+	$data .= pack_node(0xffffb9) . pack_node(0xffff00), next if $i == 31;
+	# continue checking bits set in ipv6 address
+	$data .= pack_node(0xffff00) . pack_node($i + 1), next
+		if grep $_ == $i, (44, 49, 50, 52, 53, 55, 56, 57);
+	# last bit set in ipv6 address
+	$data .= pack_node(0xffffe1) . pack_node(0xffff00), next if $i == 156;
+	$data .= pack_node($i + 1) . pack_node(0xffff00);
+}
+
+$data .= chr(0x00) x 3;
+$data .= chr(0xFF) x 3;
+$data .= chr(12);
+
+$t->write_file('country.dat', $data);
+
+# city database:
+#
+# "167772161","167772161","RU","48","Moscow","119034","55.7543",37.6202",,
+
+$data = '';
+
+for my $i (0 .. 31) {
+	$data .= pack_node(32) . pack_node($i + 1), next if $i == 4 or $i == 6;
+	$data .= pack_node(32) . pack_node($i + 2), next if $i == 31;
+	$data .= pack_node($i + 1) . pack_node(32);
+}
+
+$data .= chr(42);
+$data .= chr(185);
+$data .= pack('Z*', 48);
+$data .= pack('Z*', 'Moscow');
+$data .= pack('Z*', 119034);
+$data .= pack_node(int((55.7543 + 180) * 10000));
+$data .= pack_node(int((37.6202 + 180) * 10000));
+$data .= chr(0) x 3;
+$data .= chr(0xFF) x 3;
+$data .= chr(2);
+$data .= pack_node(32);
+
+$t->write_file('city.dat', $data);
+
+# organization database:
+#
+# "167772161","167772161","Nginx"
+
+$data = '';
+
+for my $i (0 .. 31) {
+	$data .= pack_org(32) . pack_org($i + 1), next if $i == 4 or $i == 6;
+	$data .= pack_org(32) . pack_org($i + 2), next if $i == 31;
+	$data .= pack_org($i + 1) . pack_org(32);
+}
+
+$data .= chr(42);
+$data .= pack('Z*', 'Nginx');
+$data .= chr(0xFF) x 3;
+$data .= chr(5);
+$data .= pack_node(32);
+
+$t->write_file('org.dat', $data);
+$t->write_file('index.html', '');
+$t->try_run('no inet6 support')->plan(20);
+
+###############################################################################
+
+my $r = http_xff('10.0.0.1');
+like($r, qr/X-Country-Code: RU/, 'geoip country code');
+like($r, qr/X-Country-Code3: RUS/, 'geoip country code 3');
+like($r, qr/X-Country-Name: Russian Federation/, 'geoip country name');
+
+like($r, qr/X-Area-Code: 0/, 'geoip area code');
+like($r, qr/X-C-Continent-Code: EU/, 'geoip city continent code');
+like($r, qr/X-C-Country-Code: RU/, 'geoip city country code');
+like($r, qr/X-C-Country-Code3: RUS/, 'geoip city country code 3');
+like($r, qr/X-C-Country-Name: Russian Federation/, 'geoip city country name');
+like($r, qr/X-Dma-Code: 0/, 'geoip dma code');
+like($r, qr/X-Latitude: 55.7543/, 'geoip latitude');
+like($r, qr/X-Longitude: 37.6202/, 'geoip longitude');
+like($r, qr/X-Region: 48/, 'geoip region');
+like($r, qr/X-Region-Name: Moscow City/, 'geoip region name');
+like($r, qr/X-City: Moscow/, 'geoip city');
+like($r, qr/X-Postal-Code: 119034/, 'geoip postal code');
+
+like($r, qr/X-Org: Nginx/, 'geoip org');
+
+like(http_xff('::ffff:10.0.0.1'), qr/X-Org: Nginx/, 'geoip ipv6 ipv4-mapped');
+
+$r = http_xff('2001:db8::');
+like($r, qr/X-Country-Code: US/, 'geoip ipv6 country code');
+like($r, qr/X-Country-Code3: USA/, 'geoip ipv6 country code 3');
+like($r, qr/X-Country-Name: United States/, 'geoip ipv6 country name');
+
+###############################################################################
+
+sub http_xff {
+	my ($xff) = @_;
+	return http(<<EOF);
+GET / HTTP/1.0
+Host: localhost
+X-Forwarded-For: $xff
+
+EOF
+}
+
+sub pack_node {
+	substr pack('V', shift), 0, 3;
+}
+
+sub pack_org {
+	pack('V', shift);
+}
+
+###############################################################################
diff --git a/tests/grpc.t b/tests/grpc.t
new file mode 100644
index 0000000..e7fca7f
--- /dev/null
+++ b/tests/grpc.t
@@ -0,0 +1,724 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for grpc backend.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::HTTP2;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http rewrite http_v2 grpc/)
+	->has(qw/upstream_keepalive/)->plan(109);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    upstream u {
+        server 127.0.0.1:8081;
+        keepalive 1;
+    }
+
+    server {
+        listen       127.0.0.1:8080 http2;
+        server_name  localhost;
+
+        http2_max_field_size 128k;
+        http2_max_header_size 128k;
+        http2_body_preread_size 128k;
+
+        location / {
+            grpc_pass grpc://127.0.0.1:8081;
+
+            if ($arg_if) {
+                # nothing
+            }
+
+            limit_except GET {
+                # nothing
+            }
+        }
+
+        location /KeepAlive {
+            grpc_pass u;
+        }
+
+        location /LongHeader {
+            grpc_pass 127.0.0.1:8081;
+            grpc_set_header X-LongHeader $arg_h;
+        }
+
+        location /LongField {
+            grpc_pass 127.0.0.1:8081;
+            grpc_buffer_size 65k;
+        }
+
+        location /SetHost {
+            grpc_pass 127.0.0.1:8081;
+            grpc_set_header Host custom;
+        }
+
+        location /SetArgs {
+            grpc_pass 127.0.0.1:8081;
+            set $args $arg_c;
+        }
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+my $p = port(8081);
+my $f = grpc();
+
+my $frames = $f->{http_start}('/SayHello');
+my ($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{flags}, 4, 'request - HEADERS flags');
+ok((my $sid = $frame->{sid}) % 2, 'request - HEADERS sid odd');
+is($frame->{headers}{':method'}, 'POST', 'request - method');
+is($frame->{headers}{':scheme'}, 'http', 'request - scheme');
+is($frame->{headers}{':path'}, '/SayHello', 'request - path');
+is($frame->{headers}{':authority'}, "127.0.0.1:$p", 'request - authority');
+is($frame->{headers}{'content-type'}, 'application/grpc',
+	'request - content type');
+is($frame->{headers}{te}, 'trailers', 'request - te');
+
+$frames = $f->{data}('Hello');
+($frame) = grep { $_->{type} eq "SETTINGS" } @$frames;
+is($frame->{flags}, 1, 'request - SETTINGS ack');
+is($frame->{sid}, 0, 'request - SETTINGS sid');
+is($frame->{length}, 0, 'request - SETTINGS length');
+
+($frame) = grep { $_->{type} eq "DATA" } @$frames;
+is($frame->{data}, 'Hello', 'request - DATA');
+is($frame->{length}, 5, 'request - DATA length');
+is($frame->{flags}, 1, 'request - DATA flags');
+is($frame->{sid}, $sid, 'request - DATA sid match');
+
+$frames = $f->{http_end}();
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{flags}, 4, 'response - HEADERS flags');
+is($frame->{sid}, 1, 'response - HEADERS sid');
+is($frame->{headers}{':status'}, '200', 'response - status');
+is($frame->{headers}{'content-type'}, 'application/grpc',
+	'response - content type');
+ok($frame->{headers}{server}, 'response - server');
+ok($frame->{headers}{date}, 'response - date');
+ok(my $c = $frame->{headers}{'x-connection'}, 'response - connection');
+
+($frame) = grep { $_->{type} eq "DATA" } @$frames;
+is($frame->{data}, 'Hello world', 'response - DATA');
+is($frame->{length}, 11, 'response - DATA length');
+is($frame->{flags}, 0, 'response - DATA flags');
+is($frame->{sid}, 1, 'response - DATA sid');
+
+(undef, $frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{flags}, 5, 'response - trailers flags');
+is($frame->{sid}, 1, 'response - trailers sid');
+is($frame->{headers}{'grpc-message'}, '', 'response - trailers message');
+is($frame->{headers}{'grpc-status'}, '0', 'response - trailers status');
+
+# next request is on a new backend connection, no sid incremented
+
+$frames = $f->{http_start}('/SayHello');
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{sid}, $sid, 'request 2 - HEADERS sid again');
+$f->{data}('Hello');
+$frames = $f->{http_end}();
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+cmp_ok($frame->{headers}{'x-connection'}, '>', $c, 'response 2 - connection');
+
+# upstream keepalive
+
+$frames = $f->{http_start}('/KeepAlive');
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{sid}, $sid, 'keepalive - HEADERS sid');
+$f->{data}('Hello');
+$frames = $f->{http_end}();
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+ok($c = $frame->{headers}{'x-connection'}, 'keepalive - connection');
+
+$frames = $f->{http_start}('/KeepAlive', reuse => 1);
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+cmp_ok($frame->{sid}, '>', $sid, 'keepalive - HEADERS sid next');
+$f->{data}('Hello');
+$frames = $f->{http_end}();
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}{'x-connection'}, $c, 'keepalive - connection reuse');
+
+# upstream keepalive
+# pending control frame ack after the response
+
+undef $f;
+$f = grpc();
+
+$frames = $f->{http_start}('/KeepAlive');
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{sid}, $sid, 'keepalive 2 - HEADERS sid');
+$f->{data}('Hello');
+$f->{settings}(0, 1 => 4096);
+$frames = $f->{http_end}();
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+ok($c = $frame->{headers}{'x-connection'}, 'keepalive 2 - connection');
+
+$frames = $f->{http_start}('/KeepAlive', reuse => 1);
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+ok($frame, 'upstream keepalive reused');
+
+cmp_ok($frame->{sid}, '>', $sid, 'keepalive 2 - HEADERS sid next');
+$f->{data}('Hello');
+$frames = $f->{http_end}();
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}{'x-connection'}, $c, 'keepalive 2 - connection reuse');
+
+undef $f;
+$f = grpc();
+
+# various header compression formats
+
+$f->{http_start}('/SayHello');
+$f->{data}('Hello');
+$frames = $f->{http_end}(mode => 3);
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}{':status'}, '200', 'without indexing');
+is($frame->{headers}{'content-type'}, 'application/grpc',
+	'without indexing 2');
+
+$f->{http_start}('/SayHello');
+$f->{data}('Hello');
+$frames = $f->{http_end}(mode => 4);
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}{':status'}, '200', 'without indexing new');
+is($frame->{headers}{'content-type'}, 'application/grpc',
+	'without indexing new 2');
+
+$f->{http_start}('/SayHello');
+$f->{data}('Hello');
+$frames = $f->{http_end}(mode => 5);
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}{':status'}, '200', 'never indexed');
+is($frame->{headers}{'content-type'}, 'application/grpc',
+	'never indexed 2');
+
+$f->{http_start}('/SayHello');
+$f->{data}('Hello');
+$frames = $f->{http_end}(mode => 6);
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}{':status'}, '200', 'never indexed new');
+is($frame->{headers}{'content-type'}, 'application/grpc',
+	'never indexed new 2');
+
+# padding & priority
+
+$f->{http_start}('/SayHello');
+$f->{data}('Hello');
+$frames = $f->{http_end}(padding => 7);
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}{':status'}, '200', 'padding');
+
+$f->{http_start}('/SayHello');
+$f->{data}('Hello');
+$frames = $f->{http_end}(prio => 137, dep => 0x01020304);
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}{':status'}, '200', 'priority');
+
+$f->{http_start}('/SayHello');
+$f->{data}('Hello');
+$frames = $f->{http_end}(padding => 7, prio => 137, dep => 0x01020304);
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}{':status'}, '200', 'padding priority');
+
+SKIP: {
+skip 'long test', 1 unless $ENV{TEST_NGINX_UNSAFE};
+
+$f->{http_start}('/SaySplit');
+$f->{data}('Hello');
+$frames = $f->{http_end}(padding => 7, prio => 137, dep => 0x01020304,
+	split => [(map{1}(1..20)), 30], split_delay => 0.1);
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}{':status'}, '200', 'padding priority split');
+
+}
+
+# grpc error, no empty data frame expected
+
+$f->{http_start}('/SayHello');
+$f->{data}('Hello');
+$frames = $f->{http_err}();
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{flags}, 5, 'grpc error - HEADERS flags');
+($frame) = grep { $_->{type} eq "DATA" } @$frames;
+ok(!$frame, 'grpc error - no DATA frame');
+
+# continuation from backend, expect parts assembled
+
+$f->{http_start}('/SayHello');
+$f->{data}('Hello');
+$frames = $f->{continuation}();
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{flags}, 4, 'continuation - HEADERS flags');
+is($frame->{headers}{':status'}, '200', 'continuation - status');
+is($frame->{headers}{'content-type'}, 'application/grpc',
+	'continuation - content type');
+
+($frame) = grep { $_->{type} eq "DATA" } @$frames;
+is($frame->{data}, 'Hello world', 'continuation - DATA');
+is($frame->{length}, 11, 'continuation - DATA length');
+is($frame->{flags}, 0, 'continuation - DATA flags');
+
+(undef, $frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{flags}, 5, 'continuation - trailers flags');
+is($frame->{headers}{'grpc-message'}, '', 'continuation - trailers message');
+is($frame->{headers}{'grpc-status'}, '0', 'continuation - trailers status');
+
+# continuation from backend, header split
+
+$f->{http_start}('/SayHello');
+$f->{data}('Hello');
+$frames = $f->{http_end}(mode => 6, continuation => [map { 1 } (1 .. 42)]);
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}{':status'}, '200', 'continuation - header split');
+
+# continuation to backend
+
+$frames = $f->{http_start}('/LongHeader?h=' . ('Z' x 31337));
+@$frames = grep { $_->{type} =~ "HEADERS|CONTINUATION" } @$frames;
+is(@$frames, 4, 'continuation - frames');
+
+$frame = shift @$frames;
+is($frame->{type}, 'HEADERS', 'continuation - HEADERS');
+is($frame->{length}, 16384, 'continuation - HEADERS length');
+is($frame->{flags}, 1, 'continuation - HEADERS flags');
+ok($frame->{sid}, 'continuation - HEADERS sid');
+
+$frame = shift @$frames;
+is($frame->{type}, 'CONTINUATION', 'continuation - CONTINUATION');
+is($frame->{length}, 16384, 'continuation - CONTINUATION length');
+is($frame->{flags}, 0, 'continuation - CONTINUATION flags');
+ok($frame->{sid}, 'continuation - CONTINUATION sid');
+
+$frame = shift @$frames;
+is($frame->{type}, 'CONTINUATION', 'continuation - CONTINUATION 2');
+is($frame->{length}, 16384, 'continuation - CONTINUATION 2 length');
+is($frame->{flags}, 0, 'continuation - CONTINUATION 2 flags');
+
+$frame = shift @$frames;
+is($frame->{type}, 'CONTINUATION', 'continuation - CONTINUATION n');
+cmp_ok($frame->{length}, '<', 16384, 'continuation - CONTINUATION n length');
+is($frame->{flags}, 4, 'continuation - CONTINUATION n flags');
+is($frame->{headers}{':path'}, '/LongHeader?h=' . 'Z' x 31337,
+	'continuation - path');
+is($frame->{headers}{'x-longheader'}, 'Z' x 31337, 'continuation - header');
+
+$f->{http_end}();
+
+# long header field
+
+$f->{http_start}('/LongField');
+$f->{data}('Hello');
+$frames = $f->{field_len}(2**7);
+($frame) = grep { $_->{flags} & 0x4 } @$frames;
+is($frame->{headers}{'x' x 2**7}, 'y' x 2**7, 'long header field 1');
+
+$f->{http_start}('/LongField');
+$f->{data}('Hello');
+$frames = $f->{field_len}(2**8);
+($frame) = grep { $_->{flags} & 0x4 } @$frames;
+is($frame->{headers}{'x' x 2**8}, 'y' x 2**8, 'long header field 2');
+
+$f->{http_start}('/LongField');
+$f->{data}('Hello');
+$frames = $f->{field_len}(2**15);
+($frame) = grep { $_->{flags} & 0x4 } @$frames;
+is($frame->{headers}{'x' x 2**15}, 'y' x 2**15, 'long header field 3');
+
+# flow control
+
+$f->{http_start}('/FlowControl');
+$frames = $f->{data_len}(('Hello' x 13000) . ('x' x 550), 65535);
+my $sum = eval join '+', map { $_->{type} eq "DATA" && $_->{length} } @$frames;
+is($sum, 65535, 'flow control - iws length');
+
+$f->{update}(10);
+$f->{update_sid}(10);
+
+$frames = $f->{data_len}(undef, 10);
+($frame) = grep { $_->{type} eq "DATA" } @$frames;
+is($frame->{length}, 10, 'flow control - update length');
+is($frame->{flags}, 0, 'flow control - update flags');
+
+$f->{update_sid}(10);
+$f->{update}(10);
+
+$frames = $f->{data_len}(undef, 5);
+($frame) = grep { $_->{type} eq "DATA" } @$frames;
+is($frame->{length}, 5, 'flow control - rest length');
+is($frame->{flags}, 1, 'flow control - rest flags');
+
+$f->{http_end}();
+
+# preserve output
+
+$f->{http_start}('/Preserve');
+$f->{data}('Hello');
+$frames = $f->{http_pres}();
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{flags}, 4, 'preserve - HEADERS');
+
+my @data = grep { $_->{type} eq "DATA" } @$frames;
+$sum = eval join '+', map { $_->{length} } @data;
+is($sum, 20480, 'preserve - DATA');
+
+(undef, $frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{flags}, 5, 'preserve - trailers');
+
+# DATA padding
+
+$f->{http_start}('/SayPadding');
+$f->{data}('Hello');
+$frames = $f->{http_end}(body_padding => 42);
+($frame) = grep { $_->{type} eq "DATA" } @$frames;
+is($frame->{data}, 'Hello world', 'DATA padding');
+is($frame->{length}, 11, 'DATA padding - length');
+is($frame->{flags}, 0, 'DATA padding - flags');
+
+# :authority inheritance
+
+$frames = $f->{http_start}('/SayHello?if=1');
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}{':authority'}, "127.0.0.1:$p", 'authority in if');
+$f->{data}('Hello');
+$f->{http_end}();
+
+# misc tests
+
+$frames = $f->{http_start}('/SetHost');
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+ok(!$frame->{headers}{':authority'}, 'set host - authority');
+is($frame->{headers}{'host'}, 'custom', 'set host - host');
+$f->{data}('Hello');
+$f->{http_end}();
+
+$frames = $f->{http_start}('/SetArgs?f');
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}{':path'}, '/SetArgs', 'set args');
+$f->{data}('Hello');
+$f->{http_end}();
+
+$frames = $f->{http_start}('/SetArgs?c=1');
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}{':path'}, '/SetArgs?1', 'set args len');
+$f->{data}('Hello');
+$f->{http_end}();
+
+$frames = $f->{http_start}('/SetArgs esc');
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}{':path'}, '/SetArgs%20esc', 'uri escape');
+$f->{data}('Hello');
+$f->{http_end}();
+
+$frames = $f->{http_start}('/');
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}{':path'}, '/', 'root index');
+$f->{data}('Hello');
+$f->{http_end}();
+
+$frames = $f->{http_start}('/', method => 'GET');
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}{':method'}, 'GET', 'method get');
+$f->{data}('Hello');
+$f->{http_end}();
+
+$frames = $f->{http_start}('/', method => 'HEAD');
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}{':method'}, 'HEAD', 'method head');
+$f->{data}('Hello');
+$f->{http_end}();
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.19.0');
+
+# receiving END_STREAM followed by WINDOW_UPDATE on incomplete request body
+
+$f->{http_start}('/Discard_WU');
+$frames = $f->{discard}();
+(undef, $frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{flags}, 5, 'discard WINDOW_UPDATE - trailers');
+
+# receiving END_STREAM followed by RST_STREAM NO_ERROR
+
+$f->{http_start}('/Discard_NE');
+$frames = $f->{discard}();
+(undef, $frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{flags}, 5, 'discard NO_ERROR - trailers');
+
+}
+
+# receiving END_STREAM followed by several RST_STREAM NO_ERROR
+
+$f->{http_start}('/Discard_NE3');
+$frames = $f->{discard}();
+(undef, $frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{flags}, undef, 'discard NO_ERROR many - no trailers');
+
+# receiving END_STREAM followed by RST_STREAM CANCEL
+
+$f->{http_start}('/Discard_CNL');
+$frames = $f->{discard}();
+(undef, $frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{flags}, undef, 'discard CANCEL - no trailers');
+
+###############################################################################
+
+sub grpc {
+	my ($server, $client, $f, $s, $c, $sid, $csid, $uri);
+	my $n = 0;
+
+	$server = IO::Socket::INET->new(
+		Proto => 'tcp',
+		LocalHost => '127.0.0.1',
+		LocalPort => $p,
+		Listen => 5,
+		Reuse => 1
+	)
+		or die "Can't create listening socket: $!\n";
+
+	$f->{http_start} = sub {
+		($uri, my %extra) = @_;
+		my $body_more = 1 if $uri !~ /LongHeader/;
+		my $meth = $extra{method} || 'POST';
+		$s = Test::Nginx::HTTP2->new() if !defined $s;
+		$csid = $s->new_stream({ body_more => $body_more, headers => [
+			{ name => ':method', value => $meth, mode => !!$meth },
+			{ name => ':scheme', value => 'http', mode => 0 },
+			{ name => ':path', value => $uri, },
+			{ name => ':authority', value => 'localhost' },
+			{ name => 'content-type', value => 'application/grpc' },
+			{ name => 'te', value => 'trailers', mode => 2 }]});
+
+		if (!$extra{reuse}) {
+			eval {
+				local $SIG{ALRM} = sub { die "timeout\n" };
+				alarm(5);
+
+				$client = $server->accept() or return;
+
+				alarm(0);
+			};
+			alarm(0);
+			if ($@) {
+				log_in("died: $@");
+				return undef;
+			}
+
+			log2c("(new connection $client)");
+			$n++;
+
+			$client->sysread(my $buf, 24) == 24 or return; # preface
+
+			$c = Test::Nginx::HTTP2->new(1, socket => $client,
+				pure => 1, preface => "") or return;
+		}
+
+		my $frames = $c->read(all => [{ fin => 4 }]);
+
+		if (!$extra{reuse}) {
+			$c->h2_settings(0);
+			$c->h2_settings(1);
+		}
+
+		my ($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+		$sid = $frame->{sid};
+		return $frames;
+	};
+	$f->{data} = sub {
+		my ($body, %extra) = @_;
+		$s->h2_body($body, { %extra });
+		return $c->read(all => [{ sid => $sid,
+			length => length($body) }]);
+	};
+	$f->{data_len} = sub {
+		my ($body, $len) = @_;
+		$s->h2_body($body) if defined $body;
+		return $c->read(all => [{ sid => $sid, length => $len }]);
+	};
+	$f->{update} = sub {
+		$c->h2_window(shift);
+	};
+	$f->{update_sid} = sub {
+		$c->h2_window(shift, $sid);
+	};
+	$f->{settings} = sub {
+		$c->h2_settings(@_);
+	};
+	$f->{http_end} = sub {
+		my (%extra) = @_;
+		$c->new_stream({ body_more => 1, %extra, headers => [
+			{ name => ':status', value => '200',
+				mode => $extra{mode} || 0 },
+			{ name => 'content-type', value => 'application/grpc',
+				mode => $extra{mode} || 1, huff => 1 },
+			{ name => 'x-connection', value => $n,
+				mode => 2, huff => 1 },
+		]}, $sid);
+		$c->h2_body('Hello world', { body_more => 1,
+			body_padding => $extra{body_padding} });
+		$c->new_stream({ headers => [
+			{ name => 'grpc-status', value => '0',
+				mode => 2, huff => 1 },
+			{ name => 'grpc-message', value => '',
+				mode => 2, huff => 1 },
+		]}, $sid);
+
+		return $s->read(all => [{ fin => 1 }]);
+	};
+	$f->{http_pres} = sub {
+		my (%extra) = @_;
+		$s->h2_settings(0, 0x4 => 8192);
+		$c->new_stream({ body_more => 1, %extra, headers => [
+			{ name => ':status', value => '200',
+				mode => $extra{mode} || 0 },
+			{ name => 'content-type', value => 'application/grpc',
+				mode => $extra{mode} || 1, huff => 1 },
+			{ name => 'x-connection', value => $n,
+				mode => 2, huff => 1 },
+		]}, $sid);
+		for (1 .. 20) {
+			$c->h2_body(sprintf('Hello %02d', $_) x 128, {
+				body_more => 1,
+				body_padding => $extra{body_padding} });
+			$c->h2_ping("PING");
+		}
+		# reopen window
+		$s->h2_window(2**24);
+		$s->h2_window(2**24, $csid);
+		$c->new_stream({ headers => [
+			{ name => 'grpc-status', value => '0',
+				mode => 2, huff => 1 },
+			{ name => 'grpc-message', value => '',
+				mode => 2, huff => 1 },
+		]}, $sid);
+
+		return $s->read(all => [{ sid => $csid, fin => 1 }]);
+	};
+	$f->{http_err} = sub {
+		$c->new_stream({ headers => [
+			{ name => ':status', value => '200', mode => 0 },
+			{ name => 'content-type', value => 'application/grpc',
+				mode => 1, huff => 1 },
+			{ name => 'grpc-status', value => '12',
+				mode => 2, huff => 1 },
+			{ name => 'grpc-message', value => 'unknown service',
+				mode => 2, huff => 1 },
+		]}, $sid);
+
+		return $s->read(all => [{ fin => 1 }]);
+	};
+	$f->{continuation} = sub {
+		$c->new_stream({ continuation => 1, body_more => 1, headers => [
+			{ name => ':status', value => '200', mode => 0 },
+		]}, $sid);
+		$c->h2_continue($sid, { continuation => 1, headers => [
+			{ name => 'content-type', value => 'application/grpc',
+				mode => 1, huff => 1 },
+		]});
+		$c->h2_continue($sid, { headers => [
+			# an empty CONTINUATION frame is legitimate
+		]});
+		$c->h2_body('Hello world', { body_more => 1 });
+		$c->new_stream({ continuation => 1, headers => [
+			{ name => 'grpc-status', value => '0',
+				mode => 2, huff => 1 },
+		]}, $sid);
+		$c->h2_continue($sid, { headers => [
+			{ name => 'grpc-message', value => '',
+				mode => 2, huff => 1 },
+		]});
+
+		return $s->read(all => [{ fin => 1 }]);
+	};
+	$f->{field_len} = sub {
+		my ($len) = @_;
+		$c->new_stream({ continuation => [map {2**14} (0..$len/2**13)],
+			body_more => 1, headers => [
+			{ name => ':status', value => '200', mode => 0 },
+			{ name => 'content-type', value => 'application/grpc',
+				mode => 1, huff => 1 },
+			{ name => 'x' x $len, value => 'y' x $len, mode => 6 },
+		]}, $sid);
+		$c->h2_body('Hello world', { body_more => 1 });
+		$c->new_stream({ headers => [
+			{ name => 'grpc-status', value => '0',
+				mode => 2, huff => 1 },
+			{ name => 'grpc-message', value => '',
+				mode => 2, huff => 1 },
+		]}, $sid);
+
+		return $s->read(all => [{ fin => 1 }]);
+	};
+	$f->{discard} = sub {
+		my (%extra) = @_;
+		$c->new_stream({ body_more => 1, %extra, headers => [
+			{ name => ':status', value => '200',
+				mode => $extra{mode} || 0 },
+			{ name => 'content-type', value => 'application/grpc',
+				mode => $extra{mode} || 1, huff => 1 },
+			{ name => 'x-connection', value => $n,
+				mode => 2, huff => 1 },
+		]}, $sid);
+		$c->h2_body('Hello world', { body_more => 1,
+			body_padding => $extra{body_padding} });
+
+		# stick trailers and subsequent frames for reproducibility
+
+		my $fld = $c->hpack('grpc-status', '0', mode => 2);
+		my $trailers = pack("x2CCCN", length($fld), 1, 5, $sid) . $fld;
+		my $window = pack("xxCCCNN", 4, 8, 0, $sid, 42);
+		my $rst = pack("x2C2xNN", 4, 3, $sid, 0);
+		my $cnl = pack("x2C2xNN", 4, 3, $sid, 8);
+
+		$trailers .= $window if $uri eq '/Discard_WU';
+		$trailers .= $rst if $uri eq '/Discard_NE';
+		$trailers .= ($rst x 3) if $uri eq '/Discard_NE3';
+		$trailers .= $cnl if $uri eq '/Discard_CNL';
+		Test::Nginx::HTTP2::raw_write($client, $trailers);
+
+		return $s->read(all => [{ fin => 1 }], wait => 2)
+			if $uri eq '/Discard_WU' || $uri eq '/Discard_NE';
+		return $s->read(all => [{ type => 'RST_STREAM' }]);
+	};
+	return $f;
+}
+
+sub log2i { Test::Nginx::log_core('|| <<', @_); }
+sub log2o { Test::Nginx::log_core('|| >>', @_); }
+sub log2c { Test::Nginx::log_core('||', @_); }
+
+###############################################################################
diff --git a/tests/grpc_next_upstream.t b/tests/grpc_next_upstream.t
new file mode 100644
index 0000000..9b34167
--- /dev/null
+++ b/tests/grpc_next_upstream.t
@@ -0,0 +1,146 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for grpc module, grpc_next_upstream directive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http http_v2 grpc rewrite/)->plan(9);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    upstream u {
+        server 127.0.0.1:8081 max_fails=2;
+        server 127.0.0.1:8082;
+    }
+
+    upstream u2 {
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8082;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            grpc_pass u;
+            grpc_next_upstream http_500 http_404 invalid_header;
+        }
+
+        location /all/ {
+            grpc_pass u2;
+            grpc_next_upstream http_500 http_404;
+            error_page 404 /all/404;
+            grpc_intercept_errors on;
+        }
+
+        location /all/404 {
+            return 200 "$upstream_addr\n";
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081 http2;
+        server_name  localhost;
+
+        location / {
+            return 404;
+        }
+        location /ok {
+            return 200 "AND-THIS\n";
+        }
+        location /500 {
+            return 500;
+        }
+        location /444 {
+            return 444;
+        }
+
+        location /all/ {
+            return 404;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8082 http2;
+        server_name  localhost;
+
+        location / {
+            return 200 "TEST-OK-IF-YOU-SEE-THIS\n";
+        }
+
+        location /all/ {
+            return 404;
+        }
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+my ($p1, $p2) = (port(8081), port(8082));
+
+# check if both request fallback to a backend
+# which returns valid response
+
+like(http_get('/'), qr/SEE-THIS/, 'grpc request');
+like(http_get('/'), qr/SEE-THIS/, 'second request');
+
+# make sure backend isn't switched off after
+# grpc_next_upstream http_404
+
+like(http_get('/ok') . http_get('/ok'), qr/AND-THIS/, 'not down');
+
+# next upstream on invalid_header
+
+like(http_get('/444'), qr/SEE-THIS/, 'request 444');
+like(http_get('/444'), qr/SEE-THIS/, 'request 444 second');
+
+# next upstream on http_500
+
+like(http_get('/500'), qr/SEE-THIS/, 'request 500');
+like(http_get('/500'), qr/SEE-THIS/, 'request 500 second');
+
+# make sure backend switched off with http_500
+
+unlike(http_get('/ok') . http_get('/ok'), qr/AND-THIS/, 'down after 500');
+
+# make sure all backends are tried once
+
+like(http_get('/all/rr'),
+	qr/^127.0.0.1:($p1, 127.0.0.1:$p2|$p2, 127.0.0.1:$p1)$/mi,
+	'all tried once');
+
+###############################################################################
diff --git a/tests/grpc_pass.t b/tests/grpc_pass.t
new file mode 100644
index 0000000..35027de
--- /dev/null
+++ b/tests/grpc_pass.t
@@ -0,0 +1,192 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for the grpc_pass directive with variables.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http http_ssl http_v2 grpc rewrite/)
+	->has_daemon('openssl')->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    upstream u {
+        server 127.0.0.1:8081;
+    }
+
+    resolver 127.0.0.1:%%PORT_8982_UDP%%;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            grpc_pass $host:%%PORT_8081%%;
+        }
+
+        location /grpc {
+            grpc_pass grpc://$host:%%PORT_8081%%;
+        }
+
+        location /grpcs {
+            grpc_pass grpcs://$host:%%PORT_8082%%;
+        }
+
+        location /arg {
+            grpc_pass $arg_b;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081 http2;
+        listen       127.0.0.1:8082 http2 ssl;
+        server_name  localhost;
+
+        ssl_certificate_key localhost.key;
+        ssl_certificate localhost.crt;
+
+        location / {
+            return 200 $http_host;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('localhost') {
+	system('openssl req -x509 -new '
+		. "-config $d/openssl.conf -subj /CN=$name/ "
+		. "-out $d/$name.crt -keyout $d/$name.key "
+		. ">>$d/openssl.out 2>&1") == 0
+		or die "Can't create certificate for $name: $!\n";
+}
+
+$t->run_daemon(\&dns_daemon, port(8982), $t);
+$t->try_run('no grpc_pass variables')->plan(5);
+
+$t->waitforfile($t->testdir . '/' . port(8982));
+
+###############################################################################
+
+like(http_get('/basic'), qr/200 OK/, 'no scheme');
+like(http_get('/grpc'), qr/200 OK/, 'grpc scheme');
+
+SKIP: {
+$t->{_configure_args} =~ /OpenSSL ([\d\.]+)/;
+skip 'OpenSSL too old', 1 unless defined $1 and $1 ge '1.0.2';
+
+like(http_get('/grpcs'), qr/200 OK/, 'grpcs scheme');
+
+}
+
+like(http_get('/arg?b=grpc://127.0.0.1:' . port(8081)), qr/200 OK/, 'addrs');
+like(http_get('/arg?b=grpc://u'), qr/200 OK/, 'no_port');
+
+###############################################################################
+
+sub reply_handler {
+	my ($recv_data) = @_;
+
+	my (@name, @rdata);
+
+	use constant NOERROR	=> 0;
+	use constant A		=> 1;
+	use constant IN		=> 1;
+
+	# default values
+
+	my ($hdr, $rcode, $ttl) = (0x8180, NOERROR, 3600);
+
+	# decode name
+
+	my ($len, $offset) = (undef, 12);
+	while (1) {
+		$len = unpack("\@$offset C", $recv_data);
+		last if $len == 0;
+		$offset++;
+		push @name, unpack("\@$offset A$len", $recv_data);
+		$offset += $len;
+	}
+
+	$offset -= 1;
+	my ($id, $type, $class) = unpack("n x$offset n2", $recv_data);
+
+	my $name = join('.', @name);
+	if ($name eq 'localhost' && $type == A) {
+		push @rdata, rd_addr($ttl, '127.0.0.1');
+	}
+
+	$len = @name;
+	pack("n6 (C/a*)$len x n2", $id, $hdr | $rcode, 1, scalar @rdata,
+		0, 0, @name, $type, $class) . join('', @rdata);
+}
+
+sub rd_addr {
+	my ($ttl, $addr) = @_;
+
+	my $code = 'split(/\./, $addr)';
+
+	return pack 'n3N', 0xc00c, A, IN, $ttl if $addr eq '';
+
+	pack 'n3N nC4', 0xc00c, A, IN, $ttl, eval "scalar $code", eval($code);
+}
+
+sub dns_daemon {
+	my ($port, $t) = @_;
+
+	my ($data, $recv_data);
+	my $socket = IO::Socket::INET->new(
+		LocalAddr => '127.0.0.1',
+		LocalPort => $port,
+		Proto => 'udp',
+	)
+		or die "Can't create listening socket: $!\n";
+
+	# signal we are ready
+
+	open my $fh, '>', $t->testdir() . '/' . $port;
+	close $fh;
+
+	while (1) {
+		$socket->recv($recv_data, 65536);
+		$data = reply_handler($recv_data);
+		$socket->send($data);
+	}
+}
+
+###############################################################################
diff --git a/tests/grpc_request_buffering.t b/tests/grpc_request_buffering.t
new file mode 100644
index 0000000..3cb7021
--- /dev/null
+++ b/tests/grpc_request_buffering.t
@@ -0,0 +1,196 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for grpc module, request body buffered.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::HTTP2;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http http_v2 grpc mirror proxy/)->plan(12);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080 http2;
+        listen       127.0.0.1:8082;
+        server_name  localhost;
+
+        location /mirror { }
+
+        location / {
+            grpc_pass 127.0.0.1:8081;
+            add_header X-Body $request_body;
+            mirror /mirror;
+        }
+
+        location /proxy {
+            proxy_pass http://127.0.0.1:8082/mirror;
+            proxy_intercept_errors on;
+            error_page 404 = @fallback;
+        }
+
+        location @fallback {
+            grpc_pass 127.0.0.1:8081;
+        }
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+my $p = port(8081);
+my $f = grpc();
+
+my $frames = $f->{http_start}('/SayHello');
+my ($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{flags}, 4, 'request - HEADERS flags');
+is($frame->{headers}{':method'}, 'POST', 'request - method');
+is($frame->{headers}{':scheme'}, 'http', 'request - scheme');
+is($frame->{headers}{':path'}, '/SayHello', 'request - path');
+is($frame->{headers}{':authority'}, "127.0.0.1:$p", 'request - authority');
+
+($frame) = grep { $_->{type} eq "DATA" } @$frames;
+is($frame->{data}, 'Hello', 'request - DATA');
+is($frame->{length}, 5, 'request - DATA length');
+is($frame->{flags}, 1, 'request - DATA flags');
+
+$frames = $f->{http_end}();
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}{'x-body'}, 'Hello', 'request body in memory');
+
+# tcp_nopush usage on peer connections
+# reopen window for request body after initial window was exhausted
+
+$frames = $f->{http_start}('/proxy');
+is(eval(join '+', map { $_->{length} } grep { $_->{type} eq "DATA" } @$frames),
+	65535, 'preserve_output - first body bytes');
+
+# expect body cleanup is disabled with preserve_output (ticket #1565).
+# after request body first bytes were proxied on behalf of initial window size,
+# send response header from upstream, this leads to body cleanup code path
+
+$frames = $f->{http_end}();
+is(eval(join '+', map { $_->{length} } grep { $_->{type} eq "DATA" } @$frames),
+	465, 'preserve_output - last body bytes');
+
+like(`grep -F '[crit]' ${\($t->testdir())}/error.log`, qr/^$/s, 'no crits');
+
+###############################################################################
+
+sub grpc {
+	my ($server, $client, $f, $s, $c, $sid, $uri);
+
+	$server = IO::Socket::INET->new(
+		Proto => 'tcp',
+		LocalHost => '127.0.0.1',
+		LocalPort => $p,
+		Listen => 5,
+		Reuse => 1
+	)
+		or die "Can't create listening socket: $!\n";
+
+	$f->{http_start} = sub {
+		($uri, my %extra) = @_;
+		$s = Test::Nginx::HTTP2->new() if !defined $s;
+		my ($body) = $uri eq '/proxy' ? 'Hello' x 13200 : 'Hello';
+		$s->new_stream({ body => $body, headers => [
+			{ name => ':method', value => 'POST', mode => 0 },
+			{ name => ':scheme', value => 'http', mode => 0 },
+			{ name => ':path', value => $uri },
+			{ name => ':authority', value => 'localhost' },
+			{ name => 'content-length', value => length($body) }]});
+
+		if (!$extra{reuse}) {
+			eval {
+				local $SIG{ALRM} = sub { die "timeout\n" };
+				alarm(5);
+
+				$client = $server->accept() or return;
+
+				alarm(0);
+			};
+			alarm(0);
+			if ($@) {
+				log_in("died: $@");
+				return undef;
+			}
+
+			log2c("(new connection $client)");
+
+			$client->sysread(my $buf, 24) == 24 or return; # preface
+
+			$c = Test::Nginx::HTTP2->new(1, socket => $client,
+				pure => 1, preface => "") or return;
+		}
+
+		my $frames = $uri eq '/proxy'
+			? $c->read(all => [{ length => 65535 }])
+			: $c->read(all => [{ fin => 1 }]);
+
+		if (!$extra{reuse}) {
+			$c->h2_settings(0);
+			$c->h2_settings(1);
+		}
+
+		my ($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+		$sid = $frame->{sid};
+		return $frames;
+	};
+	$f->{http_end} = sub {
+		$c->new_stream({ body_more => 1, headers => [
+			{ name => ':status', value => '200', mode => 0 },
+			{ name => 'content-type', value => 'application/grpc' },
+		]}, $sid);
+
+		# reopen window for request body after response HEADERS is sent
+
+		if ($uri eq '/proxy') {
+			$c->h2_window(2**16, $sid);
+			$c->h2_window(2**16);
+			return $c->read(all => [{ sid => $sid, fin => 1 }]);
+		}
+
+		$c->h2_body('Hello world', { body_more => 1 });
+		$c->new_stream({ headers => [
+			{ name => 'grpc-status', value => '0', mode => 2 },
+			{ name => 'grpc-message', value => '', mode => 2 },
+		]}, $sid);
+
+		return $s->read(all => [{ fin => 1 }]);
+	};
+	return $f;
+}
+
+sub log2c { Test::Nginx::log_core('||', @_); }
+
+###############################################################################
diff --git a/tests/grpc_ssl.t b/tests/grpc_ssl.t
new file mode 100644
index 0000000..41bac32
--- /dev/null
+++ b/tests/grpc_ssl.t
@@ -0,0 +1,303 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for grpc backend with ssl.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::HTTP2;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http rewrite http_v2 grpc/)
+	->has(qw/upstream_keepalive http_ssl/)->has_daemon('openssl');
+
+$t->{_configure_args} =~ /OpenSSL ([\d\.]+)/;
+plan(skip_all => 'OpenSSL too old') unless defined $1 and $1 ge '1.0.2';
+
+$t->write_file_expand('nginx.conf', <<'EOF')->plan(33);
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    upstream u {
+        server 127.0.0.1:8081;
+        keepalive 1;
+    }
+
+    server {
+        listen       127.0.0.1:8081 http2 ssl;
+        server_name  localhost;
+
+        ssl_certificate_key localhost.key;
+        ssl_certificate localhost.crt;
+
+        ssl_verify_client optional;
+        ssl_client_certificate client.crt;
+
+        http2_max_field_size 128k;
+        http2_max_header_size 128k;
+        http2_body_preread_size 128k;
+
+        location / {
+            grpc_pass 127.0.0.1:8082;
+            add_header X-Connection $connection;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8080 http2;
+        server_name  localhost;
+
+        http2_max_field_size 128k;
+        http2_max_header_size 128k;
+        http2_body_preread_size 128k;
+
+        location / {
+            grpc_pass grpcs://127.0.0.1:8081;
+            grpc_ssl_name localhost;
+            grpc_ssl_verify on;
+            grpc_ssl_trusted_certificate localhost.crt;
+
+            grpc_ssl_certificate client.crt;
+            grpc_ssl_certificate_key client.key;
+            grpc_ssl_password_file password;
+
+            if ($arg_if) {
+                # nothing
+            }
+
+            limit_except GET {
+                # nothing
+            }
+        }
+
+        location /KeepAlive {
+            grpc_pass grpcs://u;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('localhost') {
+	system('openssl req -x509 -new '
+		. "-config $d/openssl.conf -subj /CN=$name/ "
+		. "-out $d/$name.crt -keyout $d/$name.key "
+		. ">>$d/openssl.out 2>&1") == 0
+		or die "Can't create certificate for $name: $!\n";
+}
+
+foreach my $name ('client') {
+	system("openssl genrsa -out $d/$name.key -passout pass:$name "
+		. "-aes128 2048 >>$d/openssl.out 2>&1") == 0
+		or die "Can't create private key: $!\n";
+	system('openssl req -x509 -new '
+		. "-config $d/openssl.conf -subj /CN=$name/ "
+		. "-out $d/$name.crt "
+		. "-key $d/$name.key -passin pass:$name"
+		. ">>$d/openssl.out 2>&1") == 0
+		or die "Can't create certificate for $name: $!\n";
+}
+
+sleep 1 if $^O eq 'MSWin32';
+
+$t->write_file('password', 'client');
+
+$t->run();
+
+###############################################################################
+
+my $p = port(8082);
+my $f = grpc();
+
+my $frames = $f->{http_start}('/SayHello');
+my ($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{flags}, 4, 'request - HEADERS flags');
+ok((my $sid = $frame->{sid}) % 2, 'request - HEADERS sid odd');
+is($frame->{headers}{':method'}, 'POST', 'request - method');
+is($frame->{headers}{':scheme'}, 'http', 'request - scheme');
+is($frame->{headers}{':path'}, '/SayHello', 'request - path');
+is($frame->{headers}{':authority'}, "127.0.0.1:$p", 'request - authority');
+is($frame->{headers}{'content-type'}, 'application/grpc',
+	'request - content type');
+is($frame->{headers}{te}, 'trailers', 'request - te');
+
+$frames = $f->{data}('Hello');
+($frame) = grep { $_->{type} eq "SETTINGS" } @$frames;
+is($frame->{flags}, 1, 'request - SETTINGS ack');
+is($frame->{sid}, 0, 'request - SETTINGS sid');
+is($frame->{length}, 0, 'request - SETTINGS length');
+
+($frame) = grep { $_->{type} eq "DATA" } @$frames;
+is($frame->{data}, 'Hello', 'request - DATA');
+is($frame->{length}, 5, 'request - DATA length');
+is($frame->{flags}, 1, 'request - DATA flags');
+is($frame->{sid}, $sid, 'request - DATA sid match');
+
+$frames = $f->{http_end}();
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{flags}, 4, 'response - HEADERS flags');
+is($frame->{sid}, 1, 'response - HEADERS sid');
+is($frame->{headers}{':status'}, '200', 'response - status');
+is($frame->{headers}{'content-type'}, 'application/grpc',
+	'response - content type');
+ok($frame->{headers}{server}, 'response - server');
+ok($frame->{headers}{date}, 'response - date');
+ok(my $c = $frame->{headers}{'x-connection'}, 'response - connection');
+
+($frame) = grep { $_->{type} eq "DATA" } @$frames;
+is($frame->{data}, 'Hello world', 'response - DATA');
+is($frame->{length}, 11, 'response - DATA length');
+is($frame->{flags}, 0, 'response - DATA flags');
+is($frame->{sid}, 1, 'response - DATA sid');
+
+(undef, $frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{flags}, 5, 'response - trailers flags');
+is($frame->{sid}, 1, 'response - trailers sid');
+is($frame->{headers}{'grpc-message'}, '', 'response - trailers message');
+is($frame->{headers}{'grpc-status'}, '0', 'response - trailers status');
+
+# next request is on a new backend connection, no sid incremented
+
+$f->{http_start}('/SayHello');
+$f->{data}('Hello');
+$frames = $f->{http_end}();
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+cmp_ok($frame->{headers}{'x-connection'}, '>', $c, 'response 2 - connection');
+
+# upstream keepalive
+
+$f->{http_start}('/KeepAlive');
+$f->{data}('Hello');
+$frames = $f->{http_end}();
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+ok($c = $frame->{headers}{'x-connection'}, 'keepalive - connection');
+
+$f->{http_start}('/KeepAlive');
+$f->{data}('Hello');
+$frames = $f->{http_end}();
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}{'x-connection'}, $c, 'keepalive - connection reuse');
+
+###############################################################################
+
+sub grpc {
+	my ($server, $client, $f, $s, $c, $sid, $uri);
+
+	$server = IO::Socket::INET->new(
+		Proto => 'tcp',
+		LocalHost => '127.0.0.1',
+		LocalPort => $p,
+		Listen => 5,
+		Reuse => 1
+	)
+		or die "Can't create listening socket: $!\n";
+
+	$f->{http_start} = sub {
+		($uri, my %extra) = @_;
+		my $body_more = 1 if $uri !~ /LongHeader/;
+		$s = Test::Nginx::HTTP2->new() if !defined $s;
+		$s->new_stream({ body_more => $body_more, headers => [
+			{ name => ':method', value => 'POST', mode => 0 },
+			{ name => ':scheme', value => 'http', mode => 0 },
+			{ name => ':path', value => $uri, },
+			{ name => ':authority', value => 'localhost' },
+			{ name => 'content-type', value => 'application/grpc' },
+			{ name => 'te', value => 'trailers', mode => 2 }]});
+
+		if (!$extra{reuse}) {
+			eval {
+				local $SIG{ALRM} = sub { die "timeout\n" };
+				alarm(5);
+
+				$client = $server->accept() or return;
+
+				alarm(0);
+			};
+			alarm(0);
+			if ($@) {
+				log_in("died: $@");
+				return undef;
+			}
+
+			log2c("(new connection $client)");
+
+			$client->sysread(my $buf, 24) == 24 or return; # preface
+
+			$c = Test::Nginx::HTTP2->new(1, socket => $client,
+				pure => 1, preface => "") or return;
+		}
+
+		my $frames = $c->read(all => [{ fin => 4 }]);
+
+		if (!$extra{reuse}) {
+			$c->h2_settings(0);
+			$c->h2_settings(1);
+		}
+
+		my ($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+		$sid = $frame->{sid};
+		return $frames;
+	};
+	$f->{data} = sub {
+		my ($body, %extra) = @_;
+		$s->h2_body($body, { %extra });
+		return $c->read(all => [{ sid => $sid,
+			length => length($body) }]);
+	};
+	$f->{http_end} = sub {
+		$c->new_stream({ body_more => 1, headers => [
+			{ name => ':status', value => '200', mode => 0 },
+			{ name => 'content-type', value => 'application/grpc',
+				mode => 1, huff => 1 },
+		]}, $sid);
+		$c->h2_body('Hello world', { body_more => 1 });
+		$c->new_stream({ headers => [
+			{ name => 'grpc-status', value => '0',
+				mode => 2, huff => 1 },
+			{ name => 'grpc-message', value => '',
+				mode => 2, huff => 1 },
+		]}, $sid);
+
+		return $s->read(all => [{ fin => 1 }]);
+	};
+	return $f;
+}
+
+sub log2i { Test::Nginx::log_core('|| <<', @_); }
+sub log2o { Test::Nginx::log_core('|| >>', @_); }
+sub log2c { Test::Nginx::log_core('||', @_); }
+
+###############################################################################
diff --git a/tests/gunzip.t b/tests/gunzip.t
new file mode 100644
index 0000000..641e076
--- /dev/null
+++ b/tests/gunzip.t
@@ -0,0 +1,114 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for gunzip filter module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx qw/ :DEFAULT :gzip /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require IO::Compress::Gzip; };
+plan(skip_all => "IO::Compress::Gzip not found") if $@;
+
+my $t = Test::Nginx->new()->has(qw/http gunzip proxy gzip_static rewrite/)
+	->plan(13);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+        location / {
+            gunzip on;
+            gzip_vary on;
+            proxy_pass http://127.0.0.1:8081/;
+            proxy_set_header Accept-Encoding gzip;
+        }
+        location /error {
+            error_page 500 /t1;
+            return 500;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location / {
+            default_type text/plain;
+            gzip_static on;
+            gzip_http_version 1.0;
+            gzip_types text/plain;
+        }
+    }
+}
+
+EOF
+
+my $in = join('', map { sprintf "X%03dXXXXXX", $_ } (0 .. 99));
+my $out;
+
+IO::Compress::Gzip::gzip(\$in => \$out);
+
+$t->write_file('t1.gz', $out);
+$t->write_file('t2.gz', $out . $out);
+$t->write_file('t3', 'not compressed');
+
+my $emptyin = '';
+my $emptyout;
+IO::Compress::Gzip::gzip(\$emptyin => \$emptyout);
+
+$t->write_file('empty.gz', $emptyout);
+
+$t->run();
+
+###############################################################################
+
+pass('runs');
+
+my $r = http_get('/t1');
+unlike($r, qr/Content-Encoding/, 'no content encoding');
+like($r, qr/^(X\d\d\dXXXXXX){100}$/m, 'correct gunzipped response');
+
+$r = http_gzip_request('/t1');
+like($r, qr/Content-Encoding: gzip/, 'gzip still works - encoding');
+like($r, qr/\Q$out\E/, 'gzip still works - content');
+
+like(http_get('/t2'), qr/^(X\d\d\dXXXXXX){200}$/m, 'multiple gzip members');
+
+like(http_get('/error'), qr/^(X\d\d\dXXXXXX){100}$/m, 'errors gunzipped');
+
+unlike(http_head('/t1'), qr/Content-Encoding/, 'head - no content encoding');
+
+like(http_get('/t1'), qr/Vary/, 'get vary');
+like(http_head('/t1'), qr/Vary/, 'head vary');
+unlike(http_get('/t3'), qr/Vary/, 'no vary on non-gzipped get');
+unlike(http_head('/t3'), qr/Vary/, 'no vary on non-gzipped head');
+
+like(http_get('/empty'), qr/ 200 /, 'gunzip empty');
+
+###############################################################################
diff --git a/tests/gunzip_memcached.t b/tests/gunzip_memcached.t
new file mode 100644
index 0000000..f651e45
--- /dev/null
+++ b/tests/gunzip_memcached.t
@@ -0,0 +1,92 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for gunzip filter module with memcached.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx qw/ :DEFAULT :gzip /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require Cache::Memcached; };
+plan(skip_all => 'Cache::Memcached not installed') if $@;
+
+eval { require IO::Compress::Gzip; };
+plan(skip_all => "IO::Compress::Gzip not found") if $@;
+
+my $t = Test::Nginx->new()->has(qw/http gunzip memcached rewrite/)
+	->has_daemon('memcached')
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        gunzip on;
+
+        location / {
+            set $memcached_key $uri;
+            memcached_pass 127.0.0.1:8081;
+            memcached_gzip_flag 2;
+        }
+    }
+}
+
+EOF
+
+my $memhelp = `memcached -h`;
+my @memopts = ();
+
+if ($memhelp =~ /repcached/) {
+	# repcached patch adds additional listen socket
+	push @memopts, '-X', port(8082);
+}
+if ($memhelp =~ /-U/) {
+	# UDP port is on by default in memcached 1.2.7+
+	push @memopts, '-U', '0';
+}
+
+$t->run_daemon('memcached', '-l', '127.0.0.1', '-p', port(8081), @memopts);
+
+$t->run()->plan(2);
+
+$t->waitforsocket('127.0.0.1:' . port(8081))
+	or die "Can't start memcached";
+
+# Put compressed value into memcached.  This requires compress_threshold to be
+# set and compressed value to be at least 20% less than original one.
+
+my $memd = Cache::Memcached->new(servers => [ '127.0.0.1:' . port(8081) ],
+	compress_threshold => 1, connect_timeout => 1.0);
+$memd->set('/', 'TEST' x 10)
+	or die "can't put value into memcached: $!";
+
+###############################################################################
+
+http_gzip_like(http_gzip_request('/'), qr/TEST/, 'memcached response gzipped');
+like(http_get('/'), qr/TEST/, 'memcached response gunzipped');
+
+###############################################################################
diff --git a/tests/gunzip_perl.t b/tests/gunzip_perl.t
new file mode 100644
index 0000000..64462bd
--- /dev/null
+++ b/tests/gunzip_perl.t
@@ -0,0 +1,72 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for gunzip filter module with perl module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx qw/ :DEFAULT :gzip /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require IO::Compress::Gzip; };
+plan(skip_all => "IO::Compress::Gzip not found") if $@;
+
+my $t = Test::Nginx->new()->has(qw/http gunzip perl/)->plan(2)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        gunzip on;
+
+        location / {
+            perl 'sub {
+                my $r = shift;
+                $r->header_out("Content-Encoding", "gzip");
+                $r->send_http_header("text/plain");
+                return OK if $r->header_only;
+                use IO::Compress::Gzip;
+                my $in = "TEST";
+                my $out;
+                IO::Compress::Gzip::gzip(\\$in => \\$out);
+                $r->print($out);
+                return OK;
+            }';
+        }
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+http_gzip_like(http_gzip_request('/'), qr/TEST/, 'perl response gzipped');
+like(http_get('/'), qr/TEST/, 'perl response gunzipped');
+
+###############################################################################
diff --git a/tests/gunzip_ssi.t b/tests/gunzip_ssi.t
new file mode 100644
index 0000000..d3f5d03
--- /dev/null
+++ b/tests/gunzip_ssi.t
@@ -0,0 +1,93 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for gunzip filter module with subrequests.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx qw/ :DEFAULT :gzip /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require IO::Compress::Gzip; };
+plan(skip_all => "IO::Compress::Gzip not found") if $@;
+
+my $t = Test::Nginx->new()->has(qw/http gunzip ssi proxy gzip_static/)
+	->plan(4);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            gunzip on;
+            gzip_vary on;
+            proxy_pass http://127.0.0.1:8081/;
+            proxy_set_header Accept-Encoding gzip;
+        }
+
+        location /t.html {
+            ssi on;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location / {
+            default_type text/plain;
+            gzip_static on;
+            gzip_http_version 1.0;
+            gzip_types text/plain;
+        }
+    }
+}
+
+EOF
+
+my $in = join('', map { sprintf "X%03dXXXXXX", $_ } (0 .. 99));
+my $out;
+
+IO::Compress::Gzip::gzip(\$in => \$out);
+
+$t->write_file('t1.gz', $out);
+$t->write_file('t.html', 'xxx <!--#include virtual="/t1" --> xxx');
+
+$t->run();
+
+###############################################################################
+
+my $r = http_get('/t.html');
+unlike($r, qr/Content-Encoding/, 'no content encoding');
+like($r, qr/^xxx (X\d\d\dXXXXXX){100} xxx$/m, 'correct gunzipped response');
+
+$r = http_gzip_request('/t.html');
+unlike($r, qr/Content-Encoding/, 'gzip - no content encoding');
+like($r, qr/(X\d\d\dXXXXXX){100}/m, 'gzip - correct gunzipped response');
+
+###############################################################################
diff --git a/tests/gunzip_static.t b/tests/gunzip_static.t
new file mode 100644
index 0000000..4104609
--- /dev/null
+++ b/tests/gunzip_static.t
@@ -0,0 +1,104 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for gunzip filter module with gzip_static always.  It is basically
+# the copy of gunzip.t with minor modifications.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx qw/ :DEFAULT :gzip /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require IO::Compress::Gzip; };
+plan(skip_all => "IO::Compress::Gzip not found") if $@;
+
+my $t = Test::Nginx->new()->has(qw/http gunzip gzip_static rewrite/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+        location / {
+            gunzip on;
+            gzip_vary on;
+            gzip_static always;
+        }
+        location = /double {
+            error_page 404 @double;
+            gzip_static on;
+        }
+        location @double {
+            rewrite ^ /t1 break;
+            gunzip on;
+            gzip_static always;
+        }
+        location /error {
+            error_page 500 /t1;
+            return 500;
+        }
+    }
+}
+
+EOF
+
+my $in = join('', map { sprintf "X%03dXXXXXX", $_ } (0 .. 99));
+my $out;
+
+IO::Compress::Gzip::gzip(\$in => \$out);
+
+$t->write_file('t1.gz', $out);
+$t->write_file('t2.gz', $out . $out);
+$t->write_file('t3', 'not compressed');
+
+$t->run()->plan(12);
+
+###############################################################################
+
+pass('runs');
+
+like(http_get('/t1'), qr/(?!Content-Encoding).*^(X\d\d\dXXXXXX){100}$/m,
+	'correct gunzipped response');
+like(http_gzip_request('/t1'), qr/Content-Encoding: gzip.*\Q$out\E/ms,
+	'gzip still works');
+
+like(http_get('/double'), qr/(?!Content-Encoding).^(X\d\d\dXXXXXX){100}$/ms,
+	'gunzip with gzip_tested');
+like(http_gzip_request('/double'), qr/Content-Encoding: gzip.*\Q$out\E/ms,
+	'gzip still works with gzip_tested');
+
+like(http_get('/t2'), qr/^(X\d\d\dXXXXXX){200}$/m, 'multiple gzip members');
+
+like(http_get('/error'), qr/^(X\d\d\dXXXXXX){100}$/m, 'errors gunzipped');
+
+unlike(http_head('/t1'), qr/Content-Encoding/, 'head - no content encoding');
+
+like(http_get('/t1'), qr/Vary/, 'get vary');
+like(http_head('/t1'), qr/Vary/, 'head vary');
+unlike(http_get('/t3'), qr/Vary/, 'no vary on non-gzipped get');
+unlike(http_head('/t3'), qr/Vary/, 'no vary on non-gzipped head');
+
+###############################################################################
diff --git a/tests/gzip.t b/tests/gzip.t
new file mode 100644
index 0000000..c720faa
--- /dev/null
+++ b/tests/gzip.t
@@ -0,0 +1,97 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for nginx gzip filter module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx qw/ :DEFAULT :gzip /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy gzip/)->plan(8);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+        location / {
+            gzip on;
+        }
+        location /proxy/ {
+            gzip on;
+            proxy_pass http://127.0.0.1:8080/local/;
+        }
+        location /local/ {
+            gzip off;
+            alias %%TESTDIR%%/;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('index.html', 'X' x 64);
+
+$t->run();
+
+###############################################################################
+
+my $r;
+
+$r = http_gzip_request('/');
+like($r, qr/^Content-Encoding: gzip/m, 'gzip');
+http_gzip_like($r, qr/^X{64}\Z/, 'gzip content correct');
+
+$r = http_gzip_request('/proxy/');
+like($r, qr/^Content-Encoding: gzip/m, 'gzip proxied');
+http_gzip_like($r, qr/^X{64}\Z/, 'gzip proxied content');
+
+# Accept-Ranges headers should be cleared
+
+unlike(http_gzip_request('/'), qr/Accept-Ranges/im, 'cleared accept-ranges');
+unlike(http_gzip_request('/proxy/'), qr/Accept-Ranges/im,
+	'cleared headers from proxy');
+
+# HEAD requests should return correct headers
+
+like(http_gzip_head('/'), qr/Content-Encoding: gzip/, 'gzip head');
+unlike(http_head('/'), qr/Content-Encoding: gzip/, 'no gzip head');
+
+###############################################################################
+
+sub http_gzip_head {
+	my ($uri) = @_;
+	return http(<<EOF);
+HEAD $uri HTTP/1.1
+Host: localhost
+Connection: close
+Accept-Encoding: gzip
+
+EOF
+}
+
+###############################################################################
diff --git a/tests/gzip_flush.t b/tests/gzip_flush.t
new file mode 100644
index 0000000..4bf77b7
--- /dev/null
+++ b/tests/gzip_flush.t
@@ -0,0 +1,72 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for gzip filter module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx qw/ :DEFAULT :gzip /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http gzip perl/)->plan(2)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        gzip on;
+        gzip_min_length 0;
+
+        location / {
+            perl 'sub {
+                my $r = shift;
+                $r->send_http_header("text/html");
+                return OK if $r->header_only;
+                $r->print("DA");
+                $r->flush();
+                $r->flush();
+                $r->print("TA");
+                return OK;
+            }';
+        }
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+like(http_get('/'), qr/DATA/, 'request with flush');
+
+# gzip filter wasn't able to handle empty flush buffers, see
+# http://nginx.org/pipermail/nginx/2010-November/023693.html
+
+http_gzip_like(http_gzip_request('/'), qr/DATA/, 'gzip request with flush');
+
+###############################################################################
diff --git a/tests/h2.t b/tests/h2.t
new file mode 100644
index 0000000..365eda8
--- /dev/null
+++ b/tests/h2.t
@@ -0,0 +1,1232 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for HTTP/2 protocol [RFC7540].
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::HTTP2;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http http_v2 proxy rewrite charset gzip/)
+	->plan(150);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080 http2;
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location / {
+            add_header X-Header X-Foo;
+            add_header X-Sent-Foo $http_x_foo;
+            add_header X-Referer $http_referer;
+            return 200 'body';
+        }
+        location /t {
+        }
+        location /gzip.html {
+            gzip on;
+            gzip_min_length 0;
+            gzip_vary on;
+            alias %%TESTDIR%%/t2.html;
+        }
+        location /frame_size {
+            http2_chunk_size 64k;
+            alias %%TESTDIR%%;
+            output_buffers 2 1m;
+        }
+        location /chunk_size {
+            http2_chunk_size 1;
+            return 200 'body';
+        }
+        location /redirect {
+            error_page 405 /;
+            return 405;
+        }
+        location /return301 {
+            return 301;
+        }
+        location /return301_absolute {
+            return 301 text;
+        }
+        location /return301_relative {
+            return 301 /;
+        }
+        location /charset {
+            charset utf-8;
+            return 200;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8082 http2;
+        server_name  localhost;
+        return 200   first;
+    }
+
+    server {
+        listen       127.0.0.1:8082 http2;
+        server_name  localhost2;
+        return 200   second;
+    }
+
+    server {
+        listen       127.0.0.1:8083 http2;
+        server_name  localhost;
+
+        http2_max_concurrent_streams 1;
+    }
+
+    server {
+        listen       127.0.0.1:8084 http2;
+        server_name  localhost;
+
+        http2_recv_timeout 1s;
+        client_header_timeout 1s;
+        send_timeout 1s;
+    }
+
+    server {
+        listen       127.0.0.1:8085 http2;
+        server_name  localhost;
+
+        http2_idle_timeout 1s;
+        client_body_timeout 1s;
+
+        location /proxy2/ {
+            add_header X-Body $request_body;
+            proxy_pass http://127.0.0.1:8081/;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8086 http2;
+        server_name  localhost;
+
+        send_timeout 1s;
+    }
+
+    server {
+        listen       127.0.0.1:8087 http2;
+        server_name  localhost;
+
+        client_header_timeout 1s;
+        client_body_timeout 1s;
+
+        location /proxy/ {
+            proxy_pass http://127.0.0.1:8081/;
+        }
+    }
+}
+
+EOF
+
+$t->run();
+
+# file size is slightly beyond initial window size: 2**16 + 80 bytes
+
+$t->write_file('t1.html',
+	join('', map { sprintf "X%04dXXX", $_ } (1 .. 8202)));
+$t->write_file('tbig.html',
+	join('', map { sprintf "XX%06dXX", $_ } (1 .. 500000)));
+
+$t->write_file('t2.html', 'SEE-THIS');
+
+###############################################################################
+
+# Upgrade mechanism
+
+my $r = http(<<EOF);
+GET / HTTP/1.1
+Host: localhost
+Connection: Upgrade, HTTP2-Settings
+Upgrade: h2c
+HTTP2-Settings: AAMAAABkAAQAAP__
+
+EOF
+
+SKIP: {
+skip 'no Upgrade-based negotiation', 2 if $r !~ m!HTTP/1.1 101!;
+
+like($r, qr!Connection: Upgrade!, 'upgrade - connection');
+like($r, qr!Upgrade: h2c!, 'upgrade - token');
+
+}
+
+# SETTINGS
+
+my $s = Test::Nginx::HTTP2->new(port(8080), pure => 1);
+my $frames = $s->read(all => [
+	{ type => 'WINDOW_UPDATE' },
+	{ type => 'SETTINGS'}
+]);
+
+my ($frame) = grep { $_->{type} eq 'WINDOW_UPDATE' } @$frames;
+ok($frame, 'WINDOW_UPDATE frame');
+is($frame->{flags}, 0, 'WINDOW_UPDATE zero flags');
+is($frame->{sid}, 0, 'WINDOW_UPDATE zero sid');
+is($frame->{length}, 4, 'WINDOW_UPDATE fixed length');
+
+($frame) = grep { $_->{type} eq 'SETTINGS' } @$frames;
+ok($frame, 'SETTINGS frame');
+is($frame->{flags}, 0, 'SETTINGS flags');
+is($frame->{sid}, 0, 'SETTINGS stream');
+
+$s->h2_settings(1);
+$s->h2_settings(0);
+
+$frames = $s->read(all => [{ type => 'SETTINGS' }]);
+
+($frame) = grep { $_->{type} eq 'SETTINGS' } @$frames;
+ok($frame, 'SETTINGS frame ack');
+is($frame->{flags}, 1, 'SETTINGS flags ack');
+
+# SETTINGS - no ack on PROTOCOL_ERROR
+
+$s = Test::Nginx::HTTP2->new(port(8080), pure => 1);
+$frames = $s->read(all => [
+	{ type => 'WINDOW_UPDATE' },
+	{ type => 'SETTINGS'}
+]);
+
+$s->h2_settings(1);
+$s->h2_settings(0, 0x5 => 42);
+
+$frames = $s->read(all => [
+	{ type => 'SETTINGS'},
+	{ type => 'GOAWAY' }
+]);
+
+($frame) = grep { $_->{type} eq 'SETTINGS' } @$frames;
+is($frame, undef, 'SETTINGS PROTOCOL_ERROR - no ack');
+
+($frame) = grep { $_->{type} eq 'GOAWAY' } @$frames;
+ok($frame, 'SETTINGS PROTOCOL_ERROR - GOAWAY');
+
+# PING
+
+$s = Test::Nginx::HTTP2->new();
+$s->h2_ping('SEE-THIS');
+$frames = $s->read(all => [{ type => 'PING' }]);
+
+($frame) = grep { $_->{type} eq "PING" } @$frames;
+ok($frame, 'PING frame');
+is($frame->{value}, 'SEE-THIS', 'PING payload');
+is($frame->{flags}, 1, 'PING flags ack');
+is($frame->{sid}, 0, 'PING stream');
+
+# timeouts
+
+SKIP: {
+skip 'long tests', 6 unless $ENV{TEST_NGINX_UNSAFE};
+
+push my @s, Test::Nginx::HTTP2->new(port(8084), pure => 1);
+push @s, Test::Nginx::HTTP2->new(port(8084), pure => 1);
+$s[-1]->h2_ping('SEE-THIS');
+push @s, Test::Nginx::HTTP2->new(port(8085), pure => 1);
+push @s, Test::Nginx::HTTP2->new(port(8085), pure => 1);
+$s[-1]->h2_ping('SEE-THIS');
+
+select undef, undef, undef, 2.1;
+
+$frames = (shift @s)->read(all => [{ type => "GOAWAY" }]);
+($frame) = grep { $_->{type} eq "GOAWAY" } @$frames;
+ok($frame, 'recv timeout - new connection GOAWAY');
+is($frame->{code}, 1, 'recv timeout - new connection code');
+
+$frames = (shift @s)->read(all => [{ type => "GOAWAY" }]);
+($frame) = grep { $_->{type} eq "GOAWAY" } @$frames;
+is($frame, undef, 'recv timeout - idle connection GOAWAY');
+
+$frames = (shift @s)->read(all => [{ type => "GOAWAY" }]);
+($frame) = grep { $_->{type} eq "GOAWAY" } @$frames;
+is($frame, undef, 'idle timeout - new connection GOAWAY');
+
+$frames = (shift @s)->read(all => [{ type => "GOAWAY" }]);
+($frame) = grep { $_->{type} eq "GOAWAY" } @$frames;
+ok($frame, 'idle timeout - idle connection GOAWAY');
+is($frame->{code}, 0, 'idle timeout - idle connection code');
+
+}
+
+# GOAWAY
+
+Test::Nginx::HTTP2->new()->h2_goaway(0, 0, 5);
+Test::Nginx::HTTP2->new()->h2_goaway(0, 0, 5, 'foobar');
+Test::Nginx::HTTP2->new()->h2_goaway(0, 0, 5, 'foobar', split => [ 8, 8, 4 ]);
+
+$s = Test::Nginx::HTTP2->new();
+$s->h2_goaway(0, 0, 5);
+$s->h2_goaway(0, 0, 5);
+
+$s = Test::Nginx::HTTP2->new();
+$s->h2_goaway(0, 0, 5, 'foobar', len => 0);
+$frames = $s->read(all => [{ type => "GOAWAY" }]);
+
+($frame) = grep { $_->{type} eq "GOAWAY" } @$frames;
+ok($frame, 'GOAWAY invalid length - GOAWAY frame');
+is($frame->{code}, 6, 'GOAWAY invalid length - GOAWAY FRAME_SIZE_ERROR');
+
+# 6.8.  GOAWAY
+#   An endpoint MUST treat a GOAWAY frame with a stream identifier other
+#   than 0x0 as a connection error (Section 5.4.1) of type PROTOCOL_ERROR.
+
+TODO: {
+local $TODO = 'not yet';
+
+$s = Test::Nginx::HTTP2->new();
+$s->h2_goaway(1, 0, 5, 'foobar');
+$frames = $s->read(all => [{ type => "GOAWAY" }], wait => 0.5);
+
+($frame) = grep { $_->{type} eq "GOAWAY" } @$frames;
+ok($frame, 'GOAWAY invalid stream - GOAWAY frame');
+is($frame->{code}, 1, 'GOAWAY invalid stream - GOAWAY PROTOCOL_ERROR');
+
+}
+
+# client-initiated PUSH_PROMISE, just to ensure nothing went wrong
+# N.B. other implementation returns zero code, which is not anyhow regulated
+
+$s = Test::Nginx::HTTP2->new();
+{
+	local $SIG{PIPE} = 'IGNORE';
+	syswrite($s->{socket}, pack("x2C2xN", 4, 0x5, 1));
+}
+$frames = $s->read(all => [{ type => "GOAWAY" }]);
+
+($frame) = grep { $_->{type} eq "GOAWAY" } @$frames;
+ok($frame, 'client-initiated PUSH_PROMISE - GOAWAY frame');
+is($frame->{code}, 1, 'client-initiated PUSH_PROMISE - GOAWAY PROTOCOL_ERROR');
+
+# GET
+
+$s = Test::Nginx::HTTP2->new();
+my $sid = $s->new_stream();
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+ok($frame, 'HEADERS frame');
+is($frame->{sid}, $sid, 'HEADERS stream');
+is($frame->{headers}->{':status'}, 200, 'HEADERS status');
+is($frame->{headers}->{'x-header'}, 'X-Foo', 'HEADERS header');
+
+($frame) = grep { $_->{type} eq "DATA" } @$frames;
+ok($frame, 'DATA frame');
+is($frame->{length}, length 'body', 'DATA length');
+is($frame->{data}, 'body', 'DATA payload');
+
+# GET in the new stream on same connection
+
+$sid = $s->new_stream();
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{sid}, $sid, 'HEADERS stream 2');
+is($frame->{headers}->{':status'}, 200, 'HEADERS status 2');
+is($frame->{headers}->{'x-header'}, 'X-Foo', 'HEADERS header 2');
+
+($frame) = grep { $_->{type} eq "DATA" } @$frames;
+ok($frame, 'DATA frame 2');
+is($frame->{sid}, $sid, 'HEADERS stream 2');
+is($frame->{length}, length 'body', 'DATA length 2');
+is($frame->{data}, 'body', 'DATA payload 2');
+
+# HEAD
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ method => 'HEAD' });
+$frames = $s->read(all => [{ sid => $sid, fin => 0x4 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{sid}, $sid, 'HEAD - HEADERS');
+is($frame->{headers}->{':status'}, 200, 'HEAD - HEADERS status');
+is($frame->{headers}->{'x-header'}, 'X-Foo', 'HEAD - HEADERS header');
+
+($frame) = grep { $_->{type} eq "DATA" } @$frames;
+is($frame, undef, 'HEAD - no body');
+
+# range filter
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET', mode => 0 },
+	{ name => ':scheme', value => 'http', mode => 0 },
+	{ name => ':path', value => '/t1.html', mode => 1 },
+	{ name => ':authority', value => 'localhost', mode => 1 },
+	{ name => 'range', value => 'bytes=10-19', mode => 1 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 206, 'range - HEADERS status');
+
+($frame) = grep { $_->{type} eq "DATA" } @$frames;
+is($frame->{length}, 10, 'range - DATA length');
+is($frame->{data}, '002XXXX000', 'range - DATA payload');
+
+# http2_chunk_size=1
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/chunk_size' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+my @data = grep { $_->{type} eq "DATA" } @$frames;
+is(@data, 4, 'chunk_size frames');
+is(join(' ', map { $_->{data} } @data), 'b o d y', 'chunk_size data');
+is(join(' ', map { $_->{flags} } @data), '0 0 0 1', 'chunk_size flags');
+
+# CONTINUATION
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ continuation => 1, headers => [
+	{ name => ':method', value => 'HEAD', mode => 1 },
+	{ name => ':scheme', value => 'http', mode => 0 },
+	{ name => ':path', value => '/', mode => 0 },
+	{ name => ':authority', value => 'localhost', mode => 1 }]});
+$s->h2_continue($sid, { continuation => 1, headers => [
+	{ name => 'x-foo', value => 'X-Bar', mode => 2 }]});
+$s->h2_continue($sid, { headers => [
+	{ name => 'referer', value => 'foo', mode => 2 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "DATA" } @$frames;
+is($frame, undef, 'CONTINUATION - fragment 1');
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{'x-sent-foo'}, 'X-Bar', 'CONTINUATION - fragment 2');
+is($frame->{headers}->{'x-referer'}, 'foo', 'CONTINUATION - fragment 3');
+
+# CONTINUATION - in the middle of request header field
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ continuation => [ 2, 4, 1, 5 ], headers => [
+	{ name => ':method', value => 'HEAD', mode => 1 },
+	{ name => ':scheme', value => 'http', mode => 0 },
+	{ name => ':path', value => '/', mode => 0 },
+	{ name => ':authority', value => 'localhost', mode => 1 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200, 'CONTINUATION - in header field');
+
+# CONTINUATION on a closed stream
+
+$s->h2_continue(1, { headers => [
+	{ name => 'x-foo', value => 'X-Bar', mode => 2 }]});
+$frames = $s->read(all => [{ sid => 1, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "GOAWAY" } @$frames;
+is($frame->{type}, 'GOAWAY', 'GOAWAY - CONTINUATION closed stream');
+is($frame->{code}, 1, 'GOAWAY - CONTINUATION closed stream - PROTOCOL_ERROR');
+
+# frame padding
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ padding => 42, headers => [
+	{ name => ':method', value => 'GET', mode => 0 },
+	{ name => ':scheme', value => 'http', mode => 0 },
+	{ name => ':path', value => '/', mode => 0 },
+	{ name => ':authority', value => 'localhost', mode => 1 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200, 'padding - HEADERS status');
+
+$sid = $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET', mode => 0 },
+	{ name => ':scheme', value => 'http', mode => 0 },
+	{ name => ':path', value => '/', mode => 0 },
+	{ name => ':authority', value => 'localhost', mode => 1 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200, 'padding - next stream');
+
+# padding followed by CONTINUATION
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ padding => 42, continuation => [ 2, 4, 1, 5 ],
+	headers => [
+	{ name => ':method', value => 'GET', mode => 1 },
+	{ name => ':scheme', value => 'http', mode => 0 },
+	{ name => ':path', value => '/', mode => 0 },
+	{ name => ':authority', value => 'localhost', mode => 1 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200, 'padding - CONTINUATION');
+
+# internal redirect
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/redirect' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 405, 'redirect - HEADERS');
+
+($frame) = grep { $_->{type} eq "DATA" } @$frames;
+ok($frame, 'redirect - DATA');
+is($frame->{data}, 'body', 'redirect - DATA payload');
+
+# return 301 with absolute URI
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/return301_absolute' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 301, 'return 301 absolute - status');
+is($frame->{headers}->{'location'}, 'text', 'return 301 absolute - location');
+
+# return 301 with relative URI
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/return301_relative' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 301, 'return 301 relative - status');
+is($frame->{headers}->{'location'}, 'http://localhost:' . port(8080) . '/',
+	'return 301 relative - location');
+
+# return 301 with relative URI and ':authority' request header field
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET', mode => 0 },
+	{ name => ':scheme', value => 'http', mode => 0 },
+	{ name => ':path', value => '/return301_relative', mode => 2 },
+	{ name => ':authority', value => 'localhost', mode => 2 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 301,
+	'return 301 relative - authority - status');
+is($frame->{headers}->{'location'}, 'http://localhost:' . port(8080) . '/',
+	'return 301 relative - authority - location');
+
+# return 301 with relative URI and 'host' request header field
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET', mode => 0 },
+	{ name => ':scheme', value => 'http', mode => 0 },
+	{ name => ':path', value => '/return301_relative', mode => 2 },
+	{ name => 'host', value => 'localhost', mode => 2 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 301,
+	'return 301 relative - host - status');
+is($frame->{headers}->{'location'}, 'http://localhost:' . port(8080) . '/',
+	'return 301 relative - host - location');
+
+# virtual host
+
+$s = Test::Nginx::HTTP2->new(port(8082));
+$sid = $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET', mode => 0 },
+	{ name => ':scheme', value => 'http', mode => 0 },
+	{ name => ':path', value => '/', mode => 0 },
+	{ name => 'host', value => 'localhost', mode => 2 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200,
+	'virtual host - host - status');
+
+($frame) = grep { $_->{type} eq "DATA" } @$frames;
+is($frame->{data}, 'first', 'virtual host - host - DATA');
+
+$sid = $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET', mode => 0 },
+	{ name => ':scheme', value => 'http', mode => 0 },
+	{ name => ':path', value => '/', mode => 0 },
+	{ name => ':authority', value => 'localhost', mode => 2 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200,
+	'virtual host - authority - status');
+
+($frame) = grep { $_->{type} eq "DATA" } @$frames;
+is($frame->{data}, 'first', 'virtual host - authority - DATA');
+
+# virtual host - second
+
+$sid = $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET', mode => 0 },
+	{ name => ':scheme', value => 'http', mode => 0 },
+	{ name => ':path', value => '/', mode => 0 },
+	{ name => 'host', value => 'localhost2', mode => 2 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200,
+	'virtual host 2 - host - status');
+
+($frame) = grep { $_->{type} eq "DATA" } @$frames;
+is($frame->{data}, 'second', 'virtual host 2 - host - DATA');
+
+$sid = $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET', mode => 0 },
+	{ name => ':scheme', value => 'http', mode => 0 },
+	{ name => ':path', value => '/', mode => 0 },
+	{ name => ':authority', value => 'localhost2', mode => 2 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200,
+	'virtual host 2 - authority - status');
+
+($frame) = grep { $_->{type} eq "DATA" } @$frames;
+is($frame->{data}, 'second', 'virtual host 2 - authority - DATA');
+
+# gzip tests for internal nginx version
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET', mode => 0 },
+	{ name => ':scheme', value => 'http', mode => 0 },
+	{ name => ':path', value => '/gzip.html' },
+	{ name => ':authority', value => 'localhost', mode => 1 },
+	{ name => 'accept-encoding', value => 'gzip' }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{'content-encoding'}, 'gzip', 'gzip - encoding');
+is($frame->{headers}->{'vary'}, 'Accept-Encoding', 'gzip - vary');
+
+($frame) = grep { $_->{type} eq "DATA" } @$frames;
+gunzip_like($frame->{data}, qr/^SEE-THIS\Z/, 'gzip - DATA');
+
+# charset
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/charset' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{'content-type'}, 'text/plain; charset=utf-8', 'charset');
+
+# partial request header frame received (field split),
+# the rest of frame is received after client header timeout
+
+$s = Test::Nginx::HTTP2->new(port(8087));
+$sid = $s->new_stream({ path => '/t2.html', split => [35],
+	split_delay => 2.1 });
+$frames = $s->read(all => [{ type => 'RST_STREAM' }]);
+
+($frame) = grep { $_->{type} eq "RST_STREAM" } @$frames;
+ok($frame, 'client header timeout');
+is($frame->{code}, 1, 'client header timeout - protocol error');
+
+$s->h2_ping('SEE-THIS');
+$frames = $s->read(all => [{ type => 'PING' }]);
+
+($frame) = grep { $_->{type} eq "PING" && $_->{flags} & 0x1 } @$frames;
+ok($frame, 'client header timeout - PING');
+
+# partial request header frame received (no field split),
+# the rest of frame is received after client header timeout
+
+$s = Test::Nginx::HTTP2->new(port(8087));
+$sid = $s->new_stream({ path => '/t2.html', split => [20], split_delay => 2.1 });
+$frames = $s->read(all => [{ type => 'RST_STREAM' }]);
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.17.9');
+
+($frame) = grep { $_->{type} eq "RST_STREAM" } @$frames;
+ok($frame, 'client header timeout 2');
+is($frame->{code}, 1, 'client header timeout 2 - protocol error');
+
+}
+
+$s->h2_ping('SEE-THIS');
+$frames = $s->read(all => [{ type => 'PING' }]);
+
+($frame) = grep { $_->{type} eq "PING" && $_->{flags} & 0x1 } @$frames;
+ok($frame, 'client header timeout 2 - PING');
+
+# partial request body data frame received, the rest is after body timeout
+
+$s = Test::Nginx::HTTP2->new(port(8087));
+$sid = $s->new_stream({ path => '/proxy/t2.html', body_more => 1 });
+$s->h2_body('TEST', { split => [10], split_delay => 2.1 });
+$frames = $s->read(all => [{ type => 'RST_STREAM' }]);
+
+($frame) = grep { $_->{type} eq "RST_STREAM" } @$frames;
+ok($frame, 'client body timeout');
+is($frame->{code}, 1, 'client body timeout - protocol error');
+
+$s->h2_ping('SEE-THIS');
+$frames = $s->read(all => [{ type => 'PING' }]);
+
+($frame) = grep { $_->{type} eq "PING" && $_->{flags} & 0x1 } @$frames;
+ok($frame, 'client body timeout - PING');
+
+# proxied request with logging pristine request header field (e.g., referer)
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET' },
+	{ name => ':scheme', value => 'http' },
+	{ name => ':path', value => '/proxy2/' },
+	{ name => ':authority', value => 'localhost' },
+	{ name => 'referer', value => 'foo' }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200, 'proxy with logging request headers');
+
+$sid = $s->new_stream();
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+ok($frame->{headers}, 'proxy with logging request headers - next');
+
+# initial window size, client side
+
+# 6.9.2.  Initial Flow-Control Window Size
+#   When an HTTP/2 connection is first established, new streams are
+#   created with an initial flow-control window size of 65,535 octets.
+#   The connection flow-control window is also 65,535 octets.
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/t1.html' });
+$frames = $s->read(all => [{ sid => $sid, length => 2**16 - 1 }]);
+
+# with the default http2_chunk_size, data is divided into 8 data frames
+
+@data = grep { $_->{type} eq "DATA" } @$frames;
+my $lengths = join ' ', map { $_->{length} } @data;
+is($lengths, '8192 8192 8192 8192 8192 8192 8192 8191',
+	'iws - stream blocked on initial window size');
+
+$s->h2_ping('SEE-THIS');
+$frames = $s->read(all => [{ type => 'PING' }]);
+
+($frame) = grep { $_->{type} eq "PING" && $_->{flags} & 0x1 } @$frames;
+ok($frame, 'iws - PING not blocked');
+
+$s->h2_window(2**16, $sid);
+$frames = $s->read(wait => 0.2);
+is(@$frames, 0, 'iws - updated stream window');
+
+$s->h2_window(2**16);
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+@data = grep { $_->{type} eq "DATA" } @$frames;
+my $sum = eval join '+', map { $_->{length} } @data;
+is($sum, 81, 'iws - updated connection window');
+
+# SETTINGS (initial window size, client side)
+
+# 6.9.2.  Initial Flow-Control Window Size
+#   Both endpoints can adjust the initial window size for new streams by
+#   including a value for SETTINGS_INITIAL_WINDOW_SIZE in the SETTINGS
+#   frame that forms part of the connection preface.  The connection
+#   flow-control window can only be changed using WINDOW_UPDATE frames.
+
+$s = Test::Nginx::HTTP2->new();
+$s->h2_settings(0, 0x4 => 2**17);
+$s->h2_window(2**17);
+
+$sid = $s->new_stream({ path => '/t1.html' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+@data = grep { $_->{type} eq "DATA" } @$frames;
+$sum = eval join '+', map { $_->{length} } @data;
+is($sum, 2**16 + 80, 'iws - increased');
+
+# INITIAL_WINDOW_SIZE duplicate settings
+
+# 6.5.  SETTINGS
+#   Each parameter in a SETTINGS frame replaces any existing value for
+#   that parameter.  Parameters are processed in the order in which they
+#   appear, and a receiver of a SETTINGS frame does not need to maintain
+#   any state other than the current value of its parameters.  Therefore,
+#   the value of a SETTINGS parameter is the last value that is seen by a
+#   receiver.
+
+$s = Test::Nginx::HTTP2->new();
+$s->h2_window(2**17);
+
+$sid = $s->new_stream({ path => '/t1.html' });
+
+$frames = $s->read(all => [{ sid => $sid, length => 2**16 - 1 }]);
+@data = grep { $_->{type} eq "DATA" } @$frames;
+$sum = eval join '+', map { $_->{length} } @data;
+is($sum, 2**16 - 1, 'iws duplicate - default stream window');
+
+# this should effect in extra stream window octect
+# $s->h2_settings(0, 0x4 => 42, 0x4 => 2**16);
+{
+	local $SIG{PIPE} = 'IGNORE';
+	syswrite($s->{socket}, pack("x2C2x5nNnN", 12, 0x4, 4, 42, 4, 2**16));
+}
+
+$frames = $s->read(all => [{ sid => $sid, length => 1 }]);
+@data = grep { $_->{type} eq "DATA" } @$frames;
+$sum = eval join '+', map { $_->{length} } @data;
+is($sum, 1, 'iws duplicate - updated stream window');
+
+# yet more octets to finish receiving the response
+
+$s->h2_settings(0, 0x4 => 2**16 + 80);
+
+$frames = $s->read(all => [{ sid => $sid, length => 80 }]);
+@data = grep { $_->{type} eq "DATA" } @$frames;
+$sum = eval join '+', map { $_->{length} } @data;
+is($sum, 80, 'iws duplicate - updated stream window 2');
+
+# probe for negative available space in a flow control window
+
+# 6.9.2.  Initial Flow-Control Window Size
+#   A change to SETTINGS_INITIAL_WINDOW_SIZE can cause the available
+#   space in a flow-control window to become negative.  A sender MUST
+#   track the negative flow-control window and MUST NOT send new flow-
+#   controlled frames until it receives WINDOW_UPDATE frames that cause
+#   the flow-control window to become positive.
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/t1.html' });
+$s->read(all => [{ sid => $sid, length => 2**16 - 1 }]);
+
+$s->h2_window(1);
+$s->h2_settings(0, 0x4 => 42);
+$s->h2_window(1024, $sid);
+
+$frames = $s->read(all => [{ type => 'SETTINGS' }]);
+
+($frame) = grep { $_->{type} eq 'SETTINGS' } @$frames;
+ok($frame, 'negative window - SETTINGS frame ack');
+is($frame->{flags}, 1, 'negative window - SETTINGS flags ack');
+
+($frame) = grep { $_->{type} ne 'SETTINGS' } @$frames;
+is($frame, undef, 'negative window - no data');
+
+# predefined window size, minus new iws settings, minus window update
+
+$s->h2_window(2**16 - 1 - 42 - 1024, $sid);
+
+$frames = $s->read(wait => 0.2);
+is(@$frames, 0, 'zero window - no data');
+
+$s->h2_window(1, $sid);
+
+$frames = $s->read(all => [{ sid => $sid, length => 1 }]);
+is(@$frames, 1, 'positive window');
+
+SKIP: {
+skip 'failed connection', 2 unless @$frames;
+
+is(@$frames[0]->{type}, 'DATA', 'positive window - data');
+is(@$frames[0]->{length}, 1, 'positive window - data length');
+
+}
+
+$s = Test::Nginx::HTTP2->new();
+$s->h2_window(2**30);
+$s->h2_settings(0, 0x4 => 2**30);
+
+$sid = $s->new_stream({ path => '/frame_size/tbig.html' });
+
+sleep 1;
+$s->h2_settings(0, 0x5 => 2**15);
+
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+$lengths = join ' ', map { $_->{length} } @$frames;
+unlike($lengths, qr/16384 0 16384/, 'SETTINGS ack after queued DATA');
+
+# ask write handler in sending large response
+
+SKIP: {
+skip 'unsafe socket tests', 4 unless $ENV{TEST_NGINX_UNSAFE};
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/tbig.html' });
+
+$s->h2_window(2**30, $sid);
+$s->h2_window(2**30);
+
+sleep 1;
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200, 'large response - HEADERS');
+
+@data = grep { $_->{type} eq "DATA" } @$frames;
+$sum = eval join '+', map { $_->{length} } @data;
+is($sum, 5000000, 'large response - DATA');
+
+# Make sure http2 write handler doesn't break a connection.
+
+$sid = $s->new_stream();
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200, 'new stream after large response');
+
+# write event send timeout
+
+$s = Test::Nginx::HTTP2->new(port(8086));
+$sid = $s->new_stream({ path => '/tbig.html' });
+$s->h2_window(2**30, $sid);
+$s->h2_window(2**30);
+
+select undef, undef, undef, 2.1;
+
+$s->h2_ping('SEE-THIS');
+
+$frames = $s->read(all => [{ type => 'PING' }]);
+ok(!grep ({ $_->{type} eq "PING" } @$frames), 'large response - send timeout');
+
+}
+
+# SETTINGS_MAX_FRAME_SIZE
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/frame_size/t1.html' });
+$s->h2_window(2**18, 1);
+$s->h2_window(2**18);
+
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+@data = grep { $_->{type} eq "DATA" } @$frames;
+is($data[0]->{length}, 2**14, 'max frame size - default');
+
+$s = Test::Nginx::HTTP2->new();
+$s->h2_settings(0, 0x5 => 2**15);
+$sid = $s->new_stream({ path => '/frame_size/t1.html' });
+$s->h2_window(2**18, 1);
+$s->h2_window(2**18);
+
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+@data = grep { $_->{type} eq "DATA" } @$frames;
+is($data[0]->{length}, 2**15, 'max frame size - custom');
+
+# SETTINGS_INITIAL_WINDOW_SIZE + SETTINGS_MAX_FRAME_SIZE
+# Expanding available stream window should not result in emitting
+# new frames before remaining SETTINGS parameters were applied.
+
+$s = Test::Nginx::HTTP2->new();
+$s->h2_window(2**17);
+$s->h2_settings(0, 0x4 => 42);
+
+$sid = $s->new_stream({ path => '/frame_size/t1.html' });
+$s->read(all => [{ sid => $sid, length => 42 }]);
+
+$s->h2_settings(0, 0x4 => 2**17, 0x5 => 2**15);
+
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+@data = grep { $_->{type} eq "DATA" } @$frames;
+$lengths = join ' ', map { $_->{length} } @data;
+is($lengths, '32768 32768 38', 'multiple SETTINGS');
+
+# stream multiplexing + WINDOW_UPDATE
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/t1.html' });
+$frames = $s->read(all => [{ sid => $sid, length => 2**16 - 1 }]);
+
+@data = grep { $_->{type} eq "DATA" } @$frames;
+$sum = eval join '+', map { $_->{length} } @data;
+is($sum, 2**16 - 1, 'multiple - stream1 data');
+
+my $sid2 = $s->new_stream({ path => '/t1.html' });
+$frames = $s->read(all => [{ sid => $sid2, fin => 0x4 }]);
+
+@data = grep { $_->{type} eq "DATA" } @$frames;
+is(@data, 0, 'multiple - stream2 no data');
+
+$s->h2_window(2**17, $sid);
+$s->h2_window(2**17, $sid2);
+$s->h2_window(2**17);
+
+$frames = $s->read(all => [
+	{ sid => $sid, fin => 1 },
+	{ sid => $sid2, fin => 1 }
+]);
+
+@data = grep { $_->{type} eq "DATA" && $_->{sid} == $sid } @$frames;
+$sum = eval join '+', map { $_->{length} } @data;
+is($sum, 81, 'multiple - stream1 remain data');
+
+@data = grep { $_->{type} eq "DATA" && $_->{sid} == $sid2 } @$frames;
+$sum = eval join '+', map { $_->{length} } @data;
+is($sum, 2**16 + 80, 'multiple - stream2 full data');
+
+# http2_max_concurrent_streams
+
+$s = Test::Nginx::HTTP2->new(port(8083), pure => 1);
+$frames = $s->read(all => [{ type => 'SETTINGS' }]);
+
+($frame) = grep { $_->{type} eq 'SETTINGS' } @$frames;
+is($frame->{3}, 1, 'http2_max_concurrent_streams SETTINGS');
+
+$s->h2_window(2**18);
+
+$sid = $s->new_stream({ path => '/t1.html' });
+$frames = $s->read(all => [{ sid => $sid, length => 2 ** 16 - 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" && $_->{sid} == $sid } @$frames;
+is($frame->{headers}->{':status'}, 200, 'http2_max_concurrent_streams');
+
+$sid2 = $s->new_stream({ path => '/t1.html' });
+$frames = $s->read(all => [{ type => 'RST_STREAM' }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" && $_->{sid} == $sid2 } @$frames;
+isnt($frame->{headers}->{':status'}, 200, 'http2_max_concurrent_streams 2');
+
+($frame) = grep { $_->{type} eq "RST_STREAM" && $_->{sid} == $sid2 } @$frames;
+is($frame->{sid}, $sid2, 'http2_max_concurrent_streams RST_STREAM sid');
+is($frame->{length}, 4, 'http2_max_concurrent_streams RST_STREAM length');
+is($frame->{flags}, 0, 'http2_max_concurrent_streams RST_STREAM flags');
+is($frame->{code}, 7, 'http2_max_concurrent_streams RST_STREAM code');
+
+# properly skip header field that's not/never indexed from discarded streams
+
+$sid2 = $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET' },
+	{ name => ':scheme', value => 'http' },
+	{ name => ':path', value => '/', mode => 6 },
+	{ name => ':authority', value => 'localhost' },
+	{ name => 'x-foo', value => 'Foo', mode => 2 }]});
+$frames = $s->read(all => [{ type => 'RST_STREAM' }]);
+
+# also if split across writes
+
+$sid2 = $s->new_stream({ split => [ 22 ], headers => [
+	{ name => ':method', value => 'GET' },
+	{ name => ':scheme', value => 'http' },
+	{ name => ':path', value => '/', mode => 6 },
+	{ name => ':authority', value => 'localhost' },
+	{ name => 'x-bar', value => 'Bar', mode => 2 }]});
+$frames = $s->read(all => [{ type => 'RST_STREAM' }]);
+
+# also if split across frames
+
+$sid2 = $s->new_stream({ continuation => [ 17 ], headers => [
+	{ name => ':method', value => 'GET' },
+	{ name => ':scheme', value => 'http' },
+	{ name => ':path', value => '/', mode => 6 },
+	{ name => ':authority', value => 'localhost' },
+	{ name => 'x-baz', value => 'Baz', mode => 2 }]});
+$frames = $s->read(all => [{ type => 'RST_STREAM' }]);
+
+$s->h2_window(2**16, $sid);
+$s->read(all => [{ sid => $sid, fin => 1 }]);
+
+$sid = $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET' },
+	{ name => ':scheme', value => 'http' },
+	{ name => ':path', value => '/t2.html' },
+	{ name => ':authority', value => 'localhost' },
+# make sure that discarded streams updated dynamic table
+	{ name => 'x-foo', value => 'Foo', mode => 0 },
+	{ name => 'x-bar', value => 'Bar', mode => 0 },
+	{ name => 'x-baz', value => 'Baz', mode => 0 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" && $_->{sid} == $sid } @$frames;
+is($frame->{headers}->{':status'}, 200, 'http2_max_concurrent_streams 3');
+
+
+# some invalid cases below
+
+# invalid connection preface
+
+$s = Test::Nginx::HTTP2->new(port(8080), preface => 'x' x 16, pure => 1);
+$frames = $s->read(all => [{ type => 'GOAWAY' }]);
+
+($frame) = grep { $_->{type} eq "GOAWAY" } @$frames;
+ok($frame, 'invalid preface - GOAWAY frame');
+is($frame->{code}, 1, 'invalid preface - error code');
+
+my $preface = 'PRI * HTTP/2.0' . CRLF . CRLF . 'x' x 8;
+$s = Test::Nginx::HTTP2->new(port(8080), preface => $preface, pure => 1);
+$frames = $s->read(all => [{ type => 'GOAWAY' }]);
+
+($frame) = grep { $_->{type} eq "GOAWAY" } @$frames;
+ok($frame, 'invalid preface 2 - GOAWAY frame');
+is($frame->{code}, 1, 'invalid preface 2 - error code');
+
+# GOAWAY on SYN_STREAM with even StreamID
+
+$s = Test::Nginx::HTTP2->new();
+$s->new_stream({ path => '/' }, 2);
+$frames = $s->read(all => [{ type => 'GOAWAY' }]);
+
+($frame) = grep { $_->{type} eq "GOAWAY" } @$frames;
+ok($frame, 'even stream - GOAWAY frame');
+is($frame->{code}, 1, 'even stream - error code');
+is($frame->{last_sid}, 0, 'even stream - last stream');
+
+# GOAWAY on SYN_STREAM with backward StreamID
+
+# 5.1.1.  Stream Identifiers
+#   The first use of a new stream identifier implicitly closes all
+#   streams in the "idle" state <..> with a lower-valued stream identifier.
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/' }, 3);
+$s->read(all => [{ sid => $sid, fin => 1 }]);
+
+$sid2 = $s->new_stream({ path => '/' }, 1);
+$frames = $s->read(all => [{ type => 'GOAWAY' }]);
+
+($frame) = grep { $_->{type} eq "GOAWAY" } @$frames;
+ok($frame, 'backward stream - GOAWAY frame');
+is($frame->{code}, 1, 'backward stream - error code');
+is($frame->{last_sid}, $sid, 'backward stream - last stream');
+
+# GOAWAY on the second SYN_STREAM with same StreamID
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/' });
+$s->read(all => [{ sid => $sid, fin => 1 }]);
+
+$sid2 = $s->new_stream({ path => '/' }, $sid);
+$frames = $s->read(all => [{ type => 'GOAWAY' }]);
+
+($frame) = grep { $_->{type} eq "GOAWAY" } @$frames;
+ok($frame, 'dup stream - GOAWAY frame');
+is($frame->{code}, 1, 'dup stream - error code');
+is($frame->{last_sid}, $sid, 'dup stream - last stream');
+
+# aborted stream with zero HEADERS payload followed by client connection close
+
+Test::Nginx::HTTP2->new()->new_stream({ split => [ 9 ], abort => 1 });
+
+# unknown frame type
+
+$s = Test::Nginx::HTTP2->new();
+$s->h2_unknown('payload');
+$s->h2_ping('SEE-THIS');
+$frames = $s->read(all => [{ type => 'PING' }]);
+
+($frame) = grep { $_->{type} eq "PING" } @$frames;
+is($frame->{value}, 'SEE-THIS', 'unknown frame type');
+
+# graceful shutdown with stream waiting on HEADERS payload
+
+my $grace = Test::Nginx::HTTP2->new(port(8084));
+$grace->new_stream({ split => [ 9 ], abort => 1 });
+
+# graceful shutdown with stream waiting on WINDOW_UPDATE
+
+my $grace2 = Test::Nginx::HTTP2->new(port(8084));
+$sid = $grace2->new_stream({ path => '/t1.html' });
+$grace2->read(all => [{ sid => $sid, length => 2**16 - 1 }]);
+
+# graceful shutdown waiting on incomplete request body DATA frames
+
+my $grace3 = Test::Nginx::HTTP2->new(port(8085));
+$sid = $grace3->new_stream({ path => '/proxy2/t2.html', body_more => 1 });
+$grace3->h2_body('TEST', { body_more => 1 });
+
+# partial request body data frame with connection close after body timeout
+
+my $grace4 = Test::Nginx::HTTP2->new(port(8087));
+$sid = $grace4->new_stream({ path => '/proxy/t2.html', body_more => 1 });
+$grace4->h2_body('TEST', { split => [ 12 ], abort => 1 });
+
+select undef, undef, undef, 1.1;
+undef $grace4;
+
+# GOAWAY without awaiting active streams, further streams ignored
+
+$s = Test::Nginx::HTTP2->new(port(8080));
+$sid = $s->new_stream({ path => '/t1.html' });
+$s->read(all => [{ sid => $sid, length => 2**16 - 1 }]);
+
+$t->reload();
+
+$frames = $s->read(all => [{ type => 'GOAWAY' }]);
+
+($frame) = grep { $_->{type} eq "GOAWAY" } @$frames;
+is($frame->{last_sid}, $sid, 'GOAWAY with active stream - last sid');
+
+$sid2 = $s->new_stream();
+$frames = $s->read(all => [{ sid => $sid2, fin => 0x4 }], wait => 0.5);
+
+($frame) = grep { $_->{type} eq 'HEADERS' } @$frames;
+is($frame, undef, 'GOAWAY with active stream - no new stream');
+
+$s->h2_window(100, $sid);
+$s->h2_window(100);
+$frames = $s->read(all => [{ sid => $sid, fin => 0x1 }]);
+
+@data = grep { $_->{type} eq "DATA" && $_->{sid} == $sid } @$frames;
+$sum = eval join '+', map { $_->{length} } @data;
+is($sum, 81, 'GOAWAY with active stream - active stream DATA after GOAWAY');
+
+# GOAWAY - force closing a connection by server with idle or active streams
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream();
+$s->read(all => [{ sid => $sid, fin => 1 }]);
+
+my $active = Test::Nginx::HTTP2->new(port(8086));
+$sid = $active->new_stream({ path => '/t1.html' });
+$active->read(all => [{ sid => $sid, length => 2**16 - 1 }]);
+
+$t->stop();
+
+$frames = $s->read(all => [{ type => 'GOAWAY' }]);
+($frame) = grep { $_->{type} eq "GOAWAY" } @$frames;
+ok($frame, 'GOAWAY on connection close - idle stream');
+
+$frames = $active->read(all => [{ type => 'GOAWAY' }]);
+($frame) = grep { $_->{type} eq "GOAWAY" } @$frames;
+ok($frame, 'GOAWAY on connection close - active stream');
+
+###############################################################################
+
+sub gunzip_like {
+	my ($in, $re, $name) = @_;
+
+	SKIP: {
+		eval { require IO::Uncompress::Gunzip; };
+		Test::More::skip(
+			"IO::Uncompress::Gunzip not installed", 1) if $@;
+
+		my $out;
+
+		IO::Uncompress::Gunzip::gunzip(\$in => \$out);
+
+		like($out, $re, $name);
+	}
+}
+
+###############################################################################
diff --git a/tests/h2_auth_request.t b/tests/h2_auth_request.t
new file mode 100644
index 0000000..ab52dc2
--- /dev/null
+++ b/tests/h2_auth_request.t
@@ -0,0 +1,86 @@
+#!/usr/bin/perl
+
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+
+# Tests for HTTP/2 protocol with auth_request.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::HTTP2;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http http_v2 rewrite proxy auth_request/)
+	->plan(2);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080 http2;
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location / {
+            return 200;
+        }
+        location /auth {
+            add_header X-Body-File $request_body_file;
+            client_body_buffer_size 512;
+            auth_request /auth_request;
+            proxy_pass http://127.0.0.1:8081/auth_proxy;
+        }
+        location /auth_request {
+            proxy_pass http://127.0.0.1:8081/;
+            proxy_pass_request_body off;
+            proxy_set_header Content-Length "";
+        }
+        location /auth_proxy {
+            add_header X-Body $request_body;
+            proxy_pass http://127.0.0.1:8081/;
+        }
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+my ($s, $sid, $frames, $frame);
+
+# second stream is used to induce body corruption issue
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/auth', method => 'POST', body => 'A' x 600 });
+$s->new_stream({ path => '/auth', method => 'POST', body => 'B' x 600 });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" && $_->{sid} == $sid } @$frames;
+is($frame->{headers}->{'x-body'}, 'A' x 600, 'auth request body');
+isnt($frame->{headers}->{'x-body-file'}, undef, 'auth request body file');
+
+###############################################################################
diff --git a/tests/h2_fastcgi_request_buffering.t b/tests/h2_fastcgi_request_buffering.t
new file mode 100644
index 0000000..00b95a8
--- /dev/null
+++ b/tests/h2_fastcgi_request_buffering.t
@@ -0,0 +1,279 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for HTTP/2 protocol with unbuffered request body and fastcgi backend.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::HTTP2;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http http_v2 fastcgi/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080 http2;
+        server_name  localhost;
+
+        location / {
+            fastcgi_request_buffering off;
+            fastcgi_pass 127.0.0.1:8081;
+            fastcgi_param REQUEST_URI $request_uri;
+            client_body_buffer_size 1k;
+        }
+    }
+}
+
+EOF
+
+$t->run();
+$t->plan(48);
+
+###############################################################################
+
+# unbuffered request body to fastcgi
+
+my $f = get_body('/');
+ok($f->{headers}, 'request');
+is($f->{upload}('01234', body_more => 1), '01234', 'part');
+is($f->{upload}('56789'), '56789_eos', 'part 2');
+is($f->{http_end}(), 200, 'response');
+
+$f = get_body('/');
+ok($f->{headers}, 'buffer');
+is($f->{upload}('0123' x 128, body_more => 1), '0123' x 128, 'buffer - below');
+is($f->{upload}('4567' x 128, body_more => 1), '4567' x 128, 'buffer - equal');
+is($f->{upload}('89AB' x 128), '89AB' x 128 . '_eos', 'buffer - above');
+is($f->{http_end}(), 200, 'buffer - response');
+
+$f = get_body('/');
+ok($f->{headers}, 'many');
+is($f->{upload}('01234many', body_split => [ 5 ], body_more => 1),
+	'01234many', 'many - part');
+is($f->{upload}('56789many', body_split => [ 5 ]),
+	'56789many_eos', 'many - part 2');
+is($f->{http_end}(), 200, 'many - response');
+
+$f = get_body('/');
+ok($f->{headers}, 'empty');
+is($f->{upload}('', body_more => 1, wait => 0.2), '', 'empty - part');
+is($f->{upload}(''), '_eos', 'empty - part 2');
+is($f->{http_end}(), 200, 'empty - response');
+
+$f = get_body('/');
+ok($f->{headers}, 'split');
+is($f->{upload}('0123456789', split => [ 14 ]), '0123456789_eos',
+	'split - part');
+is($f->{http_end}(), 200, 'split - response');
+
+# unbuffered request body to fastcgi, content-length
+
+$f = get_body('/', 'content-length' => 10);
+ok($f->{headers}, 'cl');
+
+is($f->{upload}('01234', body_more => 1), '01234', 'cl - part');
+is($f->{upload}('56789'), '56789_eos', 'cl - part 2');
+is($f->{http_end}(), 200, 'cl - response');
+
+$f = get_body('/', 'content-length' => 1536);
+ok($f->{headers}, 'cl buffer');
+is($f->{upload}('0123' x 128, body_more => 1), '0123' x 128,
+	'cl buffer - below');
+is($f->{upload}('4567' x 128, body_more => 1), '4567' x 128,
+	'cl buffer - equal');
+is($f->{upload}('89AB' x 128), '89AB' x 128 . '_eos', 'cl buffer - above');
+is($f->{http_end}(), 200, 'cl buffer - response');
+
+$f = get_body('/', 'content-length' => 10);
+ok($f->{headers}, 'cl much');
+is($f->{upload}('0123456789', body_more => 1), '0123456789', 'cl much - part');
+is($f->{upload}('many'), '', 'cl much - part 2');
+is($f->{http_end}(), 400, 'cl much - response');
+
+$f = get_body('/', 'content-length' => 10);
+ok($f->{headers}, 'cl less');
+is($f->{upload}('0123', body_more => 1), '0123', 'cl less - part');
+is($f->{upload}('56789'), '', 'cl less - part 2');
+is($f->{http_end}(), 400, 'cl less - response');
+
+$f = get_body('/', 'content-length' => 18);
+ok($f->{headers}, 'cl many');
+is($f->{upload}('01234many', body_split => [ 5 ], body_more => 1),
+	'01234many', 'cl many - part');
+is($f->{upload}('56789many', body_split => [ 5 ]), '56789many_eos',
+	'cl many - part 2');
+is($f->{http_end}(), 200, 'cl many - response');
+
+$f = get_body('/', 'content-length' => 0);
+ok($f->{headers}, 'cl empty');
+is($f->{upload}('', body_more => 1, wait => 0.2), '', 'cl empty - part');
+is($f->{upload}(''), '_eos', 'cl empty - part 2');
+is($f->{http_end}(), 200, 'cl empty - response');
+
+$f = get_body('/', 'content-length' => 10);
+ok($f->{headers}, 'cl split');
+is($f->{upload}('0123456789', split => [ 14 ]), '0123456789_eos', 'cl split');
+is($f->{http_end}(), 200, 'cl split - response');
+
+###############################################################################
+
+# Simple FastCGI responder implementation.
+
+# http://www.fastcgi.com/devkit/doc/fcgi-spec.html
+
+sub fastcgi_read_record($) {
+	my ($buf) = @_;
+	my $h;
+
+	return undef unless length $$buf;
+
+	@{$h}{qw/ version type id clen plen /} = unpack("CCnnC", $$buf);
+
+	$h->{content} = substr $$buf, 8, $h->{clen};
+	$h->{padding} = substr $$buf, 8 + $h->{clen}, $h->{plen};
+
+	$$buf = substr $$buf, 8 + $h->{clen} + $h->{plen};
+
+	return $h;
+}
+
+sub fastcgi_respond($$$$) {
+	my ($socket, $version, $id, $body) = @_;
+
+	# stdout
+	$socket->write(pack("CCnnCx", $version, 6, $id, length($body), 0));
+	$socket->write($body);
+
+	# close stdout
+	$socket->write(pack("CCnnCx", $version, 6, $id, 0, 0));
+
+	# end request
+	$socket->write(pack("CCnnCx", $version, 3, $id, 8, 0));
+	$socket->write(pack("NCxxx", 0, 0));
+}
+
+sub get_body {
+	my ($url, %extra) = @_;
+	my ($server, $client, $f);
+
+	$server = IO::Socket::INET->new(
+		Proto => 'tcp',
+		LocalHost => '127.0.0.1',
+		LocalPort => port(8081),
+		Listen => 5,
+		Timeout => 3,
+		Reuse => 1
+	)
+		or die "Can't create listening socket: $!\n";
+
+	my $s = Test::Nginx::HTTP2->new();
+	my $sid = exists $extra{'content-length'}
+		? $s->new_stream({ headers => [
+			{ name => ':method', value => 'GET' },
+			{ name => ':scheme', value => 'http' },
+			{ name => ':path', value => $url, },
+			{ name => ':authority', value => 'localhost' },
+			{ name => 'content-length',
+				value => $extra{'content-length'} }],
+			body_more => 1 })
+		: $s->new_stream({ path => $url, body_more => 1 });
+
+	$client = $server->accept() or return;
+
+	log2c("(new connection $client)");
+
+	$f->{headers} = backend_read($client);
+
+	my $h = fastcgi_read_record(\$f->{headers});
+	my $version = $h->{version};
+	my $id = $h->{id};
+
+	$f->{upload} = sub {
+		my ($body, %extra) = @_;
+		my $len = length($body);
+		my $wait = $extra{wait};
+
+		$s->h2_body($body, { %extra });
+
+		$body = '';
+
+		for (1 .. 10) {
+			my $buf = backend_read($client, $wait) or return '';
+
+			while (my $h = fastcgi_read_record(\$buf)) {
+
+				# skip everything unless stdin
+				next if $h->{type} != 5;
+
+				$body .= $h->{content};
+
+				# mark the end-of-stream indication
+				$body .= "_eos" if $h->{clen} == 0;
+			}
+
+			last if length($body) >= $len;
+		}
+
+		return $body;
+	};
+	$f->{http_end} = sub {
+		local $SIG{PIPE} = 'IGNORE';
+
+		fastcgi_respond($client, $version, $id, <<EOF);
+Status: 200 OK
+Connection: close
+
+OK
+EOF
+
+		$client->close;
+
+		my $frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+		my ($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+		return $frame->{headers}->{':status'};
+	};
+	return $f;
+}
+
+sub backend_read {
+	my ($s, $timo) = @_;
+	my $buf = '';
+
+	if (IO::Select->new($s)->can_read($timo || 8)) {
+		$s->sysread($buf, 16384) or return;
+		log2i($buf);
+	}
+	return $buf;
+}
+
+sub log2i { Test::Nginx::log_core('|| <<', @_); }
+sub log2o { Test::Nginx::log_core('|| >>', @_); }
+sub log2c { Test::Nginx::log_core('||', @_); }
+
+###############################################################################
diff --git a/tests/h2_headers.t b/tests/h2_headers.t
new file mode 100644
index 0000000..91c82d1
--- /dev/null
+++ b/tests/h2_headers.t
@@ -0,0 +1,1199 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for HTTP/2 headers.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::HTTP2;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http http_v2 proxy rewrite/)->plan(104)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080 http2;
+        listen       127.0.0.1:8081;
+        listen       127.0.0.1:8082 http2 sndbuf=128;
+        server_name  localhost;
+
+        http2_max_field_size 128k;
+        http2_max_header_size 128k;
+
+        location / {
+            add_header X-Sent-Foo $http_x_foo;
+            add_header X-Referer $http_referer;
+            return 200;
+        }
+        location /frame_size {
+            add_header X-LongHeader $arg_h;
+            add_header X-LongHeader $arg_h;
+            add_header X-LongHeader $arg_h;
+            alias %%TESTDIR%%/t2.html;
+        }
+        location /continuation {
+            add_header X-LongHeader $arg_h;
+            add_header X-LongHeader $arg_h;
+            add_header X-LongHeader $arg_h;
+            return 200 body;
+
+            location /continuation/204 {
+                return 204;
+            }
+        }
+        location /proxy/ {
+            add_header X-UC-a $upstream_cookie_a;
+            add_header X-UC-c $upstream_cookie_c;
+            proxy_pass http://127.0.0.1:8083/;
+            proxy_set_header X-Cookie-a $cookie_a;
+            proxy_set_header X-Cookie-c $cookie_c;
+        }
+        location /proxy2/ {
+            proxy_pass http://127.0.0.1:8081/;
+        }
+        location /set-cookie {
+            add_header Set-Cookie a=b;
+            add_header Set-Cookie c=d;
+            return 200;
+        }
+        location /cookie {
+            add_header X-Cookie $http_cookie;
+            add_header X-Cookie-a $cookie_a;
+            add_header X-Cookie-c $cookie_c;
+            return 200;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8084 http2;
+        server_name  localhost;
+
+        http2_max_field_size 22;
+    }
+
+    server {
+        listen       127.0.0.1:8085 http2;
+        server_name  localhost;
+
+        http2_max_header_size 64;
+    }
+
+    server {
+        listen       127.0.0.1:8086 http2;
+        server_name  localhost;
+
+        underscores_in_headers on;
+        add_header X-Sent-Foo $http_x_foo always;
+    }
+
+    server {
+        listen       127.0.0.1:8087 http2;
+        server_name  localhost;
+
+        ignore_invalid_headers off;
+        add_header X-Sent-Foo $http_x_foo always;
+    }
+}
+
+EOF
+
+$t->run_daemon(\&http_daemon);
+$t->run()->waitforsocket('127.0.0.1:' . port(8083));
+
+# file size is slightly beyond initial window size: 2**16 + 80 bytes
+
+$t->write_file('t1.html',
+	join('', map { sprintf "X%04dXXX", $_ } (1 .. 8202)));
+
+$t->write_file('t2.html', 'SEE-THIS');
+
+###############################################################################
+
+# 6.1. Indexed Header Field Representation
+
+my $s = Test::Nginx::HTTP2->new();
+my $sid = $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET', mode => 0 },
+	{ name => ':scheme', value => 'http', mode => 0 },
+	{ name => ':path', value => '/', mode => 0 },
+	{ name => ':authority', value => 'localhost', mode => 1 }]});
+my $frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+my ($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200, 'indexed header field');
+
+# 6.2.1. Literal Header Field with Incremental Indexing
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET', mode => 1, huff => 0 },
+	{ name => ':scheme', value => 'http', mode => 1, huff => 0 },
+	{ name => ':path', value => '/', mode => 1, huff => 0 },
+	{ name => ':authority', value => 'localhost', mode => 1, huff => 0 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200, 'literal with indexing');
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET', mode => 1, huff => 1 },
+	{ name => ':scheme', value => 'http', mode => 1, huff => 1 },
+	{ name => ':path', value => '/', mode => 1, huff => 1 },
+	{ name => ':authority', value => 'localhost', mode => 1, huff => 1 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200, 'literal with indexing - huffman');
+
+# 6.2.1. Literal Header Field with Incremental Indexing -- New Name
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET', mode => 2, huff => 0 },
+	{ name => ':scheme', value => 'http', mode => 2, huff => 0 },
+	{ name => ':path', value => '/', mode => 2, huff => 0 },
+	{ name => ':authority', value => 'localhost', mode => 2, huff => 0 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200, 'literal with indexing - new');
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET', mode => 2, huff => 1 },
+	{ name => ':scheme', value => 'http', mode => 2, huff => 1 },
+	{ name => ':path', value => '/', mode => 2, huff => 1 },
+	{ name => ':authority', value => 'localhost', mode => 2, huff => 1 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200, 'literal with indexing - new huffman');
+
+# 6.2.2. Literal Header Field without Indexing
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET', mode => 3, huff => 0 },
+	{ name => ':scheme', value => 'http', mode => 3, huff => 0 },
+	{ name => ':path', value => '/', mode => 3, huff => 0 },
+	{ name => ':authority', value => 'localhost', mode => 3, huff => 0 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200, 'literal without indexing');
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET', mode => 3, huff => 1 },
+	{ name => ':scheme', value => 'http', mode => 3, huff => 1 },
+	{ name => ':path', value => '/', mode => 3, huff => 1 },
+	{ name => ':authority', value => 'localhost', mode => 3, huff => 1 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200, 'literal without indexing - huffman');
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET', mode => 3, huff => 0 },
+	{ name => ':scheme', value => 'http', mode => 3, huff => 0 },
+	{ name => ':path', value => '/', mode => 3, huff => 0 },
+	{ name => ':authority', value => 'localhost', mode => 3, huff => 0 },
+	{ name => 'referer', value => 'foo', mode => 3, huff => 0 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200,
+	'literal without indexing - multibyte index');
+is($frame->{headers}->{'x-referer'}, 'foo',
+	'literal without indexing - multibyte index value');
+
+# 6.2.2. Literal Header Field without Indexing -- New Name
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET', mode => 4, huff => 0 },
+	{ name => ':scheme', value => 'http', mode => 4, huff => 0 },
+	{ name => ':path', value => '/', mode => 4, huff => 0 },
+	{ name => ':authority', value => 'localhost', mode => 4, huff => 0 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200, 'literal without indexing - new');
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET', mode => 4, huff => 1 },
+	{ name => ':scheme', value => 'http', mode => 4, huff => 1 },
+	{ name => ':path', value => '/', mode => 4, huff => 1 },
+	{ name => ':authority', value => 'localhost', mode => 4, huff => 1 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200,
+	'literal without indexing - new huffman');
+
+# 6.2.3. Literal Header Field Never Indexed
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET', mode => 5, huff => 0 },
+	{ name => ':scheme', value => 'http', mode => 5, huff => 0 },
+	{ name => ':path', value => '/', mode => 5, huff => 0 },
+	{ name => ':authority', value => 'localhost', mode => 5, huff => 0 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200, 'literal never indexed');
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET', mode => 5, huff => 1 },
+	{ name => ':scheme', value => 'http', mode => 5, huff => 1 },
+	{ name => ':path', value => '/', mode => 5, huff => 1 },
+	{ name => ':authority', value => 'localhost', mode => 5, huff => 1 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200, 'literal never indexed - huffman');
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET', mode => 5, huff => 0 },
+	{ name => ':scheme', value => 'http', mode => 5, huff => 0 },
+	{ name => ':path', value => '/', mode => 5, huff => 0 },
+	{ name => ':authority', value => 'localhost', mode => 5, huff => 0 },
+	{ name => 'referer', value => 'foo', mode => 5, huff => 0 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200,
+	'literal never indexed - multibyte index');
+is($frame->{headers}->{'x-referer'}, 'foo',
+	'literal never indexed - multibyte index value');
+
+# 6.2.3. Literal Header Field Never Indexed -- New Name
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET', mode => 6, huff => 0 },
+	{ name => ':scheme', value => 'http', mode => 6, huff => 0 },
+	{ name => ':path', value => '/', mode => 6, huff => 0 },
+	{ name => ':authority', value => 'localhost', mode => 6, huff => 0 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200, 'literal never indexed - new');
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET', mode => 6, huff => 1 },
+	{ name => ':scheme', value => 'http', mode => 6, huff => 1 },
+	{ name => ':path', value => '/', mode => 6, huff => 1 },
+	{ name => ':authority', value => 'localhost', mode => 6, huff => 1 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200, 'literal never indexed - new huffman');
+
+# reuse literal with multibyte indexing
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET', mode => 0 },
+	{ name => ':scheme', value => 'http', mode => 0 },
+	{ name => ':path', value => '/', mode => 0 },
+	{ name => ':authority', value => 'localhost', mode => 1 },
+	{ name => 'referer', value => 'foo', mode => 1 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{'x-referer'}, 'foo', 'value with indexing - new');
+
+$sid = $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET', mode => 0 },
+	{ name => ':scheme', value => 'http', mode => 0 },
+	{ name => ':path', value => '/', mode => 0 },
+	{ name => ':authority', value => 'localhost', mode => 0 },
+	{ name => 'referer', value => 'foo', mode => 0 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{'x-referer'}, 'foo', 'value with indexing - indexed');
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET', mode => 0 },
+	{ name => ':scheme', value => 'http', mode => 0 },
+	{ name => ':path', value => '/', mode => 0 },
+	{ name => ':authority', value => 'localhost', mode => 1 },
+	{ name => 'x-foo', value => 'X-Bar', mode => 2 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{'x-sent-foo'}, 'X-Bar', 'name with indexing - new');
+
+# reuse literal with multibyte indexing - reused name
+
+$sid = $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET', mode => 0 },
+	{ name => ':scheme', value => 'http', mode => 0 },
+	{ name => ':path', value => '/', mode => 0 },
+	{ name => ':authority', value => 'localhost', mode => 0 },
+	{ name => 'x-foo', value => 'X-Bar', mode => 0 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{'x-sent-foo'}, 'X-Bar', 'name with indexing - indexed');
+
+# reuse literal with multibyte indexing - reused name only
+
+$sid = $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET', mode => 0 },
+	{ name => ':scheme', value => 'http', mode => 0 },
+	{ name => ':path', value => '/', mode => 0 },
+	{ name => ':authority', value => 'localhost', mode => 0 },
+	{ name => 'x-foo', value => 'X-Baz', mode => 1 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{'x-sent-foo'}, 'X-Baz',
+	'name with indexing - indexed name');
+
+# response header field with characters not suitable for huffman encoding
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET', mode => 0 },
+	{ name => ':scheme', value => 'http', mode => 0 },
+	{ name => ':path', value => '/', mode => 0 },
+	{ name => ':authority', value => 'localhost', mode => 1 },
+	{ name => 'x-foo', value => '{{{{{', mode => 2 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{'x-sent-foo'}, '{{{{{', 'rare chars');
+like($s->{headers}, qr/\Q{{{{{/, 'rare chars - no huffman encoding');
+
+# response header field with huffman encoding
+# NB: implementation detail, not obligated
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET', mode => 0 },
+	{ name => ':scheme', value => 'http', mode => 0 },
+	{ name => ':path', value => '/', mode => 0 },
+	{ name => ':authority', value => 'localhost', mode => 1 },
+	{ name => 'x-foo', value => 'aaaaa', mode => 2 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{'x-sent-foo'}, 'aaaaa', 'well known chars');
+unlike($s->{headers}, qr/aaaaa/, 'well known chars - huffman encoding');
+
+# response header field with huffman encoding - complete table mod \0, CR, LF
+# first saturate with short-encoded characters (NB: implementation detail)
+
+my $field = pack "C*", ((map { 97 } (1 .. 862)), 1 .. 9, 11, 12, 14 .. 255);
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET', mode => 0 },
+	{ name => ':scheme', value => 'http', mode => 0 },
+	{ name => ':path', value => '/', mode => 0 },
+	{ name => ':authority', value => 'localhost', mode => 1 },
+	{ name => 'x-foo', value => $field, mode => 2 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{'x-sent-foo'}, $field, 'all chars');
+unlike($s->{headers}, qr/abcde/, 'all chars - huffman encoding');
+
+# 6.3.  Dynamic Table Size Update
+
+# remove some indexed headers from the dynamic table
+# by maintaining dynamic table space only for index 0
+# 'x-foo' has index 0, and 'referer' has index 1
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET', mode => 0 },
+	{ name => ':scheme', value => 'http', mode => 0 },
+	{ name => ':path', value => '/', mode => 0 },
+	{ name => ':authority', value => 'localhost', mode => 1 },
+	{ name => 'referer', value => 'foo', mode => 1 },
+	{ name => 'x-foo', value => 'X-Bar', mode => 2 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+$sid = $s->new_stream({ table_size => 61, headers => [
+	{ name => ':method', value => 'GET', mode => 0 },
+	{ name => ':scheme', value => 'http', mode => 0 },
+	{ name => ':path', value => '/', mode => 0 },
+	{ name => 'x-foo', value => 'X-Bar', mode => 0 },
+	{ name => ':authority', value => 'localhost', mode => 1 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+isnt($frame, undef, 'updated table size - remaining index');
+
+$sid = $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET', mode => 0 },
+	{ name => ':scheme', value => 'http', mode => 0 },
+	{ name => ':path', value => '/', mode => 0 },
+	{ name => ':authority', value => 'localhost', mode => 1 },
+	{ name => 'referer', value => 'foo', mode => 0 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "GOAWAY" } @$frames;
+is($frame->{code}, 0x9, 'invalid index');
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET', mode => 0 },
+	{ name => ':scheme', value => 'http', mode => 0 },
+	{ name => ':path', value => '/', mode => 0 },
+	{ name => ':authority', value => 'localhost', mode => 1 },
+	{ name => 'unknown', value => 'foo', mode => 3 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "GOAWAY" } @$frames;
+is($frame->{code}, 0x9, 'invalid index in literal header field');
+
+# 5.4.1.  Connection Error Handling
+#   An endpoint that encounters a connection error SHOULD first send a
+#   GOAWAY frame <..>
+
+($frame) = grep { $_->{type} eq "GOAWAY" } @$frames;
+ok($frame, 'invalid index - GOAWAY');
+
+# RFC 7541, 2.3.3.  Index Address Space
+#   Indices strictly greater than the sum of the lengths of both tables
+#   MUST be treated as a decoding error.
+
+# 4.3.  Header Compression and Decompression
+#   A decoding error in a header block MUST be treated
+#   as a connection error of type COMPRESSION_ERROR.
+
+is($frame->{last_sid}, $sid, 'invalid index - GOAWAY last stream');
+is($frame->{code}, 9, 'invalid index - GOAWAY COMPRESSION_ERROR');
+
+# HPACK zero index
+
+# RFC 7541, 6.1  Indexed Header Field Representation
+#   The index value of 0 is not used.  It MUST be treated as a decoding
+#   error if found in an indexed header field representation.
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET', mode => 0 },
+	{ name => ':scheme', value => 'http', mode => 0 },
+	{ name => ':path', value => '/', mode => 0 },
+	{ name => ':authority', value => 'localhost', mode => 1 },
+	{ name => '', value => '', mode => 0 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+ok($frame, 'zero index - GOAWAY');
+is($frame->{code}, 9, 'zero index - GOAWAY COMPRESSION_ERROR');
+
+# invalid table size update
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ table_size => 4097, headers => [
+	{ name => ':method', value => 'GET', mode => 0 },
+	{ name => ':scheme', value => 'http', mode => 0 },
+	{ name => ':path', value => '/', mode => 0 },
+	{ name => 'x-foo', value => 'X-Bar', mode => 0 },
+	{ name => ':authority', value => 'localhost', mode => 1 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "GOAWAY" } @$frames;
+ok($frame, 'invalid table size - GOAWAY');
+is($frame->{last_sid}, $sid, 'invalid table size - GOAWAY last stream');
+is($frame->{code}, 9, 'invalid table size - GOAWAY COMPRESSION_ERROR');
+
+# request header field with multiple values
+
+# 8.1.2.5.  Compressing the Cookie Header Field
+#   To allow for better compression efficiency, the Cookie header field
+#   MAY be split into separate header fields <..>.
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET', mode => 0 },
+	{ name => ':scheme', value => 'http', mode => 0 },
+	{ name => ':path', value => '/cookie', mode => 2 },
+	{ name => ':authority', value => 'localhost', mode => 1 },
+	{ name => 'cookie', value => 'a=b', mode => 2},
+	{ name => 'cookie', value => 'c=d', mode => 2}]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{'x-cookie-a'}, 'b',
+	'multiple request header fields - cookie');
+is($frame->{headers}->{'x-cookie-c'}, 'd',
+	'multiple request header fields - cookie 2');
+is($frame->{headers}->{'x-cookie'}, 'a=b; c=d',
+	'multiple request header fields - semi-colon');
+
+# request header field with multiple values to HTTP backend
+
+# 8.1.2.5.  Compressing the Cookie Header Field
+#   these MUST be concatenated into a single octet string
+#   using the two-octet delimiter of 0x3B, 0x20 (the ASCII string "; ")
+#   before being passed into a non-HTTP/2 context, such as an HTTP/1.1
+#   connection <..>
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET', mode => 0 },
+	{ name => ':scheme', value => 'http', mode => 0 },
+	{ name => ':path', value => '/proxy/cookie', mode => 2 },
+	{ name => ':authority', value => 'localhost', mode => 1 },
+	{ name => 'cookie', value => 'a=b', mode => 2 },
+	{ name => 'cookie', value => 'c=d', mode => 2 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{'x-sent-cookie'}, 'a=b; c=d',
+	'multiple request header fields proxied - semi-colon');
+is($frame->{headers}->{'x-sent-cookie2'}, '',
+	'multiple request header fields proxied - dublicate cookie');
+is($frame->{headers}->{'x-sent-cookie-a'}, 'b',
+	'multiple request header fields proxied - cookie 1');
+is($frame->{headers}->{'x-sent-cookie-c'}, 'd',
+	'multiple request header fields proxied - cookie 2');
+
+# response header field with multiple values
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/set-cookie' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{'set-cookie'}[0], 'a=b',
+	'multiple response header fields - cookie');
+is($frame->{headers}->{'set-cookie'}[1], 'c=d',
+	'multiple response header fields - cookie 2');
+
+# response header field with multiple values from HTTP backend
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/proxy/set-cookie' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{'set-cookie'}[0], 'a=b',
+	'multiple response header proxied - cookie');
+is($frame->{headers}->{'set-cookie'}[1], 'c=d',
+	'multiple response header proxied - cookie 2');
+is($frame->{headers}->{'x-uc-a'}, 'b',
+	'multiple response header proxied - upstream cookie');
+is($frame->{headers}->{'x-uc-c'}, 'd',
+	'multiple response header proxied - upstream cookie 2');
+
+# CONTINUATION in response
+# put three long header fields (not less than SETTINGS_MAX_FRAME_SIZE/2)
+# to break header block into separate frames, one such field per frame
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/continuation?h=' . 'x' x 2**13 });
+
+$frames = $s->read(all => [{ sid => $sid, fin => 0x4 }]);
+my @data = grep { $_->{type} =~ "HEADERS|CONTINUATION" } @$frames;
+my $data = $data[-1];
+is(@{$data->{headers}{'x-longheader'}}, 3,
+	'response CONTINUATION - headers');
+is($data->{headers}{'x-longheader'}[0], 'x' x 2**13,
+	'response CONTINUATION - header 1');
+is($data->{headers}{'x-longheader'}[1], 'x' x 2**13,
+	'response CONTINUATION - header 2');
+is($data->{headers}{'x-longheader'}[2], 'x' x 2**13,
+	'response CONTINUATION - header 3');
+@data = sort { $a <=> $b } map { $_->{length} } @data;
+cmp_ok($data[-1], '<=', 2**14, 'response CONTINUATION - max frame size');
+
+# same but without response DATA frames
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/continuation/204?h=' . 'x' x 2**13 });
+
+$frames = $s->read(all => [{ sid => $sid, fin => 0x4 }]);
+@data = grep { $_->{type} =~ "HEADERS|CONTINUATION" } @$frames;
+$data = $data[-1];
+is(@{$data->{headers}{'x-longheader'}}, 3,
+	'no body CONTINUATION - headers');
+is($data->{headers}{'x-longheader'}[0], 'x' x 2**13,
+	'no body CONTINUATION - header 1');
+is($data->{headers}{'x-longheader'}[1], 'x' x 2**13,
+	'no body CONTINUATION - header 2');
+is($data->{headers}{'x-longheader'}[2], 'x' x 2**13,
+	'no body CONTINUATION - header 3');
+@data = sort { $a <=> $b } map { $_->{length} } @data;
+cmp_ok($data[-1], '<=', 2**14, 'no body CONTINUATION - max frame size');
+
+# response header block is always split by SETTINGS_MAX_FRAME_SIZE
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/continuation?h=' . 'x' x 2**15 });
+
+$frames = $s->read(all => [{ sid => $sid, fin => 0x4 }]);
+@data = grep { $_->{type} =~ "HEADERS|CONTINUATION" } @$frames;
+@data = sort { $a <=> $b } map { $_->{length} } @data;
+cmp_ok($data[-1], '<=', 2**14, 'response header frames limited');
+
+# response header frame sent in parts
+
+$s = Test::Nginx::HTTP2->new(port(8082));
+$s->h2_settings(0, 0x5 => 2**17);
+
+$sid = $s->new_stream({ path => '/frame_size?h=' . 'x' x 2**15 });
+$frames = $s->read(all => [{ sid => $sid, fin => 0x4 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+ok($frame, 'response header - parts');
+
+SKIP: {
+skip 'response header failed', 1 unless $frame;
+
+is(length join('', @{$frame->{headers}->{'x-longheader'}}), 98304,
+	'response header - headers');
+
+}
+
+# response header block split and sent in parts
+
+$s = Test::Nginx::HTTP2->new(port(8082));
+$sid = $s->new_stream({ path => '/continuation?h=' . 'x' x 2**15 });
+$frames = $s->read(all => [{ sid => $sid, fin => 0x4 }]);
+
+@data = grep { $_->{type} =~ "HEADERS|CONTINUATION" } @$frames;
+ok(@data, 'response header split');
+
+SKIP: {
+skip 'response header split failed', 2 unless @data;
+
+my ($lengths) = sort { $b <=> $a } map { $_->{length} } @data;
+cmp_ok($lengths, '<=', 16384, 'response header split - max size');
+
+is(length join('', @{$data[-1]->{headers}->{'x-longheader'}}), 98304,
+	'response header split - headers');
+
+}
+
+# max_field_size - header field name
+
+$s = Test::Nginx::HTTP2->new(port(8084));
+$sid = $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET', mode => 0 },
+	{ name => ':scheme', value => 'http', mode => 0 },
+	{ name => ':path', value => '/t2.html', mode => 1 },
+	{ name => ':authority', value => 'localhost', mode => 1 },
+	{ name => 'longname10' x 2 . 'x', value => 'value', mode => 2 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq 'DATA' } @$frames;
+ok($frame, 'field name size less');
+
+$sid = $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET', mode => 0 },
+	{ name => ':scheme', value => 'http', mode => 0 },
+	{ name => ':path', value => '/t2.html', mode => 1 },
+	{ name => ':authority', value => 'localhost', mode => 1 },
+	{ name => 'longname10' x 2 . 'x', value => 'value', mode => 2 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq 'DATA' } @$frames;
+ok($frame, 'field name size second');
+
+$s = Test::Nginx::HTTP2->new(port(8084));
+$sid = $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET', mode => 0 },
+	{ name => ':scheme', value => 'http', mode => 0 },
+	{ name => ':path', value => '/t2.html', mode => 1 },
+	{ name => ':authority', value => 'localhost', mode => 1 },
+	{ name => 'longname10' x 2 . 'xx', value => 'value', mode => 2 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq 'DATA' } @$frames;
+ok($frame, 'field name size equal');
+
+$s = Test::Nginx::HTTP2->new(port(8084));
+$sid = $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET', mode => 0 },
+	{ name => ':scheme', value => 'http', mode => 0 },
+	{ name => ':path', value => '/t2.html', mode => 1 },
+	{ name => ':authority', value => 'localhost', mode => 1 },
+	{ name => 'longname10' x 2 . 'xxx', value => 'value', mode => 2 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq 'DATA' } @$frames;
+is($frame, undef, 'field name size greater');
+
+# max_field_size - header field value
+
+$s = Test::Nginx::HTTP2->new(port(8084));
+$sid = $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET', mode => 0 },
+	{ name => ':scheme', value => 'http', mode => 0 },
+	{ name => ':path', value => '/t2.html', mode => 1 },
+	{ name => ':authority', value => 'localhost', mode => 1 },
+	{ name => 'name', value => 'valu5' x 4 . 'x', mode => 2 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq 'DATA' } @$frames;
+ok($frame, 'field value size less');
+
+$s = Test::Nginx::HTTP2->new(port(8084));
+$sid = $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET', mode => 0 },
+	{ name => ':scheme', value => 'http', mode => 0 },
+	{ name => ':path', value => '/t2.html', mode => 1 },
+	{ name => ':authority', value => 'localhost', mode => 1 },
+	{ name => 'name', value => 'valu5' x 4 . 'xx', mode => 2 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq 'DATA' } @$frames;
+ok($frame, 'field value size equal');
+
+$s = Test::Nginx::HTTP2->new(port(8084));
+$sid = $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET', mode => 0 },
+	{ name => ':scheme', value => 'http', mode => 0 },
+	{ name => ':path', value => '/t2.html', mode => 1 },
+	{ name => ':authority', value => 'localhost', mode => 1 },
+	{ name => 'name', value => 'valu5' x 4 . 'xxx', mode => 2 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq 'DATA' } @$frames;
+is($frame, undef, 'field value size greater');
+
+# max_header_size
+
+$s = Test::Nginx::HTTP2->new(port(8085));
+$sid = $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET', mode => 0 },
+	{ name => ':scheme', value => 'http', mode => 0 },
+	{ name => ':path', value => '/t2.html', mode => 1 },
+	{ name => ':authority', value => 'localhost', mode => 1 },
+	{ name => 'longname9', value => 'x', mode => 2 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq 'DATA' } @$frames;
+ok($frame, 'header size less');
+
+$sid = $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET', mode => 0 },
+	{ name => ':scheme', value => 'http', mode => 0 },
+	{ name => ':path', value => '/t2.html', mode => 1 },
+	{ name => ':authority', value => 'localhost', mode => 1 },
+	{ name => 'longname9', value => 'x', mode => 2 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq 'DATA' } @$frames;
+ok($frame, 'header size second');
+
+$s = Test::Nginx::HTTP2->new(port(8085));
+$sid = $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET', mode => 0 },
+	{ name => ':scheme', value => 'http', mode => 0 },
+	{ name => ':path', value => '/t2.html', mode => 1 },
+	{ name => ':authority', value => 'localhost', mode => 1 },
+	{ name => 'longname9', value => 'xx', mode => 2 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq 'DATA' } @$frames;
+ok($frame, 'header size equal');
+
+$s = Test::Nginx::HTTP2->new(port(8085));
+$sid = $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET', mode => 0 },
+	{ name => ':scheme', value => 'http', mode => 0 },
+	{ name => ':path', value => '/t2.html', mode => 1 },
+	{ name => ':authority', value => 'localhost', mode => 1 },
+	{ name => 'longname9', value => 'xxx', mode => 2 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq 'DATA' } @$frames;
+is($frame, undef, 'header size greater');
+
+# header size is based on (decompressed) header list
+# two extra 1-byte indices would otherwise fit in max_header_size
+
+$s = Test::Nginx::HTTP2->new(port(8085));
+$sid = $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET', mode => 0 },
+	{ name => ':scheme', value => 'http', mode => 0 },
+	{ name => ':path', value => '/t2.html', mode => 1 },
+	{ name => ':authority', value => 'localhost', mode => 1 },
+	{ name => 'longname9', value => 'x', mode => 2 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq 'DATA' } @$frames;
+ok($frame, 'header size new index');
+
+$sid = $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET', mode => 0 },
+	{ name => ':scheme', value => 'http', mode => 0 },
+	{ name => ':path', value => '/t2.html', mode => 1 },
+	{ name => ':authority', value => 'localhost', mode => 1 },
+	{ name => 'longname9', value => 'x', mode => 0 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq 'DATA' } @$frames;
+ok($frame, 'header size indexed');
+
+$sid = $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET', mode => 0 },
+	{ name => ':scheme', value => 'http', mode => 0 },
+	{ name => ':path', value => '/t2.html', mode => 1 },
+	{ name => ':authority', value => 'localhost', mode => 1 },
+	{ name => 'longname9', value => 'x', mode => 0 },
+	{ name => 'longname9', value => 'x', mode => 0 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq 'GOAWAY' } @$frames;
+is($frame->{code}, 0xb, 'header size indexed greater');
+
+# HPACK table boundary
+
+$s = Test::Nginx::HTTP2->new();
+$s->read(all => [{ sid => $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET', mode => 0 },
+	{ name => ':scheme', value => 'http', mode => 0 },
+	{ name => ':path', value => '/', mode => 0 },
+	{ name => ':authority', value => '', mode => 0 },
+	{ name => 'x' x 2016, value => 'x' x 2048, mode => 2 }]}), fin => 1 }]);
+$frames = $s->read(all => [{ sid => $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET', mode => 0 },
+	{ name => ':scheme', value => 'http', mode => 0 },
+	{ name => ':path', value => '/', mode => 0 },
+	{ name => ':authority', value => '', mode => 0 },
+	{ name => 'x' x 2016, value => 'x' x 2048, mode => 0 }]}), fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+ok($frame, 'HPACK table boundary');
+
+$s->read(all => [{ sid => $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET', mode => 0 },
+	{ name => ':scheme', value => 'http', mode => 0 },
+	{ name => ':path', value => '/', mode => 0 },
+	{ name => ':authority', value => '', mode => 0 },
+	{ name => 'x' x 33, value => 'x' x 4031, mode => 2 }]}), fin => 1 }]);
+$frames = $s->read(all => [{ sid => $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET', mode => 0 },
+	{ name => ':scheme', value => 'http', mode => 0 },
+	{ name => ':path', value => '/', mode => 0 },
+	{ name => ':authority', value => '', mode => 0 },
+	{ name => 'x' x 33, value => 'x' x 4031, mode => 0 }]}), fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+ok($frame, 'HPACK table boundary - header field name');
+
+$s->read(all => [{ sid => $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET', mode => 0 },
+	{ name => ':scheme', value => 'http', mode => 0 },
+	{ name => ':path', value => '/', mode => 0 },
+	{ name => ':authority', value => '', mode => 0 },
+	{ name => 'x', value => 'x' x 64, mode => 2 }]}), fin => 1 }]);
+$frames = $s->read(all => [{ sid => $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET', mode => 0 },
+	{ name => ':scheme', value => 'http', mode => 0 },
+	{ name => ':path', value => '/', mode => 0 },
+	{ name => ':authority', value => '', mode => 0 },
+	{ name => 'x', value => 'x' x 64, mode => 0 }]}), fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+ok($frame, 'HPACK table boundary - header field value');
+
+# ensure that request header field value with newline doesn't get split
+#
+# 10.3.  Intermediary Encapsulation Attacks
+#   Any request or response that contains a character not permitted
+#   in a header field value MUST be treated as malformed.
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET', mode => 0 },
+	{ name => ':scheme', value => 'http', mode => 0 },
+	{ name => ':path', value => '/proxy2/', mode => 1 },
+	{ name => ':authority', value => 'localhost', mode => 1 },
+	{ name => 'x-foo', value => "x-bar\r\nreferer:see-this", mode => 2 }]});
+$frames = $s->read(all => [{ type => 'RST_STREAM' }]);
+
+# 10.3.  Intermediary Encapsulation Attacks
+#   An intermediary therefore cannot translate an HTTP/2 request or response
+#   containing an invalid field name into an HTTP/1.1 message.
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+isnt($frame->{headers}->{'x-referer'}, 'see-this', 'newline in request header');
+
+# 8.1.2.6.  Malformed Requests and Responses
+#   Malformed requests or responses that are detected MUST be treated
+#   as a stream error (Section 5.4.2) of type PROTOCOL_ERROR.
+
+($frame) = grep { $_->{type} eq "RST_STREAM" } @$frames;
+is($frame->{sid}, $sid, 'newline in request header - RST_STREAM sid');
+is($frame->{length}, 4, 'newline in request header - RST_STREAM length');
+is($frame->{flags}, 0, 'newline in request header - RST_STREAM flags');
+is($frame->{code}, 1, 'newline in request header - RST_STREAM code');
+
+# invalid header name as seen with underscore should not lead to ignoring rest
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET', mode => 0 },
+	{ name => ':scheme', value => 'http', mode => 0 },
+	{ name => ':path', value => '/', mode => 0 },
+	{ name => ':authority', value => 'localhost', mode => 1 },
+	{ name => 'x_foo', value => "x-bar", mode => 2 },
+	{ name => 'referer', value => "see-this", mode => 1 }]});
+$frames = $s->read(all => [{ type => 'HEADERS' }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{'x-referer'}, 'see-this', 'after invalid header name');
+
+# other invalid header name characters as seen with ':' result in RST_STREAM
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET', mode => 0 },
+	{ name => ':scheme', value => 'http', mode => 0 },
+	{ name => ':path', value => '/', mode => 0 },
+	{ name => ':authority', value => 'localhost', mode => 1 },
+	{ name => 'x:foo', value => "x-bar", mode => 2 },
+	{ name => 'referer', value => "see-this", mode => 1 }]});
+$frames = $s->read(all => [{ type => 'RST_STREAM' }]);
+
+($frame) = grep { $_->{type} eq "RST_STREAM" } @$frames;
+is($frame->{sid}, $sid, 'colon in header name - RST_STREAM sid');
+is($frame->{code}, 1, 'colon in header name - RST_STREAM code');
+
+# header name with underscore - underscores_in_headers on
+
+$s = Test::Nginx::HTTP2->new(port(8086));
+$sid = $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET', mode => 0 },
+	{ name => ':scheme', value => 'http', mode => 0 },
+	{ name => ':path', value => '/', mode => 0 },
+	{ name => ':authority', value => 'localhost', mode => 1 },
+	{ name => 'x_foo', value => "x-bar", mode => 2 },
+	{ name => 'referer', value => "see-this", mode => 1 }]});
+$frames = $s->read(all => [{ type => 'HEADERS' }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{'x-sent-foo'}, 'x-bar',
+	'underscore in header name - underscores_in_headers');
+
+# header name with underscore - ignore_invalid_headers off
+
+$s = Test::Nginx::HTTP2->new(port(8087));
+$sid = $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET', mode => 0 },
+	{ name => ':scheme', value => 'http', mode => 0 },
+	{ name => ':path', value => '/', mode => 0 },
+	{ name => ':authority', value => 'localhost', mode => 1 },
+	{ name => 'x_foo', value => "x-bar", mode => 2 },
+	{ name => 'referer', value => "see-this", mode => 1 }]});
+$frames = $s->read(all => [{ type => 'HEADERS' }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{'x-sent-foo'}, 'x-bar',
+	'underscore in header name - ignore_invalid_headers');
+
+# missing mandatory request header ':scheme'
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET', mode => 0 },
+	{ name => ':path', value => '/', mode => 0 },
+	{ name => ':authority', value => 'localhost', mode => 1 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 400, 'incomplete headers');
+
+# empty request header ':authority'
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET', mode => 0 },
+	{ name => ':scheme', value => 'http', mode => 0 },
+	{ name => ':path', value => '/', mode => 0 },
+	{ name => ':authority', value => '', mode => 0 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 400, 'empty authority');
+
+# client sent invalid :path header
+
+$sid = $s->new_stream({ path => 't1.html' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 400, 'invalid path');
+
+
+# ngx_http_v2_parse_int() error handling
+
+# NGX_ERROR
+
+$s = Test::Nginx::HTTP2->new();
+{
+	local $SIG{PIPE} = 'IGNORE';
+	syswrite($s->{socket}, pack("x2C3NC", 1, 0x1, 5, 1, 0xff));
+}
+$frames = $s->read(all => [{ type => "GOAWAY" }]);
+
+($frame) = grep { $_->{type} eq 'GOAWAY' } @$frames;
+is($frame->{code}, 0x6, 'invalid index length');
+
+$s = Test::Nginx::HTTP2->new();
+{
+	local $SIG{PIPE} = 'IGNORE';
+	syswrite($s->{socket}, pack("x2C3NC2", 2, 0x1, 5, 1, 0x42, 0xff));
+}
+$frames = $s->read(all => [{ type => "GOAWAY" }]);
+
+($frame) = grep { $_->{type} eq 'GOAWAY' } @$frames;
+is($frame->{code}, 0x6, 'invalid literal length');
+
+# NGX_DECLINED
+
+$s = Test::Nginx::HTTP2->new();
+{
+	local $SIG{PIPE} = 'IGNORE';
+	syswrite($s->{socket}, pack("x2C3NN", 5, 0x1, 5, 1, 0xffffffff));
+}
+$frames = $s->read(all => [{ type => "GOAWAY" }]);
+
+($frame) = grep { $_->{type} eq 'GOAWAY' } @$frames;
+is($frame->{code}, 0x9, 'too long index');
+
+$s = Test::Nginx::HTTP2->new();
+{
+	local $SIG{PIPE} = 'IGNORE';
+	syswrite($s->{socket}, pack("x2C3NCN", 6, 0x1, 5, 1, 0x42, 0xffffffff));
+}
+$frames = $s->read(all => [{ type => "GOAWAY" }]);
+
+($frame) = grep { $_->{type} eq 'GOAWAY' } @$frames;
+is($frame->{code}, 0x9, 'too long literal');
+
+# NGX_AGAIN
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ split => [35], split_delay => 1.1, headers => [
+        { name => ':method', value => 'GET', mode => 3, huff => 0 },
+        { name => ':scheme', value => 'http', mode => 3, huff => 0 },
+        { name => ':path', value => '/', mode => 3, huff => 0 },
+        { name => ':authority', value => 'localhost', mode => 3, huff => 0 },
+        { name => 'referer', value => 'foo', mode => 3, huff => 0 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{'x-referer'}, 'foo', 'header split index');
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ split => [37], split_delay => 1.1, headers => [
+        { name => ':method', value => 'GET', mode => 3, huff => 0 },
+        { name => ':scheme', value => 'http', mode => 3, huff => 0 },
+        { name => ':path', value => '/', mode => 3, huff => 0 },
+        { name => ':authority', value => 'localhost', mode => 3, huff => 0 },
+        { name => 'referer', value => '1234' x 32, mode => 3, huff => 0 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{'x-referer'}, '1234' x 32, 'header split field length');
+
+###############################################################################
+
+sub http_daemon {
+	my $server = IO::Socket::INET->new(
+		Proto => 'tcp',
+		LocalHost => '127.0.0.1',
+		LocalPort => port(8083),
+		Listen => 5,
+		Reuse => 1
+	)
+		or die "Can't create listening socket: $!\n";
+
+	local $SIG{PIPE} = 'IGNORE';
+
+	while (my $client = $server->accept()) {
+		$client->autoflush(1);
+
+		my $headers = '';
+		my $uri = '';
+
+		while (<$client>) {
+			$headers .= $_;
+			last if (/^\x0d?\x0a?$/);
+		}
+
+		next if $headers eq '';
+		$uri = $1 if $headers =~ /^\S+\s+([^ ]+)\s+HTTP/i;
+
+		if ($uri eq '/cookie') {
+
+			my ($cookie, $cookie2) = $headers =~ /Cookie: (.+)/ig;
+			$cookie2 = '' unless defined $cookie2;
+
+			my ($cookie_a, $cookie_c) = ('', '');
+			$cookie_a = $1 if $headers =~ /X-Cookie-a: (.+)/i;
+			$cookie_c = $1 if $headers =~ /X-Cookie-c: (.+)/i;
+
+			print $client <<EOF;
+HTTP/1.1 200 OK
+Connection: close
+X-Sent-Cookie: $cookie
+X-Sent-Cookie2: $cookie2
+X-Sent-Cookie-a: $cookie_a
+X-Sent-Cookie-c: $cookie_c
+
+EOF
+
+		} elsif ($uri eq '/set-cookie') {
+
+			print $client <<EOF;
+HTTP/1.1 200 OK
+Connection: close
+Set-Cookie: a=b
+Set-Cookie: c=d
+
+EOF
+
+		}
+
+	} continue {
+		close $client;
+	}
+}
+
+###############################################################################
diff --git a/tests/h2_limit_conn.t b/tests/h2_limit_conn.t
new file mode 100644
index 0000000..e99e5f5
--- /dev/null
+++ b/tests/h2_limit_conn.t
@@ -0,0 +1,98 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for HTTP/2 protocol with limit_conn.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::HTTP2;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http http_v2 limit_conn/)->plan(4)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    limit_conn_zone  $binary_remote_addr  zone=conn:1m;
+
+    server {
+        listen       127.0.0.1:8080 http2;
+        server_name  localhost;
+
+        location /t.html {
+            limit_conn conn 1;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('t.html', 'SEE-THIS');
+$t->run();
+
+###############################################################################
+
+my $s = Test::Nginx::HTTP2->new();
+$s->h2_settings(0, 0x4 => 1);
+
+my $sid = $s->new_stream({ path => '/t.html' });
+my $frames = $s->read(all => [{ sid => $sid, length => 1 }]);
+
+my ($frame) = grep { $_->{type} eq "HEADERS" && $_->{sid} == $sid } @$frames;
+is($frame->{headers}->{':status'}, 200, 'limit_conn first stream');
+
+my $sid2 = $s->new_stream({ path => '/t.html' });
+$frames = $s->read(all => [{ sid => $sid2, length => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" && $_->{sid} == $sid2 } @$frames;
+is($frame->{headers}->{':status'}, 503, 'limit_conn rejected');
+
+$s->h2_settings(0, 0x4 => 2**16);
+
+$s->read(all => [
+	{ sid => $sid, fin => 1 },
+	{ sid => $sid2, fin => 1 }
+]);
+
+# limit_conn + client's RST_STREAM
+
+$s = Test::Nginx::HTTP2->new();
+$s->h2_settings(0, 0x4 => 1);
+
+$sid = $s->new_stream({ path => '/t.html' });
+$frames = $s->read(all => [{ sid => $sid, length => 1 }]);
+$s->h2_rst($sid, 5);
+
+($frame) = grep { $_->{type} eq "HEADERS" && $_->{sid} == $sid } @$frames;
+is($frame->{headers}->{':status'}, 200, 'RST_STREAM 1');
+
+$sid2 = $s->new_stream({ path => '/t.html' });
+$frames = $s->read(all => [{ sid => $sid2, length => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" && $_->{sid} == $sid2 } @$frames;
+is($frame->{headers}->{':status'}, 200, 'RST_STREAM 2');
+
+###############################################################################
diff --git a/tests/h2_limit_req.t b/tests/h2_limit_req.t
new file mode 100644
index 0000000..f5289e9
--- /dev/null
+++ b/tests/h2_limit_req.t
@@ -0,0 +1,175 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for HTTP/2 protocol with limit_req.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::HTTP2;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http http_v2 proxy rewrite limit_req/)
+	->plan(7);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    limit_req_zone   $binary_remote_addr  zone=req:1m rate=1r/s;
+
+    server {
+        listen       127.0.0.1:8080 http2;
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location / { }
+        location /limit_req {
+            limit_req  zone=req burst=2;
+            alias %%TESTDIR%%/t.html;
+        }
+        location /proxy_limit_req/ {
+            add_header X-Body $request_body;
+            add_header X-Body-File $request_body_file;
+            client_body_in_file_only on;
+            proxy_pass http://127.0.0.1:8081/;
+            limit_req  zone=req burst=2;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('index.html', '');
+$t->write_file('t.html', 'SEE-THIS');
+$t->run();
+
+###############################################################################
+
+# request body delayed in limit_req
+
+my $s = Test::Nginx::HTTP2->new();
+my $sid = $s->new_stream({ path => '/proxy_limit_req/', body_more => 1 });
+$s->h2_body('TEST');
+my $frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+my ($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is(read_body_file($frame->{headers}->{'x-body-file'}), 'TEST',
+	'request body - limit req');
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/proxy_limit_req/', body_more => 1 });
+select undef, undef, undef, 1.1;
+$s->h2_body('TEST');
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is(read_body_file($frame->{headers}->{'x-body-file'}), 'TEST',
+	'request body - limit req - limited');
+
+# request body delayed in limit_req - with an empty DATA frame
+# "zero size buf in output" alerts seen
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/proxy_limit_req/', body_more => 1 });
+$s->h2_body('');
+select undef, undef, undef, 1.1;
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200, 'request body - limit req - empty');
+
+# predict send windows
+
+$sid = $s->new_stream();
+my ($maxwin) = sort {$a <=> $b} $s->{streams}{$sid}, $s->{conn_window};
+
+SKIP: {
+skip 'not enough window', 1 if $maxwin < 5;
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/proxy_limit_req/', body => 'TEST2' });
+select undef, undef, undef, 1.1;
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is(read_body_file($frame->{headers}->{'x-body-file'}), 'TEST2',
+	'request body - limit req 2');
+
+}
+
+# partial request body data frame received (to be discarded) within request
+# delayed in limit_req, the rest of data frame is received after response
+
+$s = Test::Nginx::HTTP2->new();
+
+SKIP: {
+skip 'not enough window', 1 if $maxwin < 4;
+
+$sid = $s->new_stream({ path => '/limit_req', body => 'TEST', split => [61],
+	split_delay => 1.1 });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, '200', 'discard body - limit req - limited');
+
+}
+
+$sid = $s->new_stream({ path => '/' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, '200', 'discard body - limit req - next');
+
+# ditto, but instead of receiving the rest of data frame, connection is closed
+# 'http request already closed while closing request' alert can be produced
+
+SKIP: {
+skip 'not enough window', 1 if $maxwin < 4;
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/limit_req', body => 'TEST', split => [61],
+	abort => 1 });
+
+select undef, undef, undef, 1.1;
+close $s->{socket};
+
+pass('discard body - limit req - eof');
+
+}
+
+###############################################################################
+
+sub read_body_file {
+	my ($path) = @_;
+	return unless $path;
+	open FILE, $path or return "$!";
+	local $/;
+	my $content = <FILE>;
+	close FILE;
+	return $content;
+}
+
+###############################################################################
diff --git a/tests/h2_max_requests.t b/tests/h2_max_requests.t
new file mode 100644
index 0000000..f3184bf
--- /dev/null
+++ b/tests/h2_max_requests.t
@@ -0,0 +1,80 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for HTTP/2 protocol, http2_max_requests directive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::HTTP2;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http http_v2/)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080 http2;
+        server_name  localhost;
+
+        http2_max_requests 2;
+
+        location / { }
+    }
+}
+
+EOF
+
+$t->write_file('index.html', '');
+$t->run()->plan(5);
+
+###############################################################################
+
+my $s = Test::Nginx::HTTP2->new();
+my $frames = $s->read(all => [{ sid => $s->new_stream(), fin => 1 }]);
+
+my ($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200, 'max requests');
+
+$frames = $s->read(all => [{ type => 'GOAWAY' }], wait => 0.5)
+	unless grep { $_->{type} eq "GOAWAY" } @$frames;
+
+($frame) = grep { $_->{type} eq "GOAWAY" } @$frames;
+is($frame, undef, 'max requests - GOAWAY');
+
+# max requests limited
+
+my $sid = $s->new_stream();
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }, { type => 'GOAWAY' }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200, 'max requests limited');
+
+($frame) = grep { $_->{type} eq "GOAWAY" } @$frames;
+ok($frame, 'max requests limited - GOAWAY');
+is($frame->{last_sid}, $sid, 'max requests limited - GOAWAY last stream');
+
+###############################################################################
diff --git a/tests/h2_priority.t b/tests/h2_priority.t
new file mode 100644
index 0000000..d17c7f5
--- /dev/null
+++ b/tests/h2_priority.t
@@ -0,0 +1,457 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for HTTP/2 protocol with priority.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::HTTP2;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http http_v2/)->plan(20)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080 http2;
+        server_name  localhost;
+    }
+}
+
+EOF
+
+$t->run();
+
+# file size is slightly beyond initial window size: 2**16 + 80 bytes
+
+$t->write_file('t1.html',
+	join('', map { sprintf "X%04dXXX", $_ } (1 .. 8202)));
+
+$t->write_file('t2.html', 'SEE-THIS');
+
+###############################################################################
+
+# stream muliplexing + PRIORITY frames
+
+my $s = Test::Nginx::HTTP2->new();
+my $sid = $s->new_stream({ path => '/t1.html' });
+$s->read(all => [{ sid => $sid, length => 2**16 - 1 }]);
+
+my $sid2 = $s->new_stream({ path => '/t2.html' });
+$s->read(all => [{ sid => $sid2, fin => 0x4 }]);
+
+$s->h2_priority(0, $sid);
+$s->h2_priority(255, $sid2);
+
+$s->h2_window(2**17, $sid);
+$s->h2_window(2**17, $sid2);
+$s->h2_window(2**17);
+
+my $frames = $s->read(all => [
+	{ sid => $sid, fin => 1 },
+	{ sid => $sid2, fin => 1 }
+]);
+
+my @data = grep { $_->{type} eq "DATA" } @$frames;
+is(join(' ', map { $_->{sid} } @data), "$sid2 $sid", 'weight - PRIORITY 1');
+
+# and vice versa
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/t1.html' });
+$s->read(all => [{ sid => $sid, length => 2**16 - 1 }]);
+
+$sid2 = $s->new_stream({ path => '/t2.html' });
+$s->read(all => [{ sid => $sid2, fin => 0x4 }]);
+
+$s->h2_priority(255, $sid);
+$s->h2_priority(0, $sid2);
+
+$s->h2_window(2**17, $sid);
+$s->h2_window(2**17, $sid2);
+$s->h2_window(2**17);
+
+$frames = $s->read(all => [
+	{ sid => $sid, fin => 1 },
+	{ sid => $sid2, fin => 1 }
+]);
+
+@data = grep { $_->{type} eq "DATA" } @$frames;
+is(join(' ', map { $_->{sid} } @data), "$sid $sid2", 'weight - PRIORITY 2');
+
+# stream muliplexing + HEADERS PRIORITY flag
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/t1.html', prio => 0 });
+$s->read(all => [{ sid => $sid, length => 2**16 - 1 }]);
+
+$sid2 = $s->new_stream({ path => '/t2.html', prio => 255 });
+$s->read(all => [{ sid => $sid2, fin => 0x4 }]);
+
+$s->h2_window(2**17, $sid);
+$s->h2_window(2**17, $sid2);
+$s->h2_window(2**17);
+
+$frames = $s->read(all => [
+	{ sid => $sid, fin => 1 },
+	{ sid => $sid2, fin => 1 }
+]);
+
+@data = grep { $_->{type} eq "DATA" } @$frames;
+my $sids = join ' ', map { $_->{sid} } @data;
+is($sids, "$sid2 $sid", 'weight - HEADERS PRIORITY 1');
+
+# and vice versa
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/t1.html', prio => 255 });
+$s->read(all => [{ sid => $sid, length => 2**16 - 1 }]);
+
+$sid2 = $s->new_stream({ path => '/t2.html', prio => 0 });
+$s->read(all => [{ sid => $sid2, fin => 0x4 }]);
+
+$s->h2_window(2**17, $sid);
+$s->h2_window(2**17, $sid2);
+$s->h2_window(2**17);
+
+$frames = $s->read(all => [
+	{ sid => $sid, fin => 1 },
+	{ sid => $sid2, fin => 1 }
+]);
+
+@data = grep { $_->{type} eq "DATA" } @$frames;
+$sids = join ' ', map { $_->{sid} } @data;
+is($sids, "$sid $sid2", 'weight - HEADERS PRIORITY 2');
+
+# 5.3.1.  Stream Dependencies
+
+# PRIORITY frame
+
+$s = Test::Nginx::HTTP2->new();
+
+$s->h2_priority(16, 3, 0);
+$s->h2_priority(16, 1, 3);
+
+$sid = $s->new_stream({ path => '/t1.html' });
+$s->read(all => [{ sid => $sid, length => 2**16 - 1 }]);
+
+$sid2 = $s->new_stream({ path => '/t2.html' });
+$s->read(all => [{ sid => $sid2, fin => 0x4 }]);
+
+$s->h2_window(2**17, $sid);
+$s->h2_window(2**17, $sid2);
+$s->h2_window(2**17);
+
+$frames = $s->read(all => [
+	{ sid => $sid, fin => 1 },
+	{ sid => $sid2, fin => 1 },
+]);
+
+@data = grep { $_->{type} eq "DATA" } @$frames;
+$sids = join ' ', map { $_->{sid} } @data;
+is($sids, "$sid2 $sid", 'dependency - PRIORITY 1');
+
+# and vice versa
+
+$s = Test::Nginx::HTTP2->new();
+
+$s->h2_priority(16, 1, 0);
+$s->h2_priority(16, 3, 1);
+
+$sid = $s->new_stream({ path => '/t1.html' });
+$s->read(all => [{ sid => $sid, length => 2**16 - 1 }]);
+
+$sid2 = $s->new_stream({ path => '/t2.html' });
+$s->read(all => [{ sid => $sid2, fin => 0x4 }]);
+
+$s->h2_window(2**17, $sid);
+$s->h2_window(2**17, $sid2);
+$s->h2_window(2**17);
+
+$frames = $s->read(all => [
+	{ sid => $sid, fin => 1 },
+	{ sid => $sid2, fin => 1 },
+]);
+
+@data = grep { $_->{type} eq "DATA" } @$frames;
+$sids = join ' ', map { $_->{sid} } @data;
+is($sids, "$sid $sid2", 'dependency - PRIORITY 2');
+
+# PRIORITY - self dependency
+
+# 5.3.1.  Stream Dependencies
+#   A stream cannot depend on itself.  An endpoint MUST treat this as a
+#   stream error of type PROTOCOL_ERROR.
+# Instead, we respond with a connection error of type PROTOCOL_ERROR.
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.17.4');
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream();
+$s->read(all => [{ sid => $sid, fin => 1 }]);
+
+$s->h2_priority(0, $sid, $sid);
+$frames = $s->read(all => [{ type => 'GOAWAY' }]);
+
+my ($frame) = grep { $_->{type} eq "GOAWAY" } @$frames;
+is($frame->{last_sid}, $sid, 'dependency - PRIORITY self - GOAWAY');
+is($frame->{code}, 1, 'dependency - PRIORITY self - PROTOCOL_ERROR');
+
+}
+
+# HEADERS PRIORITY flag, reprioritize prior PRIORITY frame records
+
+$s = Test::Nginx::HTTP2->new();
+
+$s->h2_priority(16, 1, 0);
+$s->h2_priority(16, 3, 0);
+
+$sid = $s->new_stream({ path => '/t1.html', dep => 3 });
+$s->read(all => [{ sid => $sid, length => 2**16 - 1 }]);
+
+$sid2 = $s->new_stream({ path => '/t2.html' });
+$s->read(all => [{ sid => $sid2, fin => 0x4 }]);
+
+$s->h2_window(2**17, $sid);
+$s->h2_window(2**17, $sid2);
+$s->h2_window(2**17);
+
+$frames = $s->read(all => [
+	{ sid => $sid, fin => 1 },
+	{ sid => $sid2, fin => 1 },
+]);
+
+@data = grep { $_->{type} eq "DATA" } @$frames;
+$sids = join ' ', map { $_->{sid} } @data;
+is($sids, "$sid2 $sid", 'dependency - HEADERS PRIORITY 1');
+
+# and vice versa
+
+$s = Test::Nginx::HTTP2->new();
+
+$s->h2_priority(16, 1, 0);
+$s->h2_priority(16, 3, 0);
+
+$sid = $s->new_stream({ path => '/t1.html' });
+$s->read(all => [{ sid => $sid, length => 2**16 - 1 }]);
+
+$sid2 = $s->new_stream({ path => '/t2.html', dep => 1 });
+$s->read(all => [{ sid => $sid2, fin => 0x4 }]);
+
+$s->h2_window(2**17, $sid);
+$s->h2_window(2**17, $sid2);
+$s->h2_window(2**17);
+
+$frames = $s->read(all => [
+	{ sid => $sid, fin => 1 },
+	{ sid => $sid2, fin => 1 },
+]);
+
+@data = grep { $_->{type} eq "DATA" } @$frames;
+$sids = join ' ', map { $_->{sid} } @data;
+is($sids, "$sid $sid2", 'dependency - HEADERS PRIORITY 2');
+
+# HEADERS - self dependency
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.17.4');
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ dep => 1 });
+$frames = $s->read(all => [{ type => 'GOAWAY' }]);
+
+my ($frame) = grep { $_->{type} eq "GOAWAY" } @$frames;
+is($frame->{last_sid}, 0, 'dependency - HEADERS self - GOAWAY');
+is($frame->{code}, 1, 'dependency - HEADERS self - PROTOCOL_ERROR');
+
+}
+
+# PRIORITY frame, weighted dependencies
+
+$s = Test::Nginx::HTTP2->new();
+
+$s->h2_priority(16, 5, 0);
+$s->h2_priority(255, 1, 5);
+$s->h2_priority(0, 3, 5);
+
+$sid = $s->new_stream({ path => '/t1.html' });
+$s->read(all => [{ sid => $sid, length => 2**16 - 1 }]);
+
+$sid2 = $s->new_stream({ path => '/t2.html' });
+$s->read(all => [{ sid => $sid2, fin => 0x4 }]);
+
+my $sid3 = $s->new_stream({ path => '/t2.html' });
+$s->read(all => [{ sid => $sid3, fin => 0x4 }]);
+
+$s->h2_window(2**16, 1);
+$s->h2_window(2**16, 3);
+$s->h2_window(2**16, 5);
+$s->h2_window(2**16);
+
+$frames = $s->read(all => [
+	{ sid => $sid, fin => 1 },
+	{ sid => $sid2, fin => 1 },
+	{ sid => $sid3, fin => 1 },
+]);
+
+@data = grep { $_->{type} eq "DATA" } @$frames;
+$sids = join ' ', map { $_->{sid} } @data;
+is($sids, "$sid3 $sid $sid2", 'weighted dependency - PRIORITY 1');
+
+# and vice versa
+
+$s = Test::Nginx::HTTP2->new();
+
+$s->h2_priority(16, 5, 0);
+$s->h2_priority(0, 1, 5);
+$s->h2_priority(255, 3, 5);
+
+$sid = $s->new_stream({ path => '/t1.html' });
+$s->read(all => [{ sid => $sid, length => 2**16 - 1 }]);
+
+$sid2 = $s->new_stream({ path => '/t2.html' });
+$s->read(all => [{ sid => $sid2, fin => 0x4 }]);
+
+$sid3 = $s->new_stream({ path => '/t2.html' });
+$s->read(all => [{ sid => $sid3, fin => 0x4 }]);
+
+$s->h2_window(2**16, 1);
+$s->h2_window(2**16, 3);
+$s->h2_window(2**16, 5);
+$s->h2_window(2**16);
+
+$frames = $s->read(all => [
+	{ sid => $sid, fin => 1 },
+	{ sid => $sid2, fin => 1 },
+	{ sid => $sid3, fin => 1 },
+]);
+
+@data = grep { $_->{type} eq "DATA" } @$frames;
+$sids = join ' ', map { $_->{sid} } @data;
+is($sids, "$sid3 $sid2 $sid", 'weighted dependency - PRIORITY 2');
+
+# PRIORITY - reprioritization with circular dependency - after [3] removed
+# initial dependency tree:
+# 1 <- [3] <- 5
+
+$s = Test::Nginx::HTTP2->new();
+
+$s->h2_window(2**18);
+
+$s->h2_priority(16, 1, 0);
+$s->h2_priority(16, 3, 1);
+$s->h2_priority(16, 5, 3);
+
+$sid = $s->new_stream({ path => '/t1.html' });
+$s->read(all => [{ sid => $sid, length => 2**16 - 1 }]);
+
+$sid2 = $s->new_stream({ path => '/t1.html' });
+$s->read(all => [{ sid => $sid2, length => 2**16 - 1 }]);
+
+$sid3 = $s->new_stream({ path => '/t1.html' });
+$s->read(all => [{ sid => $sid3, length => 2**16 - 1 }]);
+
+$s->h2_window(2**16, $sid2);
+
+$frames = $s->read(all => [{ sid => $sid2, fin => 1 }]);
+$sids = join ' ', map { $_->{sid} } grep { $_->{type} eq "DATA" } @$frames;
+is($sids, $sid2, 'removed dependency');
+
+for (1 .. 40) {
+	$s->read(all => [{ sid => $s->new_stream(), fin => 1 }]);
+}
+
+# make circular dependency
+# 1 <- 5 -- current dependency tree before reprioritization
+# 5 <- 1
+# 1 <- 5
+
+$s->h2_priority(16, 1, 5);
+$s->h2_priority(16, 5, 1);
+
+$s->h2_window(2**16, $sid);
+$s->h2_window(2**16, $sid3);
+
+$frames = $s->read(all => [
+	{ sid => $sid, fin => 1 },
+	{ sid => $sid3, fin => 1 },
+]);
+
+my ($frame) = grep { $_->{type} eq "DATA" && $_->{sid} == $sid } @$frames;
+is($frame->{length}, 81, 'removed dependency - first stream');
+
+($frame) = grep { $_->{type} eq "DATA" && $_->{sid} == $sid3 } @$frames;
+is($frame->{length}, 81, 'removed dependency - last stream');
+
+# PRIORITY - reprioritization with circular dependency - exclusive [5]
+# 1 <- [5] <- 3
+
+$s = Test::Nginx::HTTP2->new();
+
+$s->h2_window(2**18);
+
+$s->h2_priority(16, 1, 0);
+$s->h2_priority(16, 3, 1);
+$s->h2_priority(16, 5, 1, excl => 1);
+
+$sid = $s->new_stream({ path => '/t1.html' });
+$s->read(all => [{ sid => $sid, length => 2**16 - 1 }]);
+
+$sid2 = $s->new_stream({ path => '/t1.html' });
+$s->read(all => [{ sid => $sid2, length => 2**16 - 1 }]);
+
+$sid3 = $s->new_stream({ path => '/t1.html' });
+$s->read(all => [{ sid => $sid3, length => 2**16 - 1 }]);
+
+$s->h2_window(2**16, $sid);
+
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+$sids = join ' ', map { $_->{sid} } grep { $_->{type} eq "DATA" } @$frames;
+is($sids, $sid, 'exclusive dependency - parent removed');
+
+# make circular dependency
+# 5 <- 3 -- current dependency tree before reprioritization
+# 3 <- 5
+
+$s->h2_priority(16, 5, 3);
+
+$s->h2_window(2**16, $sid2);
+$s->h2_window(2**16, $sid3);
+
+$frames = $s->read(all => [
+	{ sid => $sid2, fin => 1 },
+	{ sid => $sid3, fin => 1 },
+]);
+
+($frame) = grep { $_->{type} eq "DATA" && $_->{sid} == $sid2 } @$frames;
+is($frame->{length}, 81, 'exclusive dependency - first stream');
+
+($frame) = grep { $_->{type} eq "DATA" && $_->{sid} == $sid3 } @$frames;
+is($frame->{length}, 81, 'exclusive dependency - last stream');
+
+###############################################################################
diff --git a/tests/h2_proxy_cache.t b/tests/h2_proxy_cache.t
new file mode 100644
index 0000000..1069838
--- /dev/null
+++ b/tests/h2_proxy_cache.t
@@ -0,0 +1,166 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for HTTP/2 protocol with cache.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::HTTP2;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http http_v2 proxy cache/)->plan(9)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    proxy_cache_path %%TESTDIR%%/cache    keys_zone=NAME:1m;
+
+    server {
+        listen       127.0.0.1:8080 http2;
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location /cache {
+            proxy_pass http://127.0.0.1:8081/;
+            proxy_cache NAME;
+            proxy_cache_valid 1m;
+        }
+
+        location /proxy_buffering_off {
+            proxy_pass http://127.0.0.1:8081/;
+            proxy_cache NAME;
+            proxy_cache_valid 1m;
+            proxy_buffering off;
+        }
+
+        location / { }
+
+        location /slow {
+            limit_rate 200;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('t.html', 'SEE-THIS');
+$t->write_file('slow.html', 'SEE-THIS');
+$t->run();
+
+###############################################################################
+
+# simple proxy cache test
+
+my $s = Test::Nginx::HTTP2->new();
+my $sid = $s->new_stream({ path => '/cache/t.html' });
+my $frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+my ($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, '200', 'proxy cache');
+
+my $etag = $frame->{headers}->{'etag'};
+
+($frame) = grep { $_->{type} eq "DATA" } @$frames;
+is($frame->{length}, length 'SEE-THIS', 'proxy cache - DATA');
+is($frame->{data}, 'SEE-THIS', 'proxy cache - DATA payload');
+
+$t->write_file('t.html', 'NOOP');
+
+$sid = $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET', mode => 0 },
+	{ name => ':scheme', value => 'http', mode => 0 },
+	{ name => ':path', value => '/cache/t.html' },
+	{ name => ':authority', value => 'localhost', mode => 1 },
+	{ name => 'if-none-match', value => $etag }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 304, 'proxy cache conditional');
+
+$t->write_file('t.html', 'SEE-THIS');
+
+# request body with cached response
+
+$sid = $s->new_stream({ path => '/cache/t.html', body_more => 1 });
+$s->h2_body('TEST');
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200, 'proxy cache - request body');
+
+$s->h2_ping('SEE-THIS');
+$frames = $s->read(all => [{ type => 'PING' }]);
+
+($frame) = grep { $_->{type} eq "PING" && $_->{flags} & 0x1 } @$frames;
+ok($frame, 'proxy cache - request body - next');
+
+# HEADERS could be received with fin, followed by DATA
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/cache/t.html?1', method => 'HEAD' });
+
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }], wait => 0.2);
+push @$frames, $_ for @{$s->read(all => [{ sid => $sid }], wait => 0.2)};
+ok(!grep ({ $_->{type} eq "DATA" } @$frames), 'proxy cache HEAD - no body');
+
+# HEAD on empty cache with proxy_buffering off
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream(
+	{ path => '/proxy_buffering_off/t.html?1', method => 'HEAD' });
+
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+push @$frames, $_ for @{$s->read(all => [{ sid => $sid }], wait => 0.2)};
+ok(!grep ({ $_->{type} eq "DATA" } @$frames),
+	'proxy cache HEAD buffering off - no body');
+
+SKIP: {
+skip 'win32', 1 if $^O eq 'MSWin32';
+
+# client cancels stream with a cacheable request that was sent to upstream
+# HEADERS should not be produced for the canceled stream
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/cache/slow.html' });
+
+$s->h2_rst($sid, 8);
+
+$frames = $s->read(all => [{ sid => $sid, fin => 0x4 }], wait => 1.2);
+ok(!(grep { $_->{type} eq "HEADERS" } @$frames), 'no headers');
+
+}
+
+# client closes connection after sending a cacheable request producing alert
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/cache/t.html?4' });
+
+undef $s;
+select undef, undef, undef, 0.2;
+
+$t->stop();
+
+###############################################################################
diff --git a/tests/h2_proxy_protocol.t b/tests/h2_proxy_protocol.t
new file mode 100644
index 0000000..9a597d4
--- /dev/null
+++ b/tests/h2_proxy_protocol.t
@@ -0,0 +1,80 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for HTTP/2 protocol with proxy_protocol.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::HTTP2;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http http_v2 realip/)->plan(4)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080 proxy_protocol http2;
+        server_name  localhost;
+
+        location /pp {
+            set_real_ip_from 127.0.0.1/32;
+            real_ip_header proxy_protocol;
+            alias %%TESTDIR%%/t.html;
+            add_header X-PP $remote_addr;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('t.html', 'SEE-THIS');
+$t->run();
+
+###############################################################################
+
+my $proxy = 'PROXY TCP4 192.0.2.1 192.0.2.2 1234 5678' . CRLF;
+my $s = Test::Nginx::HTTP2->new(port(8080), proxy => $proxy);
+my $sid = $s->new_stream({ path => '/pp' });
+my $frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+my ($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+ok($frame, 'PROXY HEADERS frame');
+is($frame->{headers}->{'x-pp'}, '192.0.2.1', 'PROXY remote addr');
+
+# invalid PROXY protocol string
+
+$proxy = 'BOGUS TCP4 192.0.2.1 192.0.2.2 1234 5678' . CRLF;
+$s = Test::Nginx::HTTP2->new(port(8080), preface => $proxy, pure => 1);
+$frames = $s->read(all => [{ type => 'GOAWAY' }]);
+
+($frame) = grep { $_->{type} eq "GOAWAY" } @$frames;
+ok($frame, 'invalid PROXY - GOAWAY frame');
+is($frame->{code}, 1, 'invalid PROXY - error code');
+
+###############################################################################
diff --git a/tests/h2_proxy_request_buffering.t b/tests/h2_proxy_request_buffering.t
new file mode 100644
index 0000000..482159b
--- /dev/null
+++ b/tests/h2_proxy_request_buffering.t
@@ -0,0 +1,281 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for HTTP/2 protocol with unbuffered request body.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::HTTP2;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http http_v2 proxy/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080 http2;
+        listen       127.0.0.1:8082;
+        server_name  localhost;
+
+        location / {
+            proxy_request_buffering off;
+            proxy_pass http://127.0.0.1:8081/;
+            client_body_buffer_size 1k;
+        }
+        location /chunked {
+            proxy_request_buffering off;
+            proxy_http_version 1.1;
+            proxy_pass http://127.0.0.1:8081/;
+            client_body_buffer_size 1k;
+        }
+        location /abort {
+            proxy_request_buffering off;
+            proxy_http_version 1.1;
+            proxy_pass http://127.0.0.1:8082/;
+        }
+    }
+}
+
+EOF
+
+$t->run();
+$t->plan(49);
+
+###############################################################################
+
+# unbuffered request body
+
+my $f = get_body('/', 'content-length' => 10);
+ok($f->{headers}, 'request');
+is($f->{upload}('01234', body_more => 1), '01234', 'part');
+is($f->{upload}('56789'), '56789', 'part 2');
+is($f->{http_end}(), 200, 'response');
+
+$f = get_body('/', 'content-length' => 10);
+ok($f->{headers}, 'much');
+is($f->{upload}('0123456789', body_more => 1), '0123456789', 'much - part');
+is($f->{upload}('many'), '', 'much - part 2');
+is($f->{http_end}(), 400, 'much - response');
+
+$f = get_body('/', 'content-length' => 10);
+ok($f->{headers}, 'less');
+is($f->{upload}('0123', body_more => 1), '0123', 'less - part');
+is($f->{upload}('56789'), '', 'less - part 2');
+is($f->{http_end}(), 400, 'less - response');
+
+$f = get_body('/', 'content-length' => 18);
+ok($f->{headers}, 'many');
+is($f->{upload}('01234many', body_split => [ 5 ], body_more => 1),
+	'01234many', 'many - part');
+is($f->{upload}('56789many', body_split => [ 5 ]),
+	'56789many', 'many - part 2');
+is($f->{http_end}(), 200, 'many - response');
+
+$f = get_body('/', 'content-length' => 0);
+ok($f->{headers}, 'empty');
+is($f->{upload}('', body_more => 1, wait => 0.2), '', 'empty - part');
+is($f->{upload}('', wait => 0.2), '', 'empty - part 2');
+is($f->{http_end}(), 200, 'empty - response');
+
+$f = get_body('/', 'content-length' => 1536);
+ok($f->{headers}, 'buffer');
+is($f->{upload}('0123' x 128, body_more => 1), '0123' x 128,
+	'buffer - below');
+is($f->{upload}('4567' x 128, body_more => 1), '4567' x 128,
+	'buffer - equal');
+is($f->{upload}('89AB' x 128), '89AB' x 128, 'buffer - above');
+is($f->{http_end}(), 200, 'buffer - response');
+
+$f = get_body('/', 'content-length' => 10);
+ok($f->{headers}, 'split');
+is($f->{upload}('0123456789', split => [ 14 ]), '0123456789', 'split');
+is($f->{http_end}(), 200, 'split - response');
+
+# unbuffered request body, chunked transfer-encoding
+
+$f = get_body('/chunked');
+ok($f->{headers}, 'chunked');
+is($f->{upload}('01234', body_more => 1), '5' . CRLF . '01234' . CRLF,
+	'chunked - part');
+is($f->{upload}('56789'), '5' . CRLF . '56789' . CRLF . '0' . CRLF . CRLF,
+	'chunked - part 2');
+is($f->{http_end}(), 200, 'chunked - response');
+
+$f = get_body('/chunked');
+ok($f->{headers}, 'chunked buffer');
+is($f->{upload}('0123' x 128, body_more => 1),
+	'200' . CRLF . '0123' x 128 . CRLF, 'chunked buffer - below');
+is($f->{upload}('4567' x 128, body_more => 1),
+	'200' . CRLF . '4567' x 128 . CRLF, 'chunked buffer - equal');
+is($f->{upload}('89AB' x 128),
+	'200' . CRLF . '89AB' x 128 . CRLF . '0' . CRLF . CRLF,
+	'chunked buffer - above');
+is($f->{http_end}(), 200, 'chunked buffer - response');
+
+$f = get_body('/chunked');
+ok($f->{headers}, 'chunked many');
+is($f->{upload}('01234many', body_split => [ 5 ], body_more => 1),
+	'9' . CRLF . '01234many' . CRLF, 'chunked many - part');
+is($f->{upload}('56789many', body_split => [ 5 ]),
+	'9' . CRLF . '56789many' . CRLF . '0' . CRLF . CRLF,
+	'chunked many - part 2');
+is($f->{http_end}(), 200, 'chunked many - response');
+
+$f = get_body('/chunked');
+ok($f->{headers}, 'chunked empty');
+is($f->{upload}('', body_more => 1, wait => 0.2), '', 'chunked empty - part');
+is($f->{upload}(''), '0' . CRLF . CRLF, 'chunked empty - part 2');
+is($f->{http_end}(), 200, 'chunked empty - response');
+
+$f = get_body('/chunked');
+ok($f->{headers}, 'chunked split');
+is(http_content($f->{upload}('0123456789', split => [ 14 ])),
+	'0123456789', 'chunked split');
+is($f->{http_end}(), 200, 'chunked split - response');
+
+# unbuffered request body, chunked transfer-encoding
+# client sends partial DATA frame and closes connection
+
+my $s = Test::Nginx::HTTP2->new();
+my $s2 = Test::Nginx::HTTP2->new();
+
+$s->new_stream({ path => '/abort', body_more => 1 });
+$s->h2_body('TEST', { split => [ 9 ], abort => 1 });
+
+close $s->{socket};
+
+$s2->h2_ping('PING');
+isnt(@{$s2->read()}, 0, 'chunked abort');
+
+###############################################################################
+
+sub http_content {
+	my ($body) = @_;
+	my $content = '';
+
+	while ($body =~ /\G\x0d?\x0a?([0-9a-f]+)\x0d\x0a?/gcmsi) {
+		my $len = hex($1);
+		$content .= substr($body, pos($body), $len);
+		pos($body) += $len;
+	}
+
+	return $content;
+}
+
+sub get_body {
+	my ($url, %extra) = @_;
+	my ($server, $client, $f);
+
+	$server = IO::Socket::INET->new(
+		Proto => 'tcp',
+		LocalHost => '127.0.0.1',
+		LocalPort => port(8081),
+		Listen => 5,
+		Timeout => 3,
+		Reuse => 1
+	)
+		or die "Can't create listening socket: $!\n";
+
+	my $s = Test::Nginx::HTTP2->new();
+	my $sid = exists $extra{'content-length'}
+		? $s->new_stream({ headers => [
+			{ name => ':method', value => 'GET' },
+			{ name => ':scheme', value => 'http' },
+			{ name => ':path', value => $url, },
+			{ name => ':authority', value => 'localhost' },
+			{ name => 'content-length',
+				value => $extra{'content-length'} }],
+			body_more => 1 })
+		: $s->new_stream({ path => $url, body_more => 1 });
+
+	$client = $server->accept() or return;
+
+	log2c("(new connection $client)");
+
+	$f->{headers} = backend_read($client);
+
+	my $chunked = $f->{headers} =~ /chunked/;
+
+	$f->{upload} = sub {
+		my ($body, %extra) = @_;
+		my $len = length($body);
+		my $wait = $extra{wait};
+
+		$s->h2_body($body, { %extra });
+
+		$body = '';
+
+		for (1 .. 10) {
+			my $buf = backend_read($client, $wait) or return '';
+			$body .= $buf;
+
+			my $got = 0;
+			$got += $chunked ? hex $_ : $_ for $chunked
+				? $body =~ /(\w+)\x0d\x0a?\w+\x0d\x0a?/g
+				: length($body);
+			next if $chunked && !$extra{body_more}
+				&& $buf !~ /^0\x0d\x0a?/m;
+			last if $got >= $len;
+		}
+
+		return $body;
+	};
+	$f->{http_end} = sub {
+		$client->write(<<EOF);
+HTTP/1.1 200 OK
+Connection: close
+
+EOF
+
+		$client->close;
+
+		my $frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+		my ($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+		return $frame->{headers}->{':status'};
+	};
+	return $f;
+}
+
+sub backend_read {
+	my ($s, $timo) = @_;
+	my $buf = '';
+
+	if (IO::Select->new($s)->can_read($timo || 8)) {
+		$s->sysread($buf, 16384) or return;
+		log2i($buf);
+	}
+	return $buf;
+}
+
+sub log2i { Test::Nginx::log_core('|| <<', @_); }
+sub log2o { Test::Nginx::log_core('|| >>', @_); }
+sub log2c { Test::Nginx::log_core('||', @_); }
+
+###############################################################################
diff --git a/tests/h2_proxy_request_buffering_redirect.t b/tests/h2_proxy_request_buffering_redirect.t
new file mode 100644
index 0000000..3617a44
--- /dev/null
+++ b/tests/h2_proxy_request_buffering_redirect.t
@@ -0,0 +1,99 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for HTTP/2 protocol with unbuffered request body.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::HTTP2;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http http_v2 proxy rewrite/)->plan(1);
+
+$t->write_file_expand('nginx.conf', <<'EOF')->run();
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080 http2;
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        proxy_http_version 1.1;
+
+        location / {
+            proxy_request_buffering off;
+            proxy_pass http://127.0.0.1:8081/bad;
+            proxy_intercept_errors on;
+            error_page 502 = /pass;
+        }
+
+        location /bad {
+            return 502;
+        }
+
+        location /pass {
+            proxy_pass http://127.0.0.1:8081/good;
+        }
+
+        location /good {
+            limit_rate 100;
+            return 200;
+        }
+    }
+}
+
+EOF
+
+###############################################################################
+
+# unbuffered request body
+
+SKIP: {
+skip 'leaves coredump', 1 unless $t->has_version('1.17.4')
+	or $ENV{TEST_NGINX_UNSAFE};
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.17.4');
+
+$t->todo_alerts() unless $t->has_version('1.17.4');
+
+my $s = Test::Nginx::HTTP2->new();
+my $sid = $s->new_stream({ body_more => 1 });
+
+$s->h2_body('SEE-', { body_more => 1 });
+sleep 1;
+$s->h2_body('THIS');
+
+my $frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+my ($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200, 'discard body rest on redirect');
+
+}
+
+}
+
+###############################################################################
diff --git a/tests/h2_proxy_request_buffering_ssl.t b/tests/h2_proxy_request_buffering_ssl.t
new file mode 100644
index 0000000..774aefb
--- /dev/null
+++ b/tests/h2_proxy_request_buffering_ssl.t
@@ -0,0 +1,286 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for HTTP/2 protocol with unbuffered request body to ssl backend.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::HTTP2;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http http_ssl http_v2 proxy/)
+	->has_daemon('openssl');
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080 http2;
+        server_name  localhost;
+
+        location / {
+            proxy_request_buffering off;
+            proxy_pass https://127.0.0.1:8082;
+            client_body_buffer_size 512;
+        }
+        location /chunked {
+            proxy_request_buffering off;
+            proxy_http_version 1.1;
+            proxy_pass https://127.0.0.1:8082;
+            client_body_buffer_size 512;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8082 ssl;
+        server_name  localhost;
+
+        ssl_certificate_key localhost.key;
+        ssl_certificate localhost.crt;
+
+        location / {
+            proxy_request_buffering off;
+            proxy_pass http://127.0.0.1:8081/;
+            client_body_buffer_size 1k;
+        }
+        location /chunked {
+            proxy_request_buffering off;
+            proxy_http_version 1.1;
+            proxy_pass http://127.0.0.1:8081/;
+            client_body_buffer_size 1k;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('localhost') {
+	system('openssl req -x509 -new '
+		. "-config $d/openssl.conf -subj /CN=$name/ "
+		. "-out $d/$name.crt -keyout $d/$name.key "
+		. ">>$d/openssl.out 2>&1") == 0
+		or die "Can't create certificate for $name: $!\n";
+}
+
+$t->run();
+$t->plan(40);
+
+###############################################################################
+
+# unbuffered request body
+
+my $f = get_body('/', 'content-length' => 10);
+ok($f->{headers}, 'request');
+is($f->{upload}('01234', body_more => 1), '01234', 'part');
+is($f->{upload}('56789'), '56789', 'part 2');
+is($f->{http_end}(), 200, 'response');
+
+$f = get_body('/', 'content-length' => 1536);
+ok($f->{headers}, 'buffer');
+is($f->{upload}('0123' x 128, body_more => 1), '0123' x 128, 'buffer - below');
+is($f->{upload}('4567' x 128, body_more => 1), '4567' x 128, 'buffer - equal');
+is($f->{upload}('89AB' x 128), '89AB' x 128, 'buffer - above');
+is($f->{http_end}(), 200, 'buffer - response');
+
+$f = get_body('/', 'content-length' => 18);
+ok($f->{headers}, 'many');
+is($f->{upload}('01234many', body_split => [ 5 ], body_more => 1),
+	'01234many', 'many - part');
+is($f->{upload}('56789many', body_split => [ 5 ]),
+	'56789many', 'many - part 2');
+is($f->{http_end}(), 200, 'many - response');
+
+$f = get_body('/', 'content-length' => 0);
+ok($f->{headers}, 'empty');
+is($f->{upload}('', body_more => 1, wait => 0.2), '', 'empty - part');
+is($f->{upload}('', wait => 0.2), '', 'empty - part 2');
+is($f->{http_end}(), 200, 'empty - response');
+
+$f = get_body('/', 'content-length' => 10);
+ok($f->{headers}, 'split');
+is($f->{upload}('0123456789', split => [ 14 ]), '0123456789', 'split');
+is($f->{http_end}(), 200, 'split - response');
+
+# unbuffered request body, chunked transfer-encoding
+
+$f = get_body('/chunked');
+ok($f->{headers}, 'chunk');
+is($f->{upload}('01234', body_more => 1), '5' . CRLF . '01234' . CRLF,
+	'chunked - part');
+is($f->{upload}('56789'), '5' . CRLF . '56789' . CRLF . '0' . CRLF . CRLF,
+	'chunked - part 2');
+is($f->{http_end}(), 200, 'chunked - response');
+
+$f = get_body('/chunked');
+ok($f->{headers}, 'chunked buffer');
+is($f->{upload}('0123' x 64, body_more => 1),
+	'100' . CRLF . '0123' x 64 . CRLF, 'chunked buffer - below');
+is($f->{upload}('4567' x 64, body_more => 1),
+	'100' . CRLF . '4567' x 64 . CRLF, 'chunked buffer - equal');
+is($f->{upload}('89AB' x 64),
+	'100' . CRLF . '89AB' x 64 . CRLF . '0' . CRLF . CRLF,
+	'chunked buffer - above');
+is($f->{http_end}(), 200, 'chunked buffer - response');
+
+$f = get_body('/chunked');
+ok($f->{headers}, 'chunked many');
+is($f->{upload}('01234many', body_split => [ 5 ], body_more => 1),
+	'9' . CRLF . '01234many' . CRLF, 'chunked many - part');
+is($f->{upload}('56789many', body_split => [ 5 ]),
+	'9' . CRLF . '56789many' . CRLF . '0' . CRLF . CRLF,
+	'chunked many - part 2');
+is($f->{http_end}(), 200, 'chunked many - response');
+
+$f = get_body('/chunked');
+ok($f->{headers}, 'chunked empty');
+is($f->{upload}('', body_more => 1, wait => 0.2), '', 'chunked empty - part');
+is($f->{upload}(''), '0' . CRLF . CRLF, 'chunked empty - part 2');
+is($f->{http_end}(), 200, 'chunked empty - response');
+
+$f = get_body('/chunked');
+ok($f->{headers}, 'chunked split');
+is(http_content($f->{upload}('0123456789', split => [ 14 ])),
+	'0123456789', 'chunked split');
+is($f->{http_end}(), 200, 'chunked split - response');
+
+###############################################################################
+
+sub http_content {
+	my ($body) = @_;
+	my $content = '';
+
+	while ($body =~ /\G\x0d?\x0a?([0-9a-f]+)\x0d\x0a?/gcmsi) {
+		my $len = hex($1);
+		$content .= substr($body, pos($body), $len);
+		pos($body) += $len;
+	}
+
+	return $content;
+}
+
+sub get_body {
+	my ($url, %extra) = @_;
+	my ($server, $client, $f);
+
+	$server = IO::Socket::INET->new(
+		Proto => 'tcp',
+		LocalHost => '127.0.0.1',
+		LocalPort => port(8081),
+		Listen => 5,
+		Timeout => 3,
+		Reuse => 1
+	)
+		or die "Can't create listening socket: $!\n";
+
+	my $s = Test::Nginx::HTTP2->new();
+	my $sid = exists $extra{'content-length'}
+		? $s->new_stream({ headers => [
+			{ name => ':method', value => 'GET' },
+			{ name => ':scheme', value => 'http' },
+			{ name => ':path', value => $url, },
+			{ name => ':authority', value => 'localhost' },
+			{ name => 'content-length',
+				value => $extra{'content-length'} }],
+			body_more => 1 })
+		: $s->new_stream({ path => $url, body_more => 1 });
+
+	$client = $server->accept() or return;
+
+	log2c("(new connection $client)");
+
+	$f->{headers} = backend_read($client);
+
+	my $chunked = $f->{headers} =~ /chunked/;
+
+	$f->{upload} = sub {
+		my ($body, %extra) = @_;
+		my $len = length($body);
+		my $wait = $extra{wait};
+
+		$s->h2_body($body, { %extra });
+
+		$body = '';
+
+		for (1 .. 10) {
+			my $buf = backend_read($client, $wait) or return '';
+			$body .= $buf;
+
+			my $got = 0;
+			$got += $chunked ? hex $_ : $_ for $chunked
+				? $body =~ /(\w+)\x0d\x0a?\w+\x0d\x0a?/g
+				: length($body);
+			next if $chunked && !$extra{body_more}
+				&& $buf !~ /^0\x0d\x0a?/m;
+			last if $got >= $len;
+		}
+
+		return $body;
+	};
+	$f->{http_end} = sub {
+		$client->write(<<EOF);
+HTTP/1.1 200 OK
+Connection: close
+
+EOF
+
+		$client->close;
+
+		my $frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+		my ($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+		return $frame->{headers}->{':status'};
+	};
+	return $f;
+}
+
+sub backend_read {
+	my ($s, $timo) = @_;
+	my $buf = '';
+
+	if (IO::Select->new($s)->can_read($timo || 8)) {
+		$s->sysread($buf, 16384) or return;
+		log2i($buf);
+	}
+	return $buf;
+}
+
+sub log2i { Test::Nginx::log_core('|| <<', @_); }
+sub log2o { Test::Nginx::log_core('|| >>', @_); }
+sub log2c { Test::Nginx::log_core('||', @_); }
+
+###############################################################################
diff --git a/tests/h2_proxy_ssl.t b/tests/h2_proxy_ssl.t
new file mode 100644
index 0000000..a7bb9a7
--- /dev/null
+++ b/tests/h2_proxy_ssl.t
@@ -0,0 +1,92 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for HTTP/2 protocol with proxy to ssl backend.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::HTTP2;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http http_ssl http_v2 proxy/)
+	->has_daemon('openssl')->plan(1);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080 http2;
+        listen       127.0.0.1:8081 ssl;
+        server_name  localhost;
+
+        ssl_certificate_key localhost.key;
+        ssl_certificate localhost.crt;
+
+        location / { }
+        location /proxy_ssl/ {
+            proxy_pass https://127.0.0.1:8081/;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('localhost') {
+	system('openssl req -x509 -new '
+		. "-config $d/openssl.conf -subj /CN=$name/ "
+		. "-out $d/$name.crt -keyout $d/$name.key "
+		. ">>$d/openssl.out 2>&1") == 0
+		or die "Can't create certificate for $name: $!\n";
+}
+
+$t->write_file('index.html', '');
+$t->run();
+
+###############################################################################
+
+# request body with an empty DATA frame proxied to ssl backend
+# "zero size buf in output" alerts seen
+
+my $s = Test::Nginx::HTTP2->new();
+my $sid = $s->new_stream({ path => '/proxy_ssl/', body_more => 1 });
+$s->h2_body('');
+my $frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+my ($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200, 'empty request body');
+
+###############################################################################
diff --git a/tests/h2_request_body.t b/tests/h2_request_body.t
new file mode 100644
index 0000000..10d37c0
--- /dev/null
+++ b/tests/h2_request_body.t
@@ -0,0 +1,475 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for HTTP/2 protocol with request body.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::HTTP2;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http http_v2 proxy/)->plan(44);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080 http2;
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location / {
+            add_header X-Length $http_content_length;
+        }
+        location /slow {
+            limit_rate 100;
+        }
+        location /off/ {
+            proxy_pass http://127.0.0.1:8081/;
+            add_header X-Body $request_body;
+            add_header X-Body-File $request_body_file;
+        }
+        location /proxy2/ {
+            add_header X-Body $request_body;
+            add_header X-Body-File $request_body_file;
+            client_body_in_file_only on;
+            proxy_pass http://127.0.0.1:8081/;
+        }
+        location /client_max_body_size {
+            add_header X-Body $request_body;
+            add_header X-Body-File $request_body_file;
+            client_body_in_single_buffer on;
+            client_body_in_file_only on;
+            proxy_pass http://127.0.0.1:8081/;
+            client_max_body_size 10;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('index.html', '');
+$t->write_file('t.html', 'SEE-THIS');
+$t->write_file('slow.html', 'SEE-THIS');
+$t->run();
+
+###############################################################################
+
+# request body (uses proxied response)
+
+my $s = Test::Nginx::HTTP2->new();
+my $sid = $s->new_stream({ path => '/proxy2/t.html', body_more => 1 });
+$s->h2_body('TEST');
+my $frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+my ($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is(read_body_file($frame->{headers}->{'x-body-file'}), 'TEST', 'request body');
+is($frame->{headers}->{'x-length'}, 4, 'request body - content length');
+
+# request body with padding (uses proxied response)
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/proxy2/t.html', body_more => 1 });
+$s->h2_body('TEST', { body_padding => 42 });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is(read_body_file($frame->{headers}->{'x-body-file'}), 'TEST',
+	'request body with padding');
+is($frame->{headers}->{'x-length'}, 4,
+	'request body with padding - content length');
+
+$sid = $s->new_stream();
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, '200', 'request body with padding - next');
+
+# request body sent in multiple DATA frames in a single packet
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/proxy2/t.html', body_more => 1 });
+$s->h2_body('TEST', { body_split => [2] });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is(read_body_file($frame->{headers}->{'x-body-file'}), 'TEST',
+	'request body in multiple frames');
+is($frame->{headers}->{'x-length'}, 4,
+	'request body in multiple frames - content length');
+
+# request body sent in multiple DATA frames, each in its own packet
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/proxy2/t.html', body_more => 1 });
+$s->h2_body('TEST', { body_more => 1 });
+select undef, undef, undef, 0.1;
+$s->h2_body('MOREDATA');
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is(read_body_file($frame->{headers}->{'x-body-file'}), 'TESTMOREDATA',
+	'request body in multiple frames separately');
+is($frame->{headers}->{'x-length'}, 12,
+	'request body in multiple frames separately - content length');
+
+# request body with an empty DATA frame
+# "zero size buf in output" alerts seen
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/proxy2/', body_more => 1 });
+$s->h2_body('');
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200, 'request body - empty');
+is($frame->{headers}->{'x-length'}, 0, 'request body - empty size');
+ok($frame->{headers}{'x-body-file'}, 'request body - empty body file');
+is(read_body_file($frame->{headers}{'x-body-file'}), '',
+	'request body - empty content');
+
+# it is expected to avoid adding Content-Length for requests without body
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/proxy2/' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200, 'request without body');
+is($frame->{headers}->{'x-length'}, undef,
+	'request without body - content length');
+
+# request body discarded
+# RST_STREAM with zero code received
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.17.4');
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ body_more => 1 });
+$frames = $s->read(all => [{ type => 'RST_STREAM' }], wait => 0.5);
+
+($frame) = grep { $_->{type} eq "RST_STREAM" } @$frames;
+is($frame->{code}, 0, 'request body discarded - zero RST_STREAM');
+
+}
+
+# malformed request body length not equal to content-length
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ body_more => 1, headers => [
+	{ name => ':method', value => 'GET', mode => 0 },
+	{ name => ':scheme', value => 'http', mode => 0 },
+	{ name => ':path', value => '/client_max_body_size', mode => 1 },
+	{ name => ':authority', value => 'localhost', mode => 1 },
+	{ name => 'content-length', value => '5', mode => 1 }]});
+$s->h2_body('TEST');
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 400, 'request body less than content-length');
+
+$sid = $s->new_stream({ body_more => 1, headers => [
+	{ name => ':method', value => 'GET', mode => 0 },
+	{ name => ':scheme', value => 'http', mode => 0 },
+	{ name => ':path', value => '/client_max_body_size', mode => 1 },
+	{ name => ':authority', value => 'localhost', mode => 1 },
+	{ name => 'content-length', value => '3', mode => 1 }]});
+$s->h2_body('TEST');
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 400, 'request body more than content-length');
+
+# client_max_body_size
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/client_max_body_size/t.html',
+	body_more => 1 });
+$s->h2_body('TESTTEST12');
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200, 'client_max_body_size - status');
+is(read_body_file($frame->{headers}->{'x-body-file'}), 'TESTTEST12',
+	'client_max_body_size - body');
+
+# client_max_body_size - limited
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/client_max_body_size/t.html',
+	body_more => 1 });
+$s->h2_body('TESTTEST123');
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 413, 'client_max_body_size - limited');
+
+# client_max_body_size - many DATA frames
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/client_max_body_size/t.html',
+	body_more => 1 });
+$s->h2_body('TESTTEST12', { body_split => [2] });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200, 'client_max_body_size many - status');
+is(read_body_file($frame->{headers}->{'x-body-file'}), 'TESTTEST12',
+	'client_max_body_size many - body');
+
+# client_max_body_size - many DATA frames - limited
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/client_max_body_size/t.html',
+	body_more => 1 });
+$s->h2_body('TESTTEST123', { body_split => [2] });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 413, 'client_max_body_size many - limited');
+
+# client_max_body_size - padded DATA
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/client_max_body_size/t.html',
+	body_more => 1 });
+$s->h2_body('TESTTEST12', { body_padding => 42 });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200, 'client_max_body_size pad - status');
+is(read_body_file($frame->{headers}->{'x-body-file'}), 'TESTTEST12',
+	'client_max_body_size pad - body');
+
+# client_max_body_size - padded DATA - limited
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/client_max_body_size/t.html',
+	body_more => 1 });
+$s->h2_body('TESTTEST123', { body_padding => 42 });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 413, 'client_max_body_size pad - limited');
+
+# client_max_body_size - many padded DATA frames
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/client_max_body_size/t.html',
+	body_more => 1 });
+$s->h2_body('TESTTEST12', { body_padding => 42, body_split => [2] });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200,
+	'client_max_body_size many pad - status');
+is(read_body_file($frame->{headers}->{'x-body-file'}), 'TESTTEST12',
+	'client_max_body_size many pad - body');
+
+# client_max_body_size - many padded DATA frames - limited
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/client_max_body_size/t.html',
+	body_more => 1 });
+$s->h2_body('TESTTEST123', { body_padding => 42, body_split => [2] });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 413,
+	'client_max_body_size many pad - limited');
+
+# request body without content-length
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ body_more => 1, headers => [
+	{ name => ':method', value => 'GET', mode => 2 },
+	{ name => ':scheme', value => 'http', mode => 2 },
+	{ name => ':path', value => '/client_max_body_size', mode => 2 },
+	{ name => ':authority', value => 'localhost', mode => 2 }]});
+$s->h2_body('TESTTEST12');
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200,
+	'request body without content-length - status');
+is(read_body_file($frame->{headers}->{'x-body-file'}), 'TESTTEST12',
+	'request body without content-length - body');
+
+# request body without content-length - limited
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ body_more => 1, headers => [
+	{ name => ':method', value => 'GET', mode => 2 },
+	{ name => ':scheme', value => 'http', mode => 2 },
+	{ name => ':path', value => '/client_max_body_size', mode => 2 },
+	{ name => ':authority', value => 'localhost', mode => 2 }]});
+$s->h2_body('TESTTEST123');
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 413,
+	'request body without content-length - limited');
+
+# request body without content-length - many DATA frames
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ body_more => 1, headers => [
+	{ name => ':method', value => 'GET', mode => 2 },
+	{ name => ':scheme', value => 'http', mode => 2 },
+	{ name => ':path', value => '/client_max_body_size', mode => 2 },
+	{ name => ':authority', value => 'localhost', mode => 2 }]});
+$s->h2_body('TESTTEST12', { body_split => [2] });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200,
+	'request body without content-length many - status');
+is(read_body_file($frame->{headers}->{'x-body-file'}), 'TESTTEST12',
+	'request body without content-length many - body');
+
+# request body without content-length - many DATA frames - limited
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ body_more => 1, headers => [
+	{ name => ':method', value => 'GET', mode => 2 },
+	{ name => ':scheme', value => 'http', mode => 2 },
+	{ name => ':path', value => '/client_max_body_size', mode => 2 },
+	{ name => ':authority', value => 'localhost', mode => 2 }]});
+$s->h2_body('TESTTEST123', { body_split => [2] });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 413,
+	'request body without content-length many - limited');
+
+# request body without content-length - padding
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ body_more => 1, headers => [
+	{ name => ':method', value => 'GET', mode => 2 },
+	{ name => ':scheme', value => 'http', mode => 2 },
+	{ name => ':path', value => '/client_max_body_size', mode => 2 },
+	{ name => ':authority', value => 'localhost', mode => 2 }]});
+$s->h2_body('TESTTEST12', { body_padding => 42 });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200,
+	'request body without content-length pad - status');
+is(read_body_file($frame->{headers}->{'x-body-file'}), 'TESTTEST12',
+	'request body without content-length pad - body');
+
+# request body without content-length - padding - limited
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ body_more => 1, headers => [
+	{ name => ':method', value => 'GET', mode => 2 },
+	{ name => ':scheme', value => 'http', mode => 2 },
+	{ name => ':path', value => '/client_max_body_size', mode => 2 },
+	{ name => ':authority', value => 'localhost', mode => 2 }]});
+$s->h2_body('TESTTEST123', { body_padding => 42 });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 413,
+	'request body without content-length pad - limited');
+
+# request body without content-length - padding with many DATA frames
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ body_more => 1, headers => [
+	{ name => ':method', value => 'GET', mode => 2 },
+	{ name => ':scheme', value => 'http', mode => 2 },
+	{ name => ':path', value => '/client_max_body_size', mode => 2 },
+	{ name => ':authority', value => 'localhost', mode => 2 }]});
+$s->h2_body('TESTTEST', { body_padding => 42, body_split => [2] });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200,
+	'request body without content-length many pad - status');
+is(read_body_file($frame->{headers}->{'x-body-file'}), 'TESTTEST',
+	'request body without content-length many pad - body');
+
+# request body without content-length - padding with many DATA frames - limited
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ body_more => 1, headers => [
+	{ name => ':method', value => 'GET', mode => 2 },
+	{ name => ':scheme', value => 'http', mode => 2 },
+	{ name => ':path', value => '/client_max_body_size', mode => 2 },
+	{ name => ':authority', value => 'localhost', mode => 2 }]});
+$s->h2_body('TESTTEST123', { body_padding => 42, body_split => [2] });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 413,
+	'request body without content-length many pad - limited');
+
+# absent request body is not buffered with client_body_in_file_only off
+# see e02f1977846b for details
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/off/t.html' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{'x-body-file'}, undef, 'no request body in file');
+
+# ticket #1384, request body corruption in recv_buffer
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/off/slow.html', body_more => 1 });
+select undef, undef, undef, 0.1;
+
+# for simplicity, DATA frame is received on its own for a known offset
+
+$s->h2_body('TEST');
+select undef, undef, undef, 0.1;
+
+# overwrite recv_buffer; since upstream response arrival is delayed,
+# this would make $request_body point to the overridden buffer space
+
+$s->h2_ping('xxxx');
+
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+isnt($frame->{headers}->{'x-body'}, 'xxxx', 'sync buffer');
+
+###############################################################################
+
+sub read_body_file {
+	my ($path) = @_;
+	open FILE, $path or return "$!";
+	local $/;
+	my $content = <FILE>;
+	close FILE;
+	return $content;
+}
+
+###############################################################################
diff --git a/tests/h2_request_body_preread.t b/tests/h2_request_body_preread.t
new file mode 100644
index 0000000..5e629db
--- /dev/null
+++ b/tests/h2_request_body_preread.t
@@ -0,0 +1,199 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for HTTP/2 protocol with preread request body.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::HTTP2;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http http_v2 proxy limit_req/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    limit_req_zone   $binary_remote_addr  zone=req:1m rate=20r/m;
+
+    server {
+        listen       127.0.0.1:8080 http2;
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        http2_body_preread_size 10;
+
+        location /t { }
+        location / {
+            add_header X-Body $request_body;
+            proxy_pass http://127.0.0.1:8081/t;
+
+            location /req {
+                limit_req  zone=req burst=2;
+                proxy_pass http://127.0.0.1:8081/t;
+            }
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8082 http2;
+        server_name  localhost;
+
+        http2_body_preread_size 0;
+
+        location / {
+            add_header X-Body $request_body;
+            proxy_pass http://127.0.0.1:8081/t;
+
+            location /req {
+                limit_req  zone=req burst=2;
+                proxy_pass http://127.0.0.1:8081/t;
+            }
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8083 http2;
+        server_name  localhost;
+
+        location / {
+            add_header X-Body $request_body;
+            proxy_pass http://127.0.0.1:8081/t;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('t', '');
+$t->run()->plan(9);
+
+###############################################################################
+
+# request body within preread size (that is, stream window)
+
+my $s = Test::Nginx::HTTP2->new();
+my $sid = $s->new_stream({ body => 'TEST' });
+my $frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+my ($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{'x-body'}, 'TEST', 'within preread');
+
+# request body beyond preread size
+# RST_STREAM expected due stream window violation
+
+TODO: {
+local $TODO = 'not yet';
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ body => 'TEST' x 10 });
+$frames = $s->read(all => [{ type => 'RST_STREAM' }], wait => 0.5);
+
+($frame) = grep { $_->{type} eq "RST_STREAM" } @$frames;
+is($frame->{code}, 3, 'beyond preread - FLOW_CONTROL_ERROR');
+
+}
+
+# within preread size - limited
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/req' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+$sid = $s->new_stream({ path => '/req', body => 'TEST' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{'x-body'}, 'TEST', 'within preread limited');
+
+# processing request body without END_STREAM in preread
+
+$sid = $s->new_stream({ path => '/req', body_more => 1, continuation => 1 });
+$s->h2_continue($sid,
+	{ headers => [{ name => 'content-length', value => '8' }]});
+
+$s->h2_body('SEE', { body_more => 1 });
+$s->read(all => [{ type => 'WINDOW_UPDATE' }]);
+
+$s->h2_body('-THIS');
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{'x-body'}, 'SEE-THIS', 'within preread limited - more');
+
+# beyond preread size - limited
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/req', body => 'TEST' x 10 });
+$frames = $s->read(all => [{ type => 'RST_STREAM' }]);
+
+($frame) = grep { $_->{type} eq "RST_STREAM" } @$frames;
+is($frame->{code}, 3, 'beyond preread limited - FLOW_CONTROL_ERROR');
+
+
+# zero preread size
+
+TODO: {
+local $TODO = 'not yet';
+
+$s = Test::Nginx::HTTP2->new(port(8082));
+$sid = $s->new_stream({ body => 'TEST' });
+$frames = $s->read(all => [{ type => 'RST_STREAM' }], wait => 0.5);
+
+($frame) = grep { $_->{type} eq "RST_STREAM" } @$frames;
+is($frame->{code}, 3, 'zero preread - FLOW_CONTROL_ERROR');
+
+}
+
+# zero preread size - limited
+
+$s = Test::Nginx::HTTP2->new(port(8082));
+$sid = $s->new_stream({ path => '/req', body => 'TEST' });
+$frames = $s->read(all => [{ type => 'RST_STREAM' }]);
+
+($frame) = grep { $_->{type} eq "RST_STREAM" } @$frames;
+is($frame->{code}, 3, 'zero preread limited - FLOW_CONTROL_ERROR');
+
+
+# REFUSED_STREAM on request body prior SETTINGS acknowledgement
+
+$s = Test::Nginx::HTTP2->new(port(8080), pure => 1);
+$sid = $s->new_stream({ body => 'TEST' });
+$frames = $s->read(all => [{ type => 'RST_STREAM' }]);
+
+($frame) = grep { $_->{type} eq "RST_STREAM" } @$frames;
+is($frame->{code}, 7, 'no SETTINGS ack - REFUSED_STREAM');
+
+# default preread size - no REFUSED_STREAM expected
+
+$s = Test::Nginx::HTTP2->new(port(8083), pure => 1);
+$sid = $s->new_stream({ body => 'TEST' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{'x-body'}, 'TEST', 'no SETTINGS ack - default preread');
+
+###############################################################################
diff --git a/tests/h2_server_push.t b/tests/h2_server_push.t
new file mode 100644
index 0000000..7199e50
--- /dev/null
+++ b/tests/h2_server_push.t
@@ -0,0 +1,446 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for HTTP/2 server push.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::HTTP2;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http http_v2 proxy rewrite gzip/)->plan(42)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080 http2;
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location /prio {
+            http2_push /t1;
+            http2_push /t2;
+            return 204;
+        }
+
+        location /expl {
+            http2_push /push;
+            http2_push /push2;
+
+            location /expl/off {
+                http2_push off;
+            }
+        }
+
+        location /preload {
+            http2_push_preload on;
+            add_header Link "</push>; rel=preload";
+            add_header X-Link $sent_http_link;
+            return 200 SEE-THIS;
+        }
+
+        location /preload2 {
+            http2_push_preload on;
+            add_header Link "</push>; rel=preload";           # valid
+            add_header Link "</push2 >; rel=preload";         # valid
+            add_header Link "</push3>; rel=preloadX";         # not
+            add_header Link '</push4>; rel="preload"';        # valid
+            add_header Link '</push5>; rel="preloadX"';       # not
+            add_header Link "</push6>; rel=preload; nopush";  # not
+            add_header Link '</push7>; rel="foo"';            # not
+            add_header Link '</push7>; rel="foo preload"';    # valid
+            return 200 SEE-THIS;
+        }
+
+        location /preload/many {
+            http2_push_preload on;
+            add_header Link "</push>; rel=preload, </push2>; rel=preload";
+            add_header Link "</push3>, </push4>; rel=preload";
+            return 200 SEE-THIS;
+        }
+
+        location /preload/proxy {
+            http2_push_preload on;
+            proxy_pass http://127.0.0.1:8081/proxied;
+        }
+
+        location /proxied {
+            add_header Link "</push>; rel=preload";
+            add_header Link "</push2>; rel=preload";
+            return 200 SEE-THIS;
+        }
+
+        location /both {
+            http2_push /push;
+            http2_push_preload on;
+            add_header Link "</push>; rel=preload";
+            return 200 SEE-THIS;
+        }
+
+        location /arg {
+            http2_push $arg_push;
+            return 204;
+        }
+
+        location /push {
+            return 200 PROMISED;
+        }
+
+        location /gzip.html {
+            gzip on;
+            gzip_min_length 0;
+            return 200 PROMISED;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8082 http2;
+        server_name  max_pushes;
+
+        http2_max_concurrent_pushes 2;
+        http2_push /push;
+        http2_push /push;
+        http2_push /push;
+    }
+}
+
+EOF
+
+$t->write_file('t1', join('', map { sprintf "X%04dXXX", $_ } (1 .. 8202)));
+$t->write_file('t2', 'SEE-THIS');
+$t->write_file('explf', join('', map { sprintf "X%06dXXX", $_ } (1 .. 6553)));
+
+$t->run();
+
+###############################################################################
+
+# 6.6.  PUSH_PROMISE
+#   PUSH_PROMISE frames MUST only be sent on a peer-initiated stream that
+#   is in either the "open" or "half-closed (remote)" state.
+
+# preload & format
+
+my $s = Test::Nginx::HTTP2->new();
+my $sid = $s->new_stream({ path => '/preload' });
+my $frames = $s->read(all => [{ sid => 1, fin => 1 }, { sid => 2, fin => 1 }]);
+
+my ($frame) = grep { $_->{type} eq "PUSH_PROMISE" } @$frames;
+ok($frame, 'push promise');
+is($frame->{headers}->{':authority'}, 'localhost', 'authority');
+is($frame->{headers}->{':scheme'}, 'http', 'scheme');
+is($frame->{headers}->{':method'}, 'GET', 'method');
+is($frame->{headers}->{':path'}, '/push', 'path');
+is($frame->{flags}, 4, 'flags');
+is($frame->{promised}, 2, 'promised stream');
+
+($frame) = grep { $_->{type} eq "DATA" && $_->{sid} eq 2 } @$frames;
+is($frame->{data}, 'PROMISED', 'promised stream payload');
+
+($frame) = grep { $_->{type} eq "HEADERS" && $_->{sid} eq $sid } @$frames;
+is($frame->{headers}->{'x-link'}, '</push>; rel=preload', 'sent_http_link');
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/preload2' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+is(grep({ $_->{type} eq "PUSH_PROMISE" } @$frames), 4, 'preload 2');
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/preload/many' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+is(grep({ $_->{type} eq "PUSH_PROMISE" } @$frames), 3, 'preload many');
+
+# preload proxy
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/preload/proxy' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+is(grep({ $_->{type} eq "PUSH_PROMISE" } @$frames), 2, 'preload proxy');
+
+# both h2_push & preload
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/both' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+is(grep({ $_->{type} eq "PUSH_PROMISE" } @$frames), 2, 'h2_push and preload');
+
+# h2_push
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/expl' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "PUSH_PROMISE" } @$frames;
+ok($frame, 'h2_push only');
+
+# h2_push off
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/expl/off' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "PUSH_PROMISE" } @$frames;
+ok(!$frame, 'h2_push off');
+
+# h2_push $var
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/arg?push=/push' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+($frame) = grep { $_->{type} eq "PUSH_PROMISE" } @$frames;
+ok($frame, 'h2_push variable');
+
+$sid = $s->new_stream({ path => '/arg?push=' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+($frame) = grep { $_->{type} eq "PUSH_PROMISE" } @$frames;
+ok(!$frame, 'h2_push variable empty');
+
+$sid = $s->new_stream({ path => '/arg?push=off' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+($frame) = grep { $_->{type} eq "PUSH_PROMISE" } @$frames;
+ok(!$frame, 'h2_push variable off');
+
+$sid = $s->new_stream({ path => '/arg?push=foo' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+($frame) = grep { $_->{type} eq "PUSH_PROMISE" } @$frames;
+ok(!$frame, 'h2_push variable relative path');
+
+# SETTINGS_ENABLE_PUSH
+
+$s = Test::Nginx::HTTP2->new();
+$s->h2_settings(0, 0x2 => 0);
+$sid = $s->new_stream({ path => '/expl' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "PUSH_PROMISE" } @$frames;
+ok(!$frame, 'push setting disabled');
+
+$s->h2_settings(0, 0x2 => 1);
+$sid = $s->new_stream({ path => '/expl' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "PUSH_PROMISE" } @$frames;
+ok($frame, 'push setting enabled');
+
+$s->h2_settings(0, 0x2 => 42);
+$frames = $s->read(all => [{ type => 'GOAWAY' }]);
+
+($frame) = grep { $_->{type} =~ "GOAWAY" } @$frames;
+is($frame->{'code'}, 1, 'push setting invalid - GOAWAY protocol error');
+cmp_ok($frame->{'last_sid'}, '<', 5, 'push setting invalid - last sid');
+
+# SETTINGS_MAX_CONCURRENT_STREAMS
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/expl' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+is(grep({ $_->{type} eq "PUSH_PROMISE" } @$frames), 2, 'max pushes default');
+
+$s = Test::Nginx::HTTP2->new();
+$s->h2_settings(0, 0x3 => 1);
+$sid = $s->new_stream({ path => '/expl' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+is(grep({ $_->{type} eq "PUSH_PROMISE" } @$frames), 1, 'max pushes limited');
+
+$s = Test::Nginx::HTTP2->new();
+$s->h2_settings(0, 0x3 => 0);
+$sid = $s->new_stream({ path => '/expl' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+is(grep({ $_->{type} eq "PUSH_PROMISE" } @$frames), 0, 'max pushes disabled');
+
+TODO: {
+todo_skip 'long tests with aio', 6 unless $ENV{TEST_NGINX_UNSAFE}
+	or $t->read_file('nginx.conf') !~ /aio (on|threads)/;
+local $TODO = 'not yet' if $t->read_file('nginx.conf') =~ /aio (on|threads)/;
+
+# server push flow control & rst
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/explf' });
+$frames = $s->read(all => [
+	{ sid => 1, fin => 1 },
+	{ sid => 2, length => 5 },
+	{ sid => 4, fin => 4 }]);
+
+($frame) = grep { $_->{type} eq "DATA" && $_->{sid} == 2 } @$frames;
+is($frame->{length}, 5, 'flow control - pushed stream limited');
+is($frame->{flags}, 0, 'flow control - pushed stream flags');
+
+($frame) = grep { $_->{type} eq "DATA" && $_->{sid} == 4 } @$frames;
+ok(!$frame, 'flow control - no window for next stream');
+
+# window update
+
+$s->h2_window(2);
+
+$frames = $s->read(all => [{ length => 2 }]);
+($frame) = grep { $_->{type} eq "DATA" && $_->{sid} == 2 } @$frames;
+is($frame->{length}, 2, 'window update');
+
+# client refused stream
+
+$s->h2_rst(4, 7);
+$s->h2_window(2**16);
+
+$frames = $s->read(all => [{ sid => 2, length => 1 }]);
+push @$frames, @{ $s->read(all => [{ sid => 4, fin => 1 }], wait => 0.2) };
+
+($frame) = grep { $_->{type} eq "DATA" && $_->{sid} == 2 } @$frames;
+is($frame->{length}, 1, 'pushed response flow control');
+is($frame->{flags}, 1, 'pushed response END_STREAM');
+
+}
+
+($frame) = grep { $_->{type} eq "DATA" && $_->{sid} == 4 } @$frames;
+ok(!$frame, 'rst pushed stream');
+
+TODO: {
+todo_skip 'long tests with aio', 2 unless $ENV{TEST_NGINX_UNSAFE}
+	or $t->read_file('nginx.conf') !~ /aio (on|threads)/;
+local $TODO = 'not yet' if $t->read_file('nginx.conf') =~ /aio (on|threads)/;
+
+# priority
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/prio' });
+$frames = $s->read(all => [{ length => 2**16 - 1 }, { sid => 4, fin => 4 }]);
+
+$s->h2_priority(16, 2, 4);
+
+$s->h2_window(2**17, 2);
+$s->h2_window(2**17, 4);
+$s->h2_window(2**17);
+
+$frames = $s->read(all => [{ sid => 2, fin => 1 }, { sid => 4, fin => 1 }]);
+my @data = grep { $_->{type} eq "DATA" } @$frames;
+is(join(' ', map { $_->{sid} } @data), "4 2", 'priority 1');
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/prio' });
+$frames = $s->read(all => [{ length => 2**16 - 1 }, { sid => 4, fin => 4 }]);
+
+$s->h2_priority(16, 4, 2);
+
+$s->h2_window(2**17, 2);
+$s->h2_window(2**17, 4);
+$s->h2_window(2**17);
+
+$frames = $s->read(all => [{ sid => 2, fin => 1 }, { sid => 4, fin => 1 }]);
+@data = grep { $_->{type} eq "DATA" } @$frames;
+is(join(' ', map { $_->{sid} } @data), "2 4", 'priority 2');
+
+}
+
+# http2_max_concurrent_pushes
+
+$s = Test::Nginx::HTTP2->new(port(8082));
+$sid = $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET', mode => 0 },
+	{ name => ':scheme', value => 'http', mode => 0 },
+	{ name => ':path', value => '/', mode => 0 },
+	{ name => ':authority', value => 'max_pushes', mode => 1 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+is(grep({ $_->{type} eq "PUSH_PROMISE" } @$frames), 2, 'http2 max pushes lim');
+
+$s = Test::Nginx::HTTP2->new(port(8082));
+$s->h2_settings(0, 0x3 => 1);
+$sid = $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET', mode => 0 },
+	{ name => ':scheme', value => 'http', mode => 0 },
+	{ name => ':path', value => '/', mode => 0 },
+	{ name => ':authority', value => 'max_pushes', mode => 1 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+is(grep({ $_->{type} eq "PUSH_PROMISE" } @$frames), 1, 'http2 max pushes 2');
+
+# missing request header ':authority'
+
+$s = Test::Nginx::HTTP2->new(port(8082));
+$sid = $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET', mode => 0 },
+	{ name => ':scheme', value => 'http', mode => 0 },
+	{ name => ':path', value => '/', mode => 0 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 400, 'incomplete headers');
+
+# gzip tests
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET', mode => 0 },
+	{ name => ':scheme', value => 'http', mode => 0 },
+	{ name => ':path', value => '/arg?push=/gzip.html' },
+	{ name => ':authority', value => 'localhost', mode => 1 },
+	{ name => 'accept-encoding', value => 'gzip' }]});
+$frames = $s->read(all => [{ sid => 2, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "PUSH_PROMISE" && $_->{sid} == $sid } @$frames;
+is($frame->{headers}->{'accept-encoding'}, 'gzip', 'gzip - push promise');
+
+($frame) = grep { $_->{type} eq "HEADERS" && $_->{sid} == 2 } @$frames;
+is($frame->{headers}->{'content-encoding'}, 'gzip', 'gzip - headers');
+
+($frame) = grep { $_->{type} eq "DATA" && $_->{sid} == 2 } @$frames;
+gunzip_like($frame->{data}, qr/^PROMISED\Z/, 'gzip - response');
+
+# scheme https
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET', mode => 0 },
+	{ name => ':scheme', value => 'https', mode => 0 },
+	{ name => ':path', value => '/preload' },
+	{ name => ':authority', value => 'localhost', mode => 1 }]});
+$frames = $s->read(all => [{ sid => 2, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "PUSH_PROMISE" && $_->{sid} == $sid } @$frames;
+is($frame->{headers}->{':scheme'}, 'https', 'scheme https');
+
+###############################################################################
+
+sub gunzip_like {
+	my ($in, $re, $name) = @_;
+
+	SKIP: {
+		eval { require IO::Uncompress::Gunzip; };
+		Test::More::skip(
+			"IO::Uncompress::Gunzip not installed", 1) if $@;
+
+		my $out;
+
+		IO::Uncompress::Gunzip::gunzip(\$in => \$out);
+
+		if ($in =~ $re) {
+			fail($name);
+			return;
+		}
+
+		like($out, $re, $name);
+	}
+}
+
+###############################################################################
diff --git a/tests/h2_server_tokens.t b/tests/h2_server_tokens.t
new file mode 100644
index 0000000..766b6dc
--- /dev/null
+++ b/tests/h2_server_tokens.t
@@ -0,0 +1,139 @@
+#!/usr/bin/perl
+
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+
+# Tests for HTTP/2 protocol with server_tokens directive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::HTTP2;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http http_v2 rewrite/)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080 http2;
+        server_name  localhost;
+
+        location /200 {
+            return 200;
+        }
+
+        location /404 {
+            return 404;
+        }
+
+        location /off {
+            server_tokens off;
+
+            location /off/200 {
+                return 200;
+            }
+
+            location /off/404 {
+                return 404;
+            }
+        }
+
+        location /on {
+            server_tokens on;
+
+            location /on/200 {
+                return 200;
+            }
+
+            location /on/404 {
+                return 404;
+            }
+        }
+
+        location /b {
+            server_tokens build;
+
+            location /b/200 {
+                return 200;
+            }
+
+            location /b/404 {
+                return 404;
+            }
+        }
+    }
+}
+
+EOF
+
+$t->run()->plan(12);
+
+###############################################################################
+
+my $re = qr/nginx\/\d+\.\d+\.\d+/;
+
+like(header_server('/200'), qr/^$re$/, 'http2 tokens default 200');
+like(header_server('/404'), qr/^$re$/, 'http2 tokens default 404');
+like(body('/404'), qr/$re/, 'http2 tokens default 404 body');
+
+is(header_server('/off/200'), 'nginx', 'http2 tokens off 200');
+is(header_server('/off/404'), 'nginx', 'http2 tokens off 404');
+like(body('/off/404'), qr/nginx(?!\/)/, 'http2 tokens off 404 body');
+
+like(header_server('/on/200'), qr/^$re$/, 'http2 tokens on 200');
+like(header_server('/on/404'), qr/^$re$/, 'http2 tokens on 404');
+like(body('/on/404'), $re, 'http2 tokens on 404 body');
+
+$re = qr/$re \Q($1)\E/ if $t->{_configure_args} =~ /--build=(\S+)/;
+
+like(header_server('/b/200'), qr/^$re$/, 'http2 tokens build 200');
+like(header_server('/b/404'), qr/^$re$/, 'http2 tokens build 404');
+like(body('/b/404'), qr/$re/, 'http2 tokens build 404 body');
+
+###############################################################################
+
+sub header_server {
+	my ($path) = shift;
+
+	my $s = Test::Nginx::HTTP2->new();
+	my $sid = $s->new_stream({ path => $path });
+	my $frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+	my ($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+	return $frame->{headers}->{'server'};
+}
+
+sub body {
+	my ($path) = shift;
+
+	my $s = Test::Nginx::HTTP2->new();
+	my $sid = $s->new_stream({ path => $path });
+	my $frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+	my ($frame) = grep { $_->{type} eq "DATA" } @$frames;
+	return $frame->{'data'};
+}
+
+###############################################################################
diff --git a/tests/h2_ssl.t b/tests/h2_ssl.t
new file mode 100644
index 0000000..907fb31
--- /dev/null
+++ b/tests/h2_ssl.t
@@ -0,0 +1,131 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for HTTP/2 protocol with ssl.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::HTTP2;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require IO::Socket::SSL; };
+plan(skip_all => 'IO::Socket::SSL not installed') if $@;
+
+my $t = Test::Nginx->new()->has(qw/http http_ssl http_v2/)
+	->has_daemon('openssl');
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080 http2 ssl;
+        server_name  localhost;
+
+        ssl_certificate_key localhost.key;
+        ssl_certificate localhost.crt;
+
+        location / { }
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('localhost') {
+	system('openssl req -x509 -new '
+		. "-config $d/openssl.conf -subj /CN=$name/ "
+		. "-out $d/$name.crt -keyout $d/$name.key "
+		. ">>$d/openssl.out 2>&1") == 0
+		or die "Can't create certificate for $name: $!\n";
+}
+
+$t->write_file('tbig.html',
+	join('', map { sprintf "XX%06dXX", $_ } (1 .. 500000)));
+
+open OLDERR, ">&", \*STDERR; close STDERR;
+$t->run();
+open STDERR, ">&", \*OLDERR;
+
+plan(skip_all => 'no ALPN/NPN negotiation') unless defined getconn(port(8080));
+$t->plan(1);
+
+###############################################################################
+
+# client cancels 2nd stream after HEADERS has been created
+# while some unsent data was left in the SSL buffer
+# HEADERS frame may stuck in SSL buffer and won't be sent producing alert
+
+my $s = getconn(port(8080));
+ok($s, 'ssl connection');
+
+my $sid = $s->new_stream({ path => '/tbig.html' });
+
+select undef, undef, undef, 0.2;
+$s->h2_rst($sid, 8);
+
+$sid = $s->new_stream({ path => '/tbig.html' });
+
+select undef, undef, undef, 0.2;
+$s->h2_rst($sid, 8);
+
+$t->stop();
+
+###############################################################################
+
+sub getconn {
+	my ($port) = @_;
+	my $s;
+
+	eval {
+		my $sock = Test::Nginx::HTTP2::new_socket($port, SSL => 1,
+			alpn => 'h2');
+		$s = Test::Nginx::HTTP2->new($port, socket => $sock)
+			if $sock->alpn_selected();
+	};
+
+	return $s if defined $s;
+
+	eval {
+		my $sock = Test::Nginx::HTTP2::new_socket($port, SSL => 1,
+			npn => 'h2');
+		$s = Test::Nginx::HTTP2->new($port, socket => $sock)
+			if $sock->next_proto_negotiated();
+	};
+
+	return $s;
+}
+
+###############################################################################
diff --git a/tests/h2_ssl_proxy_cache.t b/tests/h2_ssl_proxy_cache.t
new file mode 100644
index 0000000..74dcfb2
--- /dev/null
+++ b/tests/h2_ssl_proxy_cache.t
@@ -0,0 +1,150 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for HTTP/2 protocol with ssl and http proxy cache.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::HTTP2;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require IO::Socket::SSL; };
+plan(skip_all => 'IO::Socket::SSL not installed') if $@;
+
+my $t = Test::Nginx->new()->has(qw/http http_ssl http_v2 proxy cache/)
+	->has_daemon('openssl');
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    proxy_cache_path   %%TESTDIR%%/cache  keys_zone=NAME:1m;
+
+    server {
+        listen       127.0.0.1:8080 http2 ssl sndbuf=32k;
+        server_name  localhost;
+
+        ssl_certificate_key localhost.key;
+        ssl_certificate localhost.crt;
+
+        send_timeout 1s;
+
+        location / {
+            proxy_pass   http://127.0.0.1:8081;
+            proxy_cache  NAME;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081 sndbuf=64k;
+        server_name  localhost;
+
+        location / { }
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('localhost') {
+	system('openssl req -x509 -new '
+		. "-config $d/openssl.conf -subj /CN=$name/ "
+		. "-out $d/$name.crt -keyout $d/$name.key "
+		. ">>$d/openssl.out 2>&1") == 0
+		or die "Can't create certificate for $name: $!\n";
+}
+
+$t->write_file('tbig.html',
+	join('', map { sprintf "XX%06dXX", $_ } (1 .. 500000)));
+
+open OLDERR, ">&", \*STDERR; close STDERR;
+$t->run();
+open STDERR, ">&", \*OLDERR;
+
+plan(skip_all => 'no ALPN/NPN negotiation') unless defined getconn(port(8080));
+$t->plan(1);
+
+###############################################################################
+
+# client cancels stream with a cacheable request sent to upstream causing alert
+
+my $s = getconn(port(8080));
+ok($s, 'ssl connection');
+
+my $sid = $s->new_stream();
+$s->h2_rst($sid, 8);
+
+# large response may stuck in SSL buffer and won't be sent producing alert
+
+my $s2 = getconn(port(8080));
+$sid = $s2->new_stream({ path => '/tbig.html' });
+$s2->h2_window(2**30, $sid);
+$s2->h2_window(2**30);
+
+select undef, undef, undef, 0.2;
+
+$t->stop();
+
+# "aio_write" is used to produce "open socket ... left in connection" alerts.
+
+$t->todo_alerts() if $t->read_file('nginx.conf') =~ /aio_write on/
+	and $t->read_file('nginx.conf') =~ /aio threads/ and $^O eq 'linux';
+
+###############################################################################
+
+sub getconn {
+	my ($port) = @_;
+	my $s;
+
+	eval {
+		my $sock = Test::Nginx::HTTP2::new_socket($port, SSL => 1,
+			alpn => 'h2');
+		$s = Test::Nginx::HTTP2->new($port, socket => $sock)
+			if $sock->alpn_selected();
+	};
+
+	return $s if defined $s;
+
+	eval {
+		my $sock = Test::Nginx::HTTP2::new_socket($port, SSL => 1,
+			npn => 'h2');
+		$s = Test::Nginx::HTTP2->new($port, socket => $sock)
+			if $sock->next_proto_negotiated();
+	};
+
+	return $s;
+}
+
+###############################################################################
diff --git a/tests/h2_ssl_variables.t b/tests/h2_ssl_variables.t
new file mode 100644
index 0000000..25d0aa0
--- /dev/null
+++ b/tests/h2_ssl_variables.t
@@ -0,0 +1,213 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for HTTP/2 protocol with ssl.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::HTTP2;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require IO::Socket::SSL; };
+plan(skip_all => 'IO::Socket::SSL not installed') if $@;
+eval { IO::Socket::SSL::SSL_VERIFY_NONE(); };
+plan(skip_all => 'IO::Socket::SSL too old') if $@;
+
+my $t = Test::Nginx->new()->has(qw/http http_ssl http_v2 rewrite/)
+	->has_daemon('openssl')->plan(8);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080 http2 ssl;
+        server_name  localhost;
+
+        ssl_certificate_key localhost.key;
+        ssl_certificate localhost.crt;
+
+        location /h2 {
+            return 200 $http2;
+        }
+        location /sp {
+            return 200 $server_protocol;
+        }
+        location /scheme {
+            return 200 $scheme;
+        }
+        location /https {
+            return 200 $https;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('localhost') {
+	system('openssl req -x509 -new '
+		. "-config $d/openssl.conf -subj /CN=$name/ "
+		. "-out $d/$name.crt -keyout $d/$name.key "
+		. ">>$d/openssl.out 2>&1") == 0
+		or die "Can't create certificate for $name: $!\n";
+}
+
+open OLDERR, ">&", \*STDERR; close STDERR;
+$t->run();
+open STDERR, ">&", \*OLDERR;
+
+###############################################################################
+
+my ($s, $sid, $frames, $frame);
+
+my $has_npn = eval { Test::Nginx::HTTP2::new_socket(port(8080), SSL => 1,
+	npn => 'h2')->next_proto_negotiated() };
+my $has_alpn = eval { Test::Nginx::HTTP2::new_socket(port(8080), SSL => 1,
+	alpn => 'h2')->alpn_selected() };
+
+# SSL/TLS connection, NPN
+
+SKIP: {
+skip 'OpenSSL NPN support required', 1 unless $has_npn;
+
+$s = Test::Nginx::HTTP2->new(port(8080), SSL => 1, npn => 'h2');
+$sid = $s->new_stream({ path => '/h2' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "DATA" } @$frames;
+is($frame->{data}, 'h2', 'http variable - npn');
+
+}
+
+# SSL/TLS connection, ALPN
+
+SKIP: {
+skip 'OpenSSL ALPN support required', 1 unless $has_alpn;
+
+$s = Test::Nginx::HTTP2->new(port(8080), SSL => 1, alpn => 'h2');
+$sid = $s->new_stream({ path => '/h2' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "DATA" } @$frames;
+is($frame->{data}, 'h2', 'http variable - alpn');
+
+}
+
+# $server_protocol - SSL/TLS connection, NPN
+
+SKIP: {
+skip 'OpenSSL NPN support required', 1 unless $has_npn;
+
+$s = Test::Nginx::HTTP2->new(port(8080), SSL => 1, npn => 'h2');
+$sid = $s->new_stream({ path => '/sp' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "DATA" } @$frames;
+is($frame->{data}, 'HTTP/2.0', 'server_protocol variable - npn');
+
+}
+
+# $server_protocol - SSL/TLS connection, ALPN
+
+SKIP: {
+skip 'OpenSSL ALPN support required', 1 unless $has_alpn;
+
+$s = Test::Nginx::HTTP2->new(port(8080), SSL => 1, alpn => 'h2');
+$sid = $s->new_stream({ path => '/sp' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "DATA" } @$frames;
+is($frame->{data}, 'HTTP/2.0', 'server_protocol variable - alpn');
+
+}
+
+# $scheme - SSL/TLS connection, NPN
+
+SKIP: {
+skip 'OpenSSL NPN support required', 1 unless $has_npn;
+
+$s = Test::Nginx::HTTP2->new(port(8080), SSL => 1, npn => 'h2');
+$sid = $s->new_stream({ path => '/scheme' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "DATA" } @$frames;
+is($frame->{data}, 'https', 'scheme variable - npn');
+
+}
+
+# $scheme - SSL/TLS connection, ALPN
+
+SKIP: {
+skip 'OpenSSL ALPN support required', 1 unless $has_alpn;
+
+$s = Test::Nginx::HTTP2->new(port(8080), SSL => 1, alpn => 'h2');
+$sid = $s->new_stream({ path => '/scheme' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "DATA" } @$frames;
+is($frame->{data}, 'https', 'scheme variable - alpn');
+
+}
+
+# $https - SSL/TLS connection, NPN
+
+SKIP: {
+skip 'OpenSSL NPN support required', 1 unless $has_npn;
+
+$s = Test::Nginx::HTTP2->new(port(8080), SSL => 1, npn => 'h2');
+$sid = $s->new_stream({ path => '/https' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "DATA" } @$frames;
+is($frame->{data}, 'on', 'https variable - npn');
+
+}
+
+# $https - SSL/TLS connection, ALPN
+
+SKIP: {
+skip 'OpenSSL ALPN support required', 1 unless $has_alpn;
+
+$s = Test::Nginx::HTTP2->new(port(8080), SSL => 1, alpn => 'h2');
+$sid = $s->new_stream({ path => '/https' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "DATA" } @$frames;
+is($frame->{data}, 'on', 'https variable - alpn');
+
+}
+
+###############################################################################
diff --git a/tests/h2_ssl_verify_client.t b/tests/h2_ssl_verify_client.t
new file mode 100644
index 0000000..5908e66
--- /dev/null
+++ b/tests/h2_ssl_verify_client.t
@@ -0,0 +1,159 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for HTTP/2 protocol with ssl, ssl_verify_client.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::HTTP2;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require IO::Socket::SSL; };
+plan(skip_all => 'IO::Socket::SSL not installed') if $@;
+eval { IO::Socket::SSL->can_client_sni() or die; };
+plan(skip_all => 'IO::Socket::SSL with OpenSSL SNI support required') if $@;
+eval { IO::Socket::SSL->can_alpn() or die; };
+plan(skip_all => 'OpenSSL ALPN support required') if $@;
+
+my $t = Test::Nginx->new()->has(qw/http http_ssl sni http_v2/)
+	->has_daemon('openssl');
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    ssl_certificate_key localhost.key;
+    ssl_certificate localhost.crt;
+
+    ssl_verify_client optional_no_ca;
+
+    add_header X-Verify $ssl_client_verify;
+
+    server {
+        listen       127.0.0.1:8080 ssl http2;
+        server_name  localhost;
+
+        ssl_client_certificate client.crt;
+
+        location / { }
+    }
+
+    server {
+        listen       127.0.0.1:8080 ssl http2;
+        server_name  example.com;
+
+        location / { }
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('localhost', 'client') {
+	system('openssl req -x509 -new '
+		. "-config $d/openssl.conf -subj /CN=$name/ "
+		. "-out $d/$name.crt -keyout $d/$name.key "
+		. ">>$d/openssl.out 2>&1") == 0
+		or die "Can't create certificate for $name: $!\n";
+}
+
+$t->write_file('t', 'SEE-THIS');
+
+open OLDERR, ">&", \*STDERR; close STDERR;
+$t->run();
+open STDERR, ">&", \*OLDERR;
+
+my $s = get_ssl_socket();
+plan(skip_all => 'no alpn') unless $s->alpn_selected();
+$t->plan(3);
+
+###############################################################################
+
+is(get('localhost')->{'x-verify'}, 'SUCCESS', 'success');
+like(get('example.com')->{'x-verify'}, qr/FAILED/, 'failed');
+is(get('localhost', 'example.com')->{':status'}, '421', 'misdirected');
+
+###############################################################################
+
+sub get_ssl_socket {
+	my ($sni) = @_;
+	my $s;
+
+	eval {
+		local $SIG{ALRM} = sub { die "timeout\n" };
+		local $SIG{PIPE} = sub { die "sigpipe\n" };
+		alarm(8);
+		$s = IO::Socket::SSL->new(
+			Proto => 'tcp',
+			PeerAddr => '127.0.0.1',
+			PeerPort => port(8080),
+			SSL_verify_mode => IO::Socket::SSL::SSL_VERIFY_NONE(),
+			SSL_alpn_protocols => [ 'h2' ],
+			SSL_hostname => $sni,
+			SSL_cert_file => "$d/client.crt",
+			SSL_key_file => "$d/client.key",
+			SSL_error_trap => sub { die $_[1] }
+		);
+		alarm(0);
+	};
+	alarm(0);
+
+	if ($@) {
+		log_in("died: $@");
+		return undef;
+	}
+
+	return $s;
+}
+
+sub get {
+	my ($sni, $host) = @_;
+
+	$host = $sni if !defined $host;
+
+	my $s = get_ssl_socket($sni);
+	my $sess = Test::Nginx::HTTP2->new(port(8080), socket => $s);
+	my $sid = $sess->new_stream({ headers => [
+		{ name => ':method', value => 'GET', mode => 0 },
+		{ name => ':scheme', value => 'http', mode => 0 },
+		{ name => ':path', value => '/t', mode => 1 },
+		{ name => ':authority', value => $host, mode => 1 }]});
+	my $frames = $sess->read(all => [{ sid => $sid, fin => 1 }]);
+
+	my ($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+	return $frame->{'headers'};
+}
+
+###############################################################################
diff --git a/tests/h2_trailers.t b/tests/h2_trailers.t
new file mode 100644
index 0000000..2b0098d
--- /dev/null
+++ b/tests/h2_trailers.t
@@ -0,0 +1,133 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for HTTP/2 trailers.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::HTTP2;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http http_v2/)->plan(22)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080 http2;
+        server_name  localhost;
+
+        location / {
+            add_trailer X-Var $host;
+        }
+
+        http2_max_field_size 256k;
+
+        location /continuation {
+            # many trailers to send in parts
+            add_trailer X-LongHeader $arg_h;
+            add_trailer X-LongHeader $arg_h;
+            add_trailer X-LongHeader $arg_h;
+            add_trailer X-LongHeader $arg_h;
+            add_trailer X-LongHeader $arg_h;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('index.html', 'SEE-THIS');
+$t->write_file('empty', '');
+$t->write_file('continuation', 'SEE-THIS');
+$t->run();
+
+###############################################################################
+
+my ($s, $sid, $frames, $frame);
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+@$frames = grep { $_->{type} =~ "HEADERS|DATA" } @$frames;
+
+is(@$frames, 3, 'frames');
+
+$frame = shift @$frames;
+is($frame->{headers}->{':status'}, 200, 'header');
+is($frame->{headers}->{'x-var'}, undef, 'header not trailer');
+is($frame->{flags}, 4, 'header flags');
+
+$frame = shift @$frames;
+is($frame->{data}, 'SEE-THIS', 'data');
+is($frame->{flags}, 0, 'data flags');
+
+$frame = shift @$frames;
+is($frame->{headers}->{'x-var'}, 'localhost', 'trailer');
+is($frame->{flags}, 5, 'trailer flags');
+
+# with zero content-length
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/empty' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+@$frames = grep { $_->{type} =~ "HEADERS|DATA" } @$frames;
+
+is(@$frames, 2, 'no data - frames');
+
+$frame = shift @$frames;
+is($frame->{headers}->{':status'}, 200, 'no data - header');
+is($frame->{flags}, 4, 'no data - header flags');
+
+$frame = shift @$frames;
+is($frame->{headers}->{'x-var'}, 'localhost', 'no data - trailer');
+is($frame->{flags}, 5, 'no data - trailer flags');
+
+# CONTINUATION in response trailers
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/continuation?h=' . 'x' x 2**12 });
+$frames = $s->read(all => [{ sid => $sid, type => 'CONTINUATION' }]);
+@$frames = grep { $_->{type} =~ "HEADERS|CONTINUATION|DATA" } @$frames;
+
+is(@$frames, 4, 'continuation - frames');
+
+$frame = shift @$frames;
+is($frame->{headers}->{':status'}, 200, 'continuation - header');
+is($frame->{flags}, 4, 'continuation - header flags');
+
+$frame = shift @$frames;
+is($frame->{data}, 'SEE-THIS', 'continuation - data');
+is($frame->{flags}, 0, 'continuation - data flags');
+
+$frame = shift @$frames;
+is($frame->{type}, 'HEADERS', 'continuation - trailer');
+is($frame->{flags}, 1, 'continuation - trailer flags');
+
+$frame = shift @$frames;
+is($frame->{type}, 'CONTINUATION', 'continuation - trailer continuation');
+is($frame->{flags}, 4, 'continuation - trailer continuation flags');
+
+###############################################################################
diff --git a/tests/h2_variables.t b/tests/h2_variables.t
new file mode 100644
index 0000000..90f70d8
--- /dev/null
+++ b/tests/h2_variables.t
@@ -0,0 +1,130 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for HTTP/2 protocol with variables.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::HTTP2;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http http_v2 rewrite/)->plan(6)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080 http2;
+        server_name  localhost;
+
+        location /h2 {
+            return 200 $http2;
+        }
+        location /sp {
+            return 200 $server_protocol;
+        }
+        location /scheme {
+            return 200 $scheme;
+        }
+        location /https {
+            return 200 "body $https";
+        }
+        location /rl {
+            return 200 $request_length;
+        }
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+# $http2
+
+my $s = Test::Nginx::HTTP2->new();
+my $sid = $s->new_stream({ path => '/h2' });
+my $frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+my ($frame) = grep { $_->{type} eq "DATA" } @$frames;
+is($frame->{data}, 'h2c', 'http variable - h2c');
+
+# $server_protocol
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/sp' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "DATA" } @$frames;
+is($frame->{data}, 'HTTP/2.0', 'server_protocol variable');
+
+# $scheme
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/scheme' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "DATA" } @$frames;
+is($frame->{data}, 'http', 'scheme variable');
+
+# $https
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/https' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "DATA" } @$frames;
+is($frame->{data}, 'body ', 'https variable');
+
+# $request_length, HEADERS payload length
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+	{ name => ':method', value => 'GET', mode => 0 },		# 1
+	{ name => ':scheme', value => 'http', mode => 0 },		# 1
+	{ name => ':authority', value => 'localhost', mode => 1 },	# 1+1+9
+	{ name => ':path', value => '/rl', mode => 1 }]});		# 1+1+3
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "DATA" } @$frames;
+is($frame->{data}, '18', 'request length');
+
+# $request_length, HEADERS+CONTINUATION payload length
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ continuation => 1, headers => [
+	{ name => ':method', value => 'GET', mode => 0 },		# 1
+	{ name => ':authority', value => 'localhost', mode => 1 },	# 1+1+9
+	{ name => ':path', value => '/rl', mode => 1 }]});		# 1+1+3
+$s->h2_continue($sid, { headers => [
+	{ name => ':scheme', value => 'http', mode => 0 }]});		# 1
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "DATA" } @$frames;
+is($frame->{data}, '18', 'request length');
+
+###############################################################################
diff --git a/tests/headers.t b/tests/headers.t
new file mode 100644
index 0000000..44538c1
--- /dev/null
+++ b/tests/headers.t
@@ -0,0 +1,182 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Maxim Dounin
+# (C) Nginx, Inc.
+
+# Tests for headers module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy/)->plan(28)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        add_header   X-URI $uri;
+        add_header   X-Always $uri always;
+        add_header   ETag foo always;
+        add_header   ETag '' always;
+        expires      epoch;
+
+        location /t1 {
+        }
+
+        location /nx {
+        }
+
+        location /epoch {
+            expires epoch;
+        }
+
+        location /max {
+            expires max;
+        }
+
+        location /off {
+            expires off;
+        }
+
+        location /access {
+            expires 2048;
+
+            location /access_inner {
+                # inherited from outer
+            }
+        }
+
+        location /negative {
+            expires -2048;
+        }
+
+        location /daily {
+            expires @15h30m33s;
+        }
+
+        location /modified {
+            expires modified 2048;
+
+            location /modified/proxy {
+                proxy_pass http://127.0.0.1:8081/modified;
+            }
+        }
+
+        location /var {
+            expires $arg_e;
+
+            location /var_inner {
+                # inherited from outer
+            }
+
+            location /var_modified {
+                expires modified $arg_e;
+            }
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        add_header   Last-Modified "Mon, 28 Sep 1970 06:00:00 GMT";
+    }
+}
+
+EOF
+
+$t->write_file('t1', '');
+$t->write_file('epoch', '');
+$t->write_file('max', '');
+$t->write_file('off', '');
+$t->write_file('access', '');
+$t->write_file('access_inner', '');
+$t->write_file('negative', '');
+$t->write_file('daily', '');
+$t->write_file('modified', '');
+$t->write_file('var', '');
+$t->write_file('var_inner', '');
+$t->write_file('var_modified', '');
+
+$t->run();
+
+###############################################################################
+
+my $r;
+
+# test for header field presence
+
+$r = http_get('/t1');
+like($r, qr/Cache-Control/, 'good expires');
+like($r, qr/X-URI/, 'good add_header');
+like($r, qr/X-Always/, 'good add_header always');
+unlike($r, qr/ETag/, 'good add_header always empty');
+
+$r = http_get('/nx');
+unlike($r, qr/Cache-Control/, 'bad expires');
+unlike($r, qr/X-URI/, 'bad add_header');
+like($r, qr/X-Always/, 'bad add_header always');
+unlike($r, qr/ETag/, 'bad add_header always empty');
+
+# various expires variants
+
+like(http_get('/epoch'), qr/Expires:.*1970/, 'expires epoch');
+like(http_get('/max'), qr/Expires:.*2037/, 'expires max');
+unlike(http_get('/off'), qr/Expires:/, 'expires off');
+like(http_get('/access'), qr/max-age=2048/, 'expires access');
+like(http_get('/access_inner'), qr/max-age=2048/, 'expires inner');
+like(http_get('/negative'), qr/no-cache/, 'expires negative');
+like(http_get('/daily'), qr/Expires:.*:33 GMT/, 'expires daily');
+like(http_get('/modified'), qr/max-age=204./, 'expires modified');
+
+# "expires modified" with proxy
+
+like(http_get('/modified/proxy'), qr/Expires: Mon, 28 Sep 1970 06:34:08 GMT/,
+	'expires modified proxy');
+
+# expires with variables
+
+like(http_get('/var?e=epoch'), qr/Expires:.*1970/, 'expires var epoch');
+like(http_get('/var?e=max'), qr/Expires:.*2037/, 'expires var max');
+unlike(http_get('/var?e=off'), qr/Expires:/, 'expires var off');
+like(http_get('/var?e=2048'), qr/max-age=2048/, 'expires var access');
+like(http_get('/var_inner?e=2048'), qr/max-age=2048/, 'expires var inner');
+like(http_get('/var?e=-2048'), qr/no-cache/, 'expires var negative');
+like(http_get('/var?e=@33s'), qr/Expires:.*:33 GMT/, 'expires var daily');
+like(http_get('/var_modified?e=2048'), qr/max-age=204./,
+	'expires var modified');
+
+# some invalid cases
+
+unlike(http_get('/var'), qr/Expires/, 'expires var empty');
+unlike(http_get('/var?e=bad'), qr/Expires/, 'expires var bad');
+unlike(http_get('/var_modified?e=epoch'), qr/Expires/,
+	'expires var modified epoch');
+
+###############################################################################
diff --git a/tests/http_absolute_redirect.t b/tests/http_absolute_redirect.t
new file mode 100644
index 0000000..93ac138
--- /dev/null
+++ b/tests/http_absolute_redirect.t
@@ -0,0 +1,118 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for absolute_redirect directive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy rewrite/)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    absolute_redirect off;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  on;
+
+        absolute_redirect on;
+
+        location / { }
+
+        location /auto/ {
+            proxy_pass http://127.0.0.1:8080;
+        }
+
+        location /return301 {
+            return 301 /redirect;
+        }
+
+        location /i/ {
+            alias %%TESTDIR%%/;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  off;
+
+        location / { }
+
+        location /auto/ {
+            proxy_pass http://127.0.0.1:8080;
+        }
+
+        location /return301 {
+            return 301 /redirect;
+        }
+
+        location /i/ {
+            alias %%TESTDIR%%/;
+        }
+    }
+}
+
+EOF
+
+mkdir($t->testdir() . '/dir');
+
+$t->run()->plan(10);
+
+###############################################################################
+
+my $p = port(8080);
+
+like(get('on', '/dir'), qr!Location: http://on:$p/dir/\x0d?$!m, 'directory');
+like(get('on', '/i/dir'), qr!Location: http://on:$p/i/dir/\x0d?$!m,
+	'directory alias');
+like(get('on', '/auto'), qr!Location: http://on:$p/auto/\x0d?$!m, 'auto');
+like(get('on', '/auto?a=b'), qr!Location: http://on:$p/auto/\?a=b\x0d?$!m,
+	'auto args');
+like(get('on', '/return301'), qr!Location: http://on:$p/redirect\x0d?$!m,
+	'return');
+
+like(get('off', '/dir'), qr!Location: /dir/\x0d?$!m, 'off directory');
+like(get('off', '/i/dir'), qr!Location: /i/dir/\x0d?$!m, 'off directory alias');
+like(get('off', '/auto'), qr!Location: /auto/\x0d?$!m, 'off auto');
+like(get('off', '/auto?a=b'), qr!Location: /auto/\?a=b\x0d?$!m,
+	'off auto args');
+like(get('off', '/return301'), qr!Location: /redirect\x0d?$!m, 'off return');
+
+###############################################################################
+
+sub get {
+	my ($host, $uri) = @_;
+	http(<<EOF);
+GET $uri HTTP/1.0
+Host: $host
+
+EOF
+}
+
+###############################################################################
diff --git a/tests/http_disable_symlinks.t b/tests/http_disable_symlinks.t
new file mode 100644
index 0000000..327f1cf
--- /dev/null
+++ b/tests/http_disable_symlinks.t
@@ -0,0 +1,288 @@
+#!/usr/bin/perl
+
+# (C) Andrey Belov
+
+# Tests for disable_symlinks directive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+use POSIX;
+use Cwd qw/ realpath /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http rewrite symlink/)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  s1;
+
+        location /on/ {
+            disable_symlinks on;
+        }
+
+        location /not_owner/ {
+            disable_symlinks if_not_owner;
+        }
+
+        location /try_on/ {
+            disable_symlinks on;
+            try_files $uri $uri.html =404;
+        }
+
+        location /try_not_owner/ {
+            disable_symlinks if_not_owner;
+            try_files $uri $uri.txt =404;
+        }
+
+        location /if_on/ {
+            disable_symlinks on;
+            if (-f $request_filename) {
+                return 204;
+            }
+        }
+
+        location /if_not_owner/ {
+            disable_symlinks if_not_owner;
+            if (-f $request_filename) {
+                return 204;
+            }
+        }
+
+        location /complex/1/ {
+            disable_symlinks on;
+            alias %%TESTDIR%%/./cached/../;
+        }
+
+        location /complex/2/ {
+            disable_symlinks on;
+            alias %%TESTDIR%%//./cached/..//;
+        }
+
+        location /complex/3/ {
+            disable_symlinks on;
+            alias ///%%TESTDIR%%//./cached/..//;
+        }
+
+        location ~ (.+/)tail$ {
+            disable_symlinks on;
+            alias %%TESTDIR%%/$1;
+        }
+
+        location ~ (.+/)tailowner$ {
+            disable_symlinks if_not_owner;
+            alias %%TESTDIR%%/$1;
+        }
+
+        location ~ (.+/)tailoff$ {
+            disable_symlinks off;
+            alias %%TESTDIR%%/$1;
+        }
+
+        location /dir {
+            disable_symlinks on;
+            try_files $uri/ =404;
+        }
+
+        location /from {
+            disable_symlinks on from=$document_root;
+
+            location /from/wo_slash {
+                alias %%TESTDIR%%/dirlink;
+            }
+            location /from/with_slash/ {
+                alias %%TESTDIR%%/dirlink/;
+            }
+            location ~ ^/from/exact/(.+)$ {
+                alias %%TESTDIR%%/$1;
+            }
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  s2;
+
+        open_file_cache max=16 inactive=60s;
+        open_file_cache_valid 30s;
+        open_file_cache_min_uses 1;
+        open_file_cache_errors on;
+
+        location /cached-off/ {
+            disable_symlinks off;
+            alias %%TESTDIR%%/cached/;
+        }
+
+        location /cached-on/ {
+            disable_symlinks on;
+            alias %%TESTDIR%%/cached/;
+        }
+
+        location /cached-if-not-owner/ {
+            disable_symlinks if_not_owner;
+            alias %%TESTDIR%%/cached/;
+        }
+
+        location / {
+            disable_symlinks off;
+        }
+    }
+}
+
+EOF
+
+my $uid = getuid();
+my ($extfile) = grep { -f && !-l && $uid != (stat())[4] }
+	('/etc/resolv.conf', '/etc/protocols', '/etc/host.conf');
+
+plan(skip_all => 'no external file found')
+	if !defined $extfile;
+
+$t->try_run('no disable_symlinks')->plan(28);
+
+my $d = $t->testdir();
+
+mkdir("$d/on");
+mkdir("$d/not_owner");
+mkdir("$d/try_on");
+mkdir("$d/try_not_owner");
+mkdir("$d/if_on");
+mkdir("$d/if_not_owner");
+mkdir("$d/cached");
+
+$t->write_file("empty.html", "");
+symlink("empty.html", "$d/link");
+symlink($extfile, "$d/link2");
+
+$t->write_file("on/empty.html", "");
+symlink("empty.html", "$d/on/link");
+symlink($extfile, "$d/on/link2");
+
+$t->write_file("not_owner/empty.html", "");
+symlink("empty.html", "$d/not_owner/link");
+symlink($extfile, "$d/not_owner/link2");
+
+$t->write_file("try_on/try.html", "LOCAL TRY");
+symlink($extfile, "$d/try_on/try");
+
+$t->write_file("try_not_owner/try.html", "LOCAL TRY");
+symlink($extfile, "$d/try_not_owner/try");
+symlink("try.html", "$d/try_not_owner/try.txt");
+
+$t->write_file("if_on/empty.html", "");
+symlink("empty.html", "$d/if_on/link");
+symlink($extfile, "$d/if_on/link2");
+
+$t->write_file("if_not_owner/empty.html", "");
+symlink("empty.html", "$d/if_not_owner/link");
+symlink($extfile, "$d/if_not_owner/link2");
+
+mkdir("$d/dir");
+$t->write_file("dir/empty.html", "");
+symlink("dir", "$d/dirlink");
+
+symlink($extfile, "$d/cached/link");
+
+###############################################################################
+
+SKIP: {
+skip 'cannot test under symlink', 25 if $d ne realpath($d) or $^O eq 'netbsd';
+
+like(http_get_host('s1', '/link'), qr!200 OK!, 'static (off, same uid)');
+like(http_get_host('s1', '/link2'), qr!200 OK!, 'static (off, other uid)');
+
+like(http_get_host('s1', '/on/link'), qr!403 Forbidden!,
+	'static (on, same uid)');
+like(http_get_host('s1', '/on/link2'), qr!403 Forbidden!,
+	'static (on, other uid)');
+
+like(http_get_host('s1', '/not_owner/link'), qr!200 OK!,
+	'static (if_not_owner, same uid)');
+like(http_get_host('s1', '/not_owner/link2'), qr!403 Forbidden!,
+	'static (if_not_owner, other uid)');
+
+like(http_get_host('s1', '/try_on/try'), qr/LOCAL TRY/,
+	'try_files (on)');
+like(http_get_host('s1', '/try_not_owner/try'), qr/LOCAL TRY/,
+	'try_files (if_not_owner)');
+
+like(http_get_host('s1', '/if_on/link'), qr!403 Forbidden!,
+	'if (on, same uid)');
+like(http_get_host('s1', '/if_on/link2'), qr!403 Forbidden!,
+	'if (on, other uid)');
+
+like(http_get_host('s1', '/if_not_owner/link'), qr!204 No Content!,
+	'if (if_not_owner, same uid)');
+like(http_get_host('s1', '/if_not_owner/link2'), qr!403 Forbidden!,
+	'if (if_not_owner, other uid)');
+
+like(http_get_host('s2', '/cached-off/link'), qr!200 OK!,
+	'open_file_cache (pass 1)');
+like(http_get_host('s2', '/cached-on/link'), qr!403 Forbidden!,
+	'open_file_cache (pass 2)');
+like(http_get_host('s2', '/cached-off/link'), qr!200 OK!,
+	'open_file_cache (pass 3)');
+like(http_get_host('s2', '/cached-if-not-owner/link'), qr!403 Forbidden!,
+	'open_file_cache (pass 4)');
+like(http_get_host('s2', '/cached-off/link'), qr!200 OK!,
+	'open_file_cache (pass 5)');
+
+like(http_get('/complex/1/empty.html'), qr!200 OK!, 'complex root 1');
+like(http_get('/complex/2/empty.html'), qr!200 OK!, 'complex root 2');
+like(http_get('/complex/3/empty.html'), qr!200 OK!, 'complex root 3');
+
+# workaround for freebsd 8: we use O_EXEC instead of O_SEARCH (since there
+# is no O_SEARCH), and O_DIRECTORY does nothing.  setting the 'x' bit
+# tests to pass as openat() will correctly fail with ENOTDIR
+
+chmod(0700, "$d/link");
+my $rc = $^O eq 'darwin' ? 200 : 404;
+
+like(http_get('/link/tail'), qr!40[34] !, 'file with trailing /, on');
+like(http_get('/link/tailowner'), qr!404 !, 'file with trailing /, owner');
+like(http_get('/link/tailoff'), qr!$rc !, 'file with trailing /, off');
+
+like(http_get('/dirlink'), qr!404 !, 'directory without /');
+like(http_get('/dirlink/'), qr!404 !, 'directory with trailing /');
+
+} # SKIP: cannot test under symlink
+
+like(http_get('/from/wo_slash/empty.html'), qr!200 OK!, '"from=" without /');
+like(http_get('/from/with_slash/empty.html'), qr!200 OK!, '"from=" with /');
+like(http_get('/from/exact/link'), qr!200 OK!, '"from=" exact match');
+
+###############################################################################
+
+sub http_get_host {
+	my ($host, $url) = @_;
+	return http(<<EOF);
+GET $url HTTP/1.0
+Host: $host
+
+EOF
+}
+
+###############################################################################
diff --git a/tests/http_error_page.t b/tests/http_error_page.t
new file mode 100644
index 0000000..ce947f0
--- /dev/null
+++ b/tests/http_error_page.t
@@ -0,0 +1,153 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for error_page directive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy rewrite/)->plan(9)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /redirect200 {
+            error_page 404 =200 http://example.com/;
+            return 404;
+        }
+
+        location /redirect497 {
+            # 497 implies implicit status code change
+            error_page 497 https://example.com/;
+            return 497;
+        }
+
+        location /error302redirect {
+            error_page 302 http://example.com/;
+            return 302 "first";
+        }
+
+        location /error302return302text {
+            error_page 302 /return302text;
+            return 302 "first";
+        }
+
+        location /return302text {
+            return 302 "http://example.com/";
+        }
+
+        location /error302return302args {
+            error_page 302 /return302args?1;
+            return 302 "first";
+        }
+
+        location /error302return302varargs {
+            error_page 302 /return302args?$arg_a;
+            return 302 "first";
+        }
+
+        location /return302args {
+            return 302 "http://example.com/$args";
+        }
+
+        location /error302rewrite {
+            error_page 302 /rewrite;
+            return 302 "first";
+        }
+
+        location /rewrite {
+            rewrite ^ http://example.com/;
+        }
+
+        location /error302directory {
+            error_page 302 /directory;
+            return 302 "first";
+        }
+
+        location /directory {
+        }
+
+        location /error302auto {
+            error_page 302 /auto;
+            return 302 "first";
+        }
+
+        location /auto/ {
+            proxy_pass http://127.0.0.1:8081;
+        }
+    }
+}
+
+EOF
+
+mkdir($t->testdir() . '/directory');
+
+$t->run();
+
+###############################################################################
+
+# tests for error_page status code change for redirects. problems
+# introduced in 0.8.53 and fixed in 0.9.5.
+
+like(http_get('/redirect200'), qr!HTTP!, 'redirect 200');
+like(http_get('/redirect497'), qr!HTTP/1.1 302!, 'redirect 497');
+
+# various tests to see if old location cleared if we happen to redirect
+# again in error_page 302
+
+like(http_get('/error302redirect'),
+	qr{HTTP/1.1 302(?!.*Location: first).*Location: http://example.com/}ms,
+	'error 302 redirect - old location cleared');
+
+like(http_get('/error302return302text'),
+	qr{HTTP/1.1 302(?!.*Location: first).*Location: http://example.com/}ms,
+	'error 302 return 302 text - old location cleared');
+
+like(http_get('/error302return302args'),
+	qr{HTTP/1.1 302(?!.*Location: first).*Location: http://example.com/1}ms,
+	'error 302 return 302 args - old location cleared');
+
+like(http_get('/error302return302varargs?a=2'),
+	qr{HTTP/1.1 302(?!.*Location: first).*Location: http://example.com/2}ms,
+	'error 302 return 302 var args - old location cleared');
+
+like(http_get('/error302rewrite'),
+	qr{HTTP/1.1 302(?!.*Location: first).*Location: http://example.com/}ms,
+	'error 302 rewrite - old location cleared');
+
+like(http_get('/error302directory'),
+	qr{HTTP/1.1 301(?!.*Location: first).*Location: http://}ms,
+	'error 302 directory redirect - old location cleared');
+
+like(http_get('/error302auto'),
+	qr{HTTP/1.1 301(?!.*Location: first).*Location: http://}ms,
+	'error 302 auto redirect - old location cleared');
+
+###############################################################################
diff --git a/tests/http_expect_100_continue.t b/tests/http_expect_100_continue.t
new file mode 100644
index 0000000..636b057
--- /dev/null
+++ b/tests/http_expect_100_continue.t
@@ -0,0 +1,107 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for Expect: 100-continue support.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy/)->plan(5);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+        location / {
+            proxy_pass http://127.0.0.1:8080/local;
+        }
+        location /local {
+        }
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+like(http_100_request('/', '1.1'), qr/ 100 /, 'expect 100 continue');
+
+# Comparison of expectation values is case-insensitive for unquoted tokens.
+
+like(http_100_request('/', '1.1', '100-Continue'), qr/ 100 /,
+	'expect 100 continue case-insensitive');
+
+# From RFC 2616, 8.2.3 Use of the 100 (Continue) Status:
+#
+#      - An origin server SHOULD NOT send a 100 (Continue) response if
+#        the request message does not include an Expect request-header
+#        field with the "100-continue" expectation, and MUST NOT send a
+#        100 (Continue) response if such a request comes from an HTTP/1.0
+#        (or earlier) client.
+
+unlike(http_100_request('/', '1.0'), qr/ 100 /, 'no 100 continue via http 1.0');
+
+# From RFC 2616, 14.20 Expect:
+#
+#    A server that does not understand or is unable to comply with any of
+#    the expectation values in the Expect field of a request MUST respond
+#    with appropriate error status. The server MUST respond with a 417
+#    (Expectation Failed) status if any of the expectations cannot be met.
+#
+#    <..> If a server receives a request containing an
+#    Expect field that includes an expectation-extension that it does not
+#    support, it MUST respond with a 417 (Expectation Failed) status.
+
+TODO: {
+local $TODO = 'not yet';
+
+like(http_100_request('/', '1.1', 'unknown'), qr/ 417 /, 'unknown expectation');
+like(http_100_request('/', '1.1', 'token=param'), qr/ 417 /,
+	'unsupported expectation extension');
+
+}
+
+###############################################################################
+
+sub http_100_request {
+	my ($url, $version, $value) = @_;
+	$value = '100-continue' unless defined $value;
+	http(<<EOF);
+POST $url HTTP/$version
+Host: localhost
+Expect: $value
+Content-Length: 0
+Connection: close
+
+EOF
+}
+
+###############################################################################
diff --git a/tests/http_header_buffers.t b/tests/http_header_buffers.t
new file mode 100644
index 0000000..7ff48fd
--- /dev/null
+++ b/tests/http_header_buffers.t
@@ -0,0 +1,248 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+# (C) Nginx, Inc.
+
+# Tests for large_client_header_buffers directive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http rewrite/)->plan(10)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    connection_pool_size 128;
+    client_header_buffer_size 128;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  five;
+
+        large_client_header_buffers 5 256;
+
+        return 204;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  ten;
+
+        large_client_header_buffers 10 256;
+
+        return 204;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  one;
+
+        large_client_header_buffers 1 256;
+
+        return 204;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  foo;
+
+        large_client_header_buffers 5 256;
+
+        add_header X-URI $uri;
+        add_header X-Foo $http_x_foo;
+        return 204;
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+TODO: {
+todo_skip 'overflow', 2 unless $ENV{TEST_NGINX_UNSAFE};
+
+# if hc->busy is allocated before the virtual server is selected,
+# and then additional buffers are allocated in a virtual server with larger
+# number of buffers configured, hc->busy will be overflowed
+
+like(http(
+	"GET / HTTP/1.0" . CRLF .
+	"X-Foo: " . ("1234567890" x 20) . CRLF .
+	"Host: ten" . CRLF .
+	"X-Foo: " . ("1234567890" x 20) . CRLF .
+	"X-Foo: " . ("1234567890" x 20) . CRLF .
+	"X-Foo: " . ("1234567890" x 20) . CRLF .
+	"X-Foo: " . ("1234567890" x 20) . CRLF .
+	"X-Foo: " . ("1234567890" x 20) . CRLF .
+	CRLF
+), qr/204|400/, 'additional buffers in virtual server');
+
+# for pipelined requests large header buffers are saved to hc->free;
+# it sized for number of buffers in the current virtual server, but
+# saves previously allocated buffers, and there may be more buffers if
+# allocatad before the virtual server was selected
+
+like(http(
+	"GET / HTTP/1.1" . CRLF .
+	"X-Foo: " . ("1234567890" x 20) . CRLF .
+	"X-Foo: " . ("1234567890" x 20) . CRLF .
+	"X-Foo: " . ("1234567890" x 20) . CRLF .
+	"X-Foo: " . ("1234567890" x 20) . CRLF .
+	"X-Foo: " . ("1234567890" x 20) . CRLF .
+	"Host: one" . CRLF .
+	CRLF .
+	"GET / HTTP/1.1" . CRLF .
+	"Host: one" . CRLF .
+	"Connection: close" . CRLF .
+	CRLF
+), qr/204/, 'pipelined with too many buffers');
+
+}
+
+# check if long header and long request lines are correctly returned
+# when nginx allocates a long header buffer
+
+like(http(
+	"GET / HTTP/1.0" . CRLF .
+	"Host: foo" . CRLF .
+	"X-Foo: foo" . ("1234567890" x 20) . "bar" . CRLF .
+	CRLF
+), qr/X-Foo: foo(1234567890){20}bar/, 'long header');
+
+like(http(
+	"GET /foo" . ("1234567890" x 20) . "bar HTTP/1.0" . CRLF .
+	"Host: foo" . CRLF .
+	CRLF
+), qr!X-URI: /foo(1234567890){20}bar!, 'long request line');
+
+# the same as the above, but with pipelining, so there is a buffer
+# allocated in the previous request
+
+like(http(
+	"GET / HTTP/1.1" . CRLF .
+	"Host: foo" . CRLF .
+	"X-Foo: " . ("1234567890" x 20) . CRLF .
+	"X-Foo: " . ("1234567890" x 20) . CRLF .
+	"X-Foo: " . ("1234567890" x 20) . CRLF .
+	CRLF .
+	"GET / HTTP/1.1" . CRLF .
+	"Host: foo" . CRLF .
+	"Connection: close" . CRLF .
+	"X-Foo: foo" . ("1234567890" x 20) . "bar" . CRLF .
+	CRLF
+), qr/X-Foo: foo(1234567890){20}bar/, 'long header after pipelining');
+
+like(http(
+	"GET / HTTP/1.1" . CRLF .
+	"Host: foo" . CRLF .
+	"X-Foo: " . ("1234567890" x 20) . CRLF .
+	"X-Foo: " . ("1234567890" x 20) . CRLF .
+	"X-Foo: " . ("1234567890" x 20) . CRLF .
+	CRLF .
+	"GET /foo" . ("1234567890" x 20) . "bar HTTP/1.1" . CRLF .
+	"Host: foo" . CRLF .
+	"Connection: close" . CRLF .
+	CRLF
+), qr!X-URI: /foo(1234567890){20}bar!, 'long request line after pipelining');
+
+# the same as the above, but with keepalive; this ensures that previously
+# allocated buffers are properly cleaned up when we set keepalive handler
+
+like(http(
+	"GET / HTTP/1.1" . CRLF .
+	"Host: foo" . CRLF .
+	"X-Foo: " . ("1234567890" x 20) . CRLF .
+	"X-Foo: " . ("1234567890" x 20) . CRLF .
+	"X-Foo: " . ("1234567890" x 20) . CRLF .
+	CRLF,
+sleep => 0.1, body =>
+	"GET / HTTP/1.1" . CRLF .
+	"Host: foo" . CRLF .
+	"Connection: close" . CRLF .
+	"X-Foo: foo" . ("1234567890" x 20) . "bar" . CRLF .
+	CRLF
+), qr/X-Foo: foo(1234567890){20}bar/, 'long header after keepalive');
+
+like(http(
+	"GET / HTTP/1.1" . CRLF .
+	"Host: foo" . CRLF .
+	"X-Foo: " . ("1234567890" x 20) . CRLF .
+	"X-Foo: " . ("1234567890" x 20) . CRLF .
+	"X-Foo: " . ("1234567890" x 20) . CRLF .
+	CRLF,
+sleep => 0.1, body =>
+	"GET /foo" . ("1234567890" x 20) . "bar HTTP/1.1" . CRLF .
+	"Host: foo" . CRLF .
+	"Connection: close" . CRLF .
+	CRLF
+), qr!X-URI: /foo(1234567890){20}bar!, 'long request line after keepalive');
+
+# the same as the above, but with pipelining and then keepalive;
+# this ensures that previously allocated buffers are properly cleaned
+# up when we set keepalive handler, including hc->free
+
+like(http(
+	"GET / HTTP/1.1" . CRLF .
+	"Host: foo" . CRLF .
+	"X-Foo: " . ("1234567890" x 20) . CRLF .
+	"X-Foo: " . ("1234567890" x 20) . CRLF .
+	"X-Foo: " . ("1234567890" x 20) . CRLF .
+	CRLF .
+	"GET / HTTP/1.1" . CRLF .
+	"Host: foo" . CRLF .
+	"X-Foo: " . ("1234567890" x 20) . CRLF .
+	CRLF,
+sleep => 0.1, body =>
+	"GET / HTTP/1.1" . CRLF .
+	"Host: foo" . CRLF .
+	"Connection: close" . CRLF .
+	"X-Foo: foo" . ("1234567890" x 20) . "bar" . CRLF .
+	CRLF
+), qr/X-Foo: foo(1234567890){20}bar/, 'long header after both');
+
+like(http(
+	"GET / HTTP/1.1" . CRLF .
+	"Host: foo" . CRLF .
+	"X-Foo: " . ("1234567890" x 20) . CRLF .
+	"X-Foo: " . ("1234567890" x 20) . CRLF .
+	"X-Foo: " . ("1234567890" x 20) . CRLF .
+	CRLF .
+	"GET / HTTP/1.1" . CRLF .
+	"Host: foo" . CRLF .
+	"X-Foo: " . ("1234567890" x 20) . CRLF .
+	CRLF,
+sleep => 0.1, body =>
+	"GET /foo" . ("1234567890" x 20) . "bar HTTP/1.1" . CRLF .
+	"Host: foo" . CRLF .
+	"Connection: close" . CRLF .
+	CRLF
+), qr!X-URI: /foo(1234567890){20}bar!, 'long request line after both');
+
+###############################################################################
diff --git a/tests/http_host.t b/tests/http_host.t
new file mode 100644
index 0000000..7bd0dcc
--- /dev/null
+++ b/tests/http_host.t
@@ -0,0 +1,201 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+# (C) Valentin Bartenev
+
+# Tests for host parsing in requests.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http rewrite/)->plan(36);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen  127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            return  200  $host;
+        }
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+is(http_host_header('www.abcd-ef.g02.xyz'), 'www.abcd-ef.g02.xyz',
+	'domain w/o port (host header)');
+is(http_host_header('abcd-ef.g02.xyz:' . port(8080)), 'abcd-ef.g02.xyz',
+	'domain w/port (host header)');
+
+is(http_absolute_path('abcd-ef.g02.xyz'), 'abcd-ef.g02.xyz',
+	'domain w/o port (absolute request)');
+is(http_absolute_path('www.abcd-ef.g02.xyz:10'), 'www.abcd-ef.g02.xyz',
+	'domain w/port (absolute request)');
+
+
+is(http_host_header('www.abcd-ef.g02.xyz.'), 'www.abcd-ef.g02.xyz',
+	'domain w/ ending dot w/o port (host header)');
+
+is(http_host_header('abcd-ef.g02.xyz.:88'), 'abcd-ef.g02.xyz',
+	'domain w/ ending dot w/port (host header)');
+
+is(http_absolute_path('www.abcd-ef.g02.xyz.'), 'www.abcd-ef.g02.xyz',
+	'domain w/ ending dot w/o port (absolute request)');
+is(http_absolute_path('abcd-ef.g02.xyz.:2'), 'abcd-ef.g02.xyz',
+	'domain w/ ending dot w/port (absolute request)');
+
+
+is(http_absolute_path('AbC-d93.0.34ZhGt-s.nk.Ru'), 'abc-d93.0.34zhgt-s.nk.ru',
+	'mixed case domain w/o port (absolute request)');
+is(http_host_header('AbC-d93.0.34ZhGt-s.nk.Ru:88'), 'abc-d93.0.34zhgt-s.nk.ru',
+	'mixed case domain w/port (host header)');
+
+
+is(http_host_header('123.40.56.78'), '123.40.56.78',
+	'ipv4 w/o port (host header)');
+is(http_host_header('123.49.0.78:987'), '123.49.0.78',
+	'ipv4 w/port (host header)');
+
+is(http_absolute_path('123.49.0.78'), '123.49.0.78',
+	'ipv4 w/o port (absolute request)');
+is(http_absolute_path('123.40.56.78:123'), '123.40.56.78',
+	'ipv4 w/port (absolute request)');
+
+is(http_host_header('[abcd::ef98:0:7654:321]'), '[abcd::ef98:0:7654:321]',
+	'ipv6 literal w/o port (host header)');
+is(http_host_header('[abcd::ef98:0:7654:321]:80'), '[abcd::ef98:0:7654:321]',
+	'ipv6 literal w/port (host header)');
+
+is(http_absolute_path('[abcd::ef98:0:7654:321]'), '[abcd::ef98:0:7654:321]',
+	'ipv6 literal w/o port (absolute request)');
+is(http_absolute_path('[abcd::ef98:0:7654:321]:5'), '[abcd::ef98:0:7654:321]',
+	'ipv6 literal w/port (absolute request)');
+
+is(http_host_header('[::ffff:12.30.67.89]'), '[::ffff:12.30.67.89]',
+	'ipv4-mapped ipv6 w/o port (host header)');
+is(http_host_header('[::123.45.67.89]:4321'), '[::123.45.67.89]',
+	'ipv4-mapped ipv6 w/port (host header)');
+
+is(http_absolute_path('[::123.45.67.89]'), '[::123.45.67.89]',
+	'ipv4-mapped ipv6 w/o port (absolute request)');
+is(http_absolute_path('[::ffff:12.30.67.89]:4321'), '[::ffff:12.30.67.89]',
+	'ipv4-mapped ipv6 w/port (absolute request)');
+
+like(http_host_header('example.com/\:552', 1), qr/ 400 /,
+	'domain w/ path separators (host header)');
+like(http_absolute_path('\e/xample.com', 1), qr/ 400 /,
+	'domain w/ path separators (absolute request)');
+
+like(http_host_header('..examp-LE.com', 1), qr/ 400 /,
+	'domain w/ double dot (host header)');
+like(http_absolute_path('com.exa-m.45..:', 1), qr/ 400 /,
+	'domain w/ double dot (absolute request)');
+
+
+like(http_host_header('[abcd::e\f98:0/:7654:321]', 1), qr/ 400 /,
+	'ipv6 literal w/ path separators (host header)');
+like(http_absolute_path('[abcd\::ef98:0:7654:321/]:12', 1), qr/ 400 /,
+	'ipv6 literal w/ path separators (absolute request)');
+
+like(http_host_header('[abcd::ef98:0:7654:321]..:98', 1), qr/ 400 /,
+	'ipv6 literal w/ double dot (host header)');
+like(http_absolute_path('[ab..cd::ef98:0:7654:321]', 1), qr/ 400 /,
+	'ipv6 literal w/ double dot (absolute request)');
+
+
+like(http_host_header('[abcd::ef98:0:7654:321]..:98', 1), qr/ 400 /,
+	'ipv6 literal w/ double dot (host header)');
+like(http_absolute_path('[ab..cd::ef98:0:7654:321]', 1), qr/ 400 /,
+	'ipv6 literal w/ double dot (absolute request)');
+
+
+# As per RFC 3986,
+# http://tools.ietf.org/html/rfc3986#section-3.2.2
+#
+# IP-literal    = "[" ( IPv6address / IPvFuture  ) "]"
+#
+# IPvFuture     = "v" 1*HEXDIG "." 1*( unreserved / sub-delims / ":" )
+#
+# sub-delims    = "!" / "$" / "&" / "'" / "(" / ")"
+#               / "*" / "+" / "," / ";" / "="
+#
+# unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
+#
+
+is(http_host_header(
+	'[v0123456789aBcDeF.!$&\'()*+,;=-._~AbCdEfGhIjKlMnOpQrStUvWxYz'
+	. '0123456789:]'),
+	'[v0123456789abcdef.!$&\'()*+,;=-._~abcdefghijklmnopqrstuvwxyz'
+	. '0123456789:]',
+	'IPvFuture all symbols (host header)');
+
+is(http_absolute_path(
+	'[v0123456789aBcDeF.!$&\'()*+,;=-._~AbCdEfGhIjKlMnOpQrStUvWxYz'
+	. '0123456789:]'),
+	'[v0123456789abcdef.!$&\'()*+,;=-._~abcdefghijklmnopqrstuvwxyz'
+	. '0123456789:]',
+	'IPvFuture all symbols (absolute request)');
+
+is(http_host_header('123.40.56.78:9000:80'), '123.40.56.78',
+	'double port hack');
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.17.9');
+
+like(http_host_header("localhost\nHost: again", 1), qr/ 400 /, 'host repeat');
+
+}
+
+###############################################################################
+
+sub http_host_header {
+	my ($host, $all) = @_;
+	my ($r) = http(<<EOF);
+GET / HTTP/1.0
+Host: $host
+
+EOF
+	return ($all ? $r : Test::Nginx::http_content($r));
+}
+
+sub http_absolute_path {
+	my ($host, $all) = @_;
+	my ($r) = http(<<EOF);
+GET http://$host/ HTTP/1.0
+Host: localhost
+
+EOF
+	return ($all ? $r : Test::Nginx::http_content($r));
+}
+
+###############################################################################
diff --git a/tests/http_include.t b/tests/http_include.t
new file mode 100644
index 0000000..d4ee01b
--- /dev/null
+++ b/tests/http_include.t
@@ -0,0 +1,102 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for include directive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http rewrite proxy access/)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    upstream u {
+        include ups.conf;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        if ($arg_s) {
+            include sif.conf;
+        }
+
+        location / {
+            if ($arg_l) {
+                include lif.conf;
+            }
+        }
+
+        location /lmt {
+            limit_except GET {
+                include lmt.conf;
+            }
+        }
+
+        location /proxy {
+            add_header X-IP $upstream_addr always;
+            proxy_pass http://u/backend;
+        }
+
+        location /backend { }
+    }
+}
+
+EOF
+
+my $p = port(8080);
+
+$t->write_file('sif.conf', 'return 200 SIF;');
+$t->write_file('lif.conf', 'return 200 LIF;');
+$t->write_file('lmt.conf', 'deny all;');
+$t->write_file('ups.conf', "server 127.0.0.1:$p;");
+
+$t->try_run('no include in any context')->plan(5);
+
+###############################################################################
+
+like(http_get('/?s=1'), qr/SIF/, 'include in server if');
+like(http_get('/?l=1'), qr/LIF/, 'include in location if');
+like(http_post('/lmt'), qr/ 403 /, 'include in limit_except');
+like(http_get('/proxy'), qr/X-IP: 127.0.0.1:$p/, 'include in upstream');
+
+unlike(http_get('/'), qr/ 200 /, 'no include');
+
+###############################################################################
+
+sub http_post {
+	my ($uri) = @_;
+	http(<<EOF);
+POST $uri HTTP/1.0
+Host: localhost
+
+EOF
+}
+
+###############################################################################
diff --git a/tests/http_keepalive.t b/tests/http_keepalive.t
new file mode 100644
index 0000000..6993259
--- /dev/null
+++ b/tests/http_keepalive.t
@@ -0,0 +1,166 @@
+#!/usr/bin/perl
+
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+
+# Tests for http keepalive directives.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use IO::Select;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http/)->plan(14)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    log_format test $sent_http_connection;
+    access_log %%TESTDIR%%/test.log test if=$arg_l;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        keepalive_requests  2;
+        keepalive_timeout   1 9;
+
+        location / { }
+        location /r {
+            keepalive_requests  4;
+        }
+
+        location /safari {
+            keepalive_disable  safari;
+        }
+
+        location /none {
+            keepalive_disable  none;
+        }
+
+        location /zero {
+            keepalive_timeout  0;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('index.html', '');
+$t->write_file('r', '');
+$t->write_file('safari', '');
+$t->write_file('none', '');
+$t->write_file('zero', '');
+$t->run();
+
+###############################################################################
+
+# keepalive_requests
+
+like(http_keepalive('/'), qr/Connection: keep-alive/, 'keepalive request');
+is(count_keepalive(http_keepalive('/?l=ok', req => 2)), 1, 'keepalive limit');
+is(count_keepalive(http_keepalive('/r', req => 3)), 3, 'keepalive merge');
+is(count_keepalive(http_keepalive('/r', req => 5)), 3, 'keepalive merge limit');
+
+# keepalive_disable
+
+like(http_keepalive('/', method => 'POST', ua => "MSIE 5.0"),
+	qr/Connection: close/, 'keepalive disable msie6');
+like(http_keepalive('/', ua => "MSIE 5.0"), qr/Connection: keep-alive/,
+	'keepalive disable msie6 GET');
+like(http_keepalive('/', method => 'POST', ua => "MSIE 7.0"),
+	qr/Connection: keep-alive/, 'keepalive disable msie6 modern');
+like(http_keepalive('/', ua => "Mac OS X Safari/7534.48.3"),
+	qr/Connection: keep-alive/, 'keepalive disable msie6 safari');
+like(http_keepalive('/safari', ua => "Mac OS X Safari/7534.48.3"),
+	qr/Connection: close/, 'keepalive disable safari');
+like(http_keepalive('/none', method => 'POST', ua => "MSIE 5.0"),
+	qr/Connection: keep-alive/, 'keepalive disable none');
+
+# keepalive_timeout
+
+my $r = http_keepalive('/', req => 2, sleep => 2.1);
+is(count_keepalive($r), 1, 'keepalive timeout request');
+like($r, qr/Keep-Alive: timeout=9/, 'keepalive timeout header');
+
+like(http_keepalive('/zero'), qr/Connection: close/, 'keepalive timeout 0');
+
+$t->stop();
+
+TODO: {
+local $TODO = 'not yet';
+
+is($t->read_file('test.log'), "keep-alive\nclose\n", 'sent_http_connection');
+
+}
+
+###############################################################################
+
+sub http_keepalive {
+	my ($url, %opts) = @_;
+	my $total = '';
+
+	$opts{ua} = $opts{ua} || '';
+	$opts{req} = $opts{req} || 1;
+	$opts{sleep} = $opts{sleep} || 0;
+	$opts{method} = $opts{method} || 'GET';
+
+	local $SIG{PIPE} = 'IGNORE';
+
+	my $s = http('', start => 1);
+
+	for my $i (1 .. $opts{req}) {
+
+		my $sleep = ($i == 1 ? $opts{sleep} : 0);
+
+		http(<<EOF, socket => $s, start => 1, sleep => $sleep);
+$opts{method} $url HTTP/1.1
+Host: localhost
+User-Agent: $opts{ua}
+
+EOF
+
+		my $data = '';
+
+		while (IO::Select->new($s)->can_read(3)) {
+			sysread($s, my $buffer, 4096) or last;
+			$data .= $buffer;
+			last if $data =~ /^\x0d\x0a/ms;
+		}
+
+		log_in($data);
+
+		$total .= $data;
+	}
+
+	return $total;
+}
+
+sub count_keepalive {
+	my ($str) = @_;
+	return $str =~ s/Connection: keep-alive//g;
+}
+
+###############################################################################
diff --git a/tests/http_listen.t b/tests/http_listen.t
new file mode 100644
index 0000000..e63f27c
--- /dev/null
+++ b/tests/http_listen.t
@@ -0,0 +1,97 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for listen port ranges.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy rewrite/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        listen       127.0.0.1:%%PORT_8082%%-%%PORT_8083%%;
+        listen       %%PORT_8085%%-%%PORT_8086%%;
+        listen       [::1]:%%PORT_8085%%-%%PORT_8086%%;
+        server_name  localhost;
+
+        location / {
+            proxy_pass  http://$arg_b/t;
+        }
+
+        location /t {
+            return  200  $server_addr:$server_port;
+        }
+    }
+
+    # catch out of range
+
+    server {
+        listen       127.0.0.1:8081;
+        listen       127.0.0.1:8084;
+        listen       127.0.0.1:8087;
+        listen       [::1]:%%PORT_8084%%;
+        listen       [::1]:%%PORT_8087%%;
+        server_name  localhost;
+    }
+}
+
+EOF
+
+my $p0 = port(8080); my $p3 = port(8083); my $p6 = port(8086);
+my $p1 = port(8081); my $p4 = port(8084); my $p7 = port(8087);
+my $p2 = port(8082); my $p5 = port(8085);
+
+plan(skip_all => 'listen on wildcard address')
+	unless $ENV{TEST_NGINX_UNSAFE};
+
+plan(skip_all => 'no requested ranges')
+	if "$p0$p1$p2$p3$p4$p5$p6$p7" ne "80808081808280838084808580868087";
+
+$t->run()->plan(12);
+
+###############################################################################
+
+like(http_get("/?b=127.0.0.1:$p0"), qr/127.0.0.1:$p0/, 'single');
+unlike(http_get("/?b=127.0.0.1:$p1"), qr/127.0.0.1:$p1/, 'out of range 1');
+like(http_get("/?b=127.0.0.1:$p2"), qr/127.0.0.1:$p2/, 'range 1');
+like(http_get("/?b=127.0.0.1:$p3"), qr/127.0.0.1:$p3/, 'range 2');
+unlike(http_get("/?b=127.0.0.1:$p4"), qr/127.0.0.$p4/, 'out of range 2');
+like(http_get("/?b=127.0.0.1:$p5"), qr/127.0.0.1:$p5/, 'wildcard range 1');
+like(http_get("/?b=127.0.0.1:$p6"), qr/127.0.0.1:$p6/, 'wildcard range 2');
+unlike(http_get("/?b=127.0.0.1:$p7"), qr/127.0.0.1:$p7/, 'out of range 3');
+
+unlike(http_get("/?b=[::1]:$p4"), qr/::1:$p4/, 'out of range 4');
+like(http_get("/?b=[::1]:$p5"), qr/::1:$p5/, 'ipv6 range 1');
+like(http_get("/?b=[::1]:$p6"), qr/::1:$p6/, 'ipv6 range 2');
+unlike(http_get("/?b=[::1]:$p7"), qr/::1:$p7/, 'out of range 5');
+
+###############################################################################
diff --git a/tests/http_location.t b/tests/http_location.t
new file mode 100644
index 0000000..625132d
--- /dev/null
+++ b/tests/http_location.t
@@ -0,0 +1,132 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for location selection.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http rewrite/)->plan(14)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location = / {
+            add_header X-Location exactlyroot;
+            return 204;
+        }
+
+        location / {
+            add_header X-Location root;
+            return 204;
+        }
+
+        location ^~ /images/ {
+            add_header X-Location images;
+            return 204;
+        }
+
+        location ~* \.(gif|jpg|jpeg)$ {
+            add_header X-Location regex;
+            return 204;
+        }
+
+        location ~ casefull {
+            add_header X-Location casefull;
+            return 204;
+        }
+
+        location = /foo {
+            add_header X-Location "/foo exact";
+            return 204;
+        }
+
+        location /foo {
+            add_header X-Location "/foo prefix";
+            return 204;
+        }
+
+        location = /foo/ {
+            add_header X-Location "/foo/ exact";
+            return 204;
+        }
+
+        location /foo/ {
+            add_header X-Location "/foo/ prefix";
+            return 204;
+        }
+
+        location /lowercase {
+            add_header X-Location lowercase;
+            return 204;
+        }
+
+        location /UPPERCASE {
+            add_header X-Location uppercase;
+            return 204;
+        }
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+like(http_get('/'), qr/X-Location: exactlyroot/, 'exactlyroot');
+like(http_get('/x'), qr/X-Location: root/, 'root');
+like(http_get('/images/t.gif'), qr/X-Location: images/, 'images');
+like(http_get('/t.gif'), qr/X-Location: regex/, 'regex');
+like(http_get('/t.GIF'), qr/X-Location: regex/, 'regex with mungled case');
+like(http_get('/casefull/t.gif'), qr/X-Location: regex/, 'first regex wins');
+like(http_get('/casefull/'), qr/X-Location: casefull/, 'casefull regex');
+
+like(http_get('/foo'), qr!X-Location: /foo exact!, '/foo exact');
+like(http_get('/foobar'), qr!X-Location: /foo prefix!, '/foo prefix');
+like(http_get('/foo/'), qr!X-Location: /foo/ exact!, '/foo/ exact');
+like(http_get('/foo/bar'), qr!X-Location: /foo/ prefix!, '/foo/ prefix');
+
+SKIP: {
+	skip 'caseless os', 1
+		if $^O eq 'MSWin32' or $^O eq 'darwin';
+
+	like(http_get('/CASEFULL/'), qr/X-Location: root/,
+		'casefull regex do not match wrong case');
+}
+
+# on case-insensitive systems a request to "/UPPERCASE" might fail,
+# if location search tree is incorrectly sorted and uppercase
+# characters are used in location directives (ticket #90)
+
+like(http_get('/lowercase'), qr/X-Location: lowercase/, 'lowercase');
+like(http_get('/UPPERCASE'), qr/X-Location: uppercase/, 'uppercase');
+
+###############################################################################
diff --git a/tests/http_location_auto.t b/tests/http_location_auto.t
new file mode 100644
index 0000000..0cb0c6e
--- /dev/null
+++ b/tests/http_location_auto.t
@@ -0,0 +1,73 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for location selection, an auto_redirect edge case.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy rewrite/)->plan(4)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        proxy_hide_header X-Location;
+        add_header X-Location unset;
+
+        # As of nginx 1.5.4, this results in the following
+        # location tree:
+        #
+        #         "/a-b"
+        # "/a-a"          "/a/"
+        #
+        # A request to "/a" is expected to match "/a/" with auto_redirect,
+        # but with such a tree it tests locations "/a-b", "/a-a" and then
+        # falls back to null location.
+        #
+        # Key factor is that "-" is less than "/".
+
+        location /a/  { proxy_pass http://127.0.0.1:8080/a-a; }
+        location /a-a { add_header X-Location a-a; return 204; }
+        location /a-b { add_header X-Location a-b; return 204; }
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+like(http_get('/a'), qr/301 Moved/, 'auto redirect');
+like(http_get('/a/'), qr/X-Location: unset/, 'match a');
+like(http_get('/a-a'), qr/X-Location: a-a/, 'match a-a');
+like(http_get('/a-b'), qr/X-Location: a-b/, 'match a-b');
+
+###############################################################################
diff --git a/tests/http_location_win32.t b/tests/http_location_win32.t
new file mode 100644
index 0000000..06733e5
--- /dev/null
+++ b/tests/http_location_win32.t
@@ -0,0 +1,118 @@
+#!/usr/bin/env perl
+
+# (C) Maxim Dounin
+
+# Tests for location selection on win32.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+plan(skip_all => 'not win32')
+	if $^O ne 'MSWin32' && $^O ne 'msys';
+
+my $t = Test::Nginx->new()->has(qw/http rewrite/)->plan(19)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon         off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            add_header X-Location root;
+            return 204;
+        }
+
+        location /directory/ {
+            add_header X-Location directory;
+            return 204;
+        }
+
+        location /direct~1 {
+        }
+
+        location = /file {
+            add_header X-Location file;
+            return 204;
+        }
+    }
+}
+
+EOF
+
+$t->run();
+
+my $d = $t->testdir();
+mkdir("$d/directory");
+
+$t->write_file('directory/file', 'SEE-THIS');
+
+###############################################################################
+
+like(http_get('/x'), qr/X-Location: root/, 'root');
+
+# these all are mapped to "/directory/"
+
+like(http_get('/directory/'), qr/X-Location: directory/, 'directory');
+like(http_get('/Directory/'), qr/X-Location: directory/, 'directory caseless');
+like(http_get('/directory./'), qr/X-Location: directory/, 'directory dot');
+like(http_get('/directory.%2ffile'), qr/X-Location: directory/,
+	'directory dot encoded slash');
+like(http_get('/directory::$index_allocation/'),
+	qr/X-Location: directory|400 Bad/,
+	'directory stream');
+like(http_get('/directory::$index_allocation./'),
+	qr/X-Location: directory|400 Bad/,
+	'directory stream dot');
+like(http_get('/directory:$i30:$index_allocation./'),
+	qr/X-Location: directory|400 Bad/,
+	'directory i30 stream dot');
+
+# these looks similar, but shouldn't be mapped to "/directory/"
+
+like(http_get('/directory../'), qr/X-Location: root/, 'directory dot dot');
+like(http_get('/directory.::$index_allocation/'), qr/X-Location: root|400 Bad/,
+	'directory dot stream');
+
+# short name, should be rejected
+
+unlike(http_get('/direct~1/file'), qr/SEE-THIS/, 'short name');
+unlike(http_get('/direct~1./file'), qr/SEE-THIS/, 'short name dot');
+unlike(http_get('/direct~1::$index_allocation./file'), qr/SEE-THIS/,
+	'short name stream dot');
+unlike(http_get('/direct~1.::$index_allocation/file'), qr/SEE-THIS/,
+	'short name dot stream');
+
+# these should be mapped to /file
+
+like(http_get('/file'), qr/X-Location: file/, 'file');
+like(http_get('/file.'), qr/X-Location: file/, 'file dot');
+like(http_get('/file..'), qr/X-Location: file/, 'file dot dot');
+like(http_get('/file%20.%20.'), qr/X-Location: file/, 'file dots and spaces');
+like(http_get('/file::$data..'), qr/X-Location: file|400 Bad/,
+	'file stream dot dot');
+
+###############################################################################
diff --git a/tests/http_resolver.t b/tests/http_resolver.t
new file mode 100644
index 0000000..4645e13
--- /dev/null
+++ b/tests/http_resolver.t
@@ -0,0 +1,595 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http resolver.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use IO::Select;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx qw/ :DEFAULT http_end /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy rewrite/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            resolver    127.0.0.1:%%PORT_8981_UDP%%;
+            resolver_timeout 1s;
+            proxy_pass  http://$host:%%PORT_8080%%/backend;
+
+            proxy_next_upstream http_504 timeout error;
+            proxy_intercept_errors on;
+            proxy_connect_timeout 1s;
+            error_page 504 502 /50x;
+        }
+        location /two {
+            resolver    127.0.0.1:%%PORT_8981_UDP%% 127.0.0.1:%%PORT_8982_UDP%%;
+            proxy_pass  http://$host:%%PORT_8080%%/backend;
+        }
+        location /valid {
+            resolver    127.0.0.1:%%PORT_8981_UDP%% valid=5s;
+            proxy_pass  http://$host:%%PORT_8080%%/backend;
+        }
+        location /case {
+            resolver    127.0.0.1:%%PORT_8981_UDP%%;
+            proxy_pass  http://$http_x_name:%%PORT_8080%%/backend;
+        }
+        location /invalid {
+            proxy_pass  http://$host:%%PORT_8080%%/backend;
+        }
+        location /long {
+            resolver    127.0.0.1:%%PORT_8981_UDP%%;
+            resolver_timeout 4s;
+            proxy_pass  http://$host:%%PORT_8080%%/backend;
+        }
+        location /resend {
+            resolver    127.0.0.1:%%PORT_8981_UDP%%;
+            resolver_timeout 8s;
+            proxy_pass  http://$host:%%PORT_8080%%/backend;
+        }
+        location /bad {
+            resolver    127.0.0.1:%%PORT_8984_UDP%%;
+            resolver_timeout 1s;
+            proxy_pass  http://$host:%%PORT_8080%%/backend;
+        }
+        location /tcp {
+            resolver    127.0.0.1:%%PORT_8983_UDP%% 127.0.0.1:%%PORT_8982_UDP%%;
+            resolver_timeout 1s;
+            proxy_pass  http://$host:%%PORT_8080%%/backend;
+            proxy_connect_timeout 1s;
+            add_header X-IP $upstream_addr;
+            error_page 504 502 /50x;
+
+            location /tcp2 {
+                resolver_timeout 8s;
+                proxy_pass  http://$host:%%PORT_8080%%/backend;
+            }
+        }
+
+        location /backend {
+            return 200;
+        }
+        location /50x {
+            return 200 $upstream_addr;
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&dns_daemon, port(8981), $t);
+$t->run_daemon(\&dns_daemon, port(8982), $t);
+
+$t->run_daemon(\&dns_daemon, port(8983), $t, tcp => 1);
+$t->waitforfile($t->testdir . '/' . port(8983));
+port(8983, socket => 1)->close();
+
+$t->run_daemon(\&dns_daemon, port(8984), $t);
+
+$t->run()->plan(38);
+
+$t->waitforfile($t->testdir . '/' . port(8981));
+$t->waitforfile($t->testdir . '/' . port(8982));
+$t->waitforfile($t->testdir . '/' . port(8984));
+
+###############################################################################
+
+my $p0 = port(8080);
+
+# schedule resend test, which takes about 5 seconds to complete
+
+my $s = http_host_header('id.example.net', '/resend', start => 1);
+my $fe = http_host_header('fe.example.net', '/resend', start => 1);
+
+like(http_host_header('a.example.net', '/'), qr/200 OK/, 'A');
+
+# ensure that resolver serves queries from cache in a case-insensitive manner
+# we check this by marking 2nd and subsequent queries on backend with SERVFAIL
+
+http_x_name_header('case.example.net', '/case');
+like(http_x_name_header('CASE.example.net', '/case'), qr/200 OK/,
+	'A case-insensitive');
+
+like(http_host_header('awide.example.net', '/'), qr/200 OK/, 'A uncompressed');
+like(http_host_header('short.example.net', '/'), qr/502 Bad/,
+	'A short dns response');
+
+like(http_host_header('nx.example.net', '/'), qr/502 Bad/, 'NXDOMAIN');
+like(http_host_header('cname.example.net', '/'), qr/200 OK/, 'CNAME');
+like(http_host_header('cname.example.net', '/'), qr/200 OK/,
+	'CNAME cached');
+
+# CNAME + A combined answer
+# demonstrates the name in answer section different from what is asked
+
+like(http_host_header('cname_a.example.net', '/'), qr/200 OK/, 'CNAME + A');
+
+# CNAME refers to non-existing A
+
+like(http_host_header('cname2.example.net', '/'), qr/502 Bad/, 'CNAME bad');
+like(http_host_header('long.example.net', '/'), qr/200 OK/, 'long label');
+like(http_host_header('long2.example.net', '/'), qr/200 OK/, 'long name');
+
+# take into account DNAME
+
+like(http_host_header('alias.example.com', '/'), qr/200 OK/, 'DNAME');
+
+# many A records in round robin
+# nonexisting IPs enumerated with proxy_next_upstream
+
+like(http_host_header('many.example.net', '/'),
+	qr/^127.0.0.20(1:$p0, 127.0.0.202:$p0|2:$p0, 127.0.0.201:$p0)$/m,
+	'A many');
+
+like(http_host_header('many.example.net', '/'),
+	qr/^127.0.0.20(1:$p0, 127.0.0.202:$p0|2:$p0, 127.0.0.201:$p0)$/m,
+	'A many cached');
+
+# tests for several resolvers specified in directive
+# query bad ns, make sure that error responses are not cached
+
+like(http_host_header('2.example.net', '/two'), qr/502 Bad/, 'two ns bad');
+
+# now get correct response
+
+like(http_host_header('2.example.net', '/two'), qr/200 OK/, 'two ns good');
+
+# response is cached, actual request would get error
+
+like(http_host_header('2.example.net', '/two'), qr/200 OK/, 'two ns cached');
+
+# ttl tested with 1st req good and 2nd req bad
+# send 1st request and cache its good response
+
+like(http_host_header('ttl.example.net', '/'), qr/200 OK/, 'ttl');
+
+# response is cached, actual request would get error
+
+like(http_host_header('ttl.example.net', '/'), qr/200 OK/, 'ttl cached 1');
+like(http_host_header('ttl.example.net', '/'), qr/200 OK/, 'ttl cached 2');
+
+sleep 2;
+
+# expired ttl causes nginx to make actual query
+
+like(http_host_header('ttl.example.net', '/'), qr/502 Bad/, 'ttl expired');
+
+# zero ttl prohibits response caching
+
+like(http_host_header('ttl0.example.net', '/'), qr/200 OK/, 'zero ttl');
+
+TODO: {
+local $TODO = 'support for zero ttl';
+
+like(http_host_header('ttl0.example.net', '/'), qr/502 Bad/,
+	'zero ttl not cached');
+
+}
+
+# "valid" parameter tested with 1st req good and 2nd req bad
+# send 1st request and cache its good response
+
+like(http_host_header('ttl.example.net', '/valid'), qr/200 OK/, 'valid');
+
+# response is cached, actual request would get error
+
+like(http_host_header('ttl.example.net', '/valid'), qr/200 OK/,
+	'valid cached 1');
+like(http_host_header('ttl.example.net', '/valid'), qr/200 OK/,
+	'valid cached 2');
+
+sleep 2;
+
+# expired ttl is overridden with "valid" parameter
+# response is taken from cache
+
+like(http_host_header('ttl.example.net', '/valid'), qr/200 OK/,
+	'valid overrides ttl');
+
+sleep 4;
+
+# expired "valid" value causes nginx to make actual query
+
+like(http_host_header('ttl.example.net', '/valid'), qr/502 Bad/,
+	'valid expired');
+
+# Ensure that resolver respects expired CNAME in CNAME + A combined response.
+# When ttl in CNAME is expired, the answer should not be served from cache.
+# Catch this by returning SERVFAIL on the 2nd and subsequent queries.
+
+http_host_header('cname_a_ttl2.example.net', '/');
+
+sleep 2;
+
+like(http_host_header('cname_a_ttl2.example.net', '/'), qr/502 Bad/,
+	'CNAME + A with expired CNAME ttl');
+
+like(http_host_header('example.net', '/invalid'), qr/502 Bad/, 'no resolver');
+
+like(http_end($s), qr/200 OK/, 'resend after malformed response');
+like(http_end($fe), qr/200 OK/, 'resend after format error');
+
+$s = http_get('/bad', start => 1);
+my $s2 = http_get('/bad', start => 1);
+
+http_end($s);
+ok(http_end($s2), 'timeout handler on 2nd request');
+
+like(http_host_header('fe_id.example.net', '/'), qr/502 Bad/, 'format error');
+
+# several requests waiting on same name query
+# 1st request aborts before name is resolved
+# 2nd request completes on resolver timeout
+
+$s = http_host_header('timeout.example.net', '/long', start => 1);
+$s2 = http_host_header('timeout.example.net', '/long', start => 1);
+
+select undef, undef, undef, 1.1;
+
+close $s;
+
+like(http_end($s2), qr/502 Bad/, 'timeout after aborted request');
+
+# resend DNS query over TCP once UDP response came truncated
+
+unlike(http_host_header('tcp.example.net', '/tcp'), qr/127.0.0.201/, 'tc');
+like(http_host_header('tcp.example.net', '/tcp'), qr/X-IP: 127.0.0.1/, 'tcp');
+like(http_host_header('tcp2.example.net', '/tcp2'), qr/X-IP: 127.0.0.1/,
+	'tcp with resend');
+
+###############################################################################
+
+sub http_host_header {
+	my ($host, $uri, %extra) = @_;
+	return http(<<EOF, %extra);
+GET $uri HTTP/1.0
+Host: $host
+
+EOF
+}
+
+sub http_x_name_header {
+	my ($host, $uri) = @_;
+	return http(<<EOF);
+GET $uri HTTP/1.0
+X-Name: $host
+
+EOF
+}
+
+###############################################################################
+
+sub reply_handler {
+	my ($recv_data, $port, $state, %extra) = @_;
+
+	my (@name, @rdata);
+
+	use constant NOERROR	=> 0;
+	use constant FORMERR	=> 1;
+	use constant SERVFAIL	=> 2;
+	use constant NXDOMAIN	=> 3;
+
+	use constant A		=> 1;
+	use constant CNAME	=> 5;
+	use constant DNAME	=> 39;
+
+	use constant IN		=> 1;
+
+	# default values
+
+	my ($hdr, $rcode, $ttl) = (0x8180, NOERROR, 3600);
+
+	# decode name
+
+	my ($len, $offset) = (undef, 12);
+	while (1) {
+		$len = unpack("\@$offset C", $recv_data);
+		last if $len == 0;
+		$offset++;
+		push @name, unpack("\@$offset A$len", $recv_data);
+		$offset += $len;
+	}
+
+	$offset -= 1;
+	my ($id, $type, $class) = unpack("n x$offset n2", $recv_data);
+
+	my $name = join('.', @name);
+	if (($name eq 'a.example.net') || ($name eq 'alias.example.net')) {
+		if ($type == A || $type == CNAME) {
+			push @rdata, rd_addr($ttl, '127.0.0.1');
+		}
+
+	} elsif ($name eq 'fe.example.net' && $type == A) {
+		if (++$state->{fecnt} > 1) {
+			$rcode = FORMERR;
+		}
+
+		push @rdata, rd_addr($ttl, '127.0.0.1');
+
+	} elsif ($name eq 'fe_id.example.net' && $type == A) {
+		$id = 42;
+		$rcode = FORMERR;
+
+	} elsif ($name eq 'case.example.net' && $type == A) {
+		if (++$state->{casecnt} > 1) {
+			$rcode = SERVFAIL;
+		}
+
+		push @rdata, rd_addr($ttl, '127.0.0.1');
+
+	} elsif ($name eq 'id.example.net' && $type == A) {
+		if (++$state->{idcnt} == 1) {
+			$id++;
+		}
+
+		push @rdata, rd_addr($ttl, '127.0.0.1');
+
+	} elsif ($name eq 'awide.example.net' && $type == A) {
+		push @rdata, pack '(C/a*)3x n2N nC4',
+			('awide', 'example', 'net'), A, IN, $ttl,
+			4, (127, 0, 0, 1);
+
+	} elsif (($name eq 'many.example.net') && $type == A) {
+		$state->{manycnt}++;
+		if ($state->{manycnt} > 1) {
+			$rcode = SERVFAIL;
+		}
+
+		push @rdata, rd_addr($ttl, '127.0.0.201');
+		push @rdata, rd_addr($ttl, '127.0.0.202');
+
+
+	} elsif (($name eq 'short.example.net')) {
+		# zero length RDATA in DNS response
+
+		if ($type == A) {
+			push @rdata, rd_addr($ttl, '');
+		}
+
+	} elsif (($name eq 'alias.example.com')) {
+		# example.com.       3600 IN DNAME example.net.
+
+		my @dname = ('example', 'net');
+		my $rdlen = length(join '', @dname) + @dname + 1;
+		push @rdata, pack("n3N n(C/a*)* x", 0xc012, DNAME, IN, $ttl,
+			$rdlen, @dname);
+
+		# alias.example.com. 3600 IN CNAME alias.example.net.
+
+		push @rdata, pack("n3N nCa5n", 0xc00c, CNAME, IN, $ttl,
+			8, 5, 'alias', 0xc02f);
+
+	} elsif ($name eq 'cname.example.net') {
+		$state->{cnamecnt}++;
+		if ($state->{cnamecnt} > 2) {
+			$rcode = SERVFAIL;
+		}
+		push @rdata, pack("n3N nCa5n", 0xc00c, CNAME, IN, $ttl,
+			8, 5, 'alias', 0xc012);
+
+	} elsif ($name eq 'timeout.example.net') {
+		select undef, undef, undef, 2.1;
+		return;
+
+	} elsif ($name eq 'cname_a.example.net') {
+		push @rdata, pack("n3N nCa5n", 0xc00c, CNAME, IN, $ttl,
+			8, 5, 'alias', 0xc014);
+
+		# points to "alias" set in previous rdata
+
+		if ($type == A) {
+			push @rdata, pack('n3N nC4', 0xc031, A, IN, $ttl,
+				4, split(/\./, '127.0.0.1'));
+		}
+
+	} elsif ($name eq 'cname_a_ttl2.example.net' && $type == A) {
+		push @rdata, pack("n3N nCa18n", 0xc00c, CNAME, IN, 1,
+			21, 18, 'cname_a_ttl2_alias', 0xc019);
+		if (++$state->{cttl2cnt} >= 2) {
+			$rcode = SERVFAIL;
+		}
+		push @rdata, pack('n3N nC4', 0xc036, A, IN, $ttl,
+			4, split(/\./, '127.0.0.1'));
+
+	} elsif ($name eq 'cname_a_ttl_alias.example.net' && $type == A) {
+		push @rdata, rd_addr($ttl, '127.0.0.1');
+
+	} elsif ($name eq 'cname2.example.net') {
+		# points to non-existing A
+
+		push @rdata, pack("n3N nCa2n", 0xc00c, CNAME, IN, $ttl,
+			5, 2, 'nx', 0xc02f);
+
+	} elsif ($name eq 'long.example.net') {
+		push @rdata, pack("n3N nCA63x", 0xc00c, CNAME, IN, $ttl,
+			65, 63, 'a' x 63);
+
+	} elsif (($name eq 'a' x 63) && $type == A) {
+		push @rdata, rd_addr($ttl, '127.0.0.1');
+
+	} elsif ($name eq 'long2.example.net') {
+		push @rdata, pack("n3N n(CA63)4x", 0xc00c, CNAME, IN, $ttl, 257,
+			63, 'a' x 63, 63, 'a' x 63, 63, 'a' x 63, 63, 'a' x 63);
+
+	} elsif (($name eq 'a' x 63 . '.' . 'a' x 63 . '.' . 'a' x 63 . '.'
+			. 'a' x 63) && $type == A)
+	{
+		push @rdata, rd_addr($ttl, '127.0.0.1');
+
+	} elsif ($name eq 'ttl.example.net' && $type == A) {
+		$state->{ttlcnt}++;
+		if ($state->{ttlcnt} == 2 || $state->{ttlcnt} == 4) {
+			$rcode = SERVFAIL;
+		}
+
+		push @rdata, rd_addr(1, '127.0.0.1');
+
+	} elsif ($name eq 'ttl0.example.net' && $type == A) {
+		$state->{ttl0cnt}++;
+		if ($state->{ttl0cnt} == 2) {
+			$rcode = SERVFAIL;
+		}
+
+		push @rdata, rd_addr(0, '127.0.0.1');
+
+	} elsif ($name eq '2.example.net') {
+		if ($port == port(8981)) {
+			$state->{twocnt}++;
+		}
+		if ($state->{twocnt} & 1) {
+			$rcode = SERVFAIL;
+		}
+
+		if ($type == A) {
+			push @rdata, rd_addr($ttl, '127.0.0.1');
+		}
+
+	} elsif ($name =~ /tcp2?.example.net/) {
+		$rcode = FORMERR if $port == port(8982);
+		$hdr |= 0x0300 unless $extra{tcp};
+		push @rdata, rd_addr($ttl, $extra{tcp}
+			? '127.0.0.1' : '127.0.0.201') if $type == A;
+	}
+
+	$len = @name;
+	pack("n6 (C/a*)$len x n2", $id, $hdr | $rcode, 1, scalar @rdata,
+		0, 0, @name, $type, $class) . join('', @rdata);
+}
+
+sub rd_addr {
+	my ($ttl, $addr) = @_;
+
+	my $code = 'split(/\./, $addr)';
+
+	return pack 'n3N', 0xc00c, A, IN, $ttl if $addr eq '';
+
+	pack 'n3N nC4', 0xc00c, A, IN, $ttl, eval "scalar $code", eval($code);
+}
+
+sub dns_daemon {
+	my ($port, $t, %extra) = @_;
+
+	my ($data, $recv_data);
+	my $socket = IO::Socket::INET->new(
+		LocalAddr => '127.0.0.1',
+		LocalPort => $port,
+		Proto => 'udp',
+	)
+		or die "Can't create listening socket: $!\n";
+
+	my $sel = IO::Select->new($socket);
+	my $tcp = 0;
+
+	if ($extra{tcp}) {
+		$tcp = port(8983, socket => 1);
+		$sel->add($tcp);
+	}
+
+	local $SIG{PIPE} = 'IGNORE';
+
+	# track number of relevant queries
+
+	my %state = (
+		cnamecnt	=> 0,
+		twocnt		=> 0,
+		ttlcnt		=> 0,
+		ttl0cnt		=> 0,
+		cttlcnt		=> 0,
+		cttl2cnt	=> 0,
+		manycnt		=> 0,
+		casecnt		=> 0,
+		idcnt		=> 0,
+		fecnt		=> 0,
+	);
+
+	# signal we are ready
+
+	open my $fh, '>', $t->testdir() . '/' . $port;
+	close $fh;
+
+	while (my @ready = $sel->can_read) {
+		foreach my $fh (@ready) {
+			if ($tcp == $fh) {
+				my $new = $fh->accept;
+				$new->autoflush(1);
+				$sel->add($new);
+
+			} elsif ($socket == $fh) {
+				$fh->recv($recv_data, 65536);
+				$data = reply_handler($recv_data, $port,
+					\%state);
+				$fh->send($data);
+
+			} else {
+				$fh->recv($recv_data, 65536);
+				unless (length $recv_data) {
+					$sel->remove($fh);
+					$fh->close;
+					next;
+				}
+
+again:
+				my $len = unpack("n", $recv_data);
+				$data = substr $recv_data, 2, $len;
+				$data = reply_handler($data, $port, \%state,
+					tcp => 1);
+				$data = pack("n", length $data) . $data;
+				$fh->send($data);
+				$recv_data = substr $recv_data, 2 + $len;
+				goto again if length $recv_data;
+			}
+		}
+	}
+}
+
+###############################################################################
diff --git a/tests/http_resolver_aaaa.t b/tests/http_resolver_aaaa.t
new file mode 100644
index 0000000..6ae16bc
--- /dev/null
+++ b/tests/http_resolver_aaaa.t
@@ -0,0 +1,628 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for AAAA capable http resolver.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy rewrite/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        listen       [::1]:%%PORT_8080%%;
+        server_name  localhost;
+
+        location / {
+            resolver    127.0.0.1:%%PORT_8981_UDP%%;
+            proxy_pass  http://$host:%%PORT_8080%%/backend;
+
+            proxy_next_upstream http_504 timeout error;
+            proxy_intercept_errors on;
+            proxy_connect_timeout 50ms;
+            error_page 504 502 /50x;
+            add_header X-Host $upstream_addr;
+        }
+        location /two {
+            resolver    127.0.0.1:%%PORT_8981_UDP%% 127.0.0.1:%%PORT_8982_UDP%%;
+            proxy_pass  http://$host:%%PORT_8080%%/backend;
+        }
+
+        location /backend {
+            return 200;
+        }
+        location /50x {
+            return 200 $upstream_addr;
+        }
+    }
+}
+
+EOF
+
+$t->try_run('no inet6 support')->plan(72);
+
+$t->run_daemon(\&dns_daemon, port(8981), $t);
+$t->run_daemon(\&dns_daemon, port(8982), $t);
+
+$t->waitforfile($t->testdir . '/' . port(8981));
+$t->waitforfile($t->testdir . '/' . port(8982));
+
+###############################################################################
+
+my (@n, $response);
+
+my $p0 = port(8080);
+
+like(http_host_header('aaaa.example.net', '/'), qr/\[fe80::1\]/, 'AAAA');
+like(http_host_header('cname.example.net', '/'), qr/\[fe80::1\]/, 'CNAME');
+like(http_host_header('cname.example.net', '/'), qr/\[fe80::1\]/,
+	'CNAME cached');
+
+# CNAME + AAAA combined answer
+# demonstrates the name in answer section different from what is asked
+
+like(http_host_header('cname_a.example.net', '/'), qr/\[::1\]/, 'CNAME + AAAA');
+
+# many AAAA records in round robin
+# nonexisting IPs enumerated with proxy_next_upstream
+
+like(http_host_header('many.example.net', '/'),
+	qr/^\[fe80::(1\]:$p0, \[fe80::2\]:$p0|2\]:$p0, \[fe80::1\]:$p0)$/m,
+	'AAAA many');
+
+like(http_host_header('many.example.net', '/'),
+	qr/^\[fe80::(1\]:$p0, \[fe80::2\]:$p0|2\]:$p0, \[fe80::1\]:$p0)$/m,
+	'AAAA many cached');
+
+# tests for several resolvers specified in directive
+# query bad ns, make sure that error responses are not cached
+
+like(http_host_header('2.example.net', '/two'), qr/502 Bad/, 'two ns bad');
+
+# now get correct response
+
+like(http_host_header('2.example.net', '/two'), qr/200 OK/, 'two ns good');
+
+# response is cached, actual request would get error
+
+like(http_host_header('2.example.net', '/two'), qr/200 OK/, 'two ns cached');
+
+# various ipv4/ipv6 combinations
+
+$response = http_host_header('z_z.example.net', '/');
+is(@n = $response =~ /$p0/g, 0, 'zero zero responses');
+like($response, qr/502 Bad/, 'zero zero');
+
+like(http_host_header('z_n.example.net', '/'), qr/^\[fe80::1\]:$p0$/ms,
+	'zero AAAA');
+
+$response = http_host_header('z_c.example.net', '/');
+is(@n = $response =~ /$p0/g, 2, 'zero CNAME responses');
+like($response, qr/127.0.0.201:$p0/, 'zero CNAME 1');
+like($response, qr/\[fe80::1\]:$p0/, 'zero CNAME 2');
+
+$response = http_host_header('z_cn.example.net', '/');
+is(@n = $response =~ /$p0/g, 2, 'zero CNAME+AAAA responses');
+like($response, qr/\[fe80::1\]:$p0/, 'zero CNAME+AAAA 1');
+like($response, qr/\[fe80::2\]:$p0/, 'zero CNAME+AAAA 2');
+
+$response = http_host_header('z_e.example.net', '/');
+is(@n = $response =~ /$p0/g, 0, 'zero error responses');
+like($response, qr/502 Bad/, 'zero error');
+
+like(http_host_header('n_z.example.net', '/'), qr/^127.0.0.201:$p0$/ms,
+	'A zero');
+
+$response = http_host_header('n_n.example.net', '/');
+is(@n = $response =~ /$p0/g, 2, 'A AAAA responses');
+like($response, qr/127.0.0.201:$p0/, 'A AAAA 1');
+like($response, qr/\[fe80::1\]:$p0/, 'A AAAA 2');
+
+like(http_host_header('n_c.example.net', '/'), qr/^127.0.0.201:$p0$/ms,
+	'A CNAME');
+
+$response = http_host_header('n_cn.example.net', '/');
+is(@n = $response =~ /$p0/g, 4, 'A CNAME+AAAA responses');
+like($response, qr/127.0.0.201:$p0/, 'A CNAME+AAAA 1');
+like($response, qr/127.0.0.202:$p0/, 'A CNAME+AAAA 2');
+like($response, qr/\[fe80::1\]:$p0/, 'A CNAME+AAAA 3');
+like($response, qr/\[fe80::2\]:$p0/, 'A CNAME+AAAA 4');
+
+$response = http_host_header('n_e.example.net', '/');
+is(@n = $response =~ /$p0/g, 0, 'A error responses');
+like($response, qr/502 Bad/, 'A error');
+
+$response = http_host_header('c_z.example.net', '/');
+is(@n = $response =~ /$p0/g, 0, 'CNAME zero responses');
+like($response, qr/502 Bad/, 'CNAME zero');
+
+like(http_host_header('c_n.example.net', '/'), qr/^\[fe80::1\]:$p0$/ms,
+	'CNAME AAAA');
+
+$response = http_host_header('c_c.example.net', '/');
+is(@n = $response =~ /$p0/g, 2, 'CNAME CNAME responses');
+like($response, qr/127.0.0.201:$p0/, 'CNAME CNAME 1');
+like($response, qr/\[fe80::1\]:$p0/, 'CNAME CNAME 2');
+
+like(http_host_header('c1_c2.example.net', '/'), qr/^\[fe80::1\]:$p0$/ms,
+	'CNAME1 CNAME2');
+
+$response = http_host_header('c_cn.example.net', '/');
+is(@n = $response =~ /$p0/g, 2, 'CNAME CNAME+AAAA responses');
+like($response, qr/\[fe80::1\]:$p0/, 'CNAME CNAME+AAAA 1');
+like($response, qr/\[fe80::2\]:$p0/, 'CNAME CNAME+AAAA 1');
+
+$response = http_host_header('c_e.example.net', '/');
+is(@n = $response =~ /$p0/g, 0, 'CNAME error responses');
+like($response, qr/502 Bad/, 'CNAME error');
+
+$response = http_host_header('cn_z.example.net', '/');
+is(@n = $response =~ /$p0/g, 2, 'CNAME+A zero responses');
+like($response, qr/127.0.0.201:$p0/, 'CNAME+A zero 1');
+like($response, qr/127.0.0.202:$p0/, 'CNAME+A zero 2');
+
+$response = http_host_header('cn_n.example.net', '/');
+is(@n = $response =~ /$p0/g, 4, 'CNAME+A AAAA responses');
+like($response, qr/127.0.0.201:$p0/, 'CNAME+A AAAA 1');
+like($response, qr/127.0.0.202:$p0/, 'CNAME+A AAAA 2');
+like($response, qr/\[fe80::1\]:$p0/, 'CNAME+A AAAA 3');
+like($response, qr/\[fe80::2\]:$p0/, 'CNAME+A AAAA 4');
+
+$response = http_host_header('cn_c.example.net', '/');
+is(@n = $response =~ /$p0/g, 2, 'CNAME+A CNAME responses');
+like($response, qr/127.0.0.201:$p0/, 'CNAME+A CNAME 1');
+like($response, qr/127.0.0.202:$p0/, 'CNAME+A CNAME 2');
+
+$response = http_host_header('cn_cn.example.net', '/');
+is(@n = $response =~ /$p0/g, 4, 'CNAME+A CNAME+AAAA responses');
+like($response, qr/127.0.0.201:$p0/, 'CNAME+A CNAME+AAAA 1');
+like($response, qr/127.0.0.202:$p0/, 'CNAME+A CNAME+AAAA 2');
+like($response, qr/\[fe80::1\]:$p0/, 'CNAME+A CNAME+AAAA 3');
+like($response, qr/\[fe80::2\]:$p0/, 'CNAME+A CNAME+AAAA 4');
+
+$response = http_host_header('cn_e.example.net', '/');
+is(@n = $response =~ /$p0/g, 0, 'CNAME+A error responses');
+like($response, qr/502 Bad/, 'CNAME+A error');
+
+$response = http_host_header('e_z.example.net', '/');
+is(@n = $response =~ /$p0/g, 0, 'error zero responses');
+like($response, qr/502 Bad/, 'error zero');
+
+$response = http_host_header('e_n.example.net', '/');
+is(@n = $response =~ /$p0/g, 0, 'error AAAA responses');
+like($response, qr/502 Bad/, 'error AAAA');
+
+$response = http_host_header('e_c.example.net', '/');
+is(@n = $response =~ /$p0/g, 0, 'error CNAME responses');
+like($response, qr/502 Bad/, 'error CNAME');
+
+$response = http_host_header('e_cn.example.net', '/');
+is(@n = $response =~ /$p0/g, 0, 'error CNAME+AAAA responses');
+like($response, qr/502 Bad/, 'error CNAME+AAAA');
+
+$response = http_host_header('e_e.example.net', '/');
+is(@n = $response =~ /$p0/g, 0, 'error error responses');
+like($response, qr/502 Bad/, 'error error');
+
+###############################################################################
+
+sub http_host_header {
+	my ($host, $uri) = @_;
+	return http(<<EOF);
+GET $uri HTTP/1.0
+Host: $host
+
+EOF
+}
+
+###############################################################################
+
+sub reply_handler {
+	my ($recv_data, $port, $state) = @_;
+
+	my (@name, @rdata);
+
+	use constant NOERROR	=> 0;
+	use constant SERVFAIL	=> 2;
+	use constant NXDOMAIN	=> 3;
+
+	use constant A		=> 1;
+	use constant CNAME	=> 5;
+	use constant AAAA	=> 28;
+	use constant DNAME	=> 39;
+
+	use constant IN		=> 1;
+
+	# default values
+
+	my ($hdr, $rcode, $ttl) = (0x8180, NOERROR, 3600);
+
+	# decode name
+
+	my ($len, $offset) = (undef, 12);
+	while (1) {
+		$len = unpack("\@$offset C", $recv_data);
+		last if $len == 0;
+		$offset++;
+		push @name, unpack("\@$offset A$len", $recv_data);
+		$offset += $len;
+	}
+
+	$offset -= 1;
+	my ($id, $type, $class) = unpack("n x$offset n2", $recv_data);
+
+	my $name = join('.', @name);
+	if (($name eq 'aaaa.example.net') || ($name eq 'alias.example.net')) {
+		if ($type == AAAA) {
+			push @rdata, rd_addr6($ttl, "fe80::1");
+		}
+
+	} elsif ($name eq 'alias2.example.net') {
+		if ($type == A) {
+			push @rdata, rd_addr($ttl, '127.0.0.201');
+		}
+		if ($type == AAAA) {
+			push @rdata, rd_addr6($ttl, "fe80::1");
+		}
+
+	} elsif ($name eq 'alias4.example.net') {
+		if ($type == A) {
+			push @rdata, rd_addr($ttl, '127.0.0.201');
+		}
+
+	} elsif ($name eq 'alias6.example.net') {
+		if ($type == AAAA) {
+			push @rdata, rd_addr6($ttl, "fe80::1");
+		}
+
+	} elsif (($name eq 'many.example.net') && $type == AAAA) {
+		$state->{manycnt}++;
+		if ($state->{manycnt} > 1) {
+			$rcode = SERVFAIL;
+		}
+
+		push @rdata, rd_addr6($ttl, 'fe80::1');
+		push @rdata, rd_addr6($ttl, 'fe80::2');
+
+	} elsif ($name eq 'cname.example.net') {
+		$state->{cnamecnt}++;
+		if ($state->{cnamecnt} > 2) {
+			$rcode = SERVFAIL;
+		}
+		push @rdata, pack("n3N nCa5n", 0xc00c, CNAME, IN, $ttl,
+			8, 5, 'alias', 0xc012);
+
+	} elsif ($name eq 'cname_a.example.net') {
+		push @rdata, pack("n3N nCa5n", 0xc00c, CNAME, IN, $ttl,
+			8, 5, 'alias', 0xc014);
+
+		# points to "alias" set in previous rdata
+
+		if ($type == AAAA) {
+			push @rdata, pack('n3N nn8', 0xc031, AAAA, IN, $ttl,
+				16, expand_ip6("::1"));
+		}
+
+	} elsif ($name eq '2.example.net') {
+		if ($port == port(8981)) {
+			$state->{twocnt}++;
+		}
+		if ($state->{twocnt} & 1) {
+			$rcode = SERVFAIL;
+		}
+
+		if ($type == AAAA) {
+			push @rdata, rd_addr6($ttl, '::1');
+		}
+
+	} elsif ($name eq 'z_z.example.net') {
+		# assume no answers given
+
+	} elsif ($name eq 'z_n.example.net') {
+		if ($type == AAAA) {
+			push @rdata, rd_addr6($ttl, 'fe80::1');
+		}
+
+	} elsif ($name eq 'z_c.example.net') {
+		if ($type == AAAA) {
+			push @rdata, pack("n3N nCa6n", 0xc00c, CNAME, IN, $ttl,
+				9, 6, 'alias2', 0xc010);
+		}
+
+	} elsif ($name eq 'z_cn.example.net') {
+		if ($type == AAAA) {
+			push @rdata, pack("n3N nCa5n", 0xc00c, CNAME, IN, $ttl,
+				8, 5, 'alias', 0xc011);
+			push @rdata, pack('n3N nn8', 0xc02e, AAAA, IN, $ttl,
+				16, expand_ip6("fe80::1"));
+			push @rdata, pack('n3N nn8', 0xc02e, AAAA, IN, $ttl,
+				16, expand_ip6("fe80::2"));
+		}
+
+	} elsif ($name eq 'z_e.example.net') {
+		if ($type == AAAA) {
+			$rcode = SERVFAIL;
+		}
+
+	} elsif ($name eq 'n_z.example.net') {
+		if ($type == A) {
+			push @rdata, rd_addr($ttl, '127.0.0.201');
+		}
+
+	} elsif ($name eq 'n_n.example.net') {
+		if ($type == A) {
+			push @rdata, rd_addr($ttl, '127.0.0.201');
+		}
+		if ($type == AAAA) {
+			push @rdata, rd_addr6($ttl, 'fe80::1');
+		}
+
+	} elsif ($name eq 'n_c.example.net') {
+		if ($type == A) {
+			push @rdata, rd_addr($ttl, '127.0.0.201');
+		}
+		if ($type == AAAA) {
+			push @rdata, pack("n3N nCa6n", 0xc00c, CNAME, IN, $ttl,
+				9, 6, 'alias2', 0xc010);
+		}
+
+	} elsif ($name eq 'n_cn.example.net') {
+		if ($type == A) {
+			push @rdata, rd_addr($ttl, '127.0.0.201');
+			push @rdata, rd_addr($ttl, '127.0.0.202');
+		}
+		if ($type == AAAA) {
+			push @rdata, pack("n3N nCa5n", 0xc00c, CNAME, IN, $ttl,
+				8, 5, 'alias', 0xc011);
+			push @rdata, pack('n3N nn8', 0xc02e, AAAA, IN, $ttl,
+				16, expand_ip6("fe80::1"));
+			push @rdata, pack('n3N nn8', 0xc02e, AAAA, IN, $ttl,
+				16, expand_ip6("fe80::2"));
+		}
+
+	} elsif ($name eq 'n_e.example.net') {
+		if ($type == A) {
+			push @rdata, rd_addr($ttl, '127.0.0.201');
+		}
+		if ($type == AAAA) {
+			$rcode = SERVFAIL;
+		}
+
+	} elsif ($name eq 'c_z.example.net') {
+		if ($type == A) {
+			push @rdata, pack("n3N nCa5n", 0xc00c, CNAME, IN, $ttl,
+				8, 5, 'alias', 0xc010);
+		}
+
+	} elsif ($name eq 'c_n.example.net') {
+		if ($type == A) {
+			push @rdata, pack("n3N nCa5n", 0xc00c, CNAME, IN, $ttl,
+				8, 5, 'alias', 0xc010);
+		}
+		if ($type == AAAA) {
+			push @rdata, rd_addr6($ttl, "fe80::1");
+		}
+
+	} elsif ($name eq 'c_c.example.net') {
+		push @rdata, pack("n3N nCa6n", 0xc00c, CNAME, IN, $ttl,
+			9, 6, 'alias2', 0xc010);
+
+	} elsif ($name eq 'c1_c2.example.net') {
+		if ($type == A) {
+			push @rdata, pack("n3N nCa6n", 0xc00c, CNAME, IN, $ttl,
+				9, 6, 'alias4', 0xc012);
+		}
+		if ($type == AAAA) {
+			push @rdata, pack("n3N nCa6n", 0xc00c, CNAME, IN, $ttl,
+				9, 6, 'alias6', 0xc012);
+		}
+
+	} elsif ($name eq 'c_cn.example.net') {
+		push @rdata, pack("n3N nCa6n", 0xc00c, CNAME, IN, $ttl,
+			9, 6, 'alias2', 0xc011);
+
+		if ($type == AAAA) {
+			push @rdata, pack('n3N nn8', 0xc02e, AAAA, IN, $ttl,
+				16, expand_ip6("fe80::1"));
+			push @rdata, pack('n3N nn8', 0xc02e, AAAA, IN, $ttl,
+				16, expand_ip6("fe80::2"));
+		}
+
+	} elsif ($name eq 'cn_z.example.net') {
+		if ($type == A) {
+			push @rdata, pack("n3N nCa6n", 0xc00c, CNAME, IN, $ttl,
+				9, 6, 'alias2', 0xc011);
+			push @rdata, pack("n3N nC4", 0xc02e, A, IN, $ttl,
+				4, split('\.', '127.0.0.201'));
+			push @rdata, pack("n3N nC4", 0xc02e, A, IN, $ttl,
+				4, split('\.', '127.0.0.202'));
+		}
+
+	} elsif ($name eq 'cn_n.example.net') {
+		if ($type == A) {
+			push @rdata, pack("n3N nCa6n", 0xc00c, CNAME, IN, $ttl,
+				9, 6, 'alias2', 0xc011);
+			push @rdata, pack("n3N nC4", 0xc02e, A, IN, $ttl,
+				4, split('\.', '127.0.0.201'));
+			push @rdata, pack("n3N nC4", 0xc02e, A, IN, $ttl,
+				4, split('\.', '127.0.0.202'));
+		}
+		if ($type == AAAA) {
+			push @rdata, pack('n3N nn8', 0xc00c, AAAA, IN, $ttl,
+				16, expand_ip6("fe80::1"));
+			push @rdata, pack('n3N nn8', 0xc00c, AAAA, IN, $ttl,
+				16, expand_ip6("fe80::2"));
+		}
+
+	} elsif ($name eq 'cn_c.example.net') {
+		push @rdata, pack("n3N nCa6n", 0xc00c, CNAME, IN, $ttl,
+			9, 6, 'alias2', 0xc011);
+		if ($type == A) {
+			push @rdata, pack("n3N nC4", 0xc02e, A, IN, $ttl,
+				4, split('\.', '127.0.0.201'));
+			push @rdata, pack("n3N nC4", 0xc02e, A, IN, $ttl,
+				4, split('\.', '127.0.0.202'));
+		}
+
+	} elsif ($name eq 'cn_cn.example.net') {
+		push @rdata, pack("n3N nCa6n", 0xc00c, CNAME, IN, $ttl,
+			9, 6, 'alias2', 0xc012);
+
+		if ($type == A) {
+			push @rdata, pack("n3N nC4", 0xc02f, A, IN, $ttl,
+				4, split('\.', '127.0.0.201'));
+			push @rdata, pack("n3N nC4", 0xc02f, A, IN, $ttl,
+				4, split('\.', '127.0.0.202'));
+		}
+		if ($type == AAAA) {
+			push @rdata, pack('n3N nn8', 0xc02f, AAAA, IN, $ttl,
+				16, expand_ip6("fe80::1"));
+			push @rdata, pack('n3N nn8', 0xc02f, AAAA, IN, $ttl,
+				16, expand_ip6("fe80::2"));
+		}
+
+	} elsif ($name eq 'cn_e.example.net') {
+		if ($type == A) {
+			push @rdata, pack("n3N nCa6n", 0xc00c, CNAME, IN, $ttl,
+				9, 6, 'alias2', 0xc011);
+			push @rdata, pack("n3N nC4", 0xc02e, A, IN, $ttl,
+				4, split('\.', '127.0.0.201'));
+			push @rdata, pack("n3N nC4", 0xc02e, A, IN, $ttl,
+				4, split('\.', '127.0.0.202'));
+		}
+		if ($type == AAAA) {
+			$rcode = SERVFAIL;
+		}
+
+
+	} elsif ($name eq 'e_z.example.net') {
+		if ($type == A) {
+			$rcode = SERVFAIL;
+		}
+
+	} elsif ($name eq 'e_n.example.net') {
+		if ($type == A) {
+			$rcode = SERVFAIL;
+		}
+		if ($type == AAAA) {
+			push @rdata, rd_addr6($ttl, 'fe80::1');
+		}
+
+	} elsif ($name eq 'e_c.example.net') {
+		if ($type == A) {
+			$rcode = SERVFAIL;
+		}
+		if ($type == AAAA) {
+			push @rdata, pack("n3N nCa6n", 0xc00c, CNAME, IN, $ttl,
+				9, 6, 'alias2', 0xc010);
+		}
+
+	} elsif ($name eq 'e_cn.example.net') {
+		if ($type == A) {
+			$rcode = SERVFAIL;
+		}
+		if ($type == AAAA) {
+			push @rdata, pack("n3N nCa5n", 0xc00c, CNAME, IN, $ttl,
+				8, 5, 'alias', 0xc011);
+			push @rdata, pack('n3N nn8', 0xc02e, AAAA, IN, $ttl,
+				16, expand_ip6("fe80::1"));
+			push @rdata, pack('n3N nn8', 0xc02e, AAAA, IN, $ttl,
+				16, expand_ip6("fe80::2"));
+		}
+
+	} elsif ($name eq 'e_e.example.net') {
+		if ($type == A) {
+			$rcode = SERVFAIL;
+		}
+		if ($type == AAAA) {
+			$rcode = NXDOMAIN;
+		}
+	}
+
+	$len = @name;
+	pack("n6 (C/a*)$len x n2", $id, $hdr | $rcode, 1, scalar @rdata,
+		0, 0, @name, $type, $class) . join('', @rdata);
+}
+
+sub rd_addr {
+	my ($ttl, $addr) = @_;
+
+	my $code = 'split(/\./, $addr)';
+
+	pack 'n3N nC4', 0xc00c, A, IN, $ttl, eval "scalar $code", eval($code);
+}
+
+sub expand_ip6 {
+	my ($addr) = @_;
+
+	substr ($addr, index($addr, "::"), 2) =
+		join "0", map { ":" } (0 .. 8 - (split /:/, $addr) + 1);
+	map { hex "0" x (4 - length $_) . "$_" } split /:/, $addr;
+}
+
+sub rd_addr6 {
+	my ($ttl, $addr) = @_;
+
+	pack 'n3N nn8', 0xc00c, AAAA, IN, $ttl, 16, expand_ip6($addr);
+}
+
+sub dns_daemon {
+	my ($port, $t) = @_;
+
+	my ($data, $recv_data);
+	my $socket = IO::Socket::INET->new(
+		LocalAddr => '127.0.0.1',
+		LocalPort => $port,
+		Proto => 'udp',
+	)
+		or die "Can't create listening socket: $!\n";
+
+	# track number of relevant queries
+
+	my %state = (
+		cnamecnt	=> 0,
+		twocnt		=> 0,
+		manycnt		=> 0,
+	);
+
+	# signal we are ready
+
+	open my $fh, '>', $t->testdir() . '/' . $port;
+	close $fh;
+
+	while (1) {
+		$socket->recv($recv_data, 65536);
+		$data = reply_handler($recv_data, $port, \%state);
+		$socket->send($data);
+	}
+}
+
+###############################################################################
diff --git a/tests/http_resolver_cleanup.t b/tests/http_resolver_cleanup.t
new file mode 100644
index 0000000..17041dc
--- /dev/null
+++ b/tests/http_resolver_cleanup.t
@@ -0,0 +1,104 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http resolver, worker process termination.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy/);
+
+plan(skip_all => 'win32') if $^O eq 'MSWin32';
+
+$t->write_file_expand('nginx.conf', <<'EOF')->plan(1);
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            resolver 127.0.0.1:%%PORT_8981_UDP%%;
+            proxy_pass http://example.net/$args;
+        }
+
+        location /pid {
+            add_header X-Pid $pid always;
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&dns_daemon, $t);
+$t->run()->waitforfile($t->testdir . '/' . port(8981));
+
+###############################################################################
+
+# truncated UDP response, no response over TCP
+
+my $s = http_get('/', start => 1);
+
+pass('request');
+
+sleep 1;
+
+# retrasmission timer wasn't removed during resolver cleanup,
+# while the event memory was freed, resulting in use-after-free
+# when later removing timer in TCP connection
+
+http_get('/pid') =~ qr/X-Pid: (\d+)/;
+kill 'TERM', $1;
+
+###############################################################################
+
+sub dns_daemon {
+	my ($t) = @_;
+	my ($data);
+
+	my $socket = IO::Socket::INET->new(
+		LocalAddr => '127.0.0.1',
+		LocalPort => port(8981),
+		Proto => 'udp',
+	)
+		or die "Can't create UDP socket: $!\n";
+
+	# signal we are ready
+
+	open my $fh, '>', $t->testdir() . '/' . port(8981);
+	close $fh;
+
+	while (1) {
+		$socket->recv($data, 65536);
+		# truncation bit set
+		$data |= pack("n2", 0, 0x8380);
+		$socket->send($data);
+	}
+}
+
+###############################################################################
diff --git a/tests/http_resolver_cname.t b/tests/http_resolver_cname.t
new file mode 100644
index 0000000..255dcd9
--- /dev/null
+++ b/tests/http_resolver_cname.t
@@ -0,0 +1,282 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http resolver with CNAME.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx qw/ :DEFAULT http_end /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy/)->plan(11);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /short {
+            resolver    127.0.0.1:%%PORT_8981_UDP%%;
+            resolver_timeout 2s;
+
+            proxy_pass  http://$host:%%PORT_8080%%/t;
+        }
+
+        location /long {
+            resolver    127.0.0.1:%%PORT_8981_UDP%%;
+            resolver_timeout 5s;
+
+            proxy_pass  http://$host:%%PORT_8080%%/t;
+        }
+
+        location / { }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&dns_daemon, port(8981), $t);
+
+$t->write_file('t', '');
+$t->run();
+
+$t->waitforfile($t->testdir . '/' . port(8981));
+
+###############################################################################
+
+# CNAME pointing to name which times out
+
+like(http_host('cn01.example.net', '/short'), qr/502 Bad/, 'CNAME timeout');
+
+# several requests on CNAME pointing to invalid name
+
+my @s;
+
+push @s, http_host('cn03.example.net', '/long', start => 1);
+push @s, http_host('cn03.example.net', '/long', start => 1);
+
+like(http_end(pop @s), qr/502 Bad/, 'invalid CNAME - first');
+like(http_end(pop @s), qr/502 Bad/, 'invalid CNAME - last');
+
+# several requests on CNAME pointing to cached name
+
+@s = ();
+
+http_host('a.example.net', '/long');
+
+push @s, http_host('cn04.example.net', '/long', start => 1);
+push @s, http_host('cn04.example.net', '/long', start => 1);
+
+like(http_end(pop @s), qr/200 OK/, 'cached CNAME - first');
+like(http_end(pop @s), qr/200 OK/, 'cached CNAME - last');
+
+# several requests on CNAME pointing to name being resolved
+
+@s = ();
+
+my $s = http_host('cn06.example.net', '/long', start => 1);
+
+sleep 1;
+
+push @s, http_host('cn05.example.net', '/long', start => 1);
+push @s, http_host('cn05.example.net', '/long', start => 1);
+
+like(http_end(pop @s), qr/502 Bad/, 'CNAME in progress - first');
+like(http_end(pop @s), qr/502 Bad/, 'CNAME in progress - last');
+
+# several requests on CNAME pointing to name which times out
+# 1st request receives CNAME with short ttl
+# 2nd request replaces expired CNAME
+
+@s = ();
+
+push @s, http_host('cn07.example.net', '/long', start => 1);
+
+sleep 2;
+
+push @s, http_host('cn07.example.net', '/long', start => 1);
+
+like(http_end(pop @s), qr/502 Bad/, 'CNAME ttl - first');
+like(http_end(pop @s), qr/502 Bad/, 'CNAME ttl - last');
+
+# several requests on CNAME pointing to name
+# 1st request aborts before name is resolved
+# 2nd request finishes with name resolved
+
+@s = ();
+
+push @s, http_host('cn09.example.net', '/long', start => 1);
+push @s, http_host('cn09.example.net', '/long', start => 1);
+
+select undef, undef, undef, 0.4;	# let resolver hang on CNAME
+
+close(shift @s);
+
+like(http_end(pop @s), qr/200 OK/, 'abort on CNAME');
+
+like(http_host('cn001.example.net', '/short'), qr/502 Bad/, 'recurse uncached');
+
+###############################################################################
+
+sub http_host {
+	my ($host, $uri, %extra) = @_;
+	return http(<<EOF, %extra);
+GET $uri HTTP/1.0
+Host: $host
+
+EOF
+}
+
+###############################################################################
+
+sub reply_handler {
+	my ($recv_data) = @_;
+
+	my (@name, @rdata);
+
+	use constant NOERROR	=> 0;
+
+	use constant A		=> 1;
+	use constant CNAME	=> 5;
+
+	use constant IN		=> 1;
+
+	# default values
+
+	my ($hdr, $rcode, $ttl) = (0x8180, NOERROR, 3600);
+
+	# decode name
+
+	my ($len, $offset) = (undef, 12);
+	while (1) {
+		$len = unpack("\@$offset C", $recv_data);
+		last if $len == 0;
+		$offset++;
+		push @name, unpack("\@$offset A$len", $recv_data);
+		$offset += $len;
+	}
+
+	$offset -= 1;
+	my ($id, $type, $class) = unpack("n x$offset n2", $recv_data);
+
+	my $name = join('.', @name);
+	if ($name eq 'a.example.net' && $type == A) {
+		push @rdata, rd_addr($ttl, '127.0.0.1');
+
+	} elsif ($name eq 'b.example.net' && $type == A) {
+		sleep 2;
+		push @rdata, rd_addr($ttl, '127.0.0.1');
+
+	} elsif ($name eq 'cn01.example.net') {
+		$ttl = 1;
+		push @rdata, pack("n3N nCa4n", 0xc00c, CNAME, IN, $ttl,
+			7, 4, "cn02", 0xc011);
+
+	} elsif ($name =~ /cn0[268].example.net/) {
+		# resolver timeout
+
+		return;
+
+	} elsif ($name eq 'cn03.example.net') {
+		select undef, undef, undef, 1.1;
+		push @rdata, pack("n3N nC", 0xc00c, CNAME, IN, $ttl, 0);
+
+	} elsif ($name eq 'cn04.example.net') {
+		select undef, undef, undef, 1.1;
+		push @rdata, pack("n3N nCa1n", 0xc00c, CNAME, IN, $ttl,
+			4, 1, "a", 0xc011);
+
+	} elsif ($name eq 'cn05.example.net') {
+		select undef, undef, undef, 1.1;
+		push @rdata, pack("n3N nCa4n", 0xc00c, CNAME, IN, $ttl,
+			7, 4, "cn06", 0xc011);
+
+	} elsif ($name eq 'cn07.example.net') {
+		$ttl = 1;
+		push @rdata, pack("n3N nCa4n", 0xc00c, CNAME, IN, $ttl,
+			7, 4, "cn08", 0xc011);
+
+	} elsif ($name eq 'cn09.example.net') {
+		if ($type == A) {
+			# await both HTTP requests
+			select undef, undef, undef, 0.2;
+		}
+		push @rdata, pack("n3N nCa1n", 0xc00c, CNAME, IN, $ttl,
+			4, 1, "b", 0xc011);
+
+	} elsif ($name eq 'cn052.example.net') {
+		if ($type == A) {
+			push @rdata, rd_addr($ttl, '127.0.0.1');
+		}
+
+	} elsif ($name =~ /cn0\d+.example.net/) {
+		my ($id) = $name =~ /cn(\d+)/;
+		$id++;
+		push @rdata, pack("n3N nCa5n", 0xc00c, CNAME, IN, $ttl,
+			8, 5, "cn$id", 0xc012);
+	}
+
+	$len = @name;
+	pack("n6 (C/a*)$len x n2", $id, $hdr | $rcode, 1, scalar @rdata,
+		0, 0, @name, $type, $class) . join('', @rdata);
+}
+
+sub rd_addr {
+	my ($ttl, $addr) = @_;
+
+	my $code = 'split(/\./, $addr)';
+
+	return pack 'n3N', 0xc00c, A, IN, $ttl if $addr eq '';
+
+	pack 'n3N nC4', 0xc00c, A, IN, $ttl, eval "scalar $code", eval($code);
+}
+
+sub dns_daemon {
+	my ($port, $t) = @_;
+
+	my ($data, $recv_data);
+	my $socket = IO::Socket::INET->new(
+		LocalAddr => '127.0.0.1',
+		LocalPort => $port,
+		Proto => 'udp',
+	)
+		or die "Can't create listening socket: $!\n";
+
+	# signal we are ready
+
+	open my $fh, '>', $t->testdir() . '/' . $port;
+	close $fh;
+
+	while (1) {
+		$socket->recv($recv_data, 65536);
+		$data = reply_handler($recv_data);
+		$socket->send($data);
+	}
+}
+
+###############################################################################
diff --git a/tests/http_server_name.t b/tests/http_server_name.t
new file mode 100644
index 0000000..90e3681
--- /dev/null
+++ b/tests/http_server_name.t
@@ -0,0 +1,232 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+
+# Tests for server_name selection.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+plan(skip_all => 'win32') if $^O eq 'MSWin32';
+
+my $t = Test::Nginx->new()->has(qw/http rewrite/)->plan(20)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server_names_hash_bucket_size 64;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            add_header X-Server $server_name;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  "";
+
+        location / {
+            add_header X-Server $server_name;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  www.example.com;
+
+        location / {
+            add_header X-Server $server_name;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  ~^EXAMPLE\.COM$;
+
+        location / {
+            add_header X-Server $server_name;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  ~^(?P<name>.+)\Q.example.com\E$;
+
+        location / {
+            add_header X-Server $server_name;
+            add_header X-Match  $name;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  "~^(?P<name>www\p{N}+)\.example\.com$";
+
+        location / {
+            add_header X-Server $server_name;
+            add_header X-Match  $name;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  many.example.com many2.example.com;
+
+        location / {
+            add_header X-Server $server_name;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  many3.example.com;
+        server_name  many4.example.com;
+
+        location / {
+            add_header X-Server $server_name;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  *.wc.example.com;
+
+        location / {
+            add_header X-Server $server_name;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  *.pref.wc.example.com;
+
+        location / {
+            add_header X-Server $server_name;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  wc2.example.*;
+
+        location / {
+            add_header X-Server $server_name;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  wc2.example.com.*;
+
+        location / {
+            add_header X-Server $server_name;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  .dot.example.com;
+
+        location / {
+            add_header X-Server $server_name;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('index.html', '');
+$t->run();
+
+###############################################################################
+
+like(http_server('xxx'), qr/X-Server: localhost/, 'default');
+unlike(http_server(), qr/X-Server/, 'empty');
+
+like(http_server('www.example.com'), qr/\QX-Server: www.example.com/,
+	'www.example.com');
+like(http_server('WWW.EXAMPLE.COM'), qr/\QX-Server: www.example.com/,
+	'www.example.com uppercase');
+
+like(http_server('example.com'), qr/\QX-Server: ~^EXAMPLE\.COM$/,
+	'example.com regex');
+like(http_server('EXAMPLE.COM'), qr/\QX-Server: ~^EXAMPLE\.COM$/,
+	'example.com regex uppercase');
+
+like(http_server('blah.example.com'), qr/X-Match: blah/,
+	'(P<name>.*).example.com named capture');
+like(http_server('BLAH.EXAMPLE.COM'), qr/X-Match: blah/,
+	'(P<name>.*).example.com named capture uppercase');
+
+like(http_server('www01.example.com'), qr/X-Match: www01/,
+	'\p{N} in named capture');
+like(http_server('WWW01.EXAMPLE.COM'), qr/X-Match: www01/,
+	'\p{N} in named capture uppercase');
+
+like(http_server('many.example.com'), qr/\QX-Server: many.example.com/,
+	'name row - first');
+like(http_server('many2.example.com'), qr/\QX-Server: many.example.com/,
+	'name row - second');
+
+like(http_server('many3.example.com'), qr/\QX-Server: many3.example.com/,
+	'name list - first');
+like(http_server('many4.example.com'), qr/\QX-Server: many3.example.com/,
+	'name list - second');
+
+like(http_server('www.wc.example.com'),
+	qr/\QX-Server: *.wc.example.com/, 'wildcard first');
+like(http_server('www.pref.wc.example.com'),
+	qr/\QX-Server: *.pref.wc.example.com/, 'wildcard first most specific');
+like(http_server('wc2.example.net'),
+	qr/\QX-Server: wc2.example.*/, 'wildcard last');
+like(http_server('wc2.example.com.pref'),
+	qr/\QX-Server: wc2.example.com.*/, 'wildcard last most specific');
+
+like(http_server('www.dot.example.com'), qr/\QX-Server: dot.example.com/,
+	'wildcard dot');
+like(http_server('dot.example.com'), qr/\QX-Server: dot.example.com/,
+	'wildcard dot empty');
+
+###############################################################################
+
+sub http_server {
+	my ($host) = @_;
+
+	my $str = 'GET / HTTP/1.0' . CRLF .
+		(defined $host ? "Host: $host" . CRLF : '') .
+		CRLF;
+
+	return http($str);
+}
+
+###############################################################################
diff --git a/tests/http_try_files.t b/tests/http_try_files.t
new file mode 100644
index 0000000..7a6d6a9
--- /dev/null
+++ b/tests/http_try_files.t
@@ -0,0 +1,123 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for try_files directive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy rewrite/)->plan(10)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            try_files $uri /fallback;
+        }
+
+        location /nouri/ {
+            try_files $uri /fallback-nouri;
+        }
+
+        location /short/ {
+            try_files /short $uri =404;
+        }
+
+        location /file-file/ {
+            try_files /found.html =404;
+        }
+
+        location /file-dir/ {
+            try_files /found.html/ =404;
+        }
+
+        location /dir-dir/ {
+            try_files /directory/ =404;
+        }
+
+        location /dir-file/ {
+            try_files /directory =404;
+        }
+
+        location ~ /alias-re.html {
+            alias %%TESTDIR%%/directory;
+            try_files $uri =404;
+        }
+
+        location /alias-nested/ {
+            alias %%TESTDIR%%/;
+            location ~ html {
+                try_files $uri =404;
+            }
+        }
+
+        location /fallback {
+            proxy_pass http://127.0.0.1:8081/fallback;
+        }
+        location /fallback-nouri {
+            proxy_pass http://127.0.0.1:8081;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location / {
+            add_header X-URI $request_uri;
+            return 204;
+        }
+    }
+}
+
+EOF
+
+mkdir($t->testdir() . '/directory');
+$t->write_file('directory/alias-re.html', 'SEE THIS');
+$t->write_file('found.html', 'SEE THIS');
+$t->run();
+
+###############################################################################
+
+like(http_get('/found.html'), qr!SEE THIS!, 'found');
+like(http_get('/uri/notfound'), qr!X-URI: /fallback!, 'not found uri');
+like(http_get('/nouri/notfound'), qr!X-URI: /fallback!, 'not found nouri');
+like(http_get('/short/long'), qr!404 Not!, 'short uri in try_files');
+
+like(http_get('/file-file/'), qr!SEE THIS!, 'file matches file');
+like(http_get('/file-dir/'), qr!404 Not!, 'file does not match dir');
+like(http_get('/dir-dir/'), qr!301 Moved Permanently!, 'dir matches dir');
+like(http_get('/dir-file/'), qr!404 Not!, 'dir does not match file');
+
+like(http_get('/alias-re.html'), qr!SEE THIS!, 'alias in regex location');
+like(http_get('/alias-nested/found.html'), qr!SEE THIS!,
+	'alias with nested location');
+
+###############################################################################
diff --git a/tests/http_uri.t b/tests/http_uri.t
new file mode 100644
index 0000000..c1b704c
--- /dev/null
+++ b/tests/http_uri.t
@@ -0,0 +1,65 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for URI normalization.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http rewrite/)->plan(8)
+	->write_file_expand('nginx.conf', <<'EOF')->run();
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            add_header  X-URI  "x $uri x";
+            return      204;
+        }
+    }
+}
+
+EOF
+
+###############################################################################
+
+local $TODO = 'not yet' unless $t->has_version('1.17.5');
+
+like(http_get('/foo/bar%'), qr/400 Bad/, 'percent');
+like(http_get('/foo/bar%1'), qr/400 Bad/, 'percent digit');
+
+like(http_get('/foo/bar/.?args'), qr!x /foo/bar/ x!, 'dot args');
+like(http_get('/foo/bar/.#frag'), qr!x /foo/bar/ x!, 'dot frag');
+like(http_get('/foo/bar/..?args'), qr!x /foo/ x!, 'dot dot args');
+like(http_get('/foo/bar/..#frag'), qr!x /foo/ x!, 'dot dot frag');
+like(http_get('/foo/bar/.'), qr!x /foo/bar/ x!, 'trailing dot');
+like(http_get('/foo/bar/..'), qr!x /foo/ x!, 'trailing dot dot');
+
+###############################################################################
diff --git a/tests/http_variables.t b/tests/http_variables.t
new file mode 100644
index 0000000..2bc98b5
--- /dev/null
+++ b/tests/http_variables.t
@@ -0,0 +1,96 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+# (C) Valentin Bartenev
+
+# Tests for http variables.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http rewrite proxy/)->plan(6);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    log_format cc "$uri: $sent_http_cache_control";
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        access_log %%TESTDIR%%/cc.log cc;
+
+        location / {
+            return 200 OK;
+        }
+
+        location /set {
+            add_header Cache-Control max-age=3600;
+            add_header Cache-Control private;
+            add_header Cache-Control must-revalidate;
+            return 200 OK;
+        }
+
+        location /redefine {
+            expires epoch;
+            proxy_pass http://127.0.0.1:8080/set;
+        }
+
+        location /limit_rate {
+            set $limit_rate $arg_l;
+            add_header X-Rate $limit_rate;
+            return 200 OK;
+        }
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+http_get('/');
+http_get('/../bad_uri');
+http_get('/redefine');
+
+# $limit_rate is a special variable that has its own set_handler / get_handler
+
+like(http_get('/limit_rate?l=40k'), qr/X-Rate: 40960/, 'limit_rate handlers');
+like(http_get('/limit_rate'), qr/X-Rate: 0/, 'limit_rate invalid');
+
+$t->stop();
+
+my $log = $t->read_file('cc.log');
+like($log, qr!^: -$!m, 'no uri');
+like($log, qr!^/: -$!m, 'no header');
+like($log, qr!^/set: max-age=3600, private, must-revalidate$!m,
+	'multi headers');
+
+like($log, qr!^/redefine: no-cache$!m, 'ignoring headers with (hash == 0)');
+
+###############################################################################
diff --git a/tests/ignore_invalid_headers.t b/tests/ignore_invalid_headers.t
new file mode 100644
index 0000000..44b13ad
--- /dev/null
+++ b/tests/ignore_invalid_headers.t
@@ -0,0 +1,171 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for ignore_invalid_headers, underscores_in_headers directives.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/ CRLF /;
+use MIME::Base64 qw/ encode_base64 decode_base64 /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy/)->plan(9)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        ignore_invalid_headers off;
+
+        location / {
+            proxy_pass http://127.0.0.1:8085;
+        }
+
+        location /v {
+            add_header X-Cookie $http_cookie;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location / {
+            proxy_pass http://127.0.0.1:8085;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8082;
+        server_name  localhost;
+
+        underscores_in_headers on;
+
+        location / {
+            proxy_pass http://127.0.0.1:8085;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('index.html', '');
+$t->write_file('v', '');
+$t->run_daemon(\&http_daemon);
+$t->run()->waitforsocket('127.0.0.1:' . port(8085));
+
+###############################################################################
+
+my $us = 'GET / HTTP/1.0' . CRLF
+	. 'x_foo: x-bar' . CRLF . CRLF;
+my $us2 = 'GET / HTTP/1.0' . CRLF
+	. '_foo: x-bar' . CRLF . CRLF;
+my $bad = 'GET / HTTP/1.0' . CRLF
+	. 'x.foo: x-bar' . CRLF . CRLF;
+my $bad2 = 'GET / HTTP/1.0' . CRLF
+	. '.foo: x-bar' . CRLF . CRLF;
+
+# ignore_invalid_headers off;
+
+like(get($us, 8080), qr/x-bar/, 'off - underscore');
+like(get($us2, 8080), qr/x-bar/, 'off - underscore first');
+like(get($bad, 8080), qr/x-bar/, 'off - bad');
+like(get($bad2, 8080), qr/x-bar/, 'off - bad first');
+
+# ignore_invalid_headers off; headers parsing post 8f55cb5c7e79
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.17.5');
+
+unlike(http('GET /v HTTP/1.0' . CRLF
+	. 'Host: localhost' . CRLF
+	. 'coo: foo' . CRLF
+	. '</kie>: x-bar' . CRLF . CRLF), qr/x-bar/, 'off - several');
+
+}
+
+# ignore_invalid_headers on;
+
+unlike(get($us, 8081), qr/x-bar/, 'on - underscore');
+unlike(get($us2, 8081), qr/x-bar/, 'on - underscore first');
+
+# ignore_invalid_headers on; underscores_in_headers on;
+
+like(get($us, 8082), qr/x-bar/, 'underscores_in_headers');
+like(get($us2, 8082), qr/x-bar/, 'underscores_in_headers - first');
+
+###############################################################################
+
+sub get {
+	my ($msg, $port) = @_;
+
+	my $s = IO::Socket::INET->new('127.0.0.1:' . port($port)) or die;
+	my ($headers) = http($msg, socket => $s) =~ /X-Headers: (\w+)/;
+	decode_base64($headers);
+}
+
+###############################################################################
+
+sub http_daemon {
+	my $once = 1;
+	my $server = IO::Socket::INET->new(
+		Proto => 'tcp',
+		LocalHost => '127.0.0.1:' . port(8085),
+		Listen => 5,
+		Reuse => 1
+	)
+		or die "Can't create listening socket: $!\n";
+
+	local $SIG{PIPE} = 'IGNORE';
+
+	while (my $client = $server->accept()) {
+		$client->autoflush(1);
+
+		my $headers = '';
+		my $uri = '';
+
+		while (<$client>) {
+			$headers .= $_;
+			last if (/^\x0d?\x0a?$/);
+		}
+
+		$headers = encode_base64($headers, "");
+
+		print $client <<EOF;
+HTTP/1.1 200 OK
+Connection: close
+X-Headers: $headers
+
+EOF
+
+	}
+}
+
+###############################################################################
diff --git a/tests/image_filter.t b/tests/image_filter.t
new file mode 100644
index 0000000..273230c
--- /dev/null
+++ b/tests/image_filter.t
@@ -0,0 +1,343 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for image filter module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/CRLF/;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require GD; };
+plan(skip_all => 'GD not installed') if $@;
+
+my $t = Test::Nginx->new()->has(qw/http proxy map image_filter/)->plan(39)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    map $arg_w $w {
+        "" '-';
+        default $arg_w;
+    }
+    map $arg_h $h {
+        "" '-';
+        default $arg_h;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /size {
+            image_filter size;
+            alias %%TESTDIR%%/;
+        }
+
+        location /test {
+            image_filter test;
+            alias %%TESTDIR%%/;
+
+            location /test/off {
+                image_filter off;
+                alias %%TESTDIR%%/;
+            }
+        }
+
+        location /resize {
+            image_filter resize 10 12;
+            alias %%TESTDIR%%/;
+        }
+        location /resize1 {
+            image_filter resize 10 -;
+            alias %%TESTDIR%%/;
+        }
+        location /resize2 {
+            image_filter resize - 12;
+            alias %%TESTDIR%%/;
+        }
+        location /resize_var {
+            image_filter resize $w $h;
+            alias %%TESTDIR%%/;
+        }
+
+        location /rotate {
+            image_filter rotate 90;
+            alias %%TESTDIR%%/;
+        }
+        location /rotate_var {
+            image_filter rotate $arg_r;
+            alias %%TESTDIR%%/;
+        }
+
+        location /crop {
+            image_filter crop 60 80;
+            alias %%TESTDIR%%/;
+        }
+        location /crop_var {
+            image_filter crop $arg_w $arg_h;
+            alias %%TESTDIR%%/;
+        }
+        location /crop_rotate {
+            image_filter crop $arg_w $arg_h;
+            image_filter rotate $arg_r;
+            alias %%TESTDIR%%/;
+        }
+        location /resize_rotate {
+            image_filter resize $w $h;
+            image_filter rotate $arg_r;
+            alias %%TESTDIR%%/;
+
+            location /resize_rotate/resize {
+                image_filter resize 10 12;
+                alias %%TESTDIR%%/;
+            }
+        }
+
+        location /interlaced {
+            image_filter resize 10 12;
+            image_filter_interlace on;
+            alias %%TESTDIR%%/;
+        }
+
+        location /nontransparent {
+            image_filter resize 10 12;
+            image_filter_transparency off;
+            alias %%TESTDIR%%/;
+        }
+
+        location /quality {
+            image_filter resize 10 12;
+            image_filter_jpeg_quality 50;
+            alias %%TESTDIR%%/;
+        }
+        location /quality_var {
+            image_filter resize 10 12;
+            image_filter_jpeg_quality $arg_q;
+            alias %%TESTDIR%%/;
+
+            location /quality_var/quality {
+                image_filter_jpeg_quality 60;
+                alias %%TESTDIR%%/;
+            }
+        }
+
+        location /buffer {
+            image_filter test;
+            image_filter_buffer 1k;
+            alias %%TESTDIR%%/;
+        }
+        location /proxy_buffer {
+            image_filter rotate 90;
+            image_filter_buffer 20;
+            proxy_pass http://127.0.0.1:8081/;
+            proxy_buffering off;
+            proxy_buffer_size 512;
+        }
+    }
+}
+
+EOF
+
+
+my $im = new GD::Image(100, 120);
+my $white = $im->colorAllocate(255, 255, 255);
+my $black = $im->colorAllocate(0, 0, 0);
+
+$im->transparent($white);
+$im->rectangle(0, 0, 99, 99, $black);
+
+$t->write_file('jpeg', $im->jpeg);
+$t->write_file('gif', $im->gif);
+$t->write_file('png', $im->png);
+$t->write_file('txt', 'SEE-THIS');
+
+$t->run_daemon(\&http_daemon, $t);
+$t->run()->waitforsocket('127.0.0.1:' . port(8081));
+
+###############################################################################
+
+like(http_head('/test/gif'), qr/200 OK/, 'test');
+like(http_head('/test/gif'), qr!Content-Type: image/gif!, 'test content-type');
+like(http_get('/test/txt'), qr/415 Unsupported/, 'test fail');
+like(http_get('/test/off/txt'), qr/SEE-THIS/, 'off');
+
+is(http_get_body('/size/txt'), '{}' . CRLF, 'size wrong type');
+like(http_head('/size/txt'), qr!Content-Type: application/json!,
+	'size content-type');
+like(http_get('/size/jpeg'), qr/"width": 100/, 'size width');
+like(http_get('/size/jpeg'), qr/"height": 120/, 'size height');
+like(http_get('/size/jpeg'), qr/"type": "jpeg"/, 'size jpeg');
+like(http_get('/size/gif'), qr/"type": "gif"/, 'size gif');
+like(http_get('/size/png'), qr/"type": "png"/, 'size png');
+
+is(gif_size('/resize/gif'), '10 12', 'resize');
+is(gif_size('/resize1/gif'), '10 12', 'resize 1');
+is(gif_size('/resize2/gif'), '10 12', 'resize 2');
+
+is(gif_size('/resize_var/gif?w=10&h=12'), '10 12', 'resize var');
+is(gif_size('/resize_var/gif?w=10'), '10 12', 'resize var 1');
+is(gif_size('/resize_var/gif?h=12'), '10 12', 'resize var 2');
+
+is(gif_size('/rotate/gif?r=90'), '120 100', 'rotate');
+is(gif_size('/rotate_var/gif?r=180'), '100 120', 'rotate var 1');
+is(gif_size('/rotate_var/gif?r=270'), '120 100', 'rotate var 2');
+
+$im = GD::Image->newFromGifData(http_get_body('/gif'));
+is($im->interlaced, 0, 'gif interlaced off');
+is($im->transparent, 0, 'gif transparent white');
+
+SKIP: {
+skip 'broken/unknown libgd', 1
+	unless has_gdversion('2.1.0') or $ENV{TEST_NGINX_UNSAFE};
+
+$im = GD::Image->newFromGifData(http_get_body('/interlaced/gif'));
+is($im->interlaced, 1, 'gif interlaced on');
+
+}
+
+$im = GD::Image->newFromGifData(http_get_body('/nontransparent/gif'));
+is($im->transparent, -1, 'gif transparent loss');
+
+$im = GD::Image->newFromPngData(http_get_body('/png'));
+is($im->interlaced, 0, 'png interlaced off');
+is($im->transparent, 0, 'png transparent white');
+
+# this test produces libpng warning on STDERR:
+# "Interlace handling should be turned on when using png_read_image"
+
+SKIP: {
+skip 'can wedge nginx with SIGPIPE', 1 unless $ENV{TEST_NGINX_UNSAFE};
+
+$im = GD::Image->newFromPngData(http_get_body('/interlaced/png'));
+is($im->interlaced, 1, 'png interlaced on');
+
+}
+
+$im = GD::Image->newFromPngData(http_get_body('/nontransparent/png'));
+is($im->transparent, -1, 'png transparent loss');
+
+like(http_get('/resize/jpeg'), qr/quality = 75/, 'quality default');
+like(http_get('/quality/jpeg'), qr/quality = 50/, 'quality');
+like(http_get('/quality_var/jpeg?q=40'), qr/quality = 40/, 'quality var');
+like(http_get('/quality_var/quality/jpeg?q=40'), qr/quality = 60/,
+	'quality nested');
+
+is(gif_size('/crop/gif'), '60 80', 'crop');
+is(gif_size('/crop_var/gif?w=10&h=20'), '10 20', 'crop var');
+is(gif_size('/crop_rotate/gif?w=5&h=6&r=90'), '5 5', 'rotate before crop');
+is(gif_size('/resize_rotate/gif?w=5&h=6&r=90'), '6 5', 'rotate after resize');
+is(gif_size('/resize_rotate/resize/gif??w=5&h=6&r=90'), '10 12',
+	'resize rotate nested');
+
+like(http_get('/buffer/jpeg'), qr/415 Unsupported/, 'small buffer');
+isnt(http_get('/proxy_buffer/jpeg'), undef, 'small buffer proxy');
+
+###############################################################################
+
+sub gif_size {
+	join ' ', unpack("x6v2", http_get_body(@_));
+}
+
+sub http_get_body {
+	my ($uri) = @_;
+
+	return undef if !defined $uri;
+
+	my $text = http_get($uri);
+
+	if ($text !~ /(.*?)\x0d\x0a?\x0d\x0a?(.*)/ms) {
+		return undef;
+	}
+
+	return $2;
+}
+
+sub has_gdversion {
+	my ($need) = @_;
+
+	my $v_str = `gdlib-config --version 2>&1`
+		|| eval { GD::VERSION_STRING() } or return 0;
+	($v_str) = $v_str =~ m!^([0-9.]+)!m or return 0;
+	my @v = split(/\./, $v_str);
+	my ($n, $v);
+
+	for $n (split(/\./, $need)) {
+		$v = shift @v || 0;
+		return 0 if $n > $v;
+		return 1 if $v > $n;
+	}
+
+	return 1;
+}
+
+###############################################################################
+
+# serve static files without Content-Length
+
+sub http_daemon {
+	my ($t) = @_;
+
+	my $server = IO::Socket::INET->new(
+		Proto => 'tcp',
+		LocalHost => '127.0.0.1',
+		LocalPort => port(8081),
+		Listen => 5,
+		Reuse => 1
+	)
+		or die "Can't create listening socket: $!\n";
+
+	local $SIG{PIPE} = 'IGNORE';
+
+	while (my $client = $server->accept()) {
+		$client->autoflush(1);
+
+		my $headers = '';
+		my $uri = '';
+
+		while (<$client>) {
+			$headers .= $_;
+			last if (/^\x0d?\x0a?$/);
+		}
+
+		next if $headers eq '';
+		$uri = $1 if $headers =~ /^\S+\s+([^ ]+)\s+HTTP/i;
+		my $data = $t->read_file($uri);
+
+		print $client <<EOF;
+HTTP/1.1 200 OK
+Connection: close
+
+$data
+EOF
+
+	} continue {
+		close $client;
+	}
+}
+
+###############################################################################
diff --git a/tests/image_filter_finalize.t b/tests/image_filter_finalize.t
new file mode 100644
index 0000000..2c04da7
--- /dev/null
+++ b/tests/image_filter_finalize.t
@@ -0,0 +1,151 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for http filter finalize code.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy cache image_filter limit_req/)
+	->has(qw/rewrite/)->plan(3)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    proxy_cache_path %%TESTDIR%%/cache keys_zone=cache:1m;
+
+    limit_req_zone $binary_remote_addr zone=limit:1m rate=25r/m;
+
+    log_format time "$request_uri:$status:$upstream_response_time";
+    access_log time.log time;
+
+    upstream u {
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8080;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        # this used to cause a segmentation fault before 07f028df3879 (1.3.1)
+        # http://nginx.org/pipermail/nginx/2011-January/024703.html
+
+        location /t1 {
+            proxy_pass http://127.0.0.1:8080/bad;
+            proxy_cache cache;
+            proxy_cache_valid any 1h;
+
+            image_filter   resize  150 100;
+            error_page     415   = /empty;
+        }
+
+        location /empty {
+            return 204;
+        }
+
+        location /bad {
+            return 404;
+        }
+
+        # another segfault, introduced in 204b780a89de (1.3.0),
+        # fixed in 07f028df3879 (1.3.1)
+
+        location /t2 {
+            proxy_pass http://127.0.0.1:8080/big;
+            proxy_store on;
+
+            image_filter_buffer 10m;
+            image_filter   resize  150 100;
+            error_page     415   = /empty;
+        }
+
+        location /big {
+            # big enough static file
+        }
+
+        # filter finalization may cause duplicate upstream finalization,
+        # resulting in wrong $upstream_response_time,
+        # http://nginx.org/pipermail/nginx-devel/2015-February/006539.html
+
+        # note that we'll need upstream response time to be at least 1 second,
+        # and at least 4 failed requests to make sure r->upstream_states will
+        # not be reallocated
+
+        location /t3 {
+            proxy_pass http://u/slow;
+            proxy_buffering off;
+
+            image_filter   resize  150 100;
+            error_page     415   = /upstream;
+        }
+
+        location /slow {
+            limit_req zone=limit burst=5;
+        }
+
+        location /upstream {
+            proxy_pass http://127.0.0.1:8080/empty;
+        }
+
+        location /time.log {
+            # access to log
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+        return 444;
+    }
+}
+
+EOF
+
+$t->write_file('big', "x" x 10240000);
+$t->write_file('slow', "x");
+
+$t->run();
+
+###############################################################################
+
+like(http_get('/t1'), qr/HTTP/, 'image filter and cache');
+like(http_get('/t2'), qr/HTTP/, 'image filter and store');
+
+http_get('/slow');
+http_get('/t3');
+like(http_get('/time.log'), qr!/t3:.*, [1-9]\.!, 'upstream response time');
+
+# "aio_write" is used to produce the following alert on some platforms:
+# "readv() failed (9: Bad file descriptor) while reading upstream"
+
+$t->todo_alerts() if $t->read_file('nginx.conf') =~ /aio_write on/
+	and $t->read_file('nginx.conf') =~ /aio threads/;
+
+###############################################################################
diff --git a/tests/image_filter_webp.t b/tests/image_filter_webp.t
new file mode 100644
index 0000000..c40351c
--- /dev/null
+++ b/tests/image_filter_webp.t
@@ -0,0 +1,129 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for image filter module, WebP support.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http image_filter/)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /size {
+            image_filter size;
+            alias %%TESTDIR%%/;
+        }
+
+        location /test {
+            image_filter test;
+            alias %%TESTDIR%%/;
+        }
+
+        location /resize {
+            image_filter resize 1 1;
+            alias %%TESTDIR%%/;
+        }
+
+        location /quality {
+            image_filter rotate 90;
+            image_filter_webp_quality 50;
+            alias %%TESTDIR%%/;
+        }
+        location /quality_var {
+            image_filter rotate 90;
+            image_filter_webp_quality $arg_q;
+            alias %%TESTDIR%%/;
+        }
+    }
+}
+
+EOF
+
+$t->run()->plan(18);
+
+$t->write_file('webp', pack("A4LA8", "RIFF", 0x22, "WEBPVP8 ") .
+	pack("N4", 0x16000000, 0x3001009d, 0x012a0100, 0x01000ec0) .
+	pack("N2n", 0xfe25a400, 0x03700000, 0x0000));
+$t->write_file('webpl', pack("A4LA8", "RIFF", 0x1a, "WEBPVP8L") .
+	pack("N4n", 0x0d000000, 0x2f000000, 0x10071011, 0x118888fe, 0x0700));
+$t->write_file('webpx', pack("A4LA8", "RIFF", 0x4a, "WEBPVP8X") .
+	pack("N4", 0x0a000000, 0x10000000, 0x00000000, 0x0000414c) .
+	pack("N4", 0x50480c00, 0x00001107, 0x1011fd0f, 0x4444ff03) .
+	pack("N4", 0x00005650, 0x38201800, 0x00001401, 0x009d012a) .
+	pack("N4n", 0x01000100, 0x0000fe00, 0x000dc000, 0xfee6b500, 0x0000));
+
+$t->write_file('webperr', pack("A4LA8", "RIFF", 0x22, "WEBPERR ") .
+	pack("N4", 0x16000000, 0x3001009d, 0x012a0100, 0x01000ec0) .
+	pack("N2n", 0xfe25a400, 0x03700000, 0x0000));
+$t->write_file('webptrunc', substr $t->read_file('webp'), 0, 29);
+
+###############################################################################
+
+my $r = http_get('/test/webp');
+like($r, qr!Content-Type: image/webp!, 'content-type');
+like($r, qr/RIFF/, 'content');
+
+$r = http_get('/size/webp');
+like($r, qr/"type": "webp"/, 'size type');
+like($r, qr/"width": 1/, 'size width');
+like($r, qr/"height": 1/, 'size height');
+
+# lossless
+
+$r = http_get('/size/webpl');
+like($r, qr/"type": "webp"/, 'lossless type');
+like($r, qr/"width": 1/, 'lossless width');
+like($r, qr/"height": 1/, 'lossless height');
+
+# extended
+
+$r = http_get('/size/webpx');
+like($r, qr/"type": "webp"/, 'extended type');
+like($r, qr/"width": 1/, 'extended width');
+like($r, qr/"height": 1/, 'extended height');
+
+# transforms, libgd may have no WebP support
+
+like(http_get('/quality/webp'), qr/RIFF|415/, 'quality');
+like(http_get('/quality_var/webp?q=40'), qr/RIFF|415/, 'quality var');
+like(http_get('/resize/webp'), qr/RIFF/, 'resize as is');
+
+# generic error handling
+
+like(http_get('/quality/webperr'), qr/415 Unsupported/, 'bad header');
+like(http_get('/quality/webptrunc'), qr/415 Unsupported/, 'truncated');
+
+like(http_get('/size/webperr'), qr/{}/, 'size - bad header');
+like(http_get('/size/webptrunc'), qr/{}/, 'size - truncated');
+
+###############################################################################
diff --git a/tests/index.t b/tests/index.t
new file mode 100644
index 0000000..584000d
--- /dev/null
+++ b/tests/index.t
@@ -0,0 +1,129 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for index module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http/)->plan(14)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+        add_header   X-URI $uri;
+
+        location / {
+            # index index.html by default
+        }
+
+        location /redirect/ {
+            index /re.html;
+        }
+
+        location /loop/ {
+            index /loop/;
+        }
+
+        location /no_index/ {
+            alias %%TESTDIR%%/;
+            index nonexisting.html;
+        }
+
+        location /many/ {
+            alias %%TESTDIR%%/;
+            index nonexisting.html many.html;
+        }
+
+        location /var/ {
+            alias %%TESTDIR%%/;
+            index $server_name.html;
+        }
+
+        location /va2/ {
+            alias %%TESTDIR%%/;
+            # before 1.13.8, the token produced emerg:
+            # directive "index" is not terminated by ";"
+            index ${server_name}.html;
+        }
+
+        location /var_redirect/ {
+            index /$server_name.html;
+        }
+
+        location /not_found/ {
+            error_log %%TESTDIR%%/log_not_found.log;
+
+            location /not_found/off/ {
+                error_log %%TESTDIR%%/off.log;
+                log_not_found off;
+            }
+        }
+    }
+}
+
+EOF
+
+$t->write_file('index.html', 'body');
+$t->write_file('many.html', 'manybody');
+$t->write_file('re.html', 'rebody');
+$t->write_file('localhost.html', 'varbody');
+
+my $d = $t->testdir();
+mkdir("$d/forbidden");
+chmod(0000, "$d/forbidden");
+
+$t->run();
+
+###############################################################################
+
+like(http_get('/'), qr/X-URI: \/index.html.*body/ms, 'default index');
+like(http_get('/no_index/'), qr/403 Forbidden/, 'no index');
+like(http_get('/redirect/'), qr/X-URI: \/re.html.*rebody/ms, 'redirect');
+like(http_get('/loop/'), qr/500 Internal/, 'redirect loop');
+like(http_get('/many/'), qr/X-URI: \/many\/many.html.*manybody/ms, 'many');
+like(http_get('/var/'), qr/X-URI: \/var\/localhost.html.*varbody/ms, 'var');
+like(http_get('/va2/'), qr/X-URI: \/va2\/localhost.html.*varbody/ms, 'var 2');
+like(http_get('/var_redirect/'), qr/X-URI: \/localhost.html.*varbody/ms,
+	'var with redirect');
+
+like(http_get('/not_found/'), qr/404 Not Found/, 'not found');
+like(http_get('/not_found/off/'), qr/404 Not Found/, 'not found log off');
+like(http_get('/forbidden/'), qr/403 Forbidden/, 'directory access denied');
+like(http_get('/index.html/'), qr/404 Not Found/, 'not a directory');
+
+$t->stop();
+
+like($t->read_file('log_not_found.log'), qr/error/, 'log_not_found');
+unlike($t->read_file('off.log'), qr/error/, 'log_not_found off');
+
+chmod(0700, "$d/forbidden");
+
+###############################################################################
diff --git a/tests/js.t b/tests/js.t
new file mode 100644
index 0000000..48466b9
--- /dev/null
+++ b/tests/js.t
@@ -0,0 +1,355 @@
+#!/usr/bin/perl
+
+# (C) Roman Arutyunyan
+# (C) Dmitry Volyntsev
+# (C) Nginx, Inc.
+
+# Tests for http njs module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http rewrite/)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    js_set $test_method   test_method;
+    js_set $test_version  test_version;
+    js_set $test_addr     test_addr;
+    js_set $test_uri      test_uri;
+    js_set $test_arg      test_arg;
+    js_set $test_iarg     test_iarg;
+    js_set $test_var      test_var;
+    js_set $test_global   test_global;
+    js_set $test_log      test_log;
+    js_set $test_except   test_except;
+
+    js_include test.js;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /njs {
+            js_content test_njs;
+        }
+
+        location /method {
+            return 200 $test_method;
+        }
+
+        location /version {
+            return 200 $test_version;
+        }
+
+        location /addr {
+            return 200 $test_addr;
+        }
+
+        location /uri {
+            return 200 $test_uri;
+        }
+
+        location /arg {
+            return 200 $test_arg;
+        }
+
+        location /iarg {
+            return 200 $test_iarg;
+        }
+
+        location /var {
+            return 200 $test_var;
+        }
+
+        location /global {
+            return 200 $test_global;
+        }
+
+        location /body {
+            js_content request_body;
+        }
+
+        location /in_file {
+            client_body_in_file_only on;
+            js_content request_body;
+        }
+
+        location /status {
+            js_content status;
+        }
+
+        location /request_body {
+            js_content request_body;
+        }
+
+        location /send {
+            js_content send;
+        }
+
+        location /return_method {
+            js_content return_method;
+        }
+
+        location /arg_keys {
+            js_content arg_keys;
+        }
+
+        location /log {
+            return 200 $test_log;
+        }
+
+        location /except {
+            return 200 $test_except;
+        }
+
+        location /content_except {
+            js_content content_except;
+        }
+
+        location /content_empty {
+            js_content content_empty;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('test.js', <<EOF);
+    var global = ['n', 'j', 's'].join("");
+
+    function test_njs(r) {
+        r.return(200, njs.version);
+    }
+
+    function test_method(r) {
+        return 'method=' + r.method;
+    }
+
+    function test_version(r) {
+        return 'version=' + r.httpVersion;
+    }
+
+    function test_addr(r) {
+        return 'addr=' + r.remoteAddress;
+    }
+
+    function test_uri(r) {
+        return 'uri=' + r.uri;
+    }
+
+    function test_arg(r) {
+        return 'arg=' + r.args.foo;
+    }
+
+    function test_iarg(r) {
+        var s = '', a;
+        for (a in r.args) {
+            if (a.substr(0, 3) == 'foo') {
+                s += r.args[a];
+            }
+        }
+        return s;
+    }
+
+    function test_var(r) {
+        return 'variable=' + r.variables.remote_addr;
+    }
+
+    function test_global(r) {
+        return 'global=' + global;
+    }
+
+    function status(r) {
+        r.status = 204;
+        r.sendHeader();
+        r.finish();
+    }
+
+    function request_body(r) {
+        try {
+            var body = r.requestBody;
+            r.return(200, body);
+
+        } catch (e) {
+            r.return(500, e.message);
+        }
+    }
+
+    function send(r) {
+        var a, s;
+        r.status = 200;
+        r.sendHeader();
+        for (a in r.args) {
+            if (a.substr(0, 3) == 'foo') {
+                s = r.args[a];
+                r.send('n=' + a + ', v=' + s.substr(0, 2) + ' ');
+            }
+        }
+        r.finish();
+    }
+
+    function return_method(r) {
+        r.return(Number(r.args.c), r.args.t);
+    }
+
+    function arg_keys(r) {
+        r.return(200, Object.keys(r.args).sort());
+    }
+
+    function test_log(r) {
+        r.log('SEE-THIS');
+    }
+
+    function test_except(r) {
+        var fs = require('fs');
+        fs.readFileSync();
+    }
+
+
+    function content_except(r) {
+        JSON.parse({}.a.a);
+    }
+
+    function content_empty(r) {
+    }
+
+EOF
+
+$t->try_run('no njs available')->plan(27);
+
+###############################################################################
+
+
+like(http_get('/method'), qr/method=GET/, 'r.method');
+like(http_get('/version'), qr/version=1.0/, 'r.httpVersion');
+like(http_get('/addr'), qr/addr=127.0.0.1/, 'r.remoteAddress');
+like(http_get('/uri'), qr/uri=\/uri/, 'r.uri');
+like(http_get('/arg?foO=12345'), qr/arg=12345/, 'r.args');
+like(http_get('/iarg?foo=12345&foo2=bar&nn=22&foo-3=z'), qr/12345barz/,
+	'r.args iteration');
+
+like(http_get('/iarg?foo=123&foo2=&foo3&foo4=456'), qr/123undefined456/,
+	'r.args iteration 2');
+like(http_get('/iarg?foo=123&foo2=&foo3'), qr/123/, 'r.args iteration 3');
+like(http_get('/iarg?foo=123&foo2='), qr/123/, 'r.args iteration 4');
+
+like(http_get('/status'), qr/204 No Content/, 'r.status');
+
+like(http_post('/body'), qr/REQ-BODY/, 'request body');
+like(http_post('/in_file'), qr/request body is in a file/,
+	'request body in file');
+like(http_post_big('/body'), qr/200.*^(1234567890){1024}$/ms,
+	'request body big');
+
+like(http_get('/send?foo=12345&n=11&foo-2=bar&ndd=&foo-3=z'),
+	qr/n=foo, v=12 n=foo-2, v=ba n=foo-3, v=z/, 'r.send');
+
+like(http_get('/return_method?c=200'), qr/200 OK.*\x0d\x0a?\x0d\x0a?$/s,
+	'return code');
+like(http_get('/return_method?c=200&t=SEE-THIS'), qr/200 OK.*^SEE-THIS$/ms,
+	'return text');
+like(http_get('/return_method?c=301&t=path'), qr/ 301 .*Location: path/s,
+	'return redirect');
+like(http_get('/return_method?c=404'), qr/404 Not.*html/s, 'return error page');
+like(http_get('/return_method?c=inv'), qr/ 500 /, 'return invalid');
+
+TODO: {
+local $TODO = 'not yet'
+               unless http_get('/njs') =~ /^([.0-9]+)$/m && $1 ge '0.3.7';
+
+like(http_get('/arg_keys?b=1&c=2&a=5'), qr/a,b,c/m, 'r.args sorted keys');
+
+}
+
+like(http_get('/var'), qr/variable=127.0.0.1/, 'r.variables');
+like(http_get('/global'), qr/global=njs/, 'global code');
+like(http_get('/log'), qr/200 OK/, 'r.log');
+
+http_get('/except');
+http_get('/content_except');
+
+like(http_get('/content_empty'), qr/500 Internal Server Error/,
+	'empty handler');
+
+$t->stop();
+
+ok(index($t->read_file('error.log'), 'SEE-THIS') > 0, 'log js');
+ok(index($t->read_file('error.log'), 'at fs.readFileSync') > 0,
+	'js_set backtrace');
+ok(index($t->read_file('error.log'), 'at JSON.parse') > 0,
+	'js_content backtrace');
+
+###############################################################################
+
+sub http_get_hdr {
+	my ($url, %extra) = @_;
+	return http(<<EOF, %extra);
+GET $url HTTP/1.0
+FoO: 12345
+
+EOF
+}
+
+sub http_get_ihdr {
+	my ($url, %extra) = @_;
+	return http(<<EOF, %extra);
+GET $url HTTP/1.0
+foo: 12345
+Host: localhost
+foo2: bar
+X-xxx: more
+foo-3: z
+
+EOF
+}
+
+sub http_post {
+	my ($url, %extra) = @_;
+
+	my $p = "POST $url HTTP/1.0" . CRLF .
+		"Host: localhost" . CRLF .
+		"Content-Length: 8" . CRLF .
+		CRLF .
+		"REQ-BODY";
+
+	return http($p, %extra);
+}
+
+sub http_post_big {
+	my ($url, %extra) = @_;
+
+	my $p = "POST $url HTTP/1.0" . CRLF .
+		"Host: localhost" . CRLF .
+		"Content-Length: 10240" . CRLF .
+		CRLF .
+		("1234567890" x 1024);
+
+	return http($p, %extra);
+}
+
+###############################################################################
diff --git a/tests/js_async.t b/tests/js_async.t
new file mode 100644
index 0000000..49169e2
--- /dev/null
+++ b/tests/js_async.t
@@ -0,0 +1,183 @@
+#!/usr/bin/perl
+
+# (C) Dmitry Volyntsev
+# (C) Nginx, Inc.
+
+# Async tests for http njs module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http rewrite/)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    js_set $test_async      set_timeout;
+    js_set $context_var     context_var;
+
+    js_include test.js;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /async_var {
+            return 200 $test_async;
+        }
+
+        location /shared_ctx {
+            add_header H $context_var;
+            js_content shared_ctx;
+        }
+
+        location /set_timeout {
+            js_content set_timeout;
+        }
+
+        location /set_timeout_many {
+            js_content set_timeout_many;
+        }
+
+        location /set_timeout_data {
+            postpone_output 0;
+            js_content set_timeout_data;
+        }
+
+        location /limit_rate {
+            postpone_output 0;
+            sendfile_max_chunk 5;
+            js_content limit_rate;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('test.js', <<EOF);
+    function set_timeout(r) {
+        var timerId = setTimeout(timeout_cb_r, 5, r, 0);
+        clearTimeout(timerId);
+        setTimeout(timeout_cb_r, 5, r, 0)
+    }
+
+    function set_timeout_data(r) {
+        setTimeout(timeout_cb_data, 5, r, 0);
+    }
+
+    function set_timeout_many(r) {
+        for (var i = 0; i < 5; i++) {
+            setTimeout(timeout_cb_empty, 5, r, i);
+        }
+
+        setTimeout(timeout_cb_reply, 10, r);
+    }
+
+    function timeout_cb_r(r, cnt) {
+        if (cnt == 10) {
+            r.status = 200;
+            r.headersOut['Content-Type'] = 'foo';
+            r.sendHeader();
+            r.finish();
+
+        } else {
+            setTimeout(timeout_cb_r, 5, r, ++cnt);
+        }
+    }
+
+    function timeout_cb_empty(r, arg) {
+        r.log("timeout_cb_empty" + arg);
+    }
+
+    function timeout_cb_reply(r) {
+        r.status = 200;
+        r.headersOut['Content-Type'] = 'reply';
+        r.sendHeader();
+        r.finish();
+    }
+
+    function timeout_cb_data(r, counter) {
+        if (counter == 0) {
+            r.log("timeout_cb_data: init");
+            r.status = 200;
+            r.sendHeader();
+            setTimeout(timeout_cb_data, 5, r, ++counter);
+
+        } else if (counter == 10) {
+            r.log("timeout_cb_data: finish");
+            r.finish();
+
+        } else {
+            r.send("" + counter);
+            setTimeout(timeout_cb_data, 5, r, ++counter);
+        }
+    }
+
+    var js_;
+    function context_var() {
+        return js_;
+    }
+
+    function shared_ctx(r) {
+        js_ = r.variables.arg_a;
+
+        r.status = 200;
+        r.sendHeader();
+        r.finish();
+    }
+
+    function limit_rate_cb(r) {
+        r.finish();
+    }
+
+    function limit_rate(r) {
+        r.status = 200;
+        r.sendHeader();
+        r.send("AAAAA".repeat(10))
+        setTimeout(limit_rate_cb, 1000, r);
+    }
+
+EOF
+
+$t->try_run('no njs available')->plan(7);
+
+###############################################################################
+
+like(http_get('/set_timeout'), qr/Content-Type: foo/, 'setTimeout');
+like(http_get('/set_timeout_many'), qr/Content-Type: reply/, 'setTimeout many');
+like(http_get('/set_timeout_data'), qr/123456789/, 'setTimeout data');
+like(http_get('/shared_ctx?a=xxx'), qr/H: xxx/, 'shared context');
+like(http_get('/limit_rate'), qr/A{50}/, 'limit_rate');
+
+http_get('/async_var');
+
+$t->stop();
+
+ok(index($t->read_file('error.log'), 'pending events') > 0,
+   'pending js events');
+ok(index($t->read_file('error.log'), 'async operation inside') > 0,
+   'async op in var handler');
+
+###############################################################################
diff --git a/tests/js_dump.t b/tests/js_dump.t
new file mode 100644
index 0000000..3f5a41c
--- /dev/null
+++ b/tests/js_dump.t
@@ -0,0 +1,122 @@
+#!/usr/bin/perl
+
+# (C) Dmitry Volyntsev
+# (C) Nginx, Inc.
+
+# Tests for http njs module, request object dump.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http rewrite/)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    js_include test.js;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /njs {
+            js_content test_njs;
+        }
+
+        location /dump {
+            js_content test_dump;
+        }
+
+        location /stringify {
+            js_content test_stringify;
+        }
+
+        location /stringify_subrequest {
+            js_content test_stringify_subrequest;
+        }
+
+        location /js_sub {
+            return 201 '{$request_method}';
+        }
+    }
+}
+
+EOF
+
+$t->write_file('test.js', <<EOF);
+    function test_njs(r) {
+        r.return(200, njs.version);
+    }
+
+    function test_dump(r) {
+        r.headersOut.baz = 'bar';
+        r.return(200, njs.dump(r));
+    }
+
+    function test_stringify(r) {
+        r.headersOut.baz = 'bar';
+        var obj = JSON.parse(JSON.stringify(r));
+        r.return(200, JSON.stringify(obj));
+    }
+
+    function test_stringify_subrequest(r) {
+        r.subrequest('/js_sub', reply => {
+            r.return(200, JSON.stringify(reply))
+        });
+    }
+
+EOF
+
+$t->try_run('no njs dump')->plan(3);
+
+###############################################################################
+
+TODO: {
+local $TODO = 'not yet'
+               unless http_get('/njs') =~ /^([.0-9]+)$/m && $1 ge '0.3.8';
+
+like(http(
+	'GET /dump?v=1&t=x HTTP/1.0' . CRLF
+	. 'Foo: bar' . CRLF
+	. 'Foo2: bar2' . CRLF
+	. 'Host: localhost' . CRLF . CRLF
+), qr/method:'GET'/, 'njs.dump(r)');
+
+like(http(
+	'GET /stringify?v=1&t=x HTTP/1.0' . CRLF
+	. 'Foo: bar' . CRLF
+	. 'Foo2: bar2' . CRLF
+	. 'Host: localhost' . CRLF . CRLF
+), qr/headersOut":\{"baz":"bar"}/, 'JSON.stringify(r)');
+
+like(http(
+	'GET /stringify_subrequest HTTP/1.0' . CRLF
+	. 'Host: localhost' . CRLF . CRLF
+), qr/responseBody":"\{GET}"/, 'JSON.stringify(reply)');
+
+}
+
+###############################################################################
diff --git a/tests/js_headers.t b/tests/js_headers.t
new file mode 100644
index 0000000..3f447f8
--- /dev/null
+++ b/tests/js_headers.t
@@ -0,0 +1,432 @@
+#!/usr/bin/perl
+
+# (C) Dmitry Volyntsev
+# (C) Nginx, Inc.
+
+# Tests for http njs module, working with headers.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http charset/)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    js_set $test_foo_in   test_foo_in;
+    js_set $test_ifoo_in  test_ifoo_in;
+
+    js_include test.js;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /njs {
+            js_content test_njs;
+        }
+
+        location /content_length {
+            js_content content_length;
+        }
+
+        location /content_length_arr {
+            js_content content_length_arr;
+        }
+
+        location /content_length_keys {
+            js_content content_length_keys;
+        }
+
+        location /content_type {
+            charset windows-1251;
+
+            default_type text/plain;
+            js_content content_type;
+        }
+
+        location /content_type_arr {
+            charset windows-1251;
+
+            default_type text/plain;
+            js_content content_type_arr;
+        }
+
+        location /content_encoding {
+            js_content content_encoding;
+        }
+
+        location /content_encoding_arr {
+            js_content content_encoding_arr;
+        }
+
+        location /headers_list {
+            js_content headers_list;
+        }
+
+        location /foo_in {
+            return 200 $test_foo_in;
+        }
+
+        location /ifoo_in {
+            return 200 $test_ifoo_in;
+        }
+
+        location /hdr_in {
+            js_content hdr_in;
+        }
+
+        location /hdr_out {
+            js_content hdr_out;
+        }
+
+        location /hdr_out_array {
+            js_content hdr_out_array;
+        }
+
+        location /hdr_out_set_cookie {
+            js_content hdr_out_set_cookie;
+        }
+
+        location /hdr_out_single {
+            js_content hdr_out_single;
+        }
+
+        location /ihdr_out {
+            js_content ihdr_out;
+        }
+
+        location /hdr_sorted_keys {
+            js_content hdr_sorted_keys;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('test.js', <<EOF);
+    function test_njs(r) {
+        r.return(200, njs.version);
+    }
+
+    function content_length(r) {
+        r.headersOut['Content-Length'] = '';
+        r.headersOut['Content-Length'] = 3;
+        delete r.headersOut['Content-Length'];
+        r.headersOut['Content-Length'] = 3;
+        r.sendHeader();
+        r.send('XXX');
+        r.finish();
+    }
+
+    function content_length_arr(r) {
+        r.headersOut['Content-Length'] = [5];
+        r.headersOut['Content-Length'] = [];
+        r.headersOut['Content-Length'] = [4,3];
+        r.sendHeader();
+        r.send('XXX');
+        r.finish();
+    }
+
+    function content_length_keys(r) {
+        r.headersOut['Content-Length'] = 3;
+        var in_keys = Object.keys(r.headersOut).some(v=>v=='Content-Length');
+        r.return(200, `B:\${in_keys}`);
+    }
+
+    function content_type(r) {
+        r.headersOut['Content-Type'] = 'text/xml';
+        r.headersOut['Content-Type'] = '';
+        r.headersOut['Content-Type'] = 'text/xml; charset=';
+        delete r.headersOut['Content-Type'];
+        r.headersOut['Content-Type'] = 'text/xml; charset=utf-8';
+        r.headersOut['Content-Type'] = 'text/xml; charset="utf-8"';
+        var in_keys = Object.keys(r.headersOut).some(v=>v=='Content-Type');
+        r.return(200, `B:\${in_keys}`);
+    }
+
+    function content_type_arr(r) {
+        r.headersOut['Content-Type'] = ['text/html'];
+        r.headersOut['Content-Type'] = [];
+        r.headersOut['Content-Type'] = [ 'text/xml', 'text/html'];
+        r.return(200);
+    }
+
+    function content_encoding(r) {
+        r.headersOut['Content-Encoding'] = '';
+        r.headersOut['Content-Encoding'] = 'test';
+        delete r.headersOut['Content-Encoding'];
+        r.headersOut['Content-Encoding'] = 'gzip';
+        r.return(200);
+    }
+
+    function content_encoding_arr(r) {
+        r.headersOut['Content-Encoding'] = 'test';
+        r.headersOut['Content-Encoding'] = [];
+        r.headersOut['Content-Encoding'] = ['test', 'gzip'];
+        r.return(200);
+    }
+
+    function headers_list(r) {
+        for (var h in {a:1, b:2, c:3}) {
+            r.headersOut[h] = h;
+        }
+
+        delete r.headersOut.b;
+        r.headersOut.d = 'd';
+
+        var out = "";
+        for (var h in r.headersOut) {
+            out += h + ":";
+        }
+
+        r.return(200, out);
+    }
+
+    function hdr_in(r) {
+        var s = '', h;
+        for (h in r.headersIn) {
+            s += `\${h.toLowerCase()}: \${r.headersIn[h]}\n`;
+        }
+
+        r.return(200, s);
+    }
+
+    function hdr_sorted_keys(r) {
+        var s = '';
+        var hdr = r.args.in ? r.headersIn : r.headersOut;
+
+        if (!r.args.in) {
+            r.headersOut.b = 'b';
+            r.headersOut.c = 'c';
+            r.headersOut.a = 'a';
+        }
+
+        r.return(200, Object.keys(hdr).sort());
+    }
+
+    function test_foo_in(r) {
+        return 'hdr=' + r.headersIn.foo;
+    }
+
+    function test_ifoo_in(r) {
+        var s = '', h;
+        for (h in r.headersIn) {
+            if (h.substr(0, 3) == 'foo') {
+                s += r.headersIn[h];
+            }
+        }
+        return s;
+    }
+
+    function hdr_out(r) {
+        r.status = 200;
+        r.headersOut['Foo'] = r.args.fOO;
+
+        if (r.args.bar) {
+            r.headersOut['Bar'] =
+                r.headersOut[(r.args.bar == 'empty' ? 'Baz' :'Foo')]
+        }
+
+        r.sendHeader();
+        r.finish();
+    }
+
+    function hdr_out_array(r) {
+        if (!r.args.hidden) {
+            r.headersOut['Foo'] = [r.args.fOO];
+            r.headersOut['Foo'] = [];
+            r.headersOut['Foo'] = ['bar', r.args.fOO];
+        }
+
+        if (r.args.scalar_set) {
+            r.headersOut['Foo'] = 'xxx';
+        }
+
+        r.return(200, `B:\${njs.dump(r.headersOut.foo)}`);
+    }
+
+    function hdr_out_single(r) {
+        r.headersOut.ETag = ['a', 'b'];
+        r.return(200, `B:\${njs.dump(r.headersOut.etag)}`);
+    }
+
+    function hdr_out_set_cookie(r) {
+        r.headersOut['Set-Cookie'] = [];
+        r.headersOut['Set-Cookie'] = ['a', 'b'];
+        delete r.headersOut['Set-Cookie'];
+        r.headersOut['Set-Cookie'] = 'e';
+        r.headersOut['Set-Cookie'] = ['c', '', null, 'd', 'f'];
+
+        r.return(200, `B:\${njs.dump(r.headersOut['Set-Cookie'])}`);
+    }
+
+    function ihdr_out(r) {
+        r.status = 200;
+        r.headersOut['a'] = r.args.a;
+        r.headersOut['b'] = r.args.b;
+
+        var s = '', h;
+        for (h in r.headersOut) {
+            s += r.headersOut[h];
+        }
+
+        r.sendHeader();
+        r.send(s);
+        r.finish();
+    }
+
+
+EOF
+
+$t->try_run('no njs')->plan(37);
+
+###############################################################################
+
+like(http_get('/content_length'), qr/Content-Length: 3/,
+	'set Content-Length');
+like(http_get('/content_type'), qr/Content-Type: text\/xml; charset="utf-8"\r/,
+	'set Content-Type');
+unlike(http_get('/content_type'), qr/Content-Type: text\/plain/,
+	'set Content-Type 2');
+like(http_get('/content_encoding'), qr/Content-Encoding: gzip/,
+	'set Content-Encoding');
+like(http_get('/headers_list'), qr/a:c:d/, 'headers list');
+
+like(http_get('/ihdr_out?a=12&b=34'), qr/^1234$/m, 'r.headersOut iteration');
+like(http_get('/ihdr_out'), qr/\x0d\x0a?\x0d\x0a?$/m, 'r.send zero');
+like(http_get('/hdr_out?foo=12345'), qr/Foo: 12345/, 'r.headersOut');
+like(http_get('/hdr_out?foo=123&bar=copy'), qr/Bar: 123/, 'r.headersOut get');
+unlike(http_get('/hdr_out?bar=empty'), qr/Bar:/, 'r.headersOut empty');
+unlike(http_get('/hdr_out?foo='), qr/Foo:/, 'r.headersOut no value');
+unlike(http_get('/hdr_out?foo'), qr/Foo:/, 'r.headersOut no value 2');
+
+TODO: {
+local $TODO = 'not yet'
+	unless http_get('/njs') =~ /^([.0-9]+)$/m && $1 ge '0.4.0';
+
+like(http_get('/content_length_keys'), qr/B:true/, 'Content-Length in keys');
+like(http_get('/content_length_arr'), qr/Content-Length: 3/,
+	'set Content-Length arr');
+
+like(http_get('/content_type'), qr/B:true/, 'Content-Type in keys');
+like(http_get('/content_type_arr'), qr/Content-Type: text\/html/,
+	'set Content-Type arr');
+like(http_get('/content_encoding_arr'), qr/Content-Encoding: gzip/,
+	'set Content-Encoding arr');
+
+like(http_get('/hdr_out_array?foo=12345'), qr/Foo: bar\r\nFoo: 12345/,
+	'r.headersOut arr');
+like(http_get('/hdr_out_array'), qr/Foo: bar/,
+	'r.headersOut arr last is empty');
+like(http_get('/hdr_out_array?foo=abc'), qr/B:bar,abc/,
+	'r.headersOut get');
+like(http_get('/hdr_out_array'), qr/B:bar/, 'r.headersOut get2');
+like(http_get('/hdr_out_array?hidden=1'), qr/B:undefined/,
+	'r.headersOut get3');
+like(http_get('/hdr_out_array?scalar_set=1'), qr/B:xxx/,
+	'r.headersOut scalar set');
+like(http_get('/hdr_out_single'), qr/ETag: a\r\nETag: b/,
+	'r.headersOut single');
+like(http_get('/hdr_out_single'), qr/B:a/,
+	'r.headersOut single get');
+like(http_get('/hdr_out_set_cookie'), qr/Set-Cookie: c\r\nSet-Cookie: d/,
+	'set_cookie');
+like(http_get('/hdr_out_set_cookie'), qr/B:\['c','d','f']/,
+	'set_cookie2');
+unlike(http_get('/hdr_out_set_cookie'), qr/Set-Cookie: [abe]/,
+	'set_cookie3');
+
+}
+
+like(http(
+	'GET /hdr_in HTTP/1.0' . CRLF
+	. 'Cookie: foo' . CRLF
+	. 'Host: localhost' . CRLF . CRLF
+), qr/cookie: foo/, 'r.headersIn cookie');
+
+like(http(
+	'GET /hdr_in HTTP/1.0' . CRLF
+	. 'X-Forwarded-For: foo' . CRLF
+	. 'Host: localhost' . CRLF . CRLF
+), qr/x-forwarded-for: foo/, 'r.headersIn xff');
+
+like(http(
+	'GET /hdr_in HTTP/1.0' . CRLF
+	. 'Cookie: foo1' . CRLF
+	. 'Cookie: foo2' . CRLF
+	. 'Host: localhost' . CRLF . CRLF
+), qr/cookie: foo1;\s?foo2/, 'r.headersIn cookie2');
+
+like(http(
+	'GET /hdr_in HTTP/1.0' . CRLF
+	. 'X-Forwarded-For: foo1' . CRLF
+	. 'X-Forwarded-For: foo2' . CRLF
+	. 'Host: localhost' . CRLF . CRLF
+), qr/x-forwarded-for: foo1,\s?foo2/, 'r.headersIn xff2');
+
+like(http(
+	'GET /hdr_in HTTP/1.0' . CRLF
+	. 'ETag: bar1' . CRLF
+	. 'ETag: bar2' . CRLF
+	. 'Host: localhost' . CRLF . CRLF
+), qr/etag: bar1(?!,\s?bar2)/, 'r.headersIn duplicate single');
+
+like(http(
+	'GET /hdr_in HTTP/1.0' . CRLF
+	. 'Content-Type: bar1' . CRLF
+	. 'Content-Type: bar2' . CRLF
+	. 'Host: localhost' . CRLF . CRLF
+), qr/content-type: bar1(?!,\s?bar2)/, 'r.headersIn duplicate single 2');
+
+TODO: {
+local $TODO = 'not yet'
+	unless http_get('/njs') =~ /^([.0-9]+)$/m && $1 ge '0.4.1';
+
+like(http(
+	'GET /hdr_in HTTP/1.0' . CRLF
+	. 'Foo: bar1' . CRLF
+	. 'Foo: bar2' . CRLF
+	. 'Host: localhost' . CRLF . CRLF
+), qr/foo: bar1,bar2/, 'r.headersIn duplicate generic');
+
+}
+
+like(http(
+	'GET /hdr_sorted_keys?in=1 HTTP/1.0' . CRLF
+	. 'Cookie: foo1' . CRLF
+	. 'Accept: */*' . CRLF
+	. 'Cookie: foo2' . CRLF
+	. 'Host: localhost' . CRLF . CRLF
+), qr/Accept,Cookie,Host/, 'r.headersIn sorted keys');
+
+like(http(
+	'GET /hdr_sorted_keys HTTP/1.0' . CRLF
+	. 'Host: localhost' . CRLF . CRLF
+), qr/a,b,c/, 'r.headersOut sorted keys');
+
+###############################################################################
diff --git a/tests/js_import.t b/tests/js_import.t
new file mode 100644
index 0000000..52ee795
--- /dev/null
+++ b/tests/js_import.t
@@ -0,0 +1,108 @@
+#!/usr/bin/perl
+
+# (C) Dmitry Volyntsev
+# (c) Nginx, Inc.
+
+# Tests for http njs module, js_import directive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http/)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    js_set $test foo.bar.p;
+
+    js_import lib.js;
+    js_import fun.js;
+    js_import foo from ./main.js;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /njs {
+            js_content foo.version;
+        }
+
+        location /test_foo {
+            js_content foo.test;
+        }
+
+        location /test_lib {
+            js_content lib.test;
+        }
+
+        location /test_fun {
+            js_content fun;
+        }
+
+        location /test_var {
+            return 200 $test;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('lib.js', <<EOF);
+    function test(r) {
+        r.return(200, "LIB-TEST");
+    }
+
+    export default {test};
+
+EOF
+
+$t->write_file('fun.js', <<EOF);
+    export default function (r) {r.return(200, "FUN-TEST")};
+
+EOF
+
+$t->write_file('main.js', <<EOF);
+    function version(r) {
+        r.return(200, njs.version);
+    }
+
+    function test(r) {
+        r.return(200, "MAIN-TEST");
+    }
+
+    export default {version, test, bar: {p(r) {return "P-TEST"}}};
+
+EOF
+
+$t->try_run('no njs available')->plan(4);
+
+###############################################################################
+
+like(http_get('/test_foo'), qr/MAIN-TEST/s, 'foo.test');
+like(http_get('/test_lib'), qr/LIB-TEST/s, 'lib.test');
+like(http_get('/test_fun'), qr/FUN-TEST/s, 'fun');
+like(http_get('/test_var'), qr/P-TEST/s, 'foo.bar.p');
+
+###############################################################################
diff --git a/tests/js_internal_redirect.t b/tests/js_internal_redirect.t
new file mode 100644
index 0000000..5b428f8
--- /dev/null
+++ b/tests/js_internal_redirect.t
@@ -0,0 +1,94 @@
+#!/usr/bin/perl
+
+# (C) Dmitry Volyntsev
+# (C) Nginx, Inc.
+
+# Tests for http njs module, internalRedirect method.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http rewrite/)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    js_include test.js;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /njs {
+            js_content test_njs;
+        }
+
+        location /test {
+            js_content test_redirect;
+        }
+
+        location /redirect {
+            internal;
+            return 200 redirect$arg_b;
+        }
+
+        location @named {
+            return 200 named;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('test.js', <<EOF);
+    function test_njs(r) {
+        r.return(200, njs.version);
+    }
+
+    function test_redirect(req) {
+        if (req.variables.arg_dest == 'named') {
+            req.internalRedirect('\@named');
+
+        } else {
+            if (req.variables.arg_a) {
+                req.internalRedirect('/redirect?b=' + req.variables.arg_a);
+
+            } else {
+                req.internalRedirect('/redirect');
+            }
+        }
+    }
+
+EOF
+
+$t->try_run('no njs available')->plan(3);
+
+###############################################################################
+
+like(http_get('/test'), qr/redirect/s, 'redirect');
+like(http_get('/test?a=A'), qr/redirectA/s, 'redirect with args');
+like(http_get('/test?dest=named'), qr/named/s, 'redirect to named location');
+
+###############################################################################
diff --git a/tests/js_modules.t b/tests/js_modules.t
new file mode 100644
index 0000000..c3ce7a9
--- /dev/null
+++ b/tests/js_modules.t
@@ -0,0 +1,90 @@
+#!/usr/bin/perl
+
+# (C) Dmitry Volyntsev
+# (C) Nginx, Inc.
+
+# Tests for http njs module, ES6 import, export.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http/)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    js_include test.js;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /njs {
+            js_content test_njs;
+        }
+
+        location /test {
+            js_content test;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('test.js', <<EOF);
+    import m from 'module.js';
+
+    function test_njs(r) {
+        r.return(200, njs.version);
+    }
+
+    function test(r) {
+        r.return(200, m[r.args.fun](r.args.a, r.args.b));
+    }
+
+EOF
+
+$t->write_file('module.js', <<EOF);
+    function sum(a, b) {
+        return Number(a) + Number(b);
+    }
+
+    function prod(a, b) {
+        return Number(a) * Number(b);
+    }
+
+    export default {sum, prod};
+
+EOF
+
+
+$t->try_run('no njs modules')->plan(2);
+
+###############################################################################
+
+like(http_get('/test?fun=sum&a=3&b=4'), qr/7/s, 'test sum');
+like(http_get('/test?fun=prod&a=3&b=4'), qr/12/s, 'test prod');
+
+###############################################################################
diff --git a/tests/js_object.t b/tests/js_object.t
new file mode 100644
index 0000000..80259dc
--- /dev/null
+++ b/tests/js_object.t
@@ -0,0 +1,149 @@
+#!/usr/bin/perl
+
+# (C) Dmitry Volyntsev
+# (C) Nginx, Inc.
+
+# Tests for http njs module, request object.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http/)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    js_include test.js;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /njs {
+            js_content test_njs;
+        }
+
+        location /to_string {
+            js_content to_string;
+        }
+
+        location /define_prop {
+            js_content define_prop;
+        }
+
+        location /in_operator {
+            js_content in_operator;
+        }
+
+        location /redefine_bind {
+            js_content redefine_bind;
+        }
+
+        location /redefine_proxy {
+            js_content redefine_proxy;
+        }
+
+        location /redefine_proto {
+            js_content redefine_proto;
+        }
+
+        location /get_own_prop_descs {
+            js_content get_own_prop_descs;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('test.js', <<EOF);
+    function test_njs(r) {
+        r.return(200, njs.version);
+    }
+
+    function to_string(r) {
+        r.return(200, r.toString());
+    }
+
+    function define_prop(r) {
+        Object.defineProperty(r.headersOut, 'Foo', {value:'bar'});
+        r.return(200);
+    }
+
+    function in_operator(r) {
+        r.return(200, ['Foo', 'Bar'].map(v=>v in r.headersIn)
+                      .toString() === 'true,false');
+    }
+
+    function redefine_bind(r) {
+        r.return = r.return.bind(r, 200);
+        r.return('redefine_bind');
+    }
+
+    function redefine_proxy(r) {
+        r.return_orig = r.return;
+        r.return = function (body) { this.return_orig(200, body);}
+        r.return('redefine_proxy');
+    }
+
+    function redefine_proto(r) {
+        r[0] = 'a';
+        r[1] = 'b';
+        r.length = 2;
+        Object.setPrototypeOf(r, Array.prototype);
+        r.return(200, r.join('|'));
+    }
+
+    function get_own_prop_descs(r) {
+        r.return(200,
+                 Object.getOwnPropertyDescriptors(r)['log'].value === r.log);
+    }
+
+EOF
+
+$t->try_run('no njs request object')->plan(7);
+
+###############################################################################
+
+TODO: {
+local $TODO = 'not yet'
+              unless http_get('/njs') =~ /^([.0-9]+)$/m && $1 ge '0.4.0';
+
+
+like(http_get('/to_string'), qr/\[object Request\]/, 'toString');
+like(http_get('/define_prop'), qr/Foo: bar/, 'define_prop');
+like(http(
+	'GET /in_operator HTTP/1.0' . CRLF
+	. 'Foo: foo' . CRLF
+	. 'Host: localhost' . CRLF . CRLF
+), qr/true/, 'in_operator');
+like(http_get('/redefine_bind'), qr/redefine_bind/, 'redefine_bind');
+like(http_get('/redefine_proxy'), qr/redefine_proxy/, 'redefine_proxy');
+like(http_get('/redefine_proto'), qr/a|b/, 'redefine_proto');
+like(http_get('/get_own_prop_descs'), qr/true/, 'get_own_prop_descs');
+
+}
+
+###############################################################################
diff --git a/tests/js_paths.t b/tests/js_paths.t
new file mode 100644
index 0000000..11e8422
--- /dev/null
+++ b/tests/js_paths.t
@@ -0,0 +1,116 @@
+#!/usr/bin/perl
+
+# (C) Dmitry Volyntsev
+# (C) Nginx, Inc.
+
+# Tests for http njs module, js_path directive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http/)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    js_path "%%TESTDIR%%/lib1";
+    js_path "lib2";
+
+    js_include test.js;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /njs {
+            js_content test_njs;
+        }
+
+        location /test {
+            js_content test;
+        }
+
+        location /test2 {
+            js_content test2;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('test.js', <<EOF);
+    import m1 from 'module1.js';
+    import m2 from 'module2.js';
+    import m3 from 'lib1/module1.js';
+
+    function test_njs(r) {
+        r.return(200, njs.version);
+    }
+
+    function test(r) {
+        r.return(200, m1[r.args.fun](r.args.a, r.args.b));
+    }
+
+    function test2(r) {
+        r.return(200, m2.sum(r.args.a, r.args.b));
+    }
+
+    function test3(r) {
+        r.return(200, m3.sum(r.args.a, r.args.b));
+    }
+
+EOF
+
+my $d = $t->testdir();
+
+mkdir("$d/lib1");
+mkdir("$d/lib2");
+
+$t->write_file('lib1/module1.js', <<EOF);
+    function sum(a, b) { return Number(a) + Number(b); }
+    function prod(a, b) { return Number(a) * Number(b); }
+
+    export default {sum, prod};
+
+EOF
+
+$t->write_file('lib2/module2.js', <<EOF);
+    function sum(a, b) { return a + b; }
+
+    export default {sum};
+
+EOF
+
+
+$t->try_run('no njs available')->plan(4);
+
+###############################################################################
+
+like(http_get('/test?fun=sum&a=3&b=4'), qr/7/s, 'test sum');
+like(http_get('/test?fun=prod&a=3&b=4'), qr/12/s, 'test prod');
+like(http_get('/test2?a=3&b=4'), qr/34/s, 'test2');
+like(http_get('/test2?a=A&b=B'), qr/AB/s, 'test2 relative');
+
+###############################################################################
diff --git a/tests/js_promise.t b/tests/js_promise.t
new file mode 100644
index 0000000..5a4590a
--- /dev/null
+++ b/tests/js_promise.t
@@ -0,0 +1,187 @@
+#!/usr/bin/perl
+
+# (C) Nginx, Inc.
+
+# Promise tests for http njs module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http/)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    js_include test.js;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /promise {
+            js_content promise;
+        }
+
+        location /promise_throw {
+            js_content promise_throw;
+        }
+
+        location /timeout {
+            js_content timeout;
+        }
+
+        location /sub_token {
+            js_content sub_token;
+        }
+
+        location /njs {
+            js_content test_njs;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('test.js', <<EOF);
+    var global_token = '';
+
+    function promise(r) {
+        promisified_subrequest(r, '/sub_token', 'code=200&token=a')
+        .then(reply => {
+            var data = JSON.parse(reply.responseBody);
+
+            if (data['token'] !== "a") {
+                throw new Error('token is not "a"');
+            }
+
+            return data['token'];
+        })
+        .then(token => {
+            promisified_subrequest(r, '/sub_token', 'code=200&token=b')
+            .then(reply => {
+                var data = JSON.parse(reply.responseBody);
+
+                r.return(200, '{"token": "' + data['token'] + '"}');
+            })
+            .catch(() => {
+                throw new Error("failed promise() test");
+            });
+        })
+        .catch(() => {
+            r.return(500);
+        });
+    }
+
+    function promise_throw(r) {
+        promisified_subrequest(r, '/sub_token', 'code=200&token=x')
+        .then(reply => {
+            var data = JSON.parse(reply.responseBody);
+
+            if (data['token'] !== "a") {
+                throw data['token'];
+            }
+
+            return data['token'];
+        })
+        .then(() => {
+            r.return(500);
+        })
+        .catch(token => {
+            r.return(200, '{"token": "' + token + '"}');
+        });
+    }
+
+    function timeout(r) {
+        promisified_subrequest(r, '/sub_token', 'code=200&token=R')
+        .then(reply => JSON.parse(reply.responseBody))
+        .then(data => {
+            setTimeout(timeout_cb, 50, r, '/sub_token', 'code=200&token=T');
+            return data;
+        })
+        .then(data => {
+            setTimeout(timeout_cb, 1, r, '/sub_token', 'code=200&token='
+                                                        + data['token']);
+        })
+        .catch(() => {
+            r.return(500);
+        });
+    }
+
+    function timeout_cb(r, url, args) {
+        promisified_subrequest(r, url, args)
+        .then(reply => {
+            if (global_token == '') {
+                var data = JSON.parse(reply.responseBody);
+
+                global_token = data['token'];
+
+                r.return(200, '{"token": "' + data['token'] + '"}');
+            }
+        })
+        .catch(() => {
+            r.return(500);
+        });
+    }
+
+    function promisified_subrequest(r, uri, args) {
+        return new Promise((resolve, reject) => {
+            r.subrequest(uri, args, (reply) => {
+                if (reply.status < 400) {
+                    resolve(reply);
+                } else {
+                    reject(reply);
+                }
+            });
+        })
+    }
+
+    function sub_token(r) {
+        var code = r.variables.arg_code;
+        var token = r.variables.arg_token;
+
+        r.return(parseInt(code), '{"token": "'+ token +'"}');
+    }
+
+    function test_njs(r) {
+        r.return(200, njs.version);
+    }
+
+EOF
+
+$t->try_run('no njs available')->plan(3);
+
+###############################################################################
+
+TODO: {
+local $TODO = 'not yet'
+	unless http_get('/njs') =~ /^([.0-9]+)$/m && $1 ge '0.3.8';
+
+like(http_get('/promise'), qr/{"token": "b"}/, "Promise");
+like(http_get('/promise_throw'), qr/{"token": "x"}/, "Promise throw and catch");
+like(http_get('/timeout'), qr/{"token": "R"}/, "Promise with timeout");
+
+}
+
+###############################################################################
diff --git a/tests/js_request_body.t b/tests/js_request_body.t
new file mode 100644
index 0000000..c537eef
--- /dev/null
+++ b/tests/js_request_body.t
@@ -0,0 +1,116 @@
+#!/usr/bin/perl
+
+# (C) Dmitry Volyntsev
+# (C) Nginx, Inc.
+
+# Tests for http njs module, req.requestBody method.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http/)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    js_include test.js;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /njs {
+            js_content test_njs;
+        }
+
+        location /body {
+            js_content test_body;
+        }
+
+        location /in_file {
+            client_body_in_file_only on;
+            js_content test_body;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('test.js', <<EOF);
+    function test_njs(r) {
+        r.return(200, njs.version);
+    }
+
+    function test_body(r) {
+        try {
+            var body = r.requestBody;
+            r.return(200, body);
+
+        } catch (e) {
+            r.return(500, e.message);
+        }
+    }
+
+EOF
+
+$t->try_run('no njs request body')->plan(3);
+
+###############################################################################
+
+like(http_post('/body'), qr/REQ-BODY/, 'request body');
+like(http_post('/in_file'), qr/request body is in a file/,
+	'request body in file');
+like(http_post_big('/body'), qr/200.*^(1234567890){1024}$/ms,
+		'request body big');
+
+###############################################################################
+
+sub http_post {
+	my ($url, %extra) = @_;
+
+	my $p = "POST $url HTTP/1.0" . CRLF .
+		"Host: localhost" . CRLF .
+		"Content-Length: 8" . CRLF .
+		CRLF .
+		"REQ-BODY";
+
+	return http($p, %extra);
+}
+
+sub http_post_big {
+	my ($url, %extra) = @_;
+
+	my $p = "POST $url HTTP/1.0" . CRLF .
+		"Host: localhost" . CRLF .
+		"Content-Length: 10240" . CRLF .
+		CRLF .
+		("1234567890" x 1024);
+
+	return http($p, %extra);
+}
+
+###############################################################################
diff --git a/tests/js_return.t b/tests/js_return.t
new file mode 100644
index 0000000..f7f9db7
--- /dev/null
+++ b/tests/js_return.t
@@ -0,0 +1,79 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http njs module, return method.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Config;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http/)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    js_include test.js;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /njs {
+            js_content test_njs;
+        }
+
+        location / {
+            js_content test_return;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('test.js', <<EOF);
+    function test_njs(r) {
+        r.return(200, njs.version);
+    }
+
+    function test_return(r) {
+        r.return(Number(r.args.c), r.args.t);
+    }
+
+EOF
+
+$t->try_run('no njs return')->plan(5);
+
+###############################################################################
+
+like(http_get('/?c=200'), qr/200 OK.*\x0d\x0a?\x0d\x0a?$/s, 'return code');
+like(http_get('/?c=200&t=SEE-THIS'), qr/200 OK.*^SEE-THIS$/ms, 'return text');
+like(http_get('/?c=301&t=path'), qr/ 301 .*Location: path/s, 'return redirect');
+like(http_get('/?c=404'), qr/404 Not.*html/s, 'return error page');
+like(http_get('/?c=inv'), qr/ 500 /, 'return invalid');
+
+###############################################################################
diff --git a/tests/js_subrequests.t b/tests/js_subrequests.t
new file mode 100644
index 0000000..8fb3786
--- /dev/null
+++ b/tests/js_subrequests.t
@@ -0,0 +1,645 @@
+#!/usr/bin/perl
+#
+# (C) Dmitry Volyntsev.
+# (C) Nginx, Inc.
+
+# Tests for subrequests in http njs module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require JSON::PP; };
+plan(skip_all => "JSON::PP not installed") if $@;
+
+my $t = Test::Nginx->new()->has(qw/http rewrite proxy cache/)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    proxy_cache_path   %%TESTDIR%%/cache1
+                       keys_zone=ON:1m      use_temp_path=on;
+
+    js_include test.js;
+
+    js_set $async_var       async_var;
+    js_set $subrequest_var  subrequest_var;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /njs {
+            js_content test_njs;
+        }
+
+        location /sr {
+            js_content sr;
+        }
+
+        location /sr_pr {
+            js_content sr_pr;
+        }
+
+        location /sr_args {
+            js_content sr_args;
+        }
+
+        location /sr_options_args {
+            js_content sr_options_args;
+        }
+
+        location /sr_options_args_pr {
+            js_content sr_options_args_pr;
+        }
+
+        location /sr_options_method {
+            js_content sr_options_method;
+        }
+
+        location /sr_options_method_pr {
+            js_content sr_options_method_pr;
+        }
+
+        location /sr_options_body {
+            js_content sr_options_body;
+        }
+
+        location /sr_options_method_head {
+            js_content sr_options_method_head;
+        }
+
+        location /sr_body {
+            js_content sr_body;
+        }
+
+        location /sr_body_pr {
+            js_content sr_body_pr;
+        }
+
+        location /sr_body_special {
+            js_content sr_body_special;
+        }
+
+        location /sr_in_variable_handler {
+            set $_ $async_var;
+            js_content sr_in_variable_handler;
+        }
+
+        location /sr_detached_in_variable_handler {
+            return 200 $subrequest_var;
+        }
+
+        location /sr_error_page {
+            set $_ $async_var;
+            error_page 404 /return;
+            return 404;
+        }
+
+        location /sr_js_in_subrequest {
+            js_content sr_js_in_subrequest;
+        }
+
+        location /sr_js_in_subrequest_pr {
+            js_content sr_js_in_subrequest_pr;
+        }
+
+        location /sr_file {
+            js_content sr_file;
+        }
+
+        location /sr_cache {
+            js_content sr_cache;
+        }
+
+
+        location /sr_unavail {
+            js_content sr_unavail;
+        }
+
+        location /sr_unavail_pr {
+            js_content sr_unavail_pr;
+        }
+
+        location /sr_broken {
+            js_content sr_broken;
+        }
+
+        location /sr_too_large {
+            js_content sr_too_large;
+        }
+
+        location /sr_out_of_order {
+            js_content sr_out_of_order;
+        }
+
+        location /sr_except_not_a_func {
+            js_content sr_except_not_a_func;
+        }
+
+        location /sr_except_failed_to_convert_arg {
+            js_content sr_except_failed_to_convert_arg;
+        }
+
+        location /sr_except_failed_to_convert_options_arg {
+            js_content sr_except_failed_to_convert_options_arg;
+        }
+
+        location /sr_except_invalid_options_header_only {
+            js_content sr_except_invalid_options_header_only;
+        }
+
+        location /sr_in_sr_callback {
+            js_content sr_in_sr_callback;
+        }
+
+        location /sr_uri_except {
+            js_content sr_uri_except;
+        }
+
+
+        location /file/ {
+            alias %%TESTDIR%%/;
+        }
+
+        location /p/ {
+            proxy_cache $arg_c;
+            proxy_pass http://127.0.0.1:8081/;
+        }
+
+        location /daemon/ {
+            proxy_pass http://127.0.0.1:8082/;
+        }
+
+        location /too_large/ {
+            subrequest_output_buffer_size 3;
+            proxy_pass http://127.0.0.1:8081/;
+        }
+
+        location /sr_in_sr {
+            js_content sr_in_sr;
+        }
+
+        location /unavail {
+            proxy_pass http://127.0.0.1:8084/;
+        }
+
+        location /sr_parent {
+             js_content sr_parent;
+        }
+
+        location /js_sub {
+            js_content js_sub;
+        }
+
+        location /return {
+            return 200 '["$request_method"]';
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location /sub1 {
+            add_header H $arg_h;
+            return 206 '{"a": {"b": 1}}';
+        }
+
+        location /sub2 {
+            return 404 '{"e": "msg"}';
+        }
+
+        location /method {
+            return 200 '["$request_method"]';
+        }
+
+        location /body {
+            js_content body;
+        }
+
+        location /detached {
+            js_content detached;
+        }
+
+        location /delayed {
+            js_content delayed;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8084;
+        server_name  localhost;
+
+        return 444;
+    }
+}
+
+EOF
+
+$t->write_file('test.js', <<EOF);
+    function test_njs(r) {
+        r.return(200, njs.version);
+    }
+
+    function sr(r) {
+        subrequest_fn(r, ['/p/sub2'], ['uri', 'status'])
+    }
+
+    function sr_pr(r) {
+        r.subrequest('/p/sub1', 'h=xxx')
+        .then(reply => r.return(200, JSON.stringify({h:reply.headersOut.h})))
+    }
+
+    function sr_args(r) {
+        r.subrequest('/p/sub1', 'h=xxx', reply => {
+            r.return(200, JSON.stringify({h:reply.headersOut.h}));
+        });
+    }
+
+    function sr_options_args(r) {
+        r.subrequest('/p/sub1', {args:'h=xxx'}, reply => {
+            r.return(200, JSON.stringify({h:reply.headersOut.h}));
+        });
+    }
+
+    function sr_options_args_pr(r) {
+        r.subrequest('/p/sub1', {args:'h=xxx'})
+        .then(reply => r.return(200, JSON.stringify({h:reply.headersOut.h})))
+    }
+
+    function sr_options_method(r) {
+        r.subrequest('/p/method', {method:r.args.m}, body_fwd_cb);
+    }
+
+    function sr_options_method_pr(r) {
+        r.subrequest('/p/method', {method:r.args.m})
+        .then(body_fwd_cb);
+    }
+
+    function sr_options_body(r) {
+        r.subrequest('/p/body', {method:'POST', body:'["REQ-BODY"]'},
+                     body_fwd_cb);
+    }
+
+    function sr_options_method_head(r) {
+        r.subrequest('/p/method', {method:'HEAD'}, reply => {
+            r.return(200, JSON.stringify({c:reply.status}));
+        });
+    }
+
+    function sr_body(r) {
+        r.subrequest('/p/sub1', body_fwd_cb);
+    }
+
+    function sr_body_pr(r) {
+        r.subrequest('/p/sub1')
+        .then(body_fwd_cb);
+    }
+
+    function sr_body_special(r) {
+        r.subrequest('/p/sub2', body_fwd_cb);
+    }
+
+    function body(r) {
+        r.return(200, r.variables.request_body);
+    }
+
+    function delayed(r) {
+        setTimeout(r => r.return(200), 100, r);
+    }
+
+    function detached(r) {
+        var method = r.variables.request_method;
+        r.log(`DETACHED: \${method} args: \${r.variables.args}`);
+
+        r.return(200);
+    }
+
+    function sr_in_variable_handler(r) {
+    }
+
+    function async_var(r) {
+        r.subrequest('/p/delayed', reply => {
+            r.return(200, JSON.stringify(["CB-VAR"]));
+        });
+
+        return "";
+    }
+
+    function subrequest_var(r) {
+        r.subrequest('/p/detached',  {detached:true});
+        r.subrequest('/p/detached',  {detached:true, args:'a=yyy',
+                                      method:'POST'});
+
+        return "subrequest_var";
+    }
+
+    function sr_file(r) {
+        r.subrequest('/file/t', body_fwd_cb);
+    }
+
+    function sr_cache(r) {
+        r.subrequest('/p/t', body_fwd_cb);
+    }
+
+    function sr_unavail(req) {
+        subrequest_fn(req, ['/unavail'], ['uri', 'status']);
+    }
+
+    function sr_unavail_pr(req) {
+        subrequest_fn_pr(req, ['/unavail'], ['uri', 'status']);
+    }
+
+    function sr_broken(r) {
+        r.subrequest('/daemon/unfinished', reply => {
+            r.return(200, JSON.stringify({code:reply.status}));
+        });
+    }
+
+    function sr_too_large(r) {
+        r.subrequest('/too_large/t', body_fwd_cb);
+    }
+
+    function sr_in_sr(r) {
+        r.subrequest('/sr', body_fwd_cb);
+    }
+
+    function sr_js_in_subrequest(r) {
+        r.subrequest('/js_sub', body_fwd_cb);
+    }
+
+    function sr_js_in_subrequest_pr(r) {
+        r.subrequest('/js_sub')
+        .then(body_fwd_cb);
+    }
+
+    function sr_in_sr_callback(r) {
+        r.subrequest('/return', function (reply) {
+                try {
+                    reply.subrequest('/return');
+
+                } catch (err) {
+                    r.return(200, JSON.stringify({e:err.message}));
+                    return;
+                }
+
+                r.return(200);
+            });
+    }
+
+    function sr_parent(r) {
+        try {
+            var parent = r.parent;
+
+        } catch (err) {
+            r.return(200, JSON.stringify({e:err.message}));
+            return;
+        }
+
+        r.return(200);
+    }
+
+    function sr_out_of_order(r) {
+        subrequest_fn(r, ['/p/delayed', '/p/sub1', '/unknown'],
+                      ['uri', 'status']);
+    }
+
+    function collect(replies, props, total, reply) {
+        reply.log(`subrequest handler: \${reply.uri} status: \${reply.status}`)
+
+        var rep = {};
+        props.forEach(p => {rep[p] = reply[p]});
+
+        replies.push(rep);
+
+        if (replies.length == total) {
+            reply.parent.return(200, JSON.stringify(replies));
+        }
+    }
+
+    function subrequest_fn(r, subs, props) {
+        var replies = [];
+
+        subs.forEach(sr =>
+                     r.subrequest(sr, collect.bind(null, replies,
+                                                   props, subs.length)));
+    }
+
+    function subrequest_fn_pr(r, subs, props) {
+        var replies = [];
+
+        subs.forEach(sr => r.subrequest(sr)
+            .then(collect.bind(null, replies, props, subs.length)));
+    }
+
+    function sr_except_not_a_func(r) {
+        r.subrequest('/sub1', 'a=1', 'b');
+    }
+
+    function sr_except_failed_to_convert_arg(r) {
+        r.subrequest('/sub1', Symbol.toStringTag, ()=>{});
+    }
+
+    function sr_except_failed_to_convert_options_arg(r) {
+        r.subrequest('/sub1', {args:r.args}, ()=>{});
+    }
+
+    function sr_uri_except(r) {
+        r.subrequest(Symbol.toStringTag, 'a=1', 'b');
+    }
+
+    function body_fwd_cb(r) {
+        r.parent.return(200, JSON.stringify(JSON.parse(r.responseBody)));
+    }
+
+    function js_sub(r) {
+        r.return(200, '["JS-SUB"]');
+    }
+
+EOF
+
+$t->write_file('t', '["SEE-THIS"]');
+
+$t->try_run('no njs available')->plan(31);
+$t->run_daemon(\&http_daemon);
+
+###############################################################################
+
+is(get_json('/sr'), '[{"status":404,"uri":"/p/sub2"}]', 'sr');
+is(get_json('/sr_args'), '{"h":"xxx"}', 'sr_args');
+is(get_json('/sr_options_args'), '{"h":"xxx"}', 'sr_options_args');
+is(get_json('/sr_options_method?m=POST'), '["POST"]', 'sr method POST');
+is(get_json('/sr_options_method?m=PURGE'), '["PURGE"]', 'sr method PURGE');
+is(get_json('/sr_options_body'), '["REQ-BODY"]', 'sr_options_body');
+is(get_json('/sr_options_method_head'), '{"c":200}', 'sr_options_method_head');
+is(get_json('/sr_body'), '{"a":{"b":1}}', 'sr_body');
+is(get_json('/sr_body_special'), '{"e":"msg"}', 'sr_body_special');
+is(get_json('/sr_in_variable_handler'), '["CB-VAR"]', 'sr_in_variable_handler');
+
+$t->todo_alerts() if $t->read_file('nginx.conf') =~ /aio (on|threads)/
+	and !$t->has_version('1.17.9');
+
+TODO: {
+local $TODO = 'header already sent' if $t->read_file('nginx.conf') =~ /aio on/
+	and !$t->has_version('1.17.9');
+local $TODO = 'open socket left' if $t->read_file('nginx.conf') =~ /aio thread/
+	and !$t->has_version('1.17.9');
+
+is(get_json('/sr_file'), '["SEE-THIS"]', 'sr_file');
+
+}
+
+is(get_json('/sr_cache?c=1'), '["SEE-THIS"]', 'sr_cache');
+is(get_json('/sr_cache?c=1'), '["SEE-THIS"]', 'sr_cached');
+is(get_json('/sr_js_in_subrequest'), '["JS-SUB"]', 'sr_js_in_subrequest');
+is(get_json('/sr_unavail'), '[{"status":502,"uri":"/unavail"}]',
+	'sr_unavail');
+is(get_json('/sr_out_of_order'),
+	'[{"status":404,"uri":"/unknown"},' .
+	'{"status":206,"uri":"/p/sub1"},' .
+	'{"status":200,"uri":"/p/delayed"}]',
+	'sr_multi');
+
+my $ver = http_get('/njs');
+
+TODO: {
+local $TODO = 'not yet'
+	unless $ver =~ /^([.0-9]+)$/m && $1 ge '0.3.8';
+
+is(get_json('/sr_pr'), '{"h":"xxx"}', 'sr_promise');
+is(get_json('/sr_options_args_pr'), '{"h":"xxx"}', 'sr_options_args_pr');
+is(get_json('/sr_options_method_pr?m=PUT'), '["PUT"]', 'sr method PUT');
+is(get_json('/sr_body_pr'), '{"a":{"b":1}}', 'sr_body_pr');
+is(get_json('/sr_js_in_subrequest_pr'), '["JS-SUB"]', 'sr_js_in_subrequest_pr');
+is(get_json('/sr_unavail_pr'), '[{"status":502,"uri":"/unavail"}]',
+	'sr_unavail_pr');
+
+}
+
+TODO: {
+local $TODO = 'not yet'
+	unless $ver =~ /^([.0-9]+)$/m && $1 ge '0.3.9';
+
+like(http_get('/sr_detached_in_variable_handler'), qr/subrequest_var/,
+     'sr_detached_in_variable_handler');
+}
+
+http_get('/sr_broken');
+http_get('/sr_in_sr');
+http_get('/sr_in_variable_handler');
+http_get('/sr_error_page');
+http_get('/sr_too_large');
+http_get('/sr_except_not_a_func');
+http_get('/sr_except_failed_to_convert_arg');
+http_get('/sr_except_failed_to_convert_options_arg');
+http_get('/sr_uri_except');
+
+is(get_json('/sr_in_sr_callback'),
+	'{"e":"subrequest can only be created for the primary request"}',
+	'subrequest for non-primary request');
+
+$t->stop();
+
+ok(index($t->read_file('error.log'), 'callback is not a function') > 0,
+	'subrequest cb exception');
+ok(index($t->read_file('error.log'), 'failed to convert uri arg') > 0,
+	'subrequest uri exception');
+ok(index($t->read_file('error.log'), 'failed to convert args') > 0,
+	'subrequest invalid args exception');
+ok(index($t->read_file('error.log'), 'too big subrequest response') > 0,
+	'subrequest too large body');
+ok(index($t->read_file('error.log'), 'subrequest creation failed') > 0,
+	'subrequest creation failed');
+ok(index($t->read_file('error.log'),
+		'js subrequest: failed to get the parent context') > 0,
+	'zero parent ctx');
+
+TODO: {
+local $TODO = 'not yet'
+	unless $ver =~ /^([.0-9]+)$/m && $1 ge '0.3.9';
+
+ok(index($t->read_file('error.log'), 'DETACHED') > 0,
+	'detached subrequest');
+}
+
+###############################################################################
+
+sub recode {
+	my $json;
+	eval { $json = JSON::PP::decode_json(shift) };
+
+	if ($@) {
+		return "<failed to parse JSON>";
+	}
+
+	JSON::PP->new()->canonical()->encode($json);
+}
+
+sub get_json {
+	http_get(shift) =~ /\x0d\x0a?\x0d\x0a?(.*)/ms;
+	recode($1);
+}
+
+###############################################################################
+
+sub http_daemon {
+	my $server = IO::Socket::INET->new(
+		Proto => 'tcp',
+		LocalAddr => '127.0.0.1:' . port(8082),
+		Listen => 5,
+		Reuse => 1
+	)
+		or die "Can't create listening socket: $!\n";
+
+	local $SIG{PIPE} = 'IGNORE';
+
+	while (my $client = $server->accept()) {
+		$client->autoflush(1);
+
+		my $headers = '';
+		my $uri = '';
+
+		while (<$client>) {
+			$headers .= $_;
+			last if (/^\x0d?\x0a?$/);
+		}
+
+		$uri = $1 if $headers =~ /^\S+\s+([^ ]+)\s+HTTP/i;
+
+		if ($uri eq '/unfinished') {
+			print $client
+				"HTTP/1.1 200 OK" . CRLF .
+				"Transfer-Encoding: chunked" . CRLF .
+				"Content-Length: 100" . CRLF .
+				CRLF .
+				"unfinished" . CRLF;
+			close($client);
+		}
+	}
+}
+
+###############################################################################
diff --git a/tests/js_variables.t b/tests/js_variables.t
new file mode 100644
index 0000000..2e9f6e3
--- /dev/null
+++ b/tests/js_variables.t
@@ -0,0 +1,101 @@
+#!/usr/bin/perl
+
+# (C) Dmitry Volyntsev
+# (C) Nginx, Inc.
+
+# Tests for http njs module, setting nginx variables.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http rewrite/)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    js_set $test_var   test_var;
+
+    js_include test.js;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        set $foo       foo_orig;
+
+        location /njs {
+            js_content test_njs;
+        }
+
+        location /var_set {
+            return 200 $test_var$foo;
+        }
+
+        location /content_set {
+            js_content content_set;
+        }
+
+        location /not_found_set {
+            js_content not_found_set;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('test.js', <<EOF);
+    function test_njs(r) {
+        r.return(200, njs.version);
+    }
+
+    function test_var(r) {
+        r.variables.foo = r.variables.arg_a;
+        return 'test_var';
+    }
+
+    function content_set(r) {
+        r.variables.foo = r.variables.arg_a;
+        r.return(200, r.variables.foo);
+    }
+
+    function not_found_set(r) {
+        try {
+            r.variables.unknown = 1;
+        } catch (e) {
+            r.return(500, e);
+        }
+    }
+
+EOF
+
+$t->try_run('no njs')->plan(3);
+
+###############################################################################
+
+like(http_get('/var_set?a=bar'), qr/test_varbar/, 'var set');
+like(http_get('/content_set?a=bar'), qr/bar/, 'content set');
+like(http_get('/not_found_set'), qr/variable not found/, 'not found exception');
+
+###############################################################################
diff --git a/tests/lib/Test/Nginx.pm b/tests/lib/Test/Nginx.pm
new file mode 100644
index 0000000..d2153da
--- /dev/null
+++ b/tests/lib/Test/Nginx.pm
@@ -0,0 +1,868 @@
+package Test::Nginx;
+
+# (C) Maxim Dounin
+
+# Generic module for nginx tests.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use base qw/ Exporter /;
+
+our @EXPORT = qw/ log_in log_out http http_get http_head port /;
+our @EXPORT_OK = qw/ http_gzip_request http_gzip_like http_start http_end /;
+our %EXPORT_TAGS = (
+	gzip => [ qw/ http_gzip_request http_gzip_like / ]
+);
+
+###############################################################################
+
+use File::Path qw/ rmtree /;
+use File::Spec qw//;
+use File::Temp qw/ tempdir /;
+use IO::Socket;
+use POSIX qw/ waitpid WNOHANG /;
+use Socket qw/ CRLF /;
+use Test::More qw//;
+
+###############################################################################
+
+our $NGINX = defined $ENV{TEST_NGINX_BINARY} ? $ENV{TEST_NGINX_BINARY}
+	: '../nginx/objs/nginx';
+our %ports = ();
+
+sub new {
+	my $self = {};
+	bless $self;
+
+	$self->{_pid} = $$;
+	$self->{_alerts} = 1;
+
+	$self->{_testdir} = tempdir(
+		'nginx-test-XXXXXXXXXX',
+		TMPDIR => 1
+	)
+		or die "Can't create temp directory: $!\n";
+	$self->{_testdir} =~ s!\\!/!g if $^O eq 'MSWin32';
+	mkdir "$self->{_testdir}/logs"
+		or die "Can't create logs directory: $!\n";
+
+	Test::More::BAIL_OUT("no $NGINX binary found")
+		unless -x $NGINX;
+
+	return $self;
+}
+
+sub DESTROY {
+	my ($self) = @_;
+	local $?;
+
+	return if $self->{_pid} != $$;
+
+	$self->stop();
+	$self->stop_daemons();
+
+	if (Test::More->builder->expected_tests) {
+		local $Test::Nginx::TODO = 'alerts' unless $self->{_alerts};
+
+		my @alerts = $self->read_file('error.log') =~ /.+\[alert\].+/gm;
+
+		if ($^O eq 'solaris') {
+			$Test::Nginx::TODO = 'alerts' if @alerts
+				&& ! grep { $_ !~ /phantom event/ } @alerts;
+		}
+		if ($^O eq 'MSWin32') {
+			my $re = qr/CloseHandle|TerminateProcess/;
+			$Test::Nginx::TODO = 'alerts' if @alerts
+				&& ! grep { $_ !~ $re } @alerts;
+		}
+
+		Test::More::is(join("\n", @alerts), '', 'no alerts');
+	}
+
+	if (Test::More->builder->expected_tests) {
+		local $Test::Nginx::TODO;
+		my $errors = $self->read_file('error.log');
+		$errors = join "\n", $errors =~ /.+Sanitizer.+/gm;
+		Test::More::is($errors, '', 'no sanitizer errors');
+	}
+
+	if ($ENV{TEST_NGINX_CATLOG}) {
+		system("cat $self->{_testdir}/error.log");
+	}
+	if (not $ENV{TEST_NGINX_LEAVE}) {
+		eval { rmtree($self->{_testdir}); };
+	}
+}
+
+sub has($;) {
+	my ($self, @features) = @_;
+
+	foreach my $feature (@features) {
+		Test::More::plan(skip_all => "no $feature available")
+			unless $self->has_module($feature)
+			or $self->has_feature($feature);
+	}
+
+	return $self;
+}
+
+sub has_module($) {
+	my ($self, $feature) = @_;
+
+	my %regex = (
+		sni	=> 'TLS SNI support enabled',
+		mail	=> '--with-mail((?!\S)|=dynamic)',
+		flv	=> '--with-http_flv_module',
+		perl	=> '--with-http_perl_module',
+		auth_request
+			=> '--with-http_auth_request_module',
+		realip	=> '--with-http_realip_module',
+		sub	=> '--with-http_sub_module',
+		charset	=> '(?s)^(?!.*--without-http_charset_module)',
+		gzip	=> '(?s)^(?!.*--without-http_gzip_module)',
+		ssi	=> '(?s)^(?!.*--without-http_ssi_module)',
+		mirror	=> '(?s)^(?!.*--without-http_mirror_module)',
+		userid	=> '(?s)^(?!.*--without-http_userid_module)',
+		access	=> '(?s)^(?!.*--without-http_access_module)',
+		auth_basic
+			=> '(?s)^(?!.*--without-http_auth_basic_module)',
+		autoindex
+			=> '(?s)^(?!.*--without-http_autoindex_module)',
+		geo	=> '(?s)^(?!.*--without-http_geo_module)',
+		map	=> '(?s)^(?!.*--without-http_map_module)',
+		referer	=> '(?s)^(?!.*--without-http_referer_module)',
+		rewrite	=> '(?s)^(?!.*--without-http_rewrite_module)',
+		proxy	=> '(?s)^(?!.*--without-http_proxy_module)',
+		fastcgi	=> '(?s)^(?!.*--without-http_fastcgi_module)',
+		uwsgi	=> '(?s)^(?!.*--without-http_uwsgi_module)',
+		scgi	=> '(?s)^(?!.*--without-http_scgi_module)',
+		grpc	=> '(?s)^(?!.*--without-http_grpc_module)',
+		memcached
+			=> '(?s)^(?!.*--without-http_memcached_module)',
+		limit_conn
+			=> '(?s)^(?!.*--without-http_limit_conn_module)',
+		limit_req
+			=> '(?s)^(?!.*--without-http_limit_req_module)',
+		empty_gif
+			=> '(?s)^(?!.*--without-http_empty_gif_module)',
+		browser	=> '(?s)^(?!.*--without-http_browser_module)',
+		upstream_hash
+			=> '(?s)^(?!.*--without-http_upstream_hash_module)',
+		upstream_ip_hash
+			=> '(?s)^(?!.*--without-http_upstream_ip_hash_module)',
+		upstream_least_conn
+			=> '(?s)^(?!.*--without-http_upstream_least_conn_mod)',
+		upstream_random
+			=> '(?s)^(?!.*--without-http_upstream_random_module)',
+		upstream_keepalive
+			=> '(?s)^(?!.*--without-http_upstream_keepalive_modu)',
+		upstream_zone
+			=> '(?s)^(?!.*--without-http_upstream_zone_module)',
+		http	=> '(?s)^(?!.*--without-http(?!\S))',
+		cache	=> '(?s)^(?!.*--without-http-cache)',
+		pop3	=> '(?s)^(?!.*--without-mail_pop3_module)',
+		imap	=> '(?s)^(?!.*--without-mail_imap_module)',
+		smtp	=> '(?s)^(?!.*--without-mail_smtp_module)',
+		pcre	=> '(?s)^(?!.*--without-pcre)',
+		split_clients
+			=> '(?s)^(?!.*--without-http_split_clients_module)',
+		stream	=> '--with-stream((?!\S)|=dynamic)',
+		stream_access
+			=> '(?s)^(?!.*--without-stream_access_module)',
+		stream_geo
+			=> '(?s)^(?!.*--without-stream_geo_module)',
+		stream_limit_conn
+			=> '(?s)^(?!.*--without-stream_limit_conn_module)',
+		stream_map
+			=> '(?s)^(?!.*--without-stream_map_module)',
+		stream_return
+			=> '(?s)^(?!.*--without-stream_return_module)',
+		stream_split_clients
+			=> '(?s)^(?!.*--without-stream_split_clients_module)',
+		stream_ssl
+			=> '--with-stream_ssl_module',
+		stream_upstream_hash
+			=> '(?s)^(?!.*--without-stream_upstream_hash_module)',
+		stream_upstream_least_conn
+			=> '(?s)^(?!.*--without-stream_upstream_least_conn_m)',
+		stream_upstream_random
+			=> '(?s)^(?!.*--without-stream_upstream_random_modul)',
+		stream_upstream_zone
+			=> '(?s)^(?!.*--without-stream_upstream_zone_module)',
+	);
+
+	my $re = $regex{$feature};
+	$re = $feature if !defined $re;
+
+	$self->{_configure_args} = `$NGINX -V 2>&1`
+		if !defined $self->{_configure_args};
+
+	return 1 if $self->{_configure_args} =~ $re;
+
+	my %modules = (
+		http_geoip
+			=> 'ngx_http_geoip_module',
+		image_filter
+			=> 'ngx_http_image_filter_module',
+		perl	=> 'ngx_http_perl_module',
+		xslt	=> 'ngx_http_xslt_filter_module',
+		mail	=> 'ngx_mail_module',
+		stream	=> 'ngx_stream_module',
+		stream_geoip
+			=> 'ngx_stream_geoip_module',
+	);
+
+	my $module = $modules{$feature};
+	if (defined $module && defined $ENV{TEST_NGINX_GLOBALS}) {
+		$re = qr/load_module\s+[^;]*\Q$module\E[-\w]*\.so\s*;/;
+		return 1 if $ENV{TEST_NGINX_GLOBALS} =~ $re;
+	}
+
+	return 0;
+}
+
+sub has_feature($) {
+	my ($self, $feature) = @_;
+
+	if ($feature eq 'symlink') {
+		return $^O ne 'MSWin32';
+	}
+
+	if ($feature eq 'unix') {
+		return $^O ne 'MSWin32';
+	}
+
+	if ($feature eq 'udp') {
+		return $^O ne 'MSWin32';
+	}
+
+	return 0;
+}
+
+sub has_version($) {
+	my ($self, $need) = @_;
+
+	$self->{_configure_args} = `$NGINX -V 2>&1`
+		if !defined $self->{_configure_args};
+
+	$self->{_configure_args} =~ m!nginx version: nginx/([0-9.]+)!;
+
+	my @v = split(/\./, $1);
+	my ($n, $v);
+
+	for $n (split(/\./, $need)) {
+		$v = shift @v || 0;
+		return 0 if $n > $v;
+		return 1 if $v > $n;
+	}
+
+	return 1;
+}
+
+sub has_daemon($) {
+	my ($self, $daemon) = @_;
+
+	if ($^O eq 'MSWin32') {
+		`for %i in ($daemon.exe) do \@echo | set /p x=%~\$PATH:i`
+			or Test::More::plan(skip_all => "$daemon not found");
+		return $self;
+	}
+
+	if ($^O eq 'solaris') {
+		Test::More::plan(skip_all => "$daemon not found")
+			unless `command -v $daemon`;
+		return $self;
+	}
+
+	Test::More::plan(skip_all => "$daemon not found")
+		unless `which $daemon`;
+
+	return $self;
+}
+
+sub try_run($$) {
+	my ($self, $message) = @_;
+
+	eval {
+		open OLDERR, ">&", \*STDERR; close STDERR;
+		$self->run();
+		open STDERR, ">&", \*OLDERR;
+	};
+
+	return $self unless $@;
+
+	if ($ENV{TEST_NGINX_VERBOSE}) {
+		my $path = $self->{_configure_args} =~ m!--error-log-path=(\S+)!
+			? $1 : 'logs/error.log';
+		$path = "$self->{_testdir}/$path" if index($path, '/');
+
+		open F, '<', $path or die "Can't open $path: $!";
+		log_core($_) while (<F>);
+		close F;
+	}
+
+	Test::More::plan(skip_all => $message);
+	return $self;
+}
+
+sub plan($) {
+	my ($self, $plan) = @_;
+
+	Test::More::plan(tests => $plan + 2);
+
+	return $self;
+}
+
+sub todo_alerts() {
+	my ($self) = @_;
+
+	$self->{_alerts} = 0;
+
+	return $self;
+}
+
+sub run(;$) {
+	my ($self, $conf) = @_;
+
+	my $testdir = $self->{_testdir};
+
+	if (defined $conf) {
+		my $c = `cat $conf`;
+		$self->write_file_expand('nginx.conf', $c);
+	}
+
+	my $pid = fork();
+	die "Unable to fork(): $!\n" unless defined $pid;
+
+	if ($pid == 0) {
+		my @globals = $self->{_test_globals} ?
+			() : ('-g', "pid $testdir/nginx.pid; "
+			. "error_log $testdir/error.log debug;");
+		exec($NGINX, '-p', "$testdir/", '-c', 'nginx.conf', @globals),
+			or die "Unable to exec(): $!\n";
+	}
+
+	# wait for nginx to start
+
+	$self->waitforfile("$testdir/nginx.pid", $pid)
+		or die "Can't start nginx";
+
+	for (1 .. 50) {
+		last if $^O ne 'MSWin32';
+		last if $self->read_file('error.log') =~ /create thread/;
+		select undef, undef, undef, 0.1;
+	}
+
+	$self->{_started} = 1;
+	return $self;
+}
+
+sub port {
+	my ($num, %opts) = @_;
+	my ($sock, $lock, $port);
+
+	goto done if defined $ports{$num};
+
+	my $socket = sub {
+		IO::Socket::INET->new(
+			Proto => 'tcp',
+			LocalAddr => '127.0.0.1:' . shift,
+			Listen => 1,
+			Reuse => ($^O ne 'MSWin32'),
+		);
+	};
+
+	my $socketl = sub {
+		IO::Socket::INET->new(
+			Proto => 'udp',
+			LocalAddr => '127.0.0.1:' . shift,
+		);
+	};
+
+	($socket, $socketl) = ($socketl, $socket) if $opts{udp};
+
+	$port = $num;
+
+	for (1 .. 10) {
+		$port = int($port / 500) * 500 + int(rand(500)) unless $_ == 1;
+
+		$lock = $socketl->($port) or next;
+		$sock = $socket->($port) and last;
+	}
+
+	die "Port limit exceeded" unless defined $lock and defined $sock;
+
+	$ports{$num} = {
+		port => $port,
+		socket => $lock
+	};
+
+done:
+	return $ports{$num}{socket} if $opts{socket};
+	return $ports{$num}{port};
+}
+
+sub dump_config() {
+	my ($self) = @_;
+
+	my $testdir = $self->{_testdir};
+
+	my @globals = $self->{_test_globals} ?
+		() : ('-g', "pid $testdir/nginx.pid; "
+		. "error_log $testdir/error.log debug;");
+	my $command = "$NGINX -T -p $testdir/ -c nginx.conf "
+		. join(' ', @globals);
+
+	return qx/$command 2>&1/;
+}
+
+sub waitforfile($;$) {
+	my ($self, $file, $pid) = @_;
+	my $exited;
+
+	# wait for file to appear
+	# or specified process to exit
+
+	for (1 .. 50) {
+		return 1 if -e $file;
+		return 0 if $exited;
+		$exited = waitpid($pid, WNOHANG) != 0 if $pid;
+		select undef, undef, undef, 0.1;
+	}
+
+	return undef;
+}
+
+sub waitforsocket($) {
+	my ($self, $peer) = @_;
+
+	# wait for socket to accept connections
+
+	for (1 .. 50) {
+		my $s = IO::Socket::INET->new(
+			Proto => 'tcp',
+			PeerAddr => $peer
+		);
+
+		return 1 if defined $s;
+
+		select undef, undef, undef, 0.1;
+	}
+
+	return undef;
+}
+
+sub reload() {
+	my ($self) = @_;
+
+	return $self unless $self->{_started};
+
+	my $pid = $self->read_file('nginx.pid');
+
+	if ($^O eq 'MSWin32') {
+		my $testdir = $self->{_testdir};
+		my @globals = $self->{_test_globals} ?
+			() : ('-g', "pid $testdir/nginx.pid; "
+			. "error_log $testdir/error.log debug;");
+		system($NGINX, '-p', $testdir, '-c', "nginx.conf",
+			'-s', 'reload', @globals) == 0
+			or die "system() failed: $?\n";
+
+	} else {
+		kill 'HUP', $pid;
+	}
+
+	return $self;
+}
+
+sub stop() {
+	my ($self) = @_;
+
+	return $self unless $self->{_started};
+
+	my $pid = $self->read_file('nginx.pid');
+
+	if ($^O eq 'MSWin32') {
+		my $testdir = $self->{_testdir};
+		my @globals = $self->{_test_globals} ?
+			() : ('-g', "pid $testdir/nginx.pid; "
+			. "error_log $testdir/error.log debug;");
+		system($NGINX, '-p', $testdir, '-c', "nginx.conf",
+			'-s', 'stop', @globals) == 0
+			or die "system() failed: $?\n";
+
+	} else {
+		kill 'QUIT', $pid;
+	}
+
+	waitpid($pid, 0);
+
+	$self->{_started} = 0;
+
+	return $self;
+}
+
+sub stop_daemons() {
+	my ($self) = @_;
+
+	while ($self->{_daemons} && scalar @{$self->{_daemons}}) {
+		my $p = shift @{$self->{_daemons}};
+		kill $^O eq 'MSWin32' ? 9 : 'TERM', $p;
+		waitpid($p, 0);
+	}
+
+	return $self;
+}
+
+sub read_file($) {
+	my ($self, $name) = @_;
+	local $/;
+
+	open F, '<', $self->{_testdir} . '/' . $name
+		or die "Can't open $name: $!";
+	my $content = <F>;
+	close F;
+
+	return $content;
+}
+
+sub write_file($$) {
+	my ($self, $name, $content) = @_;
+
+	open F, '>' . $self->{_testdir} . '/' . $name
+		or die "Can't create $name: $!";
+	binmode F;
+	print F $content;
+	close F;
+
+	return $self;
+}
+
+sub write_file_expand($$) {
+	my ($self, $name, $content) = @_;
+
+	$content =~ s/%%TEST_GLOBALS%%/$self->test_globals()/gmse;
+	$content =~ s/%%TEST_GLOBALS_HTTP%%/$self->test_globals_http()/gmse;
+	$content =~ s/%%TESTDIR%%/$self->{_testdir}/gms;
+
+	$content =~ s/127\.0\.0\.1:(8\d\d\d)/'127.0.0.1:' . port($1)/gmse;
+
+	$content =~ s/%%PORT_(\d+)%%/port($1)/gmse;
+	$content =~ s/%%PORT_(\d+)_UDP%%/port($1, udp => 1)/gmse;
+
+	return $self->write_file($name, $content);
+}
+
+sub run_daemon($;@) {
+	my ($self, $code, @args) = @_;
+
+	my $pid = fork();
+	die "Can't fork daemon: $!\n" unless defined $pid;
+
+	if ($pid == 0) {
+		if (ref($code) eq 'CODE') {
+			$code->(@args);
+			exit 0;
+		} else {
+			exec($code, @args);
+			exit 0;
+		}
+	}
+
+	$self->{_daemons} = [] unless defined $self->{_daemons};
+	push @{$self->{_daemons}}, $pid;
+
+	return $self;
+}
+
+sub testdir() {
+	my ($self) = @_;
+	return $self->{_testdir};
+}
+
+sub test_globals() {
+	my ($self) = @_;
+
+	return $self->{_test_globals}
+		if defined $self->{_test_globals};
+
+	my $s = '';
+
+	$s .= "user root;\n";
+	$s .= "pid $self->{_testdir}/nginx.pid;\n";
+	$s .= "error_log $self->{_testdir}/error.log debug;\n";
+
+	$s .= $ENV{TEST_NGINX_GLOBALS}
+		if $ENV{TEST_NGINX_GLOBALS};
+
+	$s .= $self->test_globals_modules();
+	$s .= $self->test_globals_perl5lib() if $s !~ /env PERL5LIB/;
+
+	$self->{_test_globals} = $s;
+}
+
+sub test_globals_modules() {
+	my ($self) = @_;
+
+	my $modules = $ENV{TEST_NGINX_MODULES};
+
+	if (!defined $modules) {
+		my ($volume, $dir) = File::Spec->splitpath($NGINX);
+		$modules = File::Spec->catpath($volume, $dir, '');
+	}
+
+	$modules = File::Spec->rel2abs($modules);
+	$modules =~ s!\\!/!g if $^O eq 'MSWin32';
+
+	my $s = '';
+
+	$s .= "load_module $modules/ngx_http_geoip_module.so;\n"
+		if $self->has_module('http_geoip\S+=dynamic');
+
+	$s .= "load_module $modules/ngx_http_image_filter_module.so;\n"
+		if $self->has_module('image_filter\S+=dynamic');
+
+	$s .= "load_module $modules/ngx_http_perl_module.so;\n"
+		if $self->has_module('perl\S+=dynamic');
+
+	$s .= "load_module $modules/ngx_http_xslt_filter_module.so;\n"
+		if $self->has_module('xslt\S+=dynamic');
+
+	$s .= "load_module $modules/ngx_mail_module.so;\n"
+		if $self->has_module('mail=dynamic');
+
+	$s .= "load_module $modules/ngx_stream_module.so;\n"
+		if $self->has_module('stream=dynamic');
+
+	$s .= "load_module $modules/ngx_stream_geoip_module.so;\n"
+		if $self->has_module('stream_geoip\S+=dynamic');
+
+	return $s;
+}
+
+sub test_globals_perl5lib() {
+	my ($self) = @_;
+
+	return '' unless $self->has_module('perl');
+
+	my ($volume, $dir) = File::Spec->splitpath($NGINX);
+	my $objs = File::Spec->catpath($volume, $dir, '');
+
+	$objs = File::Spec->rel2abs($objs);
+	$objs =~ s!\\!/!g if $^O eq 'MSWin32';
+
+	return "env PERL5LIB=$objs/src/http/modules/perl:"
+		. "$objs/src/http/modules/perl/blib/arch;\n";
+}
+
+sub test_globals_http() {
+	my ($self) = @_;
+
+	return $self->{_test_globals_http}
+		if defined $self->{_test_globals_http};
+
+	my $s = '';
+
+	$s .= "root $self->{_testdir};\n";
+	$s .= "access_log $self->{_testdir}/access.log;\n";
+	$s .= "client_body_temp_path $self->{_testdir}/client_body_temp;\n";
+
+	$s .= "fastcgi_temp_path $self->{_testdir}/fastcgi_temp;\n"
+		if $self->has_module('fastcgi');
+
+	$s .= "proxy_temp_path $self->{_testdir}/proxy_temp;\n"
+		if $self->has_module('proxy');
+
+	$s .= "uwsgi_temp_path $self->{_testdir}/uwsgi_temp;\n"
+		if $self->has_module('uwsgi');
+
+	$s .= "scgi_temp_path $self->{_testdir}/scgi_temp;\n"
+		if $self->has_module('scgi');
+
+	$s .= $ENV{TEST_NGINX_GLOBALS_HTTP}
+		if $ENV{TEST_NGINX_GLOBALS_HTTP};
+
+	$self->{_test_globals_http} = $s;
+}
+
+###############################################################################
+
+sub log_core {
+	return unless $ENV{TEST_NGINX_VERBOSE};
+	my ($prefix, $msg) = @_;
+	($prefix, $msg) = ('', $prefix) unless defined $msg;
+	$prefix .= ' ' if length($prefix) > 0;
+
+	if (length($msg) > 2048) {
+		$msg = substr($msg, 0, 2048)
+			. "(...logged only 2048 of " . length($msg)
+			. " bytes)";
+	}
+
+	$msg =~ s/^/# $prefix/gm;
+	$msg =~ s/([^\x20-\x7e])/sprintf('\\x%02x', ord($1)) . (($1 eq "\n") ? "\n" : '')/gmxe;
+	$msg .= "\n" unless $msg =~ /\n\Z/;
+	print $msg;
+}
+
+sub log_out {
+	log_core('>>', @_);
+}
+
+sub log_in {
+	log_core('<<', @_);
+}
+
+###############################################################################
+
+sub http_get($;%) {
+	my ($url, %extra) = @_;
+	return http(<<EOF, %extra);
+GET $url HTTP/1.0
+Host: localhost
+
+EOF
+}
+
+sub http_head($;%) {
+	my ($url, %extra) = @_;
+	return http(<<EOF, %extra);
+HEAD $url HTTP/1.0
+Host: localhost
+
+EOF
+}
+
+sub http($;%) {
+	my ($request, %extra) = @_;
+
+	my $s = http_start($request, %extra);
+
+	return $s if $extra{start} or !defined $s;
+	return http_end($s);
+}
+
+sub http_start($;%) {
+	my ($request, %extra) = @_;
+	my $s;
+
+	eval {
+		local $SIG{ALRM} = sub { die "timeout\n" };
+		local $SIG{PIPE} = sub { die "sigpipe\n" };
+		alarm(8);
+
+		$s = $extra{socket} || IO::Socket::INET->new(
+			Proto => 'tcp',
+			PeerAddr => '127.0.0.1:' . port(8080)
+		)
+			or die "Can't connect to nginx: $!\n";
+
+		log_out($request);
+		$s->print($request);
+
+		select undef, undef, undef, $extra{sleep} if $extra{sleep};
+		return '' if $extra{aborted};
+
+		if ($extra{body}) {
+			log_out($extra{body});
+			$s->print($extra{body});
+		}
+
+		alarm(0);
+	};
+	alarm(0);
+	if ($@) {
+		log_in("died: $@");
+		return undef;
+	}
+
+	return $s;
+}
+
+sub http_end($;%) {
+	my ($s) = @_;
+	my $reply;
+
+	eval {
+		local $SIG{ALRM} = sub { die "timeout\n" };
+		local $SIG{PIPE} = sub { die "sigpipe\n" };
+		alarm(8);
+
+		local $/;
+		$reply = $s->getline();
+
+		alarm(0);
+	};
+	alarm(0);
+	if ($@) {
+		log_in("died: $@");
+		return undef;
+	}
+
+	log_in($reply);
+	return $reply;
+}
+
+###############################################################################
+
+sub http_gzip_request {
+	my ($url) = @_;
+	my $r = http(<<EOF);
+GET $url HTTP/1.1
+Host: localhost
+Connection: close
+Accept-Encoding: gzip
+
+EOF
+}
+
+sub http_content {
+	my ($text) = @_;
+
+	return undef if !defined $text;
+
+	if ($text !~ /(.*?)\x0d\x0a?\x0d\x0a?(.*)/ms) {
+		return undef;
+	}
+
+	my ($headers, $body) = ($1, $2);
+
+	if ($headers !~ /Transfer-Encoding: chunked/i) {
+		return $body;
+	}
+
+	my $content = '';
+	while ($body =~ /\G\x0d?\x0a?([0-9a-f]+)\x0d\x0a?/gcmsi) {
+		my $len = hex($1);
+		$content .= substr($body, pos($body), $len);
+		pos($body) += $len;
+	}
+
+	return $content;
+}
+
+sub http_gzip_like {
+	my ($text, $re, $name) = @_;
+
+	SKIP: {
+		eval { require IO::Uncompress::Gunzip; };
+		Test::More::skip(
+			"IO::Uncompress::Gunzip not installed", 1) if $@;
+
+		my $in = http_content($text);
+		my $out;
+
+		IO::Uncompress::Gunzip::gunzip(\$in => \$out);
+
+		Test::More->builder->like($out, $re, $name);
+	}
+}
+
+###############################################################################
+
+1;
+
+###############################################################################
diff --git a/tests/lib/Test/Nginx/HTTP2.pm b/tests/lib/Test/Nginx/HTTP2.pm
new file mode 100644
index 0000000..2a7f0a6
--- /dev/null
+++ b/tests/lib/Test/Nginx/HTTP2.pm
@@ -0,0 +1,1103 @@
+package Test::Nginx::HTTP2;
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Module for nginx HTTP/2 tests.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More qw//;
+use IO::Select;
+use IO::Socket;
+use Socket qw/ CRLF /;
+use Data::Dumper;
+
+use Test::Nginx;
+
+my %cframe = (
+	0 => { name => 'DATA', value => \&data },
+	1 => { name => 'HEADERS', value => \&headers },
+#	2 => { name => 'PRIORITY', value => \&priority },
+	3 => { name => 'RST_STREAM', value => \&rst_stream },
+	4 => { name => 'SETTINGS', value => \&settings },
+	5 => { name => 'PUSH_PROMISE', value => \&push_promise },
+	6 => { name => 'PING', value => \&ping },
+	7 => { name => 'GOAWAY', value => \&goaway },
+	8 => { name => 'WINDOW_UPDATE', value => \&window_update },
+	9 => { name => 'CONTINUATION', value => \&continuation },
+);
+
+sub new {
+	my $class = shift;
+	my ($port, %extra) = @_;
+
+	my $s = $extra{socket} || new_socket($port, %extra);
+	my $preface = defined $extra{preface} ? $extra{preface}
+		: 'PRI * HTTP/2.0' . CRLF . CRLF . 'SM' . CRLF . CRLF;
+
+	if ($extra{proxy}) {
+		raw_write($s, $extra{proxy});
+	}
+
+	# preface
+
+	raw_write($s, $preface);
+
+	my $self = bless {
+		socket => $s, last_stream => -1,
+		dynamic_encode => [ static_table() ],
+		dynamic_decode => [ static_table() ],
+		static_table_size => scalar @{[static_table()]},
+		iws => 65535, conn_window => 65535, streams => {}
+	}, $class;
+
+	return $self if $extra{pure};
+
+	# update windows, if any
+
+	my $frames = $self->read(all => [
+		{ type => 'WINDOW_UPDATE' },
+		{ type => 'SETTINGS'}
+	]);
+
+	# 6.5.3.  Settings Synchronization
+
+	if (grep { $_->{type} eq "SETTINGS" && $_->{flags} == 0 } @$frames) {
+		$self->h2_settings(1);
+	}
+
+	return $self;
+}
+
+sub h2_ping {
+	my ($self, $payload) = @_;
+
+	raw_write($self->{socket}, pack("x2C2x5a8", 8, 0x6, $payload));
+}
+
+sub h2_rst {
+	my ($self, $stream, $error) = @_;
+
+	raw_write($self->{socket}, pack("x2C2xNN", 4, 0x3, $stream, $error));
+}
+
+sub h2_goaway {
+	my ($self, $stream, $lstream, $err, $debug, %extra) = @_;
+	$debug = '' unless defined $debug;
+	my $len = defined $extra{len} ? $extra{len} : 8 + length($debug);
+	my $buf = pack("x2C2xN3A*", $len, 0x7, $stream, $lstream, $err, $debug);
+
+	my @bufs = map {
+		raw_write($self->{socket}, substr $buf, 0, $_, "");
+		select undef, undef, undef, 0.2;
+	} @{$extra{split}};
+
+	raw_write($self->{socket}, $buf);
+}
+
+sub h2_priority {
+	my ($self, $w, $stream, $dep, %extra) = @_;
+
+	$stream = 0 unless defined $stream;
+	$dep = 0 unless defined $dep;
+	$dep |= $extra{excl} << 31 if exists $extra{excl};
+	raw_write($self->{socket}, pack("x2C2xNNC", 5, 0x2, $stream, $dep, $w));
+}
+
+sub h2_window {
+	my ($self, $win, $stream) = @_;
+
+	$stream = 0 unless defined $stream;
+	raw_write($self->{socket}, pack("x2C2xNN", 4, 0x8, $stream, $win));
+}
+
+sub h2_settings {
+	my ($self, $ack, @pairs) = @_;
+
+	my $len = 6 * @pairs / 2;
+	my $buf = pack_length($len) . pack "CCx4", 0x4, $ack ? 0x1 : 0x0;
+	$buf .= pack "nN", splice @pairs, 0, 2 while @pairs;
+	raw_write($self->{socket}, $buf);
+}
+
+sub h2_unknown {
+	my ($self, $payload) = @_;
+
+	my $buf = pack_length(length($payload)) . pack("Cx5a*", 0xa, $payload);
+	raw_write($self->{socket}, $buf);
+}
+
+sub h2_continue {
+	my ($ctx, $stream, $uri) = @_;
+
+	$uri->{h2_continue} = 1;
+	return new_stream($ctx, $uri, $stream);
+}
+
+sub h2_body {
+	my ($self, $body, $extra) = @_;
+	$extra = {} unless defined $extra;
+
+	my $len = length $body;
+	my $sid = $self->{last_stream};
+
+	if ($len > $self->{conn_window} || $len > $self->{streams}{$sid}) {
+		$self->read(all => [{ type => 'WINDOW_UPDATE' }]);
+	}
+
+	if ($len > $self->{conn_window} || $len > $self->{streams}{$sid}) {
+		return;
+	}
+
+	$self->{conn_window} -= $len;
+	$self->{streams}{$sid} -= $len;
+
+	my $buf;
+
+	my $split = ref $extra->{body_split} && $extra->{body_split} || [];
+	for (@$split) {
+		$buf .= pack_body($self, substr($body, 0, $_, ""), 0x0, $extra);
+	}
+
+	$buf .= pack_body($self, $body, 0x1, $extra) if defined $body;
+
+	$split = ref $extra->{split} && $extra->{split} || [];
+	for (@$split) {
+		raw_write($self->{socket}, substr($buf, 0, $_, ""));
+		return if $extra->{abort};
+		select undef, undef, undef, ($extra->{split_delay} || 0.2);
+	}
+
+	raw_write($self->{socket}, $buf);
+}
+
+sub new_stream {
+	my ($self, $uri, $stream) = @_;
+	my ($input, $buf);
+	my ($d, $status);
+
+	$self->{headers} = '';
+
+	my $host = $uri->{host} || 'localhost';
+	my $method = $uri->{method} || 'GET';
+	my $scheme = $uri->{scheme} || 'http';
+	my $path = $uri->{path} || '/';
+	my $headers = $uri->{headers};
+	my $body = $uri->{body};
+	my $prio = $uri->{prio};
+	my $dep = $uri->{dep};
+
+	my $pad = defined $uri->{padding} ? $uri->{padding} : 0;
+	my $padlen = defined $uri->{padding} ? 1 : 0;
+
+	my $type = defined $uri->{h2_continue} ? 0x9 : 0x1;
+	my $flags = defined $uri->{continuation} ? 0x0 : 0x4;
+	$flags |= 0x1 unless defined $body || defined $uri->{body_more}
+		|| defined $uri->{h2_continue};
+	$flags |= 0x8 if $padlen;
+	$flags |= 0x20 if defined $dep || defined $prio;
+
+	if ($stream) {
+		$self->{last_stream} = $stream;
+	} else {
+		$self->{last_stream} += 2;
+	}
+	$self->{streams}{$self->{last_stream}} = $self->{iws};
+
+	$buf = pack("xxx");				# Length stub
+	$buf .= pack("CC", $type, $flags);		# END_HEADERS
+	$buf .= pack("N", $self->{last_stream});	# Stream-ID
+
+	$dep = 0 if defined $prio and not defined $dep;
+	$prio = 16 if defined $dep and not defined $prio;
+
+	unless ($headers) {
+		$input = hpack($self, ":method", $method);
+		$input .= hpack($self, ":scheme", $scheme);
+		$input .= hpack($self, ":path", $path);
+		$input .= hpack($self, ":authority", $host);
+		$input .= hpack($self, "content-length", length($body))
+			if $body;
+
+	} else {
+		$input = join '', map {
+			hpack($self, $_->{name}, $_->{value},
+			mode => $_->{mode}, huff => $_->{huff})
+		} @$headers if $headers;
+	}
+
+	$input = pack("B*", '001' . ipack(5, $uri->{table_size})) . $input
+		if defined $uri->{table_size};
+
+	my $split = ref $uri->{continuation} && $uri->{continuation} || [];
+	my @input = map { substr $input, 0, $_, "" } @$split;
+	push @input, $input;
+
+	# set length, attach headers, padding, priority
+
+	my $hlen = length($input[0]) + $pad + $padlen;
+	$hlen += 5 if $flags & 0x20;
+	$buf |= pack_length($hlen);
+
+	$buf .= pack 'C', $pad if $padlen;		# Pad Length?
+	$buf .= pack 'NC', $dep, $prio if $flags & 0x20;
+	$buf .= $input[0];
+	$buf .= (pack 'C', 0) x $pad if $padlen;	# Padding
+
+	shift @input;
+
+	while (@input) {
+		$input = shift @input;
+		$flags = @input ? 0x0 : 0x4;
+		$buf .= pack_length(length($input));
+		$buf .= pack("CC", 0x9, $flags);
+		$buf .= pack("N", $self->{last_stream});
+		$buf .= $input;
+	}
+
+	$split = ref $uri->{body_split} && $uri->{body_split} || [];
+	for (@$split) {
+		$buf .= pack_body($self, substr($body, 0, $_, ""), 0x0, $uri);
+	}
+
+	$buf .= pack_body($self, $body, 0x1, $uri) if defined $body;
+
+	$split = ref $uri->{split} && $uri->{split} || [];
+	for (@$split) {
+		raw_write($self->{socket}, substr($buf, 0, $_, ""));
+		goto done if $uri->{abort};
+		select undef, undef, undef, ($uri->{split_delay} || 0.2);
+	}
+
+	raw_write($self->{socket}, $buf);
+done:
+	return $self->{last_stream};
+}
+
+sub read {
+	my ($self, %extra) = @_;
+	my (@got);
+	my $s = $self->{socket};
+	my $buf = '';
+	my $wait = $extra{wait};
+
+	local $Data::Dumper::Terse = 1;
+
+	while (1) {
+		$buf = raw_read($s, $buf, 9, $wait);
+		last if length $buf < 9;
+
+		my $length = unpack_length($buf);
+		my $type = unpack('x3C', $buf);
+		my $flags = unpack('x4C', $buf);
+
+		my $stream = unpack "x5 B32", $buf;
+		substr($stream, 0, 1) = 0;
+		$stream = unpack("N", pack("B32", $stream));
+
+		$buf = raw_read($s, $buf, $length + 9, $wait);
+		last if length($buf) < $length + 9;
+
+		$buf = substr($buf, 9);
+
+		my $frame = $cframe{$type}{value}($self, $buf, $length, $flags,
+			$stream);
+		$frame->{length} = $length;
+		$frame->{type} = $cframe{$type}{name};
+		$frame->{flags} = $flags;
+		$frame->{sid} = $stream;
+		push @got, $frame;
+
+		Test::Nginx::log_core('||', $_) for split "\n", Dumper $frame;
+
+		$buf = substr($buf, $length);
+
+		last unless $extra{all} && test_fin($got[-1], $extra{all});
+	};
+	return \@got;
+}
+
+###############################################################################
+
+sub pack_body {
+	my ($ctx, $body, $flags, $extra) = @_;
+
+	my $pad = defined $extra->{body_padding} ? $extra->{body_padding} : 0;
+	my $padlen = defined $extra->{body_padding} ? 1 : 0;
+
+	my $buf = pack_length(length($body) + $pad + $padlen);
+	$flags |= 0x8 if $padlen;
+	vec($flags, 0, 1) = 0 if $extra->{body_more};
+	$buf .= pack 'CC', 0x0, $flags;		# DATA, END_STREAM
+	$buf .= pack 'N', $ctx->{last_stream};
+	$buf .= pack 'C', $pad if $padlen;	# DATA Pad Length?
+	$buf .= $body;
+	$buf .= pack "x$pad" if $padlen;	# DATA Padding
+	return $buf;
+}
+
+sub test_fin {
+	my ($frame, $all) = @_;
+	my @test = @{$all};
+
+	# wait for the specified DATA length
+
+	for (@test) {
+		if ($_->{length} && $frame->{type} eq 'DATA') {
+			# check also for StreamID if needed
+
+			if (!$_->{sid} || $_->{sid} == $frame->{sid}) {
+				$_->{length} -= $frame->{length};
+			}
+		}
+	}
+	@test = grep { !(defined $_->{length} && $_->{length} == 0) } @test;
+
+	# wait for the fin flag
+
+	@test = grep { !(defined $_->{fin}
+		&& (!defined $_->{sid} || $_->{sid} == $frame->{sid})
+		&& $_->{fin} & $frame->{flags})
+	} @test if defined $frame->{flags};
+
+	# wait for the specified frame
+
+	@test = grep { !($_->{type} && $_->{type} eq $frame->{type}) } @test;
+
+	@{$all} = @test;
+}
+
+sub headers {
+	my ($ctx, $buf, $len, $flags) = @_;
+	$ctx->{headers} = substr($buf, 0, $len);
+	return unless $flags & 0x4;
+	{ headers => hunpack($ctx, $buf, $len) };
+}
+
+sub continuation {
+	my ($ctx, $buf, $len, $flags) = @_;
+	$ctx->{headers} .= substr($buf, 0, $len);
+	return unless $flags & 0x4;
+	{ headers => hunpack($ctx, $ctx->{headers}, length($ctx->{headers})) };
+}
+
+sub data {
+	my ($ctx, $buf, $len) = @_;
+	return { data => substr($buf, 0, $len) };
+}
+
+sub settings {
+	my ($ctx, $buf, $len) = @_;
+	my %payload;
+	my $skip = 0;
+
+	for (1 .. $len / 6) {
+		my $id = hex unpack "\@$skip n", $buf; $skip += 2;
+		$payload{$id} = unpack "\@$skip N", $buf; $skip += 4;
+
+		$ctx->{iws} = $payload{$id} if $id == 4;
+	}
+	return \%payload;
+}
+
+sub push_promise {
+	my ($ctx, $buf, $len, $flags) = @_;
+	$len -= 4;
+
+	{ promised => unpack("N", $buf),
+	  headers => hunpack($ctx, substr($buf, 4, $len), $len) };
+}
+
+sub ping {
+	my ($ctx, $buf, $len) = @_;
+	return { value => unpack "A$len", $buf };
+}
+
+sub rst_stream {
+	my ($ctx, $buf, $len) = @_;
+	return { code => unpack "N", $buf };
+}
+
+sub goaway {
+	my ($ctx, $buf, $len) = @_;
+	my %payload;
+
+	my $stream = unpack "B32", $buf;
+	substr($stream, 0, 1) = 0;
+	$stream = unpack("N", pack("B32", $stream));
+	$payload{last_sid} = $stream;
+
+	$len -= 4;
+	$payload{code} = unpack "x4 N", $buf;
+	$payload{debug} = unpack "x8 A$len", $buf;
+	return \%payload;
+}
+
+sub window_update {
+	my ($ctx, $buf, $len, $flags, $sid) = @_;
+	my $value = unpack "B32", $buf;
+	substr($value, 0, 1) = 0;
+	$value = unpack("N", pack("B32", $value));
+
+	unless ($sid) {
+		$ctx->{conn_window} += $value;
+
+	} else {
+		$ctx->{streams}{$sid} = $ctx->{iws}
+			unless defined $ctx->{streams}{$sid};
+		$ctx->{streams}{$sid} += $value;
+	}
+
+	return { wdelta => $value };
+}
+
+sub pack_length {
+	pack 'c3', unpack 'xc3', pack 'N', $_[0];
+}
+
+sub unpack_length {
+	unpack 'N', pack 'xc3', unpack 'c3', $_[0];
+}
+
+sub raw_read {
+	my ($s, $buf, $len, $timo) = @_;
+	$timo = 8 unless $timo;
+	my $got = '';
+
+	while (length($buf) < $len && IO::Select->new($s)->can_read($timo)) {
+		$s->sysread($got, 16384) or last;
+		log_in($got);
+		$buf .= $got;
+	}
+	return $buf;
+}
+
+sub raw_write {
+	my ($s, $message) = @_;
+
+	local $SIG{PIPE} = 'IGNORE';
+
+	while (IO::Select->new($s)->can_write(0.4)) {
+		log_out($message);
+		my $n = $s->syswrite($message);
+		last unless $n;
+		$message = substr($message, $n);
+		last unless length $message;
+	}
+}
+
+sub new_socket {
+	my ($port, %extra) = @_;
+	my $npn = $extra{'npn'};
+	my $alpn = $extra{'alpn'};
+	my $s;
+
+	$port ||= port(8080);
+
+	eval {
+		local $SIG{ALRM} = sub { die "timeout\n" };
+		local $SIG{PIPE} = sub { die "sigpipe\n" };
+		alarm(8);
+		$s = IO::Socket::INET->new(
+			Proto => 'tcp',
+			PeerAddr => "127.0.0.1:$port",
+		);
+		require IO::Socket::SSL if $extra{'SSL'};
+		IO::Socket::SSL->start_SSL($s,
+			SSL_verify_mode => IO::Socket::SSL::SSL_VERIFY_NONE(),
+			SSL_npn_protocols => $npn ? [ $npn ] : undef,
+			SSL_alpn_protocols => $alpn ? [ $alpn ] : undef,
+			SSL_error_trap => sub { die $_[1] }
+		) if $extra{'SSL'};
+		alarm(0);
+	};
+	alarm(0);
+
+	if ($@) {
+		log_in("died: $@");
+		return undef;
+	}
+
+	return $s;
+}
+
+sub static_table {
+	[ '',			''		], # unused
+	[ ':authority',		''		],
+	[ ':method',		'GET'		],
+	[ ':method',		'POST'		],
+	[ ':path',		'/'		],
+	[ ':path',		'/index.html'	],
+	[ ':scheme',		'http'		],
+	[ ':scheme',		'https'		],
+	[ ':status',		'200'		],
+	[ ':status',		'204'		],
+	[ ':status',		'206'		],
+	[ ':status',		'304'		],
+	[ ':status',		'400'		],
+	[ ':status',		'404'		],
+	[ ':status',		'500'		],
+	[ 'accept-charset',	''		],
+	[ 'accept-encoding',	'gzip, deflate'	],
+	[ 'accept-language',	''		],
+	[ 'accept-ranges',	''		],
+	[ 'accept',		''		],
+	[ 'access-control-allow-origin',
+				''		],
+	[ 'age',		''		],
+	[ 'allow',		''		],
+	[ 'authorization',	''		],
+	[ 'cache-control',	''		],
+	[ 'content-disposition',
+				''		],
+	[ 'content-encoding',	''		],
+	[ 'content-language',	''		],
+	[ 'content-length',	''		],
+	[ 'content-location',	''		],
+	[ 'content-range',	''		],
+	[ 'content-type',	''		],
+	[ 'cookie',		''		],
+	[ 'date',		''		],
+	[ 'etag',		''		],
+	[ 'expect',		''		],
+	[ 'expires',		''		],
+	[ 'from',		''		],
+	[ 'host',		''		],
+	[ 'if-match',		''		],
+	[ 'if-modified-since',	''		],
+	[ 'if-none-match',	''		],
+	[ 'if-range',		''		],
+	[ 'if-unmodified-since',
+				''		],
+	[ 'last-modified',	''		],
+	[ 'link',		''		],
+	[ 'location',		''		],
+	[ 'max-forwards',	''		],
+	[ 'proxy-authenticate',	''		],
+	[ 'proxy-authorization',
+				''		],
+	[ 'range',		''		],
+	[ 'referer',		''		],
+	[ 'refresh',		''		],
+	[ 'retry-after',	''		],
+	[ 'server',		''		],
+	[ 'set-cookie',		''		],
+	[ 'strict-transport-security',
+				''		],
+	[ 'transfer-encoding',	''		],
+	[ 'user-agent',		''		],
+	[ 'vary',		''		],
+	[ 'via',		''		],
+	[ 'www-authenticate',	''		],
+}
+
+# RFC 7541, 5.1.  Integer Representation
+
+sub ipack {
+	my ($base, $d) = @_;
+	return sprintf("%.*b", $base, $d) if $d < 2**$base - 1;
+
+	my $o = sprintf("%${base}b", 2**$base - 1);
+	$d -= 2**$base - 1;
+	while ($d >= 128) {
+		$o .= sprintf("%8b", $d % 128 + 128);
+		$d /= 128;
+	}
+	$o .= sprintf("%08b", $d);
+	return $o;
+}
+
+sub iunpack {
+	my ($base, $b, $s) = @_;
+
+	my $len = unpack("\@$s B8", $b); $s++;
+	my $prefix = substr($len, 0, 8 - $base);
+	$len = '0' x (8 - $base) . substr($len, 8 - $base);
+	$len = unpack("C", pack("B8", $len));
+
+	return ($len, $s, $prefix) if $len < 2**$base - 1;
+
+	my $m = 0;
+	my $d;
+
+	do {
+		$d = unpack("\@$s C", $b); $s++;
+		$len += ($d & 127) * 2**$m;
+		$m += $base;
+	} while (($d & 128) == 128);
+
+	return ($len, $s, $prefix);
+}
+
+sub hpack {
+	my ($ctx, $name, $value, %extra) = @_;
+	my $table = $ctx->{dynamic_encode};
+	my $mode = defined $extra{mode} ? $extra{mode} : 1;
+	my $huff = $extra{huff};
+
+	my ($index, $buf) = 0;
+
+	# 6.1.  Indexed Header Field Representation
+
+	if ($mode == 0) {
+		++$index until $index > $#$table
+			or $table->[$index][0] eq $name
+			and $table->[$index][1] eq $value;
+		$buf = pack('B*', '1' . ipack(7, $index));
+	}
+
+	# 6.2.1.  Literal Header Field with Incremental Indexing
+
+	if ($mode == 1) {
+		splice @$table, $ctx->{static_table_size}, 0, [ $name, $value ];
+
+		++$index until $index > $#$table
+			or $table->[$index][0] eq $name;
+		my $value = $huff ? huff($value) : $value;
+
+		$buf = pack('B*', '01' . ipack(6, $index)
+			. ($huff ? '1' : '0') . ipack(7, length($value)));
+		$buf .= $value;
+	}
+
+	# 6.2.1.  Literal Header Field with Incremental Indexing -- New Name
+
+	if ($mode == 2) {
+		splice @$table, $ctx->{static_table_size}, 0, [ $name, $value ];
+
+		my $name = $huff ? huff($name) : $name;
+		my $value = $huff ? huff($value) : $value;
+		my $hbit = ($huff ? '1' : '0');
+
+		$buf = pack('B*', '01000000');
+		$buf .= pack('B*', $hbit . ipack(7, length($name)));
+		$buf .= $name;
+		$buf .= pack('B*', $hbit . ipack(7, length($value)));
+		$buf .= $value;
+	}
+
+	# 6.2.2.  Literal Header Field without Indexing
+
+	if ($mode == 3) {
+		++$index until $index > $#$table
+			or $table->[$index][0] eq $name;
+		my $value = $huff ? huff($value) : $value;
+
+		$buf = pack('B*', '0000' . ipack(4, $index)
+			. ($huff ? '1' : '0') . ipack(7, length($value)));
+		$buf .= $value;
+	}
+
+	# 6.2.2.  Literal Header Field without Indexing -- New Name
+
+	if ($mode == 4) {
+		my $name = $huff ? huff($name) : $name;
+		my $value = $huff ? huff($value) : $value;
+		my $hbit = ($huff ? '1' : '0');
+
+		$buf = pack('B*', '00000000');
+		$buf .= pack('B*', $hbit . ipack(7, length($name)));
+		$buf .= $name;
+		$buf .= pack('B*', $hbit . ipack(7, length($value)));
+		$buf .= $value;
+	}
+
+	# 6.2.3.  Literal Header Field Never Indexed
+
+	if ($mode == 5) {
+		++$index until $index > $#$table
+			or $table->[$index][0] eq $name;
+		my $value = $huff ? huff($value) : $value;
+
+		$buf = pack('B*', '0001' . ipack(4, $index)
+			. ($huff ? '1' : '0') . ipack(7, length($value)));
+		$buf .= $value;
+	}
+
+	# 6.2.3.  Literal Header Field Never Indexed -- New Name
+
+	if ($mode == 6) {
+		my $name = $huff ? huff($name) : $name;
+		my $value = $huff ? huff($value) : $value;
+		my $hbit = ($huff ? '1' : '0');
+
+		$buf = pack('B*', '00010000');
+		$buf .= pack('B*', $hbit . ipack(7, length($name)));
+		$buf .= $name;
+		$buf .= pack('B*', $hbit . ipack(7, length($value)));
+		$buf .= $value;
+	}
+
+	return $buf;
+}
+
+sub hunpack {
+	my ($ctx, $data, $length) = @_;
+	my $table = $ctx->{dynamic_decode};
+	my %headers;
+	my $skip = 0;
+	my ($index, $name, $value, $size);
+
+	my $field = sub {
+		my ($b) = @_;
+		my ($len, $s, $huff) = iunpack(7, @_);
+
+		my $field = substr($b, $s, $len);
+		$field = $huff ? dehuff($field) : $field;
+		$s += $len;
+		return ($field, $s);
+	};
+
+	my $add = sub {
+		my ($h, $n, $v) = @_;
+		return $h->{$n} = $v unless exists $h->{$n};
+		$h->{$n} = [ $h->{$n} ] unless ref $h->{$n};
+		push @{$h->{$n}}, $v;
+	};
+
+	while ($skip < $length) {
+		my $ib = unpack("\@$skip B8", $data);
+
+		if (substr($ib, 0, 1) eq '1') {
+			($index, $skip) = iunpack(7, $data, $skip);
+			$add->(\%headers,
+				$table->[$index][0], $table->[$index][1]);
+			next;
+		}
+
+		if (substr($ib, 0, 2) eq '01') {
+			($index, $skip) = iunpack(6, $data, $skip);
+			$name = $table->[$index][0];
+
+			($name, $skip) = $field->($data, $skip) unless $name;
+			($value, $skip) = $field->($data, $skip);
+
+			splice @$table,
+				$ctx->{static_table_size}, 0, [ $name, $value ];
+			$add->(\%headers, $name, $value);
+			next;
+		}
+
+		if (substr($ib, 0, 4) eq '0000') {
+			($index, $skip) = iunpack(4, $data, $skip);
+			$name = $table->[$index][0];
+
+			($name, $skip) = $field->($data, $skip) unless $name;
+			($value, $skip) = $field->($data, $skip);
+
+			$add->(\%headers, $name, $value);
+			next;
+		}
+
+		if (substr($ib, 0, 3) eq '001') {
+			($size, $skip) = iunpack(5, $data, $skip);
+
+			# TODO: handle dynamic table size update
+
+			next;
+		}
+
+		last;
+	}
+
+	return \%headers;
+}
+
+sub huff_code { scalar {
+	pack('C', 0)	=> '1111111111000',
+	pack('C', 1)	=> '11111111111111111011000',
+	pack('C', 2)	=> '1111111111111111111111100010',
+	pack('C', 3)	=> '1111111111111111111111100011',
+	pack('C', 4)	=> '1111111111111111111111100100',
+	pack('C', 5)	=> '1111111111111111111111100101',
+	pack('C', 6)	=> '1111111111111111111111100110',
+	pack('C', 7)	=> '1111111111111111111111100111',
+	pack('C', 8)	=> '1111111111111111111111101000',
+	pack('C', 9)	=> '111111111111111111101010',
+	pack('C', 10)	=> '111111111111111111111111111100',
+	pack('C', 11)	=> '1111111111111111111111101001',
+	pack('C', 12)	=> '1111111111111111111111101010',
+	pack('C', 13)	=> '111111111111111111111111111101',
+	pack('C', 14)	=> '1111111111111111111111101011',
+	pack('C', 15)	=> '1111111111111111111111101100',
+	pack('C', 16)	=> '1111111111111111111111101101',
+	pack('C', 17)	=> '1111111111111111111111101110',
+	pack('C', 18)	=> '1111111111111111111111101111',
+	pack('C', 19)	=> '1111111111111111111111110000',
+	pack('C', 20)	=> '1111111111111111111111110001',
+	pack('C', 21)	=> '1111111111111111111111110010',
+	pack('C', 22)	=> '111111111111111111111111111110',
+	pack('C', 23)	=> '1111111111111111111111110011',
+	pack('C', 24)	=> '1111111111111111111111110100',
+	pack('C', 25)	=> '1111111111111111111111110101',
+	pack('C', 26)	=> '1111111111111111111111110110',
+	pack('C', 27)	=> '1111111111111111111111110111',
+	pack('C', 28)	=> '1111111111111111111111111000',
+	pack('C', 29)	=> '1111111111111111111111111001',
+	pack('C', 30)	=> '1111111111111111111111111010',
+	pack('C', 31)	=> '1111111111111111111111111011',
+	pack('C', 32)	=> '010100',
+	pack('C', 33)	=> '1111111000',
+	pack('C', 34)	=> '1111111001',
+	pack('C', 35)	=> '111111111010',
+	pack('C', 36)	=> '1111111111001',
+	pack('C', 37)	=> '010101',
+	pack('C', 38)	=> '11111000',
+	pack('C', 39)	=> '11111111010',
+	pack('C', 40)	=> '1111111010',
+	pack('C', 41)	=> '1111111011',
+	pack('C', 42)	=> '11111001',
+	pack('C', 43)	=> '11111111011',
+	pack('C', 44)	=> '11111010',
+	pack('C', 45)	=> '010110',
+	pack('C', 46)	=> '010111',
+	pack('C', 47)	=> '011000',
+	pack('C', 48)	=> '00000',
+	pack('C', 49)	=> '00001',
+	pack('C', 50)	=> '00010',
+	pack('C', 51)	=> '011001',
+	pack('C', 52)	=> '011010',
+	pack('C', 53)	=> '011011',
+	pack('C', 54)	=> '011100',
+	pack('C', 55)	=> '011101',
+	pack('C', 56)	=> '011110',
+	pack('C', 57)	=> '011111',
+	pack('C', 58)	=> '1011100',
+	pack('C', 59)	=> '11111011',
+	pack('C', 60)	=> '111111111111100',
+	pack('C', 61)	=> '100000',
+	pack('C', 62)	=> '111111111011',
+	pack('C', 63)	=> '1111111100',
+	pack('C', 64)	=> '1111111111010',
+	pack('C', 65)	=> '100001',
+	pack('C', 66)	=> '1011101',
+	pack('C', 67)	=> '1011110',
+	pack('C', 68)	=> '1011111',
+	pack('C', 69)	=> '1100000',
+	pack('C', 70)	=> '1100001',
+	pack('C', 71)	=> '1100010',
+	pack('C', 72)	=> '1100011',
+	pack('C', 73)	=> '1100100',
+	pack('C', 74)	=> '1100101',
+	pack('C', 75)	=> '1100110',
+	pack('C', 76)	=> '1100111',
+	pack('C', 77)	=> '1101000',
+	pack('C', 78)	=> '1101001',
+	pack('C', 79)	=> '1101010',
+	pack('C', 80)	=> '1101011',
+	pack('C', 81)	=> '1101100',
+	pack('C', 82)	=> '1101101',
+	pack('C', 83)	=> '1101110',
+	pack('C', 84)	=> '1101111',
+	pack('C', 85)	=> '1110000',
+	pack('C', 86)	=> '1110001',
+	pack('C', 87)	=> '1110010',
+	pack('C', 88)	=> '11111100',
+	pack('C', 89)	=> '1110011',
+	pack('C', 90)	=> '11111101',
+	pack('C', 91)	=> '1111111111011',
+	pack('C', 92)	=> '1111111111111110000',
+	pack('C', 93)	=> '1111111111100',
+	pack('C', 94)	=> '11111111111100',
+	pack('C', 95)	=> '100010',
+	pack('C', 96)	=> '111111111111101',
+	pack('C', 97)	=> '00011',
+	pack('C', 98)	=> '100011',
+	pack('C', 99)	=> '00100',
+	pack('C', 100)	=> '100100',
+	pack('C', 101)	=> '00101',
+	pack('C', 102)	=> '100101',
+	pack('C', 103)	=> '100110',
+	pack('C', 104)	=> '100111',
+	pack('C', 105)	=> '00110',
+	pack('C', 106)	=> '1110100',
+	pack('C', 107)	=> '1110101',
+	pack('C', 108)	=> '101000',
+	pack('C', 109)	=> '101001',
+	pack('C', 110)	=> '101010',
+	pack('C', 111)	=> '00111',
+	pack('C', 112)	=> '101011',
+	pack('C', 113)	=> '1110110',
+	pack('C', 114)	=> '101100',
+	pack('C', 115)	=> '01000',
+	pack('C', 116)	=> '01001',
+	pack('C', 117)	=> '101101',
+	pack('C', 118)	=> '1110111',
+	pack('C', 119)	=> '1111000',
+	pack('C', 120)	=> '1111001',
+	pack('C', 121)	=> '1111010',
+	pack('C', 122)	=> '1111011',
+	pack('C', 123)	=> '111111111111110',
+	pack('C', 124)	=> '11111111100',
+	pack('C', 125)	=> '11111111111101',
+	pack('C', 126)	=> '1111111111101',
+	pack('C', 127)	=> '1111111111111111111111111100',
+	pack('C', 128)	=> '11111111111111100110',
+	pack('C', 129)	=> '1111111111111111010010',
+	pack('C', 130)	=> '11111111111111100111',
+	pack('C', 131)	=> '11111111111111101000',
+	pack('C', 132)	=> '1111111111111111010011',
+	pack('C', 133)	=> '1111111111111111010100',
+	pack('C', 134)	=> '1111111111111111010101',
+	pack('C', 135)	=> '11111111111111111011001',
+	pack('C', 136)	=> '1111111111111111010110',
+	pack('C', 137)	=> '11111111111111111011010',
+	pack('C', 138)	=> '11111111111111111011011',
+	pack('C', 139)	=> '11111111111111111011100',
+	pack('C', 140)	=> '11111111111111111011101',
+	pack('C', 141)	=> '11111111111111111011110',
+	pack('C', 142)	=> '111111111111111111101011',
+	pack('C', 143)	=> '11111111111111111011111',
+	pack('C', 144)	=> '111111111111111111101100',
+	pack('C', 145)	=> '111111111111111111101101',
+	pack('C', 146)	=> '1111111111111111010111',
+	pack('C', 147)	=> '11111111111111111100000',
+	pack('C', 148)	=> '111111111111111111101110',
+	pack('C', 149)	=> '11111111111111111100001',
+	pack('C', 150)	=> '11111111111111111100010',
+	pack('C', 151)	=> '11111111111111111100011',
+	pack('C', 152)	=> '11111111111111111100100',
+	pack('C', 153)	=> '111111111111111011100',
+	pack('C', 154)	=> '1111111111111111011000',
+	pack('C', 155)	=> '11111111111111111100101',
+	pack('C', 156)	=> '1111111111111111011001',
+	pack('C', 157)	=> '11111111111111111100110',
+	pack('C', 158)	=> '11111111111111111100111',
+	pack('C', 159)	=> '111111111111111111101111',
+	pack('C', 160)	=> '1111111111111111011010',
+	pack('C', 161)	=> '111111111111111011101',
+	pack('C', 162)	=> '11111111111111101001',
+	pack('C', 163)	=> '1111111111111111011011',
+	pack('C', 164)	=> '1111111111111111011100',
+	pack('C', 165)	=> '11111111111111111101000',
+	pack('C', 166)	=> '11111111111111111101001',
+	pack('C', 167)	=> '111111111111111011110',
+	pack('C', 168)	=> '11111111111111111101010',
+	pack('C', 169)	=> '1111111111111111011101',
+	pack('C', 170)	=> '1111111111111111011110',
+	pack('C', 171)	=> '111111111111111111110000',
+	pack('C', 172)	=> '111111111111111011111',
+	pack('C', 173)	=> '1111111111111111011111',
+	pack('C', 174)	=> '11111111111111111101011',
+	pack('C', 175)	=> '11111111111111111101100',
+	pack('C', 176)	=> '111111111111111100000',
+	pack('C', 177)	=> '111111111111111100001',
+	pack('C', 178)	=> '1111111111111111100000',
+	pack('C', 179)	=> '111111111111111100010',
+	pack('C', 180)	=> '11111111111111111101101',
+	pack('C', 181)	=> '1111111111111111100001',
+	pack('C', 182)	=> '11111111111111111101110',
+	pack('C', 183)	=> '11111111111111111101111',
+	pack('C', 184)	=> '11111111111111101010',
+	pack('C', 185)	=> '1111111111111111100010',
+	pack('C', 186)	=> '1111111111111111100011',
+	pack('C', 187)	=> '1111111111111111100100',
+	pack('C', 188)	=> '11111111111111111110000',
+	pack('C', 189)	=> '1111111111111111100101',
+	pack('C', 190)	=> '1111111111111111100110',
+	pack('C', 191)	=> '11111111111111111110001',
+	pack('C', 192)	=> '11111111111111111111100000',
+	pack('C', 193)	=> '11111111111111111111100001',
+	pack('C', 194)	=> '11111111111111101011',
+	pack('C', 195)	=> '1111111111111110001',
+	pack('C', 196)	=> '1111111111111111100111',
+	pack('C', 197)	=> '11111111111111111110010',
+	pack('C', 198)	=> '1111111111111111101000',
+	pack('C', 199)	=> '1111111111111111111101100',
+	pack('C', 200)	=> '11111111111111111111100010',
+	pack('C', 201)	=> '11111111111111111111100011',
+	pack('C', 202)	=> '11111111111111111111100100',
+	pack('C', 203)	=> '111111111111111111111011110',
+	pack('C', 204)	=> '111111111111111111111011111',
+	pack('C', 205)	=> '11111111111111111111100101',
+	pack('C', 206)	=> '111111111111111111110001',
+	pack('C', 207)	=> '1111111111111111111101101',
+	pack('C', 208)	=> '1111111111111110010',
+	pack('C', 209)	=> '111111111111111100011',
+	pack('C', 210)	=> '11111111111111111111100110',
+	pack('C', 211)	=> '111111111111111111111100000',
+	pack('C', 212)	=> '111111111111111111111100001',
+	pack('C', 213)	=> '11111111111111111111100111',
+	pack('C', 214)	=> '111111111111111111111100010',
+	pack('C', 215)	=> '111111111111111111110010',
+	pack('C', 216)	=> '111111111111111100100',
+	pack('C', 217)	=> '111111111111111100101',
+	pack('C', 218)	=> '11111111111111111111101000',
+	pack('C', 219)	=> '11111111111111111111101001',
+	pack('C', 220)	=> '1111111111111111111111111101',
+	pack('C', 221)	=> '111111111111111111111100011',
+	pack('C', 222)	=> '111111111111111111111100100',
+	pack('C', 223)	=> '111111111111111111111100101',
+	pack('C', 224)	=> '11111111111111101100',
+	pack('C', 225)	=> '111111111111111111110011',
+	pack('C', 226)	=> '11111111111111101101',
+	pack('C', 227)	=> '111111111111111100110',
+	pack('C', 228)	=> '1111111111111111101001',
+	pack('C', 229)	=> '111111111111111100111',
+	pack('C', 230)	=> '111111111111111101000',
+	pack('C', 231)	=> '11111111111111111110011',
+	pack('C', 232)	=> '1111111111111111101010',
+	pack('C', 233)	=> '1111111111111111101011',
+	pack('C', 234)	=> '1111111111111111111101110',
+	pack('C', 235)	=> '1111111111111111111101111',
+	pack('C', 236)	=> '111111111111111111110100',
+	pack('C', 237)	=> '111111111111111111110101',
+	pack('C', 238)	=> '11111111111111111111101010',
+	pack('C', 239)	=> '11111111111111111110100',
+	pack('C', 240)	=> '11111111111111111111101011',
+	pack('C', 241)	=> '111111111111111111111100110',
+	pack('C', 242)	=> '11111111111111111111101100',
+	pack('C', 243)	=> '11111111111111111111101101',
+	pack('C', 244)	=> '111111111111111111111100111',
+	pack('C', 245)	=> '111111111111111111111101000',
+	pack('C', 246)	=> '111111111111111111111101001',
+	pack('C', 247)	=> '111111111111111111111101010',
+	pack('C', 248)	=> '111111111111111111111101011',
+	pack('C', 249)	=> '1111111111111111111111111110',
+	pack('C', 250)	=> '111111111111111111111101100',
+	pack('C', 251)	=> '111111111111111111111101101',
+	pack('C', 252)	=> '111111111111111111111101110',
+	pack('C', 253)	=> '111111111111111111111101111',
+	pack('C', 254)	=> '111111111111111111111110000',
+	pack('C', 255)	=> '11111111111111111111101110',
+	'_eos'		=> '111111111111111111111111111111',
+}};
+
+sub huff {
+	my ($string) = @_;
+	my $code = &huff_code;
+
+	my $ret = join '', map { $code->{$_} } (split //, $string);
+	my $len = length($ret) + (8 - length($ret) % 8);
+	$ret .= $code->{_eos};
+
+	return pack("B$len", $ret);
+}
+
+sub dehuff {
+	my ($string) = @_;
+	my $code = &huff_code;
+	my %decode = reverse %$code;
+
+	my $ret = ''; my $c = '';
+	for (split //, unpack('B*', $string)) {
+		$c .= $_;
+		next unless exists $decode{$c};
+		last if $decode{$c} eq '_eos';
+
+		$ret .= $decode{$c};
+		$c = '';
+	}
+
+	return $ret;
+}
+
+###############################################################################
+
+1;
+
+###############################################################################
diff --git a/tests/lib/Test/Nginx/IMAP.pm b/tests/lib/Test/Nginx/IMAP.pm
new file mode 100644
index 0000000..f2e5b5d
--- /dev/null
+++ b/tests/lib/Test/Nginx/IMAP.pm
@@ -0,0 +1,135 @@
+package Test::Nginx::IMAP;
+
+# (C) Maxim Dounin
+
+# Module for nginx imap tests.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More qw//;
+use IO::Select;
+use IO::Socket;
+use Socket qw/ CRLF /;
+
+use Test::Nginx;
+
+sub new {
+	my $self = {};
+	bless $self, shift @_;
+
+	$self->{_socket} = IO::Socket::INET->new(
+		Proto => "tcp",
+		PeerAddr => "127.0.0.1:" . port(8143),
+		@_
+	)
+		or die "Can't connect to nginx: $!\n";
+
+	if ({@_}->{'SSL'}) {
+		require IO::Socket::SSL;
+		IO::Socket::SSL->start_SSL($self->{_socket}, @_)
+			or die $IO::Socket::SSL::SSL_ERROR . "\n";
+	}
+
+	$self->{_socket}->autoflush(1);
+
+	return $self;
+}
+
+sub eof {
+	my $self = shift;
+	return $self->{_socket}->eof();
+}
+
+sub print {
+	my ($self, $cmd) = @_;
+	log_out($cmd);
+	$self->{_socket}->print($cmd);
+}
+
+sub send {
+	my ($self, $cmd) = @_;
+	log_out($cmd);
+	$self->{_socket}->print($cmd . CRLF);
+}
+
+sub read {
+	my ($self) = @_;
+	my $socket = $self->{_socket};
+	eval {
+		local $SIG{ALRM} = sub { die "timeout\n" };
+		alarm(8);
+		while (<$socket>) {
+			log_in($_);
+			# XXX
+			next if m/^\d\d\d-/;
+			last;
+		}
+		alarm(0);
+	};
+	alarm(0);
+	if ($@) {
+		log_in("died: $@");
+		return undef;
+	}
+	return $_;
+}
+
+sub check {
+	my ($self, $regex, $name) = @_;
+	Test::More->builder->like($self->read(), $regex, $name);
+}
+
+sub ok {
+	my $self = shift;
+	Test::More->builder->like($self->read(), qr/^\S+ OK/, @_);
+}
+
+sub can_read {
+	my ($self, $timo) = @_;
+	IO::Select->new($self->{_socket})->can_read($timo || 3);
+}
+
+###############################################################################
+
+sub imap_test_daemon {
+	my ($port) = @_;
+
+	my $server = IO::Socket::INET->new(
+		Proto => 'tcp',
+		LocalAddr => '127.0.0.1:' . ($port || port(8144)),
+		Listen => 5,
+		Reuse => 1
+	)
+		or die "Can't create listening socket: $!\n";
+
+	while (my $client = $server->accept()) {
+		$client->autoflush(1);
+		print $client "* OK fake imap server ready" . CRLF;
+
+		while (<$client>) {
+			my $tag = '';
+
+			$tag = $1 if m/^(\S+)/;
+			s/^(\S+)\s+//;
+
+			if (/^logout/i) {
+				print $client $tag . ' OK logout ok' . CRLF;
+			} elsif (/^login /i) {
+				print $client $tag . ' OK login ok' . CRLF;
+			} else {
+				print $client $tag . ' ERR unknown command' . CRLF;
+			}
+		}
+
+		close $client;
+	}
+}
+
+###############################################################################
+
+1;
+
+###############################################################################
diff --git a/tests/lib/Test/Nginx/POP3.pm b/tests/lib/Test/Nginx/POP3.pm
new file mode 100644
index 0000000..05310cc
--- /dev/null
+++ b/tests/lib/Test/Nginx/POP3.pm
@@ -0,0 +1,132 @@
+package Test::Nginx::POP3;
+
+# (C) Maxim Dounin
+
+# Module for nginx pop3 tests.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More qw//;
+use IO::Select;
+use IO::Socket;
+use Socket qw/ CRLF /;
+
+use Test::Nginx;
+
+sub new {
+	my $self = {};
+	bless $self, shift @_;
+
+	$self->{_socket} = IO::Socket::INET->new(
+		Proto => "tcp",
+		PeerAddr => "127.0.0.1:" . port(8110),
+		@_
+	)
+		or die "Can't connect to nginx: $!\n";
+
+	if ({@_}->{'SSL'}) {
+		require IO::Socket::SSL;
+		IO::Socket::SSL->start_SSL($self->{_socket}, @_)
+			or die $IO::Socket::SSL::SSL_ERROR . "\n";
+	}
+
+	$self->{_socket}->autoflush(1);
+
+	return $self;
+}
+
+sub eof {
+	my $self = shift;
+	return $self->{_socket}->eof();
+}
+
+sub print {
+	my ($self, $cmd) = @_;
+	log_out($cmd);
+	$self->{_socket}->print($cmd);
+}
+
+sub send {
+	my ($self, $cmd) = @_;
+	log_out($cmd);
+	$self->{_socket}->print($cmd . CRLF);
+}
+
+sub read {
+	my ($self) = @_;
+	my $socket = $self->{_socket};
+	eval {
+		local $SIG{ALRM} = sub { die "timeout\n" };
+		alarm(8);
+		while (<$socket>) {
+			log_in($_);
+			# XXX
+			next if m/^\d\d\d-/;
+			last;
+		}
+		alarm(0);
+	};
+	alarm(0);
+	if ($@) {
+		log_in("died: $@");
+		return undef;
+	}
+	return $_;
+}
+
+sub check {
+	my ($self, $regex, $name) = @_;
+	Test::More->builder->like($self->read(), $regex, $name);
+}
+
+sub ok {
+	my $self = shift;
+	Test::More->builder->like($self->read(), qr/^\+OK/, @_);
+}
+
+sub can_read {
+	my ($self, $timo) = @_;
+	IO::Select->new($self->{_socket})->can_read($timo || 3);
+}
+
+###############################################################################
+
+sub pop3_test_daemon {
+	my ($port) = @_;
+
+	my $server = IO::Socket::INET->new(
+		Proto => 'tcp',
+		LocalAddr => '127.0.0.1:' . ($port || port(8111)),
+		Listen => 5,
+		Reuse => 1
+	)
+		or die "Can't create listening socket: $!\n";
+
+	while (my $client = $server->accept()) {
+		$client->autoflush(1);
+		print $client "+OK fake pop3 server ready" . CRLF;
+
+		while (<$client>) {
+			if (/^quit/i) {
+				print $client '+OK quit ok' . CRLF;
+			} elsif (/^user test\@example.com/i) {
+				print $client '+OK user ok' . CRLF;
+			} elsif (/^pass secret/i) {
+				print $client '+OK pass ok' . CRLF;
+			} else {
+				print $client "-ERR unknown command" . CRLF;
+			}
+		}
+
+		close $client;
+	}
+}
+
+###############################################################################
+
+1;
+
+###############################################################################
diff --git a/tests/lib/Test/Nginx/SMTP.pm b/tests/lib/Test/Nginx/SMTP.pm
new file mode 100644
index 0000000..c722212
--- /dev/null
+++ b/tests/lib/Test/Nginx/SMTP.pm
@@ -0,0 +1,148 @@
+package Test::Nginx::SMTP;
+
+# (C) Maxim Dounin
+
+# Module for nginx smtp tests.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More qw//;
+use IO::Select;
+use IO::Socket;
+use Socket qw/ CRLF /;
+
+use Test::Nginx;
+
+sub new {
+	my $self = {};
+	bless $self, shift @_;
+
+	$self->{_socket} = IO::Socket::INET->new(
+		Proto => "tcp",
+		PeerAddr => "127.0.0.1:" . port(8025),
+		@_
+	)
+		or die "Can't connect to nginx: $!\n";
+
+	if ({@_}->{'SSL'}) {
+		require IO::Socket::SSL;
+		IO::Socket::SSL->start_SSL($self->{_socket}, @_)
+			or die $IO::Socket::SSL::SSL_ERROR . "\n";
+	}
+
+	$self->{_socket}->autoflush(1);
+
+	return $self;
+}
+
+sub eof {
+	my $self = shift;
+	return $self->{_socket}->eof();
+}
+
+sub print {
+	my ($self, $cmd) = @_;
+	log_out($cmd);
+	$self->{_socket}->print($cmd);
+}
+
+sub send {
+	my ($self, $cmd) = @_;
+	log_out($cmd);
+	$self->{_socket}->print($cmd . CRLF);
+}
+
+sub read {
+	my ($self) = @_;
+	my $socket = $self->{_socket};
+	eval {
+		local $SIG{ALRM} = sub { die "timeout\n" };
+		alarm(8);
+		while (<$socket>) {
+			log_in($_);
+			next if m/^\d\d\d-/;
+			last;
+		}
+		alarm(0);
+	};
+	alarm(0);
+	if ($@) {
+		log_in("died: $@");
+		return undef;
+	}
+	return $_;
+}
+
+sub check {
+	my ($self, $regex, $name) = @_;
+	Test::More->builder->like($self->read(), $regex, $name);
+}
+
+sub ok {
+	my $self = shift;
+	Test::More->builder->like($self->read(), qr/^2\d\d /, @_);
+}
+
+sub authok {
+	my $self = shift;
+	Test::More->builder->like($self->read(), qr/^235 /, @_);
+}
+
+sub can_read {
+	my ($self, $timo) = @_;
+	IO::Select->new($self->{_socket})->can_read($timo || 3);
+}
+
+###############################################################################
+
+sub smtp_test_daemon {
+	my ($port) = @_;
+
+	my $server = IO::Socket::INET->new(
+		Proto => 'tcp',
+		LocalAddr => '127.0.0.1:' . ($port || port(8026)),
+		Listen => 5,
+		Reuse => 1
+	)
+		or die "Can't create listening socket: $!\n";
+
+	while (my $client = $server->accept()) {
+		$client->autoflush(1);
+		print $client "220 fake esmtp server ready" . CRLF;
+
+		while (<$client>) {
+			Test::Nginx::log_core('||', $_);
+
+			if (/^quit/i) {
+				print $client '221 quit ok' . CRLF;
+			} elsif (/^(ehlo|helo)/i) {
+				print $client '250 hello ok' . CRLF;
+			} elsif (/^rset/i) {
+				print $client '250 rset ok' . CRLF;
+			} elsif (/^mail from:[^@]+$/i) {
+				print $client '500 mail from error' . CRLF;
+			} elsif (/^mail from:/i) {
+				print $client '250 mail from ok' . CRLF;
+			} elsif (/^rcpt to:[^@]+$/i) {
+				print $client '500 rcpt to error' . CRLF;
+			} elsif (/^rcpt to:/i) {
+				print $client '250 rcpt to ok' . CRLF;
+			} elsif (/^xclient/i) {
+				print $client '220 xclient ok' . CRLF;
+			} else {
+				print $client "500 unknown command" . CRLF;
+			}
+		}
+
+		close $client;
+	}
+}
+
+###############################################################################
+
+1;
+
+###############################################################################
diff --git a/tests/lib/Test/Nginx/Stream.pm b/tests/lib/Test/Nginx/Stream.pm
new file mode 100644
index 0000000..b5cb81a
--- /dev/null
+++ b/tests/lib/Test/Nginx/Stream.pm
@@ -0,0 +1,140 @@
+package Test::Nginx::Stream;
+
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+
+# Module for nginx stream tests.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use base qw/ Exporter /;
+our @EXPORT_OK = qw/ stream dgram /;
+
+use Test::More qw//;
+use IO::Select;
+use IO::Socket;
+
+use Test::Nginx;
+
+sub stream {
+	return Test::Nginx::Stream->new(@_);
+}
+
+sub dgram {
+	unshift(@_, "PeerAddr") if @_ == 1;
+
+	return Test::Nginx::Stream->new(
+		Proto => "udp",
+		@_
+	);
+}
+
+sub new {
+	my $self = {};
+	bless $self, shift @_;
+
+	unshift(@_, "PeerAddr") if @_ == 1;
+
+	$self->{_socket} = IO::Socket::INET->new(
+		Proto => "tcp",
+		PeerAddr => '127.0.0.1',
+		@_
+	)
+		or die "Can't connect to nginx: $!\n";
+
+	if ({@_}->{'SSL'}) {
+		require IO::Socket::SSL;
+		IO::Socket::SSL->start_SSL($self->{_socket}, @_)
+			or die $IO::Socket::SSL::SSL_ERROR . "\n";
+	}
+
+	$self->{_socket}->autoflush(1);
+
+	return $self;
+}
+
+sub write {
+	my ($self, $message, %extra) = @_;
+	my $s = $self->{_socket};
+
+	local $SIG{PIPE} = 'IGNORE';
+
+	$s->blocking(0);
+	while (IO::Select->new($s)->can_write($extra{write_timeout} || 1.5)) {
+		my $n = $s->syswrite($message);
+		log_out(substr($message, 0, $n));
+		last unless $n;
+
+		$message = substr($message, $n);
+		last unless length $message;
+	}
+
+	if (length $message) {
+		$s->close();
+	}
+}
+
+sub read {
+	my ($self, %extra) = @_;
+	my ($s, $buf);
+
+	$s = $self->{_socket};
+
+	$s->blocking(0);
+	if (IO::Select->new($s)->can_read($extra{read_timeout} || 8)) {
+		$s->sysread($buf, 1024);
+	};
+
+	log_in($buf);
+	return $buf;
+}
+
+sub io {
+	my $self = shift;
+
+	my ($data, %extra) = @_;
+	my $length = $extra{length};
+	my $read = $extra{read};
+
+	$read = 1 if !defined $read
+		&& $self->{_socket}->socktype() == &SOCK_DGRAM;
+
+	$self->write($data, %extra);
+
+	$data = '';
+	while (1) {
+		last if defined $read && --$read < 0;
+
+		my $buf = $self->read(%extra);
+		last unless defined $buf and length($buf);
+
+		$data .= $buf;
+		last if defined $length && length($data) >= $length;
+	}
+
+	return $data;
+}
+
+sub sockaddr {
+	my $self = shift;
+	return $self->{_socket}->sockaddr();
+}
+
+sub sockhost {
+	my $self = shift;
+	return $self->{_socket}->sockhost();
+}
+
+sub sockport {
+	my $self = shift;
+	return $self->{_socket}->sockport();
+}
+
+###############################################################################
+
+1;
+
+###############################################################################
diff --git a/tests/limit_conn.t b/tests/limit_conn.t
new file mode 100644
index 0000000..7149919
--- /dev/null
+++ b/tests/limit_conn.t
@@ -0,0 +1,118 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+
+# limit_req based tests for nginx limit_conn module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy limit_conn limit_req/);
+
+$t->write_file_expand('nginx.conf', <<'EOF')->plan(8);
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    limit_req_zone   $binary_remote_addr  zone=req:1m rate=30r/m;
+
+    limit_conn_zone  $binary_remote_addr  zone=zone:1m;
+    limit_conn_zone  $binary_remote_addr  zone=zone2:1m;
+    limit_conn_zone  $binary_remote_addr  zone=custom:1m;
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location /w {
+            limit_req  zone=req burst=10;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            proxy_pass http://127.0.0.1:8081;
+            limit_conn zone 1;
+        }
+
+        location /1 {
+            limit_conn zone 1;
+        }
+
+        location /zone {
+            limit_conn zone2 1;
+        }
+
+        location /unlim {
+            limit_conn zone 5;
+        }
+
+        location /custom {
+            proxy_pass http://127.0.0.1:8081/;
+            limit_conn_log_level info;
+            limit_conn_status 501;
+            limit_conn custom 1;
+        }
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+# charge limit_req
+
+http_get('/w');
+
+# same and other zones in different locations
+
+my $s = http_get('/w', start => 1);
+like(http_get('/'), qr/^HTTP\/1.. 503 /, 'rejected');
+like(http_get('/1'), qr/^HTTP\/1.. 503 /, 'rejected different location');
+unlike(http_get('/zone'), qr/^HTTP\/1.. 503 /, 'passed different zone');
+
+close $s;
+unlike(http_get('/1'), qr/^HTTP\/1.. 503 /, 'passed');
+
+# custom error code and log level
+
+$s = http_get('/custom/w', start => 1);
+like(http_get('/custom'), qr/^HTTP\/1.. 501 /, 'limit_conn_status');
+
+like($t->read_file('error.log'),
+	qr/\[info\].*limiting connections by zone "custom"/,
+	'limit_conn_log_level');
+
+# limited after unlimited
+
+$s = http_get('/w', start => 1);
+like(http_get('/unlim'), qr/404 Not Found/, 'unlimited passed');
+like(http_get('/'), qr/503 Service/, 'limited rejected');
+
+###############################################################################
diff --git a/tests/limit_conn_complex.t b/tests/limit_conn_complex.t
new file mode 100644
index 0000000..1952647
--- /dev/null
+++ b/tests/limit_conn_complex.t
@@ -0,0 +1,99 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# limit_req based tests for limit_conn module with complex keys.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use IO::Select;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy limit_conn limit_req/)
+	->plan(4);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    limit_req_zone   $binary_remote_addr$arg_r  zone=req:1m rate=1r/m;
+    limit_req_zone   $binary_remote_addr        zone=re2:1m rate=1r/m;
+    limit_conn_zone  $binary_remote_addr$arg_c  zone=conn:1m;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            limit_conn conn 1;
+        }
+
+        location /w {
+            limit_conn conn 1;
+            proxy_pass http://127.0.0.1:8080/req2;
+        }
+
+        location /req {
+            limit_req  zone=req burst=2;
+        }
+
+        location /req2 {
+            limit_req  zone=re2 burst=2;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('req', '');
+$t->run();
+
+###############################################################################
+
+my $s;
+
+# charge limit_req
+
+http_get('/req');
+
+# limit_req tests
+
+$s = http_get('/req', start => 1);
+ok(!IO::Select->new($s)->can_read(1), 'limit_req same key');
+
+like(http_get('/req?r=2'), qr/200 OK/, 'limit_req different key');
+
+# limit_conn tests
+
+http_get('/req2');
+
+$s = http_get('/w', start => 1);
+select undef, undef, undef, 0.2;
+
+like(http_get('/'), qr/^HTTP\/1.. 503 /, 'limit_conn same key');
+unlike(http_get('/?c=2'), qr/^HTTP\/1.. 503 /, 'limit_conn different key');
+
+###############################################################################
diff --git a/tests/limit_conn_dry_run.t b/tests/limit_conn_dry_run.t
new file mode 100644
index 0000000..2ea63dc
--- /dev/null
+++ b/tests/limit_conn_dry_run.t
@@ -0,0 +1,95 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for limit_conn_dry_run directive, limit_conn_status variable.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy limit_conn limit_req/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    limit_req_zone   $binary_remote_addr  zone=req:1m rate=30r/m;
+    limit_conn_zone  $binary_remote_addr  zone=zone:1m;
+
+    log_format test $uri:$limit_conn_status;
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location /w {
+            limit_req  zone=req burst=10;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        add_header X-Status $limit_conn_status always;
+        access_log %%TESTDIR%%/test.log test;
+
+        location /reject {
+            proxy_pass http://127.0.0.1:8081/w;
+            limit_conn zone 1;
+        }
+
+        location /dry {
+            limit_conn zone 1;
+            limit_conn_dry_run on;
+        }
+
+        location / { }
+    }
+}
+
+EOF
+
+$t->write_file('w', '');
+$t->try_run('no limit_conn_dry_run/limit_conn_status')->plan(6);
+
+###############################################################################
+
+like(http_get('/reject'), qr/ 200 .*PASSED/s, 'passed');
+
+my $s = http_get('/reject', start => 1);
+like(http_get('/reject'), qr/ 503 .*REJECTED(?!_)/s, 'rejected');
+like(http_get('/dry'), qr/ 404 .*REJECTED_DRY_RUN/s, 'rejected dry run');
+unlike(http_get('/'), qr/X-Status/, 'no limit');
+
+close $s;
+
+$t->stop();
+
+like($t->read_file('error.log'), qr/limiting connections, dry/, 'log dry run');
+like($t->read_file('test.log'), qr|^/:-|m, 'log not found');
+
+###############################################################################
diff --git a/tests/limit_rate.t b/tests/limit_rate.t
new file mode 100644
index 0000000..b9644b4
--- /dev/null
+++ b/tests/limit_rate.t
@@ -0,0 +1,114 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for limit_rate and limit_rate_after directives.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+plan(skip_all => 'win32') if $^O eq 'MSWin32';
+
+my $t = Test::Nginx->new()->has(qw/http proxy/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    log_format test escape=none $uri:$arg_a$arg_xal:$upstream_response_time;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            proxy_pass http://127.0.0.1:8081;
+            access_log %%TESTDIR%%/test.log test;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        limit_rate 12k;
+        limit_rate_after 256;
+
+        location /data {
+            add_header X-Accel-Redirect $arg_xar;
+            add_header X-Accel-Limit-Rate $arg_xal;
+        }
+
+        location /redirect {
+            limit_rate 0;
+            alias %%TESTDIR%%/data;
+        }
+
+        location /var {
+            alias %%TESTDIR%%/data;
+            limit_rate $arg_l;
+            limit_rate_after $arg_a;
+        }
+
+        location /proxy/ {
+            proxy_pass http://127.0.0.1:8081/;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('data', 'X' x 30000);
+$t->try_run('no limit_rate variables')->plan(7);
+
+###############################################################################
+
+# NB: response time may be 1s less, if timer is scheduled on upper half second
+
+like(http_get('/data'), qr/^(XXXXXXXXXX){3000}\x0d?\x0a?$/m, 'response body');
+like($t->read_file('test.log'), qr/data::[12]/, 'limit_rate');
+
+# /proxy -> /redirect
+# before 1.17.0, limit was set once in ngx_http_update_location_config()
+
+http_get('/proxy/data?xar=/redirect');
+like($t->read_file('test.log'), qr!proxy/data::0!, 'X-Accel-Redirect');
+
+# X-Accel-Limit-Rate has higher precedence
+
+http_get('/proxy/data?xar=/redirect&xal=13000');
+like($t->read_file('test.log'), qr!roxy/data:13000:[12]!, 'X-Accel-Limit-Rate');
+
+http_get('/var?l=12k&a=256');
+like($t->read_file('test.log'), qr/var:256:[12]/, 'variable');
+
+http_get('/var?l=12k&a=40k');
+like($t->read_file('test.log'), qr/var:40k:0/, 'variable after');
+
+http_get('/var');
+like($t->read_file('test.log'), qr/var::0/, 'variables unset');
+
+###############################################################################
diff --git a/tests/limit_req.t b/tests/limit_req.t
new file mode 100644
index 0000000..facb1eb
--- /dev/null
+++ b/tests/limit_req.t
@@ -0,0 +1,97 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for nginx limit_req module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http limit_req/)->plan(6);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    limit_req_zone  $binary_remote_addr  zone=one:1m   rate=2r/s;
+    limit_req_zone  $binary_remote_addr  zone=long:1m  rate=2r/s;
+    limit_req_zone  $binary_remote_addr  zone=fast:1m  rate=1000r/s;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+        location / {
+            limit_req    zone=one  burst=1  nodelay;
+        }
+        location /status {
+            limit_req    zone=one  burst=1  nodelay;
+
+            limit_req_status  501;
+        }
+        location /long {
+            limit_req    zone=long  burst=5;
+        }
+        location /fast {
+            limit_req    zone=fast  burst=1;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('test1.html', 'XtestX');
+$t->write_file('long.html', "1234567890\n" x (1 << 16));
+$t->write_file('fast.html', 'XtestX');
+$t->run();
+
+###############################################################################
+
+like(http_get('/test1.html'), qr/^HTTP\/1.. 200 /m, 'request');
+http_get('/test1.html');
+like(http_get('/test1.html'), qr/^HTTP\/1.. 503 /m, 'request rejected');
+like(http_get('/status.html'), qr/^HTTP\/1.. 501 /m, 'request rejected status');
+http_get('/test1.html');
+http_get('/test1.html');
+
+# Second request will be delayed by limit_req, make sure it isn't truncated.
+# The bug only manifests itself if buffer will be filled, so sleep for a while
+# before reading response.
+
+my $l1 = length(http_get('/long.html'));
+my $l2 = length(http_get('/long.html', sleep => 0.6));
+is($l2, $l1, 'delayed big request not truncated');
+
+# make sure rejected requests are not counted, and access is again allowed
+# after 1/rate seconds
+
+like(http_get('/test1.html'), qr/^HTTP\/1.. 200 /m, 'rejects not counted');
+
+# make sure negative excess values are handled properly
+
+http_get('/fast.html');
+select undef, undef, undef, 0.1;
+like(http_get('/fast.html'), qr/^HTTP\/1.. 200 /m, 'negative excess');
+
+###############################################################################
diff --git a/tests/limit_req2.t b/tests/limit_req2.t
new file mode 100644
index 0000000..1f30a97
--- /dev/null
+++ b/tests/limit_req2.t
@@ -0,0 +1,97 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for nginx limit_req module, multiple limits.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http limit_req/)->plan(14);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    limit_req_zone  $arg_a  zone=slow:1m   rate=1r/m;
+    limit_req_zone  $arg_b  zone=fast:1m   rate=1000r/s;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            limit_req    zone=fast;
+            limit_req    zone=slow;
+        }
+
+        location /t2.html {
+            limit_req    zone=fast  nodelay;
+            limit_req    zone=slow  nodelay;
+
+            alias %%TESTDIR%%/t1.html;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('t1.html', 'XtestX');
+$t->run();
+
+###############################################################################
+
+like(http_get('/t1.html?b=1'), qr/^HTTP\/1.. 200 /m, 'fast');
+select undef, undef, undef, 0.1;
+like(http_get('/t1.html?b=1'), qr/^HTTP\/1.. 200 /m, 'fast - passed');
+
+like(http_get('/t1.html?a=1'), qr/^HTTP\/1.. 200 /m, 'slow');
+select undef, undef, undef, 0.1;
+like(http_get('/t1.html?a=1'), qr/^HTTP\/1.. 503 /m, 'slow - rejected');
+
+like(http_get('/t1.html?a=2&b=2'), qr/^HTTP\/1.. 200 /m, 'both');
+select undef, undef, undef, 0.1;
+like(http_get('/t1.html?a=2&b=2'), qr/^HTTP\/1.. 503 /m, 'both - rejected');
+
+like(http_get('/t1.html'), qr/^HTTP\/1.. 200 /m, 'no key');
+like(http_get('/t1.html'), qr/^HTTP\/1.. 200 /m, 'no key - passed');
+
+# nodelay
+
+like(http_get('/t2.html?b=3'), qr/^HTTP\/1.. 200 /m, 'nodelay fast');
+select undef, undef, undef, 0.1;
+like(http_get('/t2.html?b=3'), qr/^HTTP\/1.. 200 /m, 'nodelay fast - passed');
+
+like(http_get('/t2.html?a=3'), qr/^HTTP\/1.. 200 /m, 'nodelay slow');
+select undef, undef, undef, 0.1;
+like(http_get('/t2.html?a=3'), qr/^HTTP\/1.. 503 /m, 'nodelay slow - rejected');
+
+like(http_get('/t2.html?a=4&b=4'), qr/^HTTP\/1.. 200 /m, 'nodelay both');
+select undef, undef, undef, 0.1;
+like(http_get('/t2.html?a=4&b=4'), qr/^HTTP\/1.. 503 /m,
+	'nodelay both - rejected');
+
+###############################################################################
diff --git a/tests/limit_req_delay.t b/tests/limit_req_delay.t
new file mode 100644
index 0000000..f3627c7
--- /dev/null
+++ b/tests/limit_req_delay.t
@@ -0,0 +1,65 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for nginx limit_req module, delay parameter.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx qw/ :DEFAULT http_end /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http limit_req/)->plan(4);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    limit_req_zone $binary_remote_addr zone=one:1m rate=30r/m;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            limit_req zone=one delay=1 burst=2;
+            add_header X-Time $request_time;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('delay.html', 'XtestX');
+$t->run();
+
+###############################################################################
+
+like(http_get('/delay.html'), qr/^HTTP\/1.. 200 /m, 'request');
+like(http_get('/delay.html'), qr/X-Time: 0.000/, 'not yet delayed');
+my $s = http_get('/delay.html', start => 1, sleep => 0.2);
+like(http_get('/delay.html'), qr/^HTTP\/1.. 503 /m, 'rejected');
+like(http_end($s), qr/^HTTP\/1.. 200 .*X-Time: (?!0.000)/ms, 'delayed');
+
+###############################################################################
diff --git a/tests/limit_req_dry_run.t b/tests/limit_req_dry_run.t
new file mode 100644
index 0000000..2376d47
--- /dev/null
+++ b/tests/limit_req_dry_run.t
@@ -0,0 +1,92 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for nginx limit_req module, limit_req_dry_run directive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http limit_req/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    limit_req_zone  $binary_remote_addr  zone=one:1m   rate=1r/m;
+
+    log_format test $uri:$limit_req_status;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        limit_req_dry_run  on;
+        add_header X-Status $limit_req_status always;
+        access_log %%TESTDIR%%/test.log test;
+
+        location /delay {
+            limit_req    zone=one  burst=2;
+        }
+
+        location /reject {
+            limit_req    zone=one;
+        }
+
+        location /reject/off {
+            limit_req    zone=one;
+
+            limit_req_dry_run off;
+        }
+
+        location / { }
+    }
+}
+
+EOF
+
+$t->write_file('delay', 'SEE-THIS');
+$t->write_file('reject', 'SEE-THIS');
+$t->try_run('no limit_req_dry_run/limit_req_status')->plan(8);
+
+###############################################################################
+
+like(http_get('/delay'), qr/ 200 .*PASSED/ms, 'dry run - passed');
+like(http_get('/delay'), qr/ 200 .*DELAYED_DRY_RUN/ms, 'dry run - delayed');
+like(http_get('/reject'), qr/ 200 .*REJECTED_DRY_RUN/ms, 'dry run - rejected');
+
+like(http_get('/reject/off'), qr/ 503 .*REJECTED/ms, 'dry run off - rejected');
+
+unlike(http_get('/'), qr/X-Status/, 'no limit');
+
+$t->stop();
+
+like($t->read_file('error.log'), qr/delaying request, dry/, 'log - delay');
+like($t->read_file('error.log'), qr/limiting requests, dry/, 'log - reject');
+
+like($t->read_file('test.log'), qr|^/:-|m, 'log - not found');
+
+###############################################################################
diff --git a/tests/mail_capability.t b/tests/mail_capability.t
new file mode 100644
index 0000000..2b64c0d
--- /dev/null
+++ b/tests/mail_capability.t
@@ -0,0 +1,228 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for imap/pop3/smtp capabilities.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::IMAP;
+use Test::Nginx::POP3;
+use Test::Nginx::SMTP;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/mail mail_ssl imap pop3 smtp/)
+	->has_daemon('openssl')->plan(17);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+mail {
+    ssl_certificate_key localhost.key;
+    ssl_certificate localhost.crt;
+
+    auth_http  http://127.0.0.1:8080; # unused
+
+    pop3_auth  plain apop cram-md5;
+
+    server {
+        listen     127.0.0.1:8143;
+        protocol   imap;
+        imap_capabilities SEE-THIS;
+    }
+
+    server {
+        listen     127.0.0.1:8144;
+        protocol   imap;
+        starttls   on;
+    }
+
+    server {
+        listen     127.0.0.1:8145;
+        protocol   imap;
+        starttls   only;
+    }
+
+    server {
+        listen     127.0.0.1:8110;
+        protocol   pop3;
+    }
+
+    server {
+        listen     127.0.0.1:8111;
+        protocol   pop3;
+        starttls   on;
+    }
+
+    server {
+        listen     127.0.0.1:8112;
+        protocol   pop3;
+        starttls   only;
+    }
+
+    server {
+        listen     127.0.0.1:8025;
+        protocol   smtp;
+        starttls   off;
+    }
+
+    server {
+        listen     127.0.0.1:8026;
+        protocol   smtp;
+        starttls   on;
+    }
+
+    server {
+        listen     127.0.0.1:8027;
+        protocol   smtp;
+        starttls   only;
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('localhost') {
+	system('openssl req -x509 -new '
+		. "-config $d/openssl.conf -subj /CN=$name/ "
+		. "-out $d/$name.crt -keyout $d/$name.key "
+		. ">>$d/openssl.out 2>&1") == 0
+		or die "Can't create certificate for $name: $!\n";
+}
+
+$t->run();
+
+###############################################################################
+
+# imap, custom capabilities
+
+my $s = Test::Nginx::IMAP->new();
+$s->read();
+
+$s->send('1 CAPABILITY');
+$s->check(qr/^\* CAPABILITY SEE-THIS AUTH=PLAIN/, 'imap capability');
+$s->ok('imap capability completed');
+
+# imap starttls
+
+$s = Test::Nginx::IMAP->new(PeerAddr => '127.0.0.1:' . port(8144));
+$s->read();
+
+$s->send('1 CAPABILITY');
+$s->check(qr/^\* CAPABILITY IMAP4 IMAP4rev1 UIDPLUS AUTH=PLAIN STARTTLS/,
+	'imap capability starttls');
+
+# imap starttls only
+
+$s = Test::Nginx::IMAP->new(PeerAddr => '127.0.0.1:' . port(8145));
+$s->read();
+
+$s->send('1 CAPABILITY');
+$s->check(qr/^\* CAPABILITY IMAP4 IMAP4rev1 UIDPLUS STARTTLS LOGINDISABLED/,
+	'imap capability starttls only');
+
+# pop3
+
+$s = Test::Nginx::POP3->new(PeerAddr => '127.0.0.1:' . port(8110));
+$s->read();
+
+$s->send('CAPA');
+$s->ok('pop3 capa');
+
+my $caps = get_auth_caps($s);
+like($caps, qr/USER/, 'pop3 - user');
+like($caps, qr/SASL (PLAIN LOGIN|LOGIN PLAIN) CRAM-MD5/, 'pop3 - methods');
+unlike($caps, qr/STLS/, 'pop3 - no stls');
+
+# pop3 starttls
+
+$s = Test::Nginx::POP3->new(PeerAddr => '127.0.0.1:' . port(8111));
+$s->read();
+
+$s->send('CAPA');
+
+$caps = get_auth_caps($s);
+like($caps, qr/USER/, 'pop3 starttls - user');
+like($caps, qr/SASL (PLAIN LOGIN|LOGIN PLAIN) CRAM-MD5/,
+	'pop3 starttls - methods');
+like($caps, qr/STLS/, 'pop3 startls - stls');
+
+# pop3 starttls only
+
+$s = Test::Nginx::POP3->new(PeerAddr => '127.0.0.1:' . port(8112));
+$s->read();
+
+$s->send('CAPA');
+
+$caps = get_auth_caps($s);
+unlike($caps, qr/USER/, 'pop3 starttls only - no user');
+unlike($caps, qr/SASL/, 'pop3 starttls only - no methods');
+like($caps, qr/STLS/, 'pop3 startls only - stls');
+
+# smtp
+
+$s = Test::Nginx::SMTP->new(PeerAddr => '127.0.0.1:' . port(8025));
+$s->read();
+
+$s->send('EHLO example.com');
+$s->check(qr/^250 AUTH PLAIN LOGIN\x0d\x0a?/, 'smtp ehlo');
+
+# smtp starttls
+
+$s = Test::Nginx::SMTP->new(PeerAddr => '127.0.0.1:' . port(8026));
+$s->read();
+
+$s->send('EHLO example.com');
+$s->check(qr/^250 STARTTLS/, 'smtp ehlo - starttls');
+
+# smtp starttls only
+
+$s = Test::Nginx::SMTP->new(PeerAddr => '127.0.0.1:' . port(8027));
+$s->read();
+
+$s->send('EHLO example.com');
+$s->check(qr/^250 STARTTLS/, 'smtp ehlo - starttls only');
+
+###############################################################################
+
+sub get_auth_caps {
+	my ($s) = @_;
+	my @meth;
+
+	while ($s->read()) {
+		last if /^\./;
+		push @meth, $1 if /(.*?)\x0d\x0a?/ms;
+	}
+	join ':', @meth;
+}
+
+###############################################################################
diff --git a/tests/mail_error_log.t b/tests/mail_error_log.t
new file mode 100644
index 0000000..013de3d
--- /dev/null
+++ b/tests/mail_error_log.t
@@ -0,0 +1,267 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for nginx mail imap module, error_log directive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use IO::Select;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::IMAP;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+plan(skip_all => 'win32') if $^O eq 'MSWin32';
+
+my $t = Test::Nginx->new()->has(qw/mail imap http rewrite/);
+
+$t->plan(30)->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+error_log %%TESTDIR%%/e_glob.log info;
+error_log %%TESTDIR%%/e_glob2.log info;
+error_log syslog:server=127.0.0.1:%%PORT_8981_UDP%% info;
+
+daemon off;
+
+events {
+}
+
+mail {
+    auth_http  http://127.0.0.1:8080/mail/auth;
+
+    server {
+        listen     127.0.0.1:8143;
+        protocol   imap;
+
+        error_log %%TESTDIR%%/e_debug.log debug;
+        error_log %%TESTDIR%%/e_info.log info;
+        error_log syslog:server=127.0.0.1:%%PORT_8982_UDP%% info;
+        error_log stderr info;
+    }
+
+    server {
+        listen     127.0.0.1:8145;
+        protocol   imap;
+
+        error_log syslog:server=127.0.0.1:%%PORT_8983_UDP%% info;
+    }
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location = /mail/auth {
+            add_header Auth-Status OK;
+            add_header Auth-Server 127.0.0.1;
+            add_header Auth-Port %%PORT_8144%%;
+            add_header Auth-Wait 1;
+            return 204;
+        }
+    }
+}
+
+EOF
+
+open OLDERR, ">&", \*STDERR;
+open STDERR, '>', $t->testdir() . '/stderr' or die "Can't reopen STDERR: $!";
+open my $stderr, '<', $t->testdir() . '/stderr'
+	or die "Can't open stderr file: $!";
+
+$t->run_daemon(\&Test::Nginx::IMAP::imap_test_daemon);
+$t->run_daemon(\&syslog_daemon, port(8981), $t, 's_glob.log');
+$t->run_daemon(\&syslog_daemon, port(8982), $t, 's_info.log');
+
+$t->waitforsocket('127.0.0.1:' . port(8144));
+$t->waitforfile($t->testdir . '/s_glob.log');
+$t->waitforfile($t->testdir . '/s_info.log');
+
+$t->run();
+
+open STDERR, ">&", \*OLDERR;
+
+###############################################################################
+
+my $s = Test::Nginx::IMAP->new();
+$s->ok('greeting');
+
+# error_log levels
+
+SKIP: {
+skip "no --with-debug", 1 unless $t->has_module('--with-debug');
+
+isnt(lines($t, 'e_debug.log', '[debug]'), 0, 'file debug in debug');
+
+}
+
+isnt(lines($t, 'e_info.log', '[info]'), 0, 'file info in info');
+is(lines($t, 'e_info.log', '[debug]'), 0, 'file debug in info');
+isnt(lines($t, 'stderr', '[info]'), 0, 'stderr info in info');
+is(lines($t, 'stderr', '[debug]'), 0, 'stderr debug in info');
+
+# multiple error_log
+
+like($t->read_file('e_glob.log'), qr!nginx/[.0-9]+!, 'error global');
+like($t->read_file('e_glob2.log'), qr!nginx/[.0-9]+!, 'error global 2');
+is_deeply(levels($t, 'e_glob.log'), levels($t, 'e_glob2.log'),
+	'multiple error global');
+
+# syslog
+
+parse_syslog_message('syslog', get_syslog());
+
+is_deeply(levels($t, 's_glob.log'), levels($t, 'e_glob.log'),
+	'global syslog messages');
+is_deeply(levels($t, 's_info.log'), levels($t, 'e_info.log'),
+	'mail syslog messages');
+
+###############################################################################
+
+sub lines {
+	my ($t, $file, $pattern) = @_;
+
+	if ($file eq 'stderr') {
+		return map { $_ =~ /\Q$pattern\E/ } (<$stderr>);
+	}
+
+	my $path = $t->testdir() . '/' . $file;
+	open my $fh, '<', $path or return "$!";
+	my $value = map { $_ =~ /\Q$pattern\E/ } (<$fh>);
+	close $fh;
+	return $value;
+}
+
+sub levels {
+	my ($t, $file) = @_;
+	my %levels_hash;
+
+	map { $levels_hash{$_}++; } ($t->read_file($file) =~ /(\[\w+\])/g);
+
+	return \%levels_hash;
+}
+
+sub get_syslog {
+	my $data = '';
+	my ($s);
+
+	eval {
+		local $SIG{ALRM} = sub { die "timeout\n" };
+		local $SIG{PIPE} = sub { die "sigpipe\n" };
+		alarm(1);
+		$s = IO::Socket::INET->new(
+			Proto => 'udp',
+			LocalAddr => '127.0.0.1:' . port(8983)
+		);
+		alarm(0);
+	};
+	alarm(0);
+	if ($@) {
+		log_in("died: $@");
+		return undef;
+	}
+
+	Test::Nginx::IMAP->new(PeerAddr => '127.0.0.1:' . port(8145))->read();
+
+	IO::Select->new($s)->can_read(1.5);
+	while (IO::Select->new($s)->can_read(0.1)) {
+		my $buffer;
+		sysread($s, $buffer, 4096);
+		$data .= $buffer;
+	}
+	$s->close();
+	return $data;
+}
+
+sub parse_syslog_message {
+	my ($desc, $line) = @_;
+
+	ok($line, $desc);
+
+SKIP: {
+	skip "$desc timeout", 18 unless $line;
+
+	my @months = ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug',
+		'Sep', 'Oct', 'Nov', 'Dec');
+
+	my ($pri, $mon, $mday, $hour, $minute, $sec, $host, $tag, $msg) =
+		$line =~ /^<(\d{1,3})>				# PRI
+			([A-Z][a-z]{2})\s			# mon
+			([ \d]\d)\s(\d{2}):(\d{2}):(\d{2})\s	# date
+			([\S]*)\s				# host
+			(\w{1,32}):\s				# tag
+			(.*)/x;					# MSG
+
+	my $sev = $pri & 0x07;
+	my $fac = ($pri & 0x03f8) >> 3;
+
+	ok(defined($pri), "$desc has PRI");
+	ok($sev >= 0 && $sev <= 7, "$desc valid severity");
+	ok($fac >= 0 && $fac < 24, "$desc valid facility");
+
+	ok(defined($mon), "$desc has month");
+	ok((grep $mon, @months), "$desc valid month");
+
+	ok(defined($mday), "$desc has day");
+	ok($mday <= 31, "$desc valid day");
+
+	ok(defined($hour), "$desc has hour");
+	ok($hour < 24, "$desc valid hour");
+
+	ok(defined($minute), "$desc has minutes");
+	ok($minute < 60, "$desc valid minutes");
+
+	ok(defined($sec), "$desc has seconds");
+	ok($sec < 60, "$desc valid seconds");
+
+	ok(defined($host), "$desc has host");
+	chomp(my $hostname = lc `hostname`);
+	is($host , $hostname, "$desc valid host");
+
+	ok(defined($tag), "$desc has tag");
+	like($tag, qr'\w+', "$desc valid tag");
+
+	ok(length($msg) > 0, "$desc valid CONTENT");
+}
+
+}
+
+###############################################################################
+
+sub syslog_daemon {
+	my ($port, $t, $file) = @_;
+
+	my $s = IO::Socket::INET->new(
+		Proto => 'udp',
+		LocalAddr => "127.0.0.1:$port"
+	);
+
+	open my $fh, '>', $t->testdir() . '/' . $file;
+	select $fh; $| = 1;
+
+	while (1) {
+		my $buffer;
+		$s->recv($buffer, 4096);
+		print $fh $buffer . "\n";
+	}
+}
+
+###############################################################################
diff --git a/tests/mail_imap.t b/tests/mail_imap.t
new file mode 100644
index 0000000..da9e7f8
--- /dev/null
+++ b/tests/mail_imap.t
@@ -0,0 +1,172 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for nginx mail imap module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use MIME::Base64;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::IMAP;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+local $SIG{PIPE} = 'IGNORE';
+
+my $t = Test::Nginx->new()->has(qw/mail imap http rewrite/)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+mail {
+    proxy_pass_error_message  on;
+    auth_http  http://127.0.0.1:8080/mail/auth;
+
+    server {
+        listen     127.0.0.1:8143;
+        protocol   imap;
+        imap_auth  plain cram-md5 external;
+    }
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location = /mail/auth {
+            set $reply ERROR;
+            set $passw "";
+
+            if ($http_auth_smtp_to ~ example.com) {
+                set $reply OK;
+            }
+
+            set $userpass "$http_auth_user:$http_auth_pass";
+            if ($userpass ~ '^test@example.com:secret$') {
+                set $reply OK;
+            }
+
+            set $userpass "$http_auth_user:$http_auth_salt:$http_auth_pass";
+            if ($userpass ~ '^test@example.com:<.*@.*>:0{32}$') {
+                set $reply OK;
+                set $passw secret;
+            }
+
+            set $userpass "$http_auth_method:$http_auth_user:$http_auth_pass";
+            if ($userpass ~ '^external:test@example.com:$') {
+                set $reply OK;
+                set $passw secret;
+            }
+
+            add_header Auth-Status $reply;
+            add_header Auth-Server 127.0.0.1;
+            add_header Auth-Port %%PORT_8144%%;
+            add_header Auth-Pass $passw;
+            add_header Auth-Wait 1;
+            return 204;
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&Test::Nginx::IMAP::imap_test_daemon);
+$t->run()->plan(14);
+
+$t->waitforsocket('127.0.0.1:' . port(8144));
+
+###############################################################################
+
+my $s = Test::Nginx::IMAP->new();
+$s->ok('greeting');
+
+# bad auth
+
+$s->send('1 AUTHENTICATE');
+$s->check(qr/^\S+ BAD/, 'auth without arguments');
+
+# auth plain
+
+$s->send('1 AUTHENTICATE PLAIN ' . encode_base64("\0test\@example.com\0bad", ''));
+$s->check(qr/^\S+ NO/, 'auth plain with bad password');
+
+$s->send('1 AUTHENTICATE PLAIN ' . encode_base64("\0test\@example.com\0secret", ''));
+$s->ok('auth plain');
+
+# auth login simple
+
+$s = Test::Nginx::IMAP->new();
+$s->read();
+
+$s->send('1 AUTHENTICATE LOGIN');
+$s->check(qr/\+ VXNlcm5hbWU6/, 'auth login username challenge');
+
+$s->send(encode_base64('test@example.com', ''));
+$s->check(qr/\+ UGFzc3dvcmQ6/, 'auth login password challenge');
+
+$s->send(encode_base64('secret', ''));
+$s->ok('auth login simple');
+
+# auth login with username
+
+$s = Test::Nginx::IMAP->new();
+$s->read();
+
+$s->send('1 AUTHENTICATE LOGIN ' . encode_base64('test@example.com', ''));
+$s->check(qr/\+ UGFzc3dvcmQ6/, 'auth login with username password challenge');
+
+$s->send(encode_base64('secret', ''));
+$s->ok('auth login with username');
+
+# auth cram-md5
+
+$s = Test::Nginx::IMAP->new();
+$s->read();
+
+$s->send('1 AUTHENTICATE CRAM-MD5');
+$s->check(qr/\+ /, 'auth cram-md5 challenge');
+
+$s->send(encode_base64('test@example.com ' . ('0' x 32), ''));
+$s->ok('auth cram-md5');
+
+# auth external
+
+$s = Test::Nginx::IMAP->new();
+$s->read();
+
+$s->send('1 AUTHENTICATE EXTERNAL');
+$s->check(qr/\+ VXNlcm5hbWU6/, 'auth external challenge');
+
+$s->send(encode_base64('test@example.com', ''));
+$s->ok('auth external');
+
+# auth external with username
+
+$s = Test::Nginx::IMAP->new();
+$s->read();
+
+$s->send('1 AUTHENTICATE EXTERNAL ' . encode_base64('test@example.com', ''));
+$s->ok('auth external with username');
+
+###############################################################################
diff --git a/tests/mail_imap_ssl.t b/tests/mail_imap_ssl.t
new file mode 100644
index 0000000..2089a7f
--- /dev/null
+++ b/tests/mail_imap_ssl.t
@@ -0,0 +1,226 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for nginx mail imap module with ssl.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use MIME::Base64;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::IMAP;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require IO::Socket::SSL; };
+plan(skip_all => 'IO::Socket::SSL not installed') if $@;
+eval { IO::Socket::SSL::SSL_VERIFY_NONE(); };
+plan(skip_all => 'IO::Socket::SSL too old') if $@;
+
+local $SIG{PIPE} = 'IGNORE';
+
+my $t = Test::Nginx->new()->has(qw/mail mail_ssl imap http rewrite/)
+	->has_daemon('openssl')->plan(12)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+mail {
+    proxy_pass_error_message  on;
+    auth_http  http://127.0.0.1:8080/mail/auth;
+    auth_http_pass_client_cert on;
+
+    ssl_certificate_key 1.example.com.key;
+    ssl_certificate 1.example.com.crt;
+
+    server {
+        listen     127.0.0.1:8142;
+        protocol   imap;
+    }
+
+    server {
+        listen     127.0.0.1:8143 ssl;
+        protocol   imap;
+
+        ssl_verify_client on;
+        ssl_client_certificate 2.example.com.crt;
+    }
+
+    server {
+        listen     127.0.0.1:8145 ssl;
+        protocol   imap;
+
+        ssl_verify_client optional;
+        ssl_client_certificate 2.example.com.crt;
+    }
+
+    server {
+        listen     127.0.0.1:8146 ssl;
+        protocol   imap;
+
+        ssl_verify_client optional;
+        ssl_client_certificate 2.example.com.crt;
+        ssl_trusted_certificate 3.example.com.crt;
+    }
+
+    server {
+        listen     127.0.0.1:8147 ssl;
+        protocol   imap;
+
+        ssl_verify_client optional_no_ca;
+        ssl_client_certificate 2.example.com.crt;
+    }
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    log_format  test  '$http_auth_ssl:$http_auth_ssl_verify:'
+                      '$http_auth_ssl_subject:$http_auth_ssl_issuer:'
+                      '$http_auth_ssl_serial:$http_auth_ssl_fingerprint:'
+                      '$http_auth_ssl_cert:$http_auth_pass';
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location = /mail/auth {
+            access_log auth.log test;
+
+            add_header Auth-Status OK;
+            add_header Auth-Server 127.0.0.1;
+            add_header Auth-Port %%PORT_8144%%;
+            add_header Auth-Wait 1;
+            return 204;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('1.example.com', '2.example.com', '3.example.com') {
+	system('openssl req -x509 -new '
+		. "-config $d/openssl.conf -subj /CN=$name/ "
+		. "-out $d/$name.crt -keyout $d/$name.key "
+		. ">>$d/openssl.out 2>&1") == 0
+		or die "Can't create certificate for $name: $!\n";
+}
+
+$t->run_daemon(\&Test::Nginx::IMAP::imap_test_daemon);
+$t->run()->waitforsocket('127.0.0.1:' . port(8144));
+
+###############################################################################
+
+my $cred = sub { encode_base64("\0test\@example.com\0$_[0]", '') };
+my %ssl = (
+	SSL => 1,
+	SSL_verify_mode => IO::Socket::SSL::SSL_VERIFY_NONE(),
+	SSL_error_trap => sub { die $_[1] },
+);
+
+# no ssl connection
+
+my $s = Test::Nginx::IMAP->new(PeerAddr => '127.0.0.1:' . port(8142));
+$s->ok('plain connection');
+$s->send('1 AUTHENTICATE PLAIN ' . $cred->("s1"));
+
+# no cert
+
+$s = Test::Nginx::IMAP->new(PeerAddr => '127.0.0.1:' . port(8143), %ssl);
+$s->check(qr/BYE No required SSL certificate/, 'no cert');
+
+# no cert with ssl_verify_client optional
+
+$s = Test::Nginx::IMAP->new(PeerAddr => '127.0.0.1:' . port(8145), %ssl);
+$s->ok('no optional cert');
+$s->send('1 AUTHENTICATE PLAIN ' . $cred->("s2"));
+
+# wrong cert with ssl_verify_client optional
+
+$s = Test::Nginx::IMAP->new(
+	PeerAddr => '127.0.0.1:' . port(8145),
+	SSL_cert_file => "$d/1.example.com.crt",
+	SSL_key_file => "$d/1.example.com.key",
+	%ssl,
+);
+$s->check(qr/BYE SSL certificate error/, 'bad optional cert');
+
+# wrong cert with ssl_verify_client optional_no_ca
+
+$s = Test::Nginx::IMAP->new(
+	PeerAddr => '127.0.0.1:' . port(8147),
+	SSL_cert_file => "$d/1.example.com.crt",
+	SSL_key_file => "$d/1.example.com.key",
+	%ssl,
+);
+$s->ok('bad optional_no_ca cert');
+$s->send('1 AUTHENTICATE PLAIN ' . $cred->("s3"));
+
+# matching cert with ssl_verify_client optional
+
+$s = Test::Nginx::IMAP->new(
+	PeerAddr => '127.0.0.1:' . port(8145),
+	SSL_cert_file => "$d/2.example.com.crt",
+	SSL_key_file => "$d/2.example.com.key",
+	%ssl,
+);
+$s->ok('good cert');
+$s->send('1 AUTHENTICATE PLAIN ' . $cred->("s4"));
+
+# trusted cert with ssl_verify_client optional
+
+$s = Test::Nginx::IMAP->new(
+	PeerAddr => '127.0.0.1:' . port(8146),
+	SSL_cert_file => "$d/3.example.com.crt",
+	SSL_key_file => "$d/3.example.com.key",
+	%ssl,
+);
+$s->ok('trusted cert');
+$s->send('1 AUTHENTICATE PLAIN ' . $cred->("s5"));
+$s->read();
+
+# test auth_http request header fields with access_log
+
+$t->stop();
+
+my $f = $t->read_file('auth.log');
+
+like($f, qr/^-:-:-:-:-:-:-\x0d?\x0a?:s1$/m, 'log - plain connection');
+like($f, qr/^on:NONE:-:-:-:-:-\x0d?\x0a?:s2$/m, 'log - no cert');
+like($f, qr!^on:FAILED(?:.*):(/?CN=1.example.com):\1:\w+:\w+:[^:]+:s3$!m,
+	'log - bad cert');
+like($f, qr!^on:SUCCESS:(/?CN=2.example.com):\1:\w+:\w+:[^:]+:s4$!m,
+	'log - good cert');
+like($f, qr!^on:SUCCESS:(/?CN=3.example.com):\1:\w+:\w+:[^:]+:s5$!m,
+	'log - trusted cert');
+
+###############################################################################
diff --git a/tests/mail_pop3.t b/tests/mail_pop3.t
new file mode 100644
index 0000000..538acb6
--- /dev/null
+++ b/tests/mail_pop3.t
@@ -0,0 +1,212 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for nginx mail pop3 module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use MIME::Base64;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::POP3;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+local $SIG{PIPE} = 'IGNORE';
+
+my $t = Test::Nginx->new()->has(qw/mail pop3 http rewrite/)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+mail {
+    proxy_pass_error_message  on;
+    auth_http  http://127.0.0.1:8080/mail/auth;
+
+    server {
+        listen     127.0.0.1:8110;
+        protocol   pop3;
+        pop3_auth  plain apop cram-md5 external;
+    }
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location = /mail/auth {
+            set $reply ERROR;
+            set $passw "";
+
+            if ($http_auth_smtp_to ~ example.com) {
+                set $reply OK;
+            }
+
+            set $userpass "$http_auth_user:$http_auth_pass";
+            if ($userpass ~ '^test@example.com:secret$') {
+                set $reply OK;
+            }
+
+            set $userpass "$http_auth_user:$http_auth_salt:$http_auth_pass";
+            if ($userpass ~ '^test@example.com:<.*@.*>:0{32}$') {
+                set $reply OK;
+                set $passw secret;
+            }
+
+            set $userpass "$http_auth_method:$http_auth_user:$http_auth_pass";
+            if ($userpass ~ '^external:test@example.com:$') {
+                set $reply OK;
+                set $passw secret;
+            }
+
+            add_header Auth-Status $reply;
+            add_header Auth-Server 127.0.0.1;
+            add_header Auth-Port %%PORT_8111%%;
+            add_header Auth-Pass $passw;
+            add_header Auth-Wait 1;
+            return 204;
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&Test::Nginx::POP3::pop3_test_daemon);
+$t->run()->plan(20);
+
+$t->waitforsocket('127.0.0.1:' . port(8111));
+
+###############################################################################
+
+my $s = Test::Nginx::POP3->new();
+$s->ok('greeting');
+
+# user / pass
+
+$s->send('USER test@example.com');
+$s->ok('user');
+
+$s->send('PASS secret');
+$s->ok('pass');
+
+# apop
+
+$s = Test::Nginx::POP3->new();
+$s->check(qr/<.*\@.*>/, 'apop salt');
+
+$s->send('APOP test@example.com ' . ('1' x 32));
+$s->check(qr/^-ERR/, 'apop error');
+
+$s->send('APOP test@example.com ' . ('0' x 32));
+$s->ok('apop');
+
+# auth capabilities
+
+$s = Test::Nginx::POP3->new();
+$s->read();
+
+$s->send('AUTH');
+$s->ok('auth');
+
+is(get_auth_caps($s), 'PLAIN:LOGIN:CRAM-MD5:EXTERNAL', 'auth capabilities');
+
+# auth plain
+
+$s = Test::Nginx::POP3->new();
+$s->read();
+
+$s->send('AUTH PLAIN ' . encode_base64("\0test\@example.com\0bad", ''));
+$s->check(qr/^-ERR/, 'auth plain with bad password');
+
+$s->send('AUTH PLAIN ' . encode_base64("\0test\@example.com\0secret", ''));
+$s->ok('auth plain');
+
+# auth login simple
+
+$s = Test::Nginx::POP3->new();
+$s->read();
+
+$s->send('AUTH LOGIN');
+$s->check(qr/\+ VXNlcm5hbWU6/, 'auth login username challenge');
+
+$s->send(encode_base64('test@example.com', ''));
+$s->check(qr/\+ UGFzc3dvcmQ6/, 'auth login password challenge');
+
+$s->send(encode_base64('secret', ''));
+$s->ok('auth login simple');
+
+# auth login with username
+
+$s = Test::Nginx::POP3->new();
+$s->read();
+
+$s->send('AUTH LOGIN ' . encode_base64('test@example.com', ''));
+$s->check(qr/\+ UGFzc3dvcmQ6/, 'auth login with username password challenge');
+
+$s->send(encode_base64('secret', ''));
+$s->ok('auth login with username');
+
+# auth cram-md5
+
+$s = Test::Nginx::POP3->new();
+$s->read();
+
+$s->send('AUTH CRAM-MD5');
+$s->check(qr/\+ /, 'auth cram-md5 challenge');
+
+$s->send(encode_base64('test@example.com ' . ('0' x 32), ''));
+$s->ok('auth cram-md5');
+
+# auth external
+
+$s = Test::Nginx::POP3->new();
+$s->read();
+
+$s->send('AUTH EXTERNAL');
+$s->check(qr/\+ VXNlcm5hbWU6/, 'auth external challenge');
+
+$s->send(encode_base64('test@example.com', ''));
+$s->ok('auth external');
+
+# auth external with username
+
+$s = Test::Nginx::POP3->new();
+$s->read();
+
+$s->send('AUTH EXTERNAL ' . encode_base64('test@example.com', ''));
+$s->ok('auth external with username');
+
+###############################################################################
+
+sub get_auth_caps {
+	my ($s) = @_;
+	my @meth;
+
+	while ($s->read()) {
+		last if /^\./;
+		push @meth, $1 if /(.*?)\x0d\x0a?/ms;
+	}
+	join ':', @meth;
+}
+
+###############################################################################
diff --git a/tests/mail_resolver.t b/tests/mail_resolver.t
new file mode 100644
index 0000000..65e2033
--- /dev/null
+++ b/tests/mail_resolver.t
@@ -0,0 +1,452 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for mail resolver.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::SMTP;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require IO::Socket::SSL; };
+plan(skip_all => 'IO::Socket::SSL not installed') if $@;
+eval { IO::Socket::SSL::SSL_VERIFY_NONE(); };
+plan(skip_all => 'IO::Socket::SSL too old') if $@;
+
+local $SIG{PIPE} = 'IGNORE';
+
+my $t = Test::Nginx->new()->has(qw/mail mail_ssl smtp http rewrite/)
+	->has_daemon('openssl')->plan(11)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+mail {
+    auth_http    http://127.0.0.1:8080/mail/auth;
+    smtp_auth    none;
+    server_name  locahost;
+
+    # prevent useless resend
+    resolver_timeout 2s;
+
+    server {
+        listen    127.0.0.1:8025;
+        protocol  smtp;
+        resolver  127.0.0.1:%%PORT_8981_UDP%%
+                  127.0.0.1:%%PORT_8982_UDP%%
+                  127.0.0.1:%%PORT_8983_UDP%%;
+    }
+
+    server {
+        listen    127.0.0.1:8027;
+        protocol  smtp;
+        resolver  127.0.0.1:%%PORT_8982_UDP%%;
+    }
+
+    server {
+        listen    127.0.0.1:8028;
+        protocol  smtp;
+        resolver  127.0.0.1:%%PORT_8983_UDP%%;
+        resolver_timeout 1s;
+    }
+
+    server {
+        listen    127.0.0.1:8029;
+        protocol  smtp;
+        resolver  127.0.0.1:%%PORT_8984_UDP%%;
+    }
+
+    server {
+        listen    127.0.0.1:8030;
+        protocol  smtp;
+        resolver  127.0.0.1:%%PORT_8985_UDP%%;
+    }
+
+    server {
+        listen    127.0.0.1:8031;
+        protocol  smtp;
+        resolver  127.0.0.1:%%PORT_8986_UDP%%;
+        resolver_timeout 1s;
+    }
+
+    server {
+        listen    127.0.0.1:8032;
+        protocol  smtp;
+        resolver  127.0.0.1:%%PORT_8987_UDP%%;
+    }
+
+    server {
+        ssl_certificate_key localhost.key;
+        ssl_certificate localhost.crt;
+
+        listen    127.0.0.1:8033 ssl;
+        protocol  smtp;
+        resolver  127.0.0.1:%%PORT_8983_UDP%%;
+    }
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location = /mail/auth {
+            set $reply $http_client_host;
+
+            if ($http_client_host !~ UNAVAIL) {
+                set $reply OK;
+            }
+
+            add_header Auth-Status $reply;
+            add_header Auth-Server 127.0.0.1;
+            add_header Auth-Port %%PORT_8026%%;
+            return 204;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('localhost') {
+	system('openssl req -x509 -new '
+		. "-config $d/openssl.conf -subj /CN=$name/ "
+		. "-out $d/$name.crt -keyout $d/$name.key "
+		. ">>$d/openssl.out 2>&1") == 0
+		or die "Can't create certificate for $name: $!\n";
+}
+
+$t->run_daemon(\&Test::Nginx::SMTP::smtp_test_daemon);
+$t->run_daemon(\&dns_daemon, port($_), $t) foreach (8981 .. 8987);
+
+$t->run();
+
+$t->waitforsocket('127.0.0.1:' . port(8026));
+$t->waitforfile($t->testdir . '/' . port($_)) foreach (8981 .. 8987);
+
+###############################################################################
+
+# PTR
+
+my $s = Test::Nginx::SMTP->new();
+my $s2 = Test::Nginx::SMTP->new();
+$s->read();
+$s->send('EHLO example.com');
+$s->read();
+$s->send('MAIL FROM:<test@example.com> SIZE=100');
+$s->read();
+
+$s->send('RCPT TO:<test@example.com>');
+$s->ok('PTR');
+
+$s->send('QUIT');
+$s->read();
+
+$s2->read();
+$s2->send('EHLO example.com');
+$s2->ok('PTR waiting');
+
+# Cached PTR prevents from querying bad ns on port 8983
+
+$s = Test::Nginx::SMTP->new();
+$s->read();
+$s->send('EHLO example.com');
+$s->read();
+$s->send('MAIL FROM:<test@example.com> SIZE=100');
+$s->read();
+
+$s->send('RCPT TO:<test@example.com>');
+$s->ok('PTR cached');
+
+$s->send('QUIT');
+$s->read();
+
+# SERVFAIL
+
+$s = Test::Nginx::SMTP->new(PeerAddr => '127.0.0.1:' . port(8027));
+$s->read();
+$s->send('EHLO example.com');
+$s->read();
+$s->send('MAIL FROM:<test@example.com> SIZE=100');
+$s->read();
+
+$s->send('RCPT TO:<test@example.com>');
+$s->check(qr/TEMPUNAVAIL/, 'PTR SERVFAIL');
+
+$s->send('QUIT');
+$s->read();
+
+# PTR with zero length RDATA
+
+$s = Test::Nginx::SMTP->new(PeerAddr => '127.0.0.1:' . port(8028));
+$s2 = Test::Nginx::SMTP->new(PeerAddr => '127.0.0.1:' . port(8028));
+$s->read();
+$s->send('EHLO example.com');
+$s->read();
+$s->send('MAIL FROM:<test@example.com> SIZE=100');
+$s->read();
+
+$s->send('RCPT TO:<test@example.com>');
+$s->check(qr/TEMPUNAVAIL/, 'PTR empty');
+
+$s->send('QUIT');
+$s->read();
+
+# resolver timeout is set
+
+$s2->read();
+$s2->send('EHLO example.com');
+$s2->ok('PTR empty waiting');
+
+# CNAME
+
+TODO: {
+local $TODO = 'support for CNAME RR';
+
+$s = Test::Nginx::SMTP->new(PeerAddr => '127.0.0.1:' . port(8029));
+$s->read();
+$s->send('EHLO example.com');
+$s->read();
+$s->send('MAIL FROM:<test@example.com> SIZE=100');
+$s->read();
+
+$s->send('RCPT TO:<test@example.com>');
+$s->ok('CNAME');
+
+$s->send('QUIT');
+$s->read();
+
+}
+
+# uncompressed answer
+
+$s = Test::Nginx::SMTP->new(PeerAddr => '127.0.0.1:' . port(8030));
+$s->read();
+$s->send('EHLO example.com');
+$s->read();
+$s->send('MAIL FROM:<test@example.com> SIZE=100');
+$s->read();
+
+$s->send('RCPT TO:<test@example.com>');
+$s->ok('uncompressed PTR');
+
+$s->send('QUIT');
+$s->read();
+
+$s = Test::Nginx::SMTP->new(PeerAddr => '127.0.0.1:' . port(8031));
+$s->read();
+$s->send('EHLO example.com');
+$s->read();
+$s->send('MAIL FROM:<test@example.com> SIZE=100');
+$s->read();
+
+$s->send('RCPT TO:<test@example.com>');
+$s->check(qr/TEMPUNAVAIL/, 'PTR type');
+
+$s->send('QUIT');
+$s->read();
+
+# CNAME and PTR in one answer section
+
+$s = Test::Nginx::SMTP->new(PeerAddr => '127.0.0.1:' . port(8032));
+$s->read();
+$s->send('EHLO example.com');
+$s->read();
+$s->send('MAIL FROM:<test@example.com> SIZE=100');
+$s->read();
+
+$s->send('RCPT TO:<test@example.com>');
+$s->ok('CNAME with PTR');
+
+$s->send('QUIT');
+$s->read();
+
+# before 1.17.3, read event while in resolving resulted in duplicate resolving
+
+TODO: {
+todo_skip 'leaves coredump', 1 unless $ENV{TEST_NGINX_UNSAFE}
+	or $t->has_version('1.17.3');
+
+my %ssl = (
+	SSL => 1,
+	SSL_verify_mode => IO::Socket::SSL::SSL_VERIFY_NONE(),
+	SSL_error_trap => sub { die $_[1] },
+);
+
+$s = Test::Nginx::SMTP->new(PeerAddr => '127.0.0.1:' . port(8033), %ssl);
+$s->send('EHLO example.com');
+$s->read();
+$s->send('MAIL FROM:<test@example.com> SIZE=100');
+$s->read();
+$s->read();
+
+$s->send('RCPT TO:<test@example.com>');
+$s->check(qr/TEMPUNAVAIL/, 'PTR SSL empty');
+
+$s->send('QUIT');
+$s->read();
+
+}
+
+###############################################################################
+
+sub reply_handler {
+	my ($recv_data, $port) = @_;
+
+	my (@name, @rdata);
+
+	use constant NOERROR	=> 0;
+	use constant SERVFAIL	=> 2;
+	use constant NXDOMAIN	=> 3;
+
+	use constant A		=> 1;
+	use constant CNAME	=> 5;
+	use constant PTR	=> 12;
+	use constant DNAME	=> 39;
+
+	use constant IN		=> 1;
+
+	# default values
+
+	my ($hdr, $rcode, $ttl) = (0x8180, NOERROR, 3600);
+
+	# decode name
+
+	my ($len, $offset) = (undef, 12);
+	while (1) {
+		$len = unpack("\@$offset C", $recv_data);
+		last if $len == 0;
+		$offset++;
+		push @name, unpack("\@$offset A$len", $recv_data);
+		$offset += $len;
+	}
+
+	$offset -= 1;
+	my ($id, $type, $class) = unpack("n x$offset n2", $recv_data);
+
+	my $name = join('.', @name);
+	if ($name eq 'a.example.net' && $type == A) {
+		push @rdata, rd_addr($ttl, '127.0.0.1');
+
+	} elsif ($name eq '1.0.0.127.in-addr.arpa' && $type == PTR) {
+		if ($port == port(8981)) {
+			push @rdata, rd_name(PTR, $ttl, 'a.example.net');
+
+		} elsif ($port == port(8982)) {
+			$rcode = SERVFAIL;
+
+		} elsif ($port == port(8983)) {
+			# zero length RDATA
+
+			push @rdata, pack("n3N n", 0xc00c, PTR, IN, $ttl, 0);
+
+		} elsif ($port == port(8984)) {
+			# PTR answered with CNAME
+
+			push @rdata, rd_name(CNAME, $ttl,
+				'1.1.0.0.127.in-addr.arpa');
+
+		} elsif ($port == port(8985)) {
+			# uncompressed answer
+
+			push @rdata, pack("(C/a*)6x n2N n(C/a*)3x",
+				('1', '0', '0', '127', 'in-addr', 'arpa'),
+				PTR, IN, $ttl, 15, ('a', 'example', 'net'));
+
+		} elsif ($port == port(8986)) {
+			push @rdata, rd_name(DNAME, $ttl, 'a.example.net');
+
+		} elsif ($port == port(8987)) {
+			# PTR answered with CNAME+PTR
+
+			push @rdata, rd_name(CNAME, $ttl,
+				'1.1.0.0.127.in-addr.arpa');
+			push @rdata, pack("n3N n(C/a*)3 x", 0xc034,
+				PTR, IN, $ttl, 15, ('a', 'example', 'net'));
+		}
+
+	} elsif ($name eq '1.1.0.0.127.in-addr.arpa' && $type == PTR) {
+		push @rdata, rd_name(PTR, $ttl, 'a.example.net');
+	}
+
+	$len = @name;
+	pack("n6 (C/a*)$len x n2", $id, $hdr | $rcode, 1, scalar @rdata,
+		0, 0, @name, $type, $class) . join('', @rdata);
+}
+
+sub rd_name {
+	my ($type, $ttl, $name) = @_;
+	my ($rdlen, @rdname);
+
+	@rdname = split /\./, $name;
+	$rdlen = length(join '', @rdname) + @rdname + 1;
+	pack("n3N n(C/a*)* x", 0xc00c, $type, IN, $ttl, $rdlen, @rdname);
+}
+
+sub rd_addr {
+	my ($ttl, $addr) = @_;
+
+	my $code = 'split(/\./, $addr)';
+
+	# use a special pack string to not zero pad
+
+	return pack 'n3N', 0xc00c, A, IN, $ttl if $addr eq '';
+
+	pack 'n3N nC4', 0xc00c, A, IN, $ttl, eval "scalar $code", eval($code);
+}
+
+sub dns_daemon {
+	my ($port, $t) = @_;
+
+	my ($data, $recv_data);
+	my $socket = IO::Socket::INET->new(
+		LocalAddr => '127.0.0.1',
+		LocalPort => $port,
+		Proto => 'udp',
+	)
+		or die "Can't create listening socket: $!\n";
+
+	# signal we are ready
+
+	open my $fh, '>', $t->testdir() . '/' . $port;
+	close $fh;
+
+	while (1) {
+		$socket->recv($recv_data, 65536);
+		$data = reply_handler($recv_data, $port);
+		$socket->send($data);
+	}
+}
+
+###############################################################################
diff --git a/tests/mail_smtp.t b/tests/mail_smtp.t
new file mode 100644
index 0000000..98065f7
--- /dev/null
+++ b/tests/mail_smtp.t
@@ -0,0 +1,268 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for nginx mail smtp module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use MIME::Base64;
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::SMTP;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+local $SIG{PIPE} = 'IGNORE';
+
+my $t = Test::Nginx->new()->has(qw/mail smtp http rewrite/)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+mail {
+    proxy_pass_error_message  on;
+    auth_http  http://127.0.0.1:8080/mail/auth;
+    xclient    off;
+
+    server {
+        listen     127.0.0.1:8025;
+        protocol   smtp;
+        smtp_auth  login plain none cram-md5 external;
+    }
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location = /mail/auth {
+            set $reply ERROR;
+
+            if ($http_auth_smtp_to ~ example.com) {
+                set $reply OK;
+            }
+
+            set $userpass "$http_auth_user:$http_auth_pass";
+            if ($userpass ~ '^test@example.com:secret$') {
+                set $reply OK;
+            }
+
+            set $userpass "$http_auth_user:$http_auth_salt:$http_auth_pass";
+            if ($userpass ~ '^test@example.com:<.*@.*>:0{32}$') {
+                set $reply OK;
+            }
+
+            set $userpass "$http_auth_method:$http_auth_user:$http_auth_pass";
+            if ($userpass ~ '^external:test@example.com:$') {
+                set $reply OK;
+            }
+
+            add_header Auth-Status $reply;
+            add_header Auth-Server 127.0.0.1;
+            add_header Auth-Port %%PORT_8026%%;
+            add_header Auth-Wait 1;
+            return 204;
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&Test::Nginx::SMTP::smtp_test_daemon);
+$t->run()->plan(30);
+
+$t->waitforsocket('127.0.0.1:' . port(8026));
+
+###############################################################################
+
+my $s = Test::Nginx::SMTP->new();
+$s->check(qr/^220 /, "greeting");
+
+$s->send('EHLO example.com');
+$s->check(qr/^250 /, "ehlo");
+
+$s->send('AUTH PLAIN ' . encode_base64("\0test\@example.com\0bad", ''));
+$s->check(qr/^5.. /, 'auth plain with bad password');
+
+$s->send('AUTH PLAIN ' . encode_base64("\0test\@example.com\0secret", ''));
+$s->authok('auth plain');
+
+# We are talking to backend from this point
+
+$s->send('MAIL FROM:<test@example.com> SIZE=100');
+$s->ok('mail from after auth');
+
+$s->send('RSET');
+$s->ok('rset');
+
+$s->send('MAIL FROM:<test@xn--e1afmkfd.xn--80akhbyknj4f> SIZE=100');
+$s->ok("idn mail from (example.test in russian)");
+
+$s->send('QUIT');
+$s->ok("quit");
+
+# Try auth login in simple form
+
+$s = Test::Nginx::SMTP->new();
+$s->read();
+$s->send('EHLO example.com');
+$s->read();
+
+$s->send('AUTH LOGIN');
+$s->check(qr/^334 VXNlcm5hbWU6/, 'auth login simple username challenge');
+$s->send(encode_base64('test@example.com', ''));
+$s->check(qr/^334 UGFzc3dvcmQ6/, 'auth login simple password challenge');
+$s->send(encode_base64('secret', ''));
+$s->authok('auth login simple');
+
+# Try auth plain with username.  Details:
+#
+# [MS-XLOGIN]: SMTP Protocol AUTH LOGIN Extension Specification
+# http://download.microsoft.com/download/5/D/D/5DD33FDF-91F5-496D-9884-0A0B0EE698BB/%5BMS-XLOGIN%5D.pdf
+
+$s = Test::Nginx::SMTP->new();
+$s->read();
+$s->send('EHLO example.com');
+$s->read();
+
+$s->send('AUTH LOGIN ' . encode_base64('test@example.com', ''));
+$s->check(qr/^334 UGFzc3dvcmQ6/, 'auth login with username password challenge');
+$s->send(encode_base64('secret', ''));
+$s->authok('auth login with username');
+
+# Try auth cram-md5
+
+$s = Test::Nginx::SMTP->new();
+$s->read();
+$s->send('EHLO example.com');
+$s->read();
+
+$s->send('AUTH CRAM-MD5');
+$s->check(qr/^334 /, 'auth cram-md5 challenge');
+$s->send(encode_base64('test@example.com ' . ('0' x 32), ''));
+$s->authok('auth cram-md5');
+
+# Try auth external
+
+$s = Test::Nginx::SMTP->new();
+$s->read();
+$s->send('EHLO example.com');
+$s->read();
+
+$s->send('AUTH EXTERNAL');
+$s->check(qr/^334 VXNlcm5hbWU6/, 'auth external challenge');
+$s->send(encode_base64('test@example.com', ''));
+$s->ok('auth external');
+
+# Try auth external with username
+
+$s = Test::Nginx::SMTP->new();
+$s->read();
+$s->send('EHLO example.com');
+$s->read();
+
+$s->send('AUTH EXTERNAL ' . encode_base64('test@example.com', ''));
+$s->ok('auth external with username');
+
+# Try auth plain with pipelining
+
+$s = Test::Nginx::SMTP->new();
+$s->read();
+$s->send('EHLO example.com');
+$s->read();
+
+$s->send('INVALID COMMAND WITH ARGUMENTS' . CRLF
+	. 'RSET');
+$s->read();
+$s->ok('pipelined rset after invalid command');
+
+$s->send('AUTH PLAIN '
+	. encode_base64("\0test\@example.com\0bad", '') . CRLF
+	. 'MAIL FROM:<test@example.com> SIZE=100');
+$s->read();
+$s->ok('mail from after failed pipelined auth');
+
+$s->send('AUTH PLAIN '
+	. encode_base64("\0test\@example.com\0secret", '') . CRLF
+	. 'MAIL FROM:<test@example.com> SIZE=100');
+$s->read();
+$s->ok('mail from after pipelined auth');
+
+# Try auth none
+
+$s = Test::Nginx::SMTP->new();
+$s->read();
+$s->send('EHLO example.com');
+$s->read();
+
+$s->send('MAIL FROM:<test@example.com> SIZE=100');
+$s->ok('auth none - mail from');
+
+$s->send('RCPT TO:<test@example.com>');
+$s->ok('auth none - rcpt to');
+
+$s->send('RSET');
+$s->ok('auth none - rset, should go to backend');
+
+# Auth none with pipelining
+
+$s = Test::Nginx::SMTP->new();
+$s->read();
+$s->send('EHLO example.com');
+$s->read();
+
+$s->send('MAIL FROM:<test@example.com> SIZE=100' . CRLF
+	. 'RCPT TO:<test@example.com>' . CRLF
+	. 'RSET');
+
+$s->ok('pipelined mail from');
+$s->ok('pipelined rcpt to');
+$s->ok('pipelined rset');
+
+# Connection must stay even if error returned to rcpt to command
+
+$s = Test::Nginx::SMTP->new();
+$s->read();
+$s->send('EHLO example.com');
+$s->read();
+
+$s->send('MAIL FROM:<test@example.com> SIZE=100');
+$s->read(); # skip mail from reply
+
+$s->send('RCPT TO:<example.com>');
+$s->check(qr/^5.. /, "bad rcpt to");
+
+$s->send('RCPT TO:<test@example.com>');
+$s->ok('good rcpt to');
+
+# Make sure command split into many packets processed correctly
+
+$s = Test::Nginx::SMTP->new();
+$s->read();
+
+$s->print('HEL');
+$s->send('O example.com');
+$s->ok('split command');
+
+###############################################################################
diff --git a/tests/mail_smtp_greeting_delay.t b/tests/mail_smtp_greeting_delay.t
new file mode 100644
index 0000000..515dcb8
--- /dev/null
+++ b/tests/mail_smtp_greeting_delay.t
@@ -0,0 +1,59 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::SMTP;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+local $SIG{PIPE} = 'IGNORE';
+
+my $t = Test::Nginx->new()->has(qw/mail smtp/)->plan(2)
+	->write_file_expand('nginx.conf', <<'EOF')->run();
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+mail {
+    proxy_pass_error_message  on;
+    auth_http  http://127.0.0.1:8080/mail/auth;
+    xclient    off;
+
+    server {
+        listen     127.0.0.1:8025;
+        protocol   smtp;
+        smtp_greeting_delay  1s;
+    }
+}
+
+EOF
+
+###############################################################################
+
+# With smtp_greeting_delay session expected to be closed after first error
+# message if client sent something before greeting.
+
+my $s = Test::Nginx::SMTP->new();
+$s->send('HELO example.com');
+$s->check(qr/^5.. /, "command before greeting - session must be rejected");
+ok($s->eof(), "session have to be closed");
+
+###############################################################################
diff --git a/tests/mail_smtp_xclient.t b/tests/mail_smtp_xclient.t
new file mode 100644
index 0000000..3ee861b
--- /dev/null
+++ b/tests/mail_smtp_xclient.t
@@ -0,0 +1,141 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use MIME::Base64;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::SMTP;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+local $SIG{PIPE} = 'IGNORE';
+
+my $t = Test::Nginx->new()->has(qw/mail smtp http rewrite/)->plan(6)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+mail {
+    proxy_pass_error_message  on;
+    auth_http  http://127.0.0.1:8080/mail/auth;
+    xclient    on;
+
+    server {
+        listen     127.0.0.1:8025;
+        protocol   smtp;
+        smtp_auth  login plain none;
+    }
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location = /mail/auth {
+            add_header Auth-Status OK;
+            add_header Auth-Server 127.0.0.1;
+            add_header Auth-Port   %%PORT_8026%%;
+            add_header Auth-Wait   1;
+            return 204;
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&Test::Nginx::SMTP::smtp_test_daemon);
+$t->run()->waitforsocket('127.0.0.1:' . port(8026));
+
+###############################################################################
+
+# When XCLIENT's HELO= argument isn't used, the  following combinations may be
+# send to backend with xclient on:
+#
+# xclient
+# xclient, helo
+# xclient, ehlo
+# xclient, from, rcpt
+# xclient, helo, from, rcpt
+# xclient, ehlo, from, rcpt
+#
+# Test them in order.
+
+# xclient
+
+my $s = Test::Nginx::SMTP->new();
+$s->read();
+$s->send('AUTH PLAIN ' . encode_base64("\0test\@example.com\0secret", ''));
+$s->authok('xclient');
+
+# xclient, helo
+
+$s = Test::Nginx::SMTP->new();
+$s->read();
+$s->send('HELO example.com');
+$s->read();
+$s->send('AUTH PLAIN ' . encode_base64("\0test\@example.com\0secret", ''));
+$s->authok('xclient, helo');
+
+# xclient, ehlo
+
+$s = Test::Nginx::SMTP->new();
+$s->read();
+$s->send('EHLO example.com');
+$s->read();
+$s->send('AUTH PLAIN ' . encode_base64("\0test\@example.com\0secret", ''));
+$s->authok('xclient, ehlo');
+
+# xclient, from, rcpt
+
+$s = Test::Nginx::SMTP->new();
+$s->read();
+$s->send('MAIL FROM:<test@example.com>');
+$s->read();
+$s->send('RCPT TO:<test@example.com>');
+$s->ok('xclient, from');
+
+# xclient, helo, from, rcpt
+
+$s = Test::Nginx::SMTP->new();
+$s->read();
+$s->send('HELO example.com');
+$s->read();
+$s->send('MAIL FROM:<test@example.com>');
+$s->read();
+$s->send('RCPT TO:<test@example.com>');
+$s->ok('xclient, helo, from');
+
+# xclient, ehlo, from, rcpt
+
+$s = Test::Nginx::SMTP->new();
+$s->read();
+$s->send('EHLO example.com');
+$s->read();
+$s->send('MAIL FROM:<test@example.com>');
+$s->read();
+$s->send('RCPT TO:<test@example.com>');
+$s->ok('xclient, ehlo, from');
+
+###############################################################################
diff --git a/tests/mail_ssl.t b/tests/mail_ssl.t
new file mode 100644
index 0000000..c0521b7
--- /dev/null
+++ b/tests/mail_ssl.t
@@ -0,0 +1,312 @@
+#!/usr/bin/perl
+
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+
+# Tests for mail ssl module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/ :DEFAULT $CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::IMAP;
+use Test::Nginx::POP3;
+use Test::Nginx::SMTP;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval {
+	require Net::SSLeay;
+	Net::SSLeay::load_error_strings();
+	Net::SSLeay::SSLeay_add_ssl_algorithms();
+	Net::SSLeay::randomize();
+};
+plan(skip_all => 'Net::SSLeay not installed') if $@;
+
+my $t = Test::Nginx->new()->has(qw/mail mail_ssl imap pop3 smtp/)
+	->has_daemon('openssl')->plan(20);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+mail {
+    ssl_certificate_key localhost.key;
+    ssl_certificate localhost.crt;
+    ssl_session_tickets off;
+
+    ssl_password_file password;
+
+    auth_http  http://127.0.0.1:8080;	# unused
+
+    ssl_session_cache none;
+
+    server {
+        listen             127.0.0.1:8143;
+        listen             127.0.0.1:8145 ssl;
+        protocol           imap;
+
+        ssl_session_cache  builtin;
+    }
+
+    server {
+        listen             127.0.0.1:8146 ssl;
+        protocol           imap;
+
+        ssl_session_cache  off;
+    }
+
+    server {
+        listen             127.0.0.1:8147;
+        protocol           imap;
+
+        # Special case for enabled "ssl" directive.
+
+        ssl on;
+        ssl_session_cache  builtin:1000;
+    }
+
+    server {
+        listen             127.0.0.1:8148 ssl;
+        protocol           imap;
+
+        ssl_session_cache shared:SSL:1m;
+        ssl_certificate_key inherits.key;
+        ssl_certificate inherits.crt;
+    }
+
+    server {
+        listen             127.0.0.1:8149;
+        protocol           imap;
+
+        starttls           on;
+    }
+
+    server {
+        listen             127.0.0.1:8150;
+        protocol           imap;
+
+        starttls           only;
+    }
+
+    server {
+        listen             127.0.0.1:8151;
+        protocol           pop3;
+
+        starttls           on;
+    }
+
+    server {
+        listen             127.0.0.1:8152;
+        protocol           pop3;
+
+        starttls           only;
+    }
+
+    server {
+        listen             127.0.0.1:8153;
+        protocol           smtp;
+
+        starttls           on;
+    }
+
+    server {
+        listen             127.0.0.1:8154;
+        protocol           smtp;
+
+        starttls           only;
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('localhost', 'inherits') {
+	system("openssl genrsa -out $d/$name.key -passout pass:localhost "
+		. "-aes128 2048 >>$d/openssl.out 2>&1") == 0
+		or die "Can't create private key: $!\n";
+	system('openssl req -x509 -new '
+		. "-config $d/openssl.conf -subj /CN=$name/ "
+		. "-out $d/$name.crt "
+		. "-key $d/$name.key -passin pass:localhost"
+		. ">>$d/openssl.out 2>&1") == 0
+		or die "Can't create certificate for $name: $!\n";
+}
+
+my $ctx = Net::SSLeay::CTX_new() or die("Failed to create SSL_CTX $!");
+$t->write_file('password', 'localhost');
+
+open OLDERR, ">&", \*STDERR; close STDERR;
+$t->run();
+open STDERR, ">&", \*OLDERR;
+
+###############################################################################
+
+# simple tests to ensure that nothing broke with ssl_password_file directive
+
+my $s = Test::Nginx::IMAP->new();
+$s->ok('greeting');
+
+$s->send('1 AUTHENTICATE LOGIN');
+$s->check(qr/\+ VXNlcm5hbWU6/, 'login');
+
+# ssl_session_cache
+
+my ($ssl, $ses);
+
+($s, $ssl) = get_ssl_socket(8145);
+$ses = Net::SSLeay::get_session($ssl);
+
+($s, $ssl) = get_ssl_socket(8145, $ses);
+is(Net::SSLeay::session_reused($ssl), 1, 'builtin session reused');
+
+($s, $ssl) = get_ssl_socket(8146);
+$ses = Net::SSLeay::get_session($ssl);
+
+($s, $ssl) = get_ssl_socket(8146, $ses);
+is(Net::SSLeay::session_reused($ssl), 0, 'session not reused');
+
+($s, $ssl) = get_ssl_socket(8147);
+$ses = Net::SSLeay::get_session($ssl);
+
+($s, $ssl) = get_ssl_socket(8147, $ses);
+is(Net::SSLeay::session_reused($ssl), 1, 'builtin size session reused');
+
+($s, $ssl) = get_ssl_socket(8148);
+$ses = Net::SSLeay::get_session($ssl);
+
+($s, $ssl) = get_ssl_socket(8148, $ses);
+is(Net::SSLeay::session_reused($ssl), 1, 'shared session reused');
+
+# ssl_certificate inheritance
+
+($s, $ssl) = get_ssl_socket(8145);
+like(Net::SSLeay::dump_peer_certificate($ssl), qr/CN=localhost/, 'CN');
+
+($s, $ssl) = get_ssl_socket(8148);
+like(Net::SSLeay::dump_peer_certificate($ssl), qr/CN=inherits/, 'CN inner');
+
+# starttls imap
+
+$s = Test::Nginx::IMAP->new(PeerAddr => '127.0.0.1:' . port(8149));
+$s->read();
+
+$s->send('1 AUTHENTICATE LOGIN');
+$s->check(qr/\+ VXNlcm5hbWU6/, 'imap auth before startls on');
+
+$s = Test::Nginx::IMAP->new(PeerAddr => '127.0.0.1:' . port(8149));
+$s->read();
+
+$s->send('1 STARTTLS');
+$s->ok('imap starttls on');
+
+$s = Test::Nginx::IMAP->new(PeerAddr => '127.0.0.1:' . port(8150));
+$s->read();
+
+$s->send('1 AUTHENTICATE LOGIN');
+$s->check(qr/^\S+ BAD/, 'imap auth before startls only');
+
+$s = Test::Nginx::IMAP->new(PeerAddr => '127.0.0.1:' . port(8150));
+$s->read();
+
+$s->send('1 STARTTLS');
+$s->ok('imap starttls only');
+
+# starttls pop3
+
+$s = Test::Nginx::POP3->new(PeerAddr => '127.0.0.1:' . port(8151));
+$s->read();
+
+$s->send('AUTH LOGIN');
+$s->check(qr/\+ VXNlcm5hbWU6/, 'pop3 auth before startls on');
+
+$s = Test::Nginx::POP3->new(PeerAddr => '127.0.0.1:' . port(8151));
+$s->read();
+
+$s->send('STLS');
+$s->ok('pop3 starttls on');
+
+$s = Test::Nginx::POP3->new(PeerAddr => '127.0.0.1:' . port(8152));
+$s->read();
+
+$s->send('AUTH LOGIN');
+$s->check(qr/^-ERR/, 'pop3 auth before startls only');
+
+$s = Test::Nginx::POP3->new(PeerAddr => '127.0.0.1:' . port(8152));
+$s->read();
+
+$s->send('STLS');
+$s->ok('pop3 starttls only');
+
+# starttls smtp
+
+$s = Test::Nginx::SMTP->new(PeerAddr => '127.0.0.1:' . port(8153));
+$s->read();
+
+$s->send('AUTH LOGIN');
+$s->check(qr/^334 VXNlcm5hbWU6/, 'smtp auth before startls on');
+
+$s = Test::Nginx::SMTP->new(PeerAddr => '127.0.0.1:' . port(8153));
+$s->read();
+
+$s->send('STARTTLS');
+$s->ok('smtp starttls on');
+
+$s = Test::Nginx::SMTP->new(PeerAddr => '127.0.0.1:' . port(8154));
+$s->read();
+
+$s->send('AUTH LOGIN');
+$s->check(qr/^5.. /, 'smtp auth before startls only');
+
+$s = Test::Nginx::SMTP->new(PeerAddr => '127.0.0.1:' . port(8154));
+$s->read();
+
+$s->send('STARTTLS');
+$s->ok('smtp starttls only');
+
+###############################################################################
+
+sub get_ssl_socket {
+	my ($port, $ses) = @_;
+	my $s;
+
+	my $dest_ip = inet_aton('127.0.0.1');
+	my $dest_serv_params = sockaddr_in(port($port), $dest_ip);
+
+	socket($s, &AF_INET, &SOCK_STREAM, 0) or die "socket: $!";
+	connect($s, $dest_serv_params) or die "connect: $!";
+
+	my $ssl = Net::SSLeay::new($ctx) or die("Failed to create SSL $!");
+	Net::SSLeay::set_session($ssl, $ses) if defined $ses;
+	Net::SSLeay::set_fd($ssl, fileno($s));
+	Net::SSLeay::connect($ssl) or die("ssl connect");
+	return ($s, $ssl);
+}
+
+###############################################################################
diff --git a/tests/map.t b/tests/map.t
new file mode 100644
index 0000000..5184e98
--- /dev/null
+++ b/tests/map.t
@@ -0,0 +1,117 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+
+# Tests for map module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http map rewrite/)->plan(19);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    map $args $x {
+        default                     0;
+        foo                         bar;
+        foo2                        bar;
+    }
+
+    map $args $y {
+        hostnames;
+        default                     0;
+        example.com                 foo;
+        example.*                   right-wildcard;
+        *.example.com               left-wildcard;
+        .dot.example.com            special-wildcard;
+        ~^REGEX.EXAMPLE\.ORG$       regex-sensitive;
+        ~*^www.regex.example\.org$  regex-insensitive;
+        \include                    include;
+        server                      $server_name;
+        var                         $z;
+    }
+
+    map $args $z {
+        default                     0;
+        var                         baz;
+        include                     map.conf;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            add_header X-Foo "x:$x y:$y\n";
+            return 204;
+        }
+        location /z {
+            add_header X-Foo "z:$z\n";
+            return 204;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('map.conf', "foo bar;");
+$t->run();
+
+###############################################################################
+
+like(http_get('/?1'), qr/x:0 y:0/, 'map default');
+like(http_get('/?foo'), qr/x:bar y:0/, 'map foo bar');
+like(http_get('/?foo2'), qr/x:bar y:0/, 'map foo bar key');
+like(http_get('/?example.com'), qr/x:0 y:foo/, 'map example.com foo');
+like(http_get('/?EXAMPLE.COM'), qr/x:0 y:foo/, 'map EXAMPLE.COM foo');
+like(http_get('/?example.com.'), qr/x:0 y:foo/, 'map example.com. foo');
+like(http_get('/?example.org'), qr/x:0 y:right-wildcard/,
+	'map example.org wildcard');
+like(http_get('/?foo.example.com'), qr/x:0 y:left-wildcard/,
+	'map foo.example.com wildcard');
+like(http_get('/?foo.example.com.'), qr/x:0 y:left-wildcard/,
+	'map foo.example.com. wildcard');
+like(http_get('/?dot.example.com'), qr/x:0 y:special-wildcard/,
+	'map dot.example.com special wildcard');
+like(http_get('/?www.dot.example.com'), qr/x:0 y:special-wildcard/,
+	'map www.dot.example.com special wildcard');
+like(http_get('/?REGEX.EXAMPLE.ORG'), qr/x:0 y:regex-sensitive/,
+	'map REGEX.EXAMPLE.ORG');
+like(http_get('/?regex.example.org'), qr/x:0 y:0/,
+	'map regex.example.org');
+like(http_get('/?www.regex.example.org'), qr/x:0 y:regex-insensitive/,
+	'map www.regex.example.org insensitive');
+like(http_get('/?WWW.REGEX.EXAMPLE.ORG'), qr/x:0 y:regex-insensitive/,
+	'map WWW.REGEX.EXAMPLE.ORG insensitive');
+like(http_get('/?include'), qr/x:0 y:include/, 'map special parameter');
+like(http_get('/?server'), qr/x:0 y:localhost/, 'map server_name variable');
+like(http_get('/?var'), qr/x:0 y:baz/, 'map z variable');
+like(http_get('/z?foo'), qr/z:bar/, 'include foo bar');
+
+###############################################################################
diff --git a/tests/map_complex.t b/tests/map_complex.t
new file mode 100644
index 0000000..51ac3d0
--- /dev/null
+++ b/tests/map_complex.t
@@ -0,0 +1,71 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for map module with complex value.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http map rewrite/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    map $args $x {
+        var      foo:$y;
+        var2     $y:foo;
+        default  foo:$y;
+    }
+
+    map $args $y {
+        default  bar;
+        same     baz;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            add_header X-Foo $x;
+            return 204;
+        }
+    }
+}
+
+EOF
+
+$t->run()->plan(3);
+
+###############################################################################
+
+like(http_get('/?var'), qr/foo:bar/, 'map cv');
+like(http_get('/?var2'), qr/bar:foo/, 'map cv 2');
+like(http_get('/?same'), qr/foo:baz/, 'map cv key');
+
+###############################################################################
diff --git a/tests/map_volatile.t b/tests/map_volatile.t
new file mode 100644
index 0000000..b886b91
--- /dev/null
+++ b/tests/map_volatile.t
@@ -0,0 +1,83 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for map module with volatile.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http map/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    map $uri $uri_cached {
+        /1/          /1/redirect;
+        /1/redirect  uncached;
+    }
+
+    map $uri $uri_uncached {
+        volatile;
+
+        /2/          /2/redirect;
+        /2/redirect  uncached;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /1 {
+            index $uri_cached;
+        }
+        location /1/redirect {
+            add_header X-URI $uri_cached always;
+        }
+
+        location /2 {
+            index $uri_uncached;
+        }
+        location /2/redirect {
+            add_header X-URI $uri_uncached always;
+        }
+    }
+}
+
+EOF
+
+mkdir($t->testdir() . '/1');
+mkdir($t->testdir() . '/2');
+
+$t->run()->plan(2);
+
+###############################################################################
+
+like(http_get('/1/'), qr!X-URI: /1/redirect!, 'map');
+like(http_get('/2/'), qr/X-URI: uncached/, 'map volatile');
+
+###############################################################################
diff --git a/tests/memcached.t b/tests/memcached.t
new file mode 100644
index 0000000..b617ded
--- /dev/null
+++ b/tests/memcached.t
@@ -0,0 +1,93 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Test for memcached backend.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require Cache::Memcached; };
+plan(skip_all => 'Cache::Memcached not installed') if $@;
+
+my $t = Test::Nginx->new()->has(qw/http rewrite memcached/)
+	->has_daemon('memcached')->plan(4)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            set $memcached_key $uri;
+            memcached_pass 127.0.0.1:8081;
+        }
+
+        location /next {
+            set $memcached_key $uri;
+            memcached_next_upstream  not_found;
+            memcached_pass 127.0.0.1:8081;
+        }
+    }
+}
+
+EOF
+
+my $memhelp = `memcached -h`;
+my @memopts = ();
+
+if ($memhelp =~ /repcached/) {
+	# repcached patch adds additional listen socket
+	push @memopts, '-X', port(8082);
+}
+if ($memhelp =~ /-U/) {
+	# UDP port is on by default in memcached 1.2.7+
+	push @memopts, '-U', '0';
+}
+
+$t->run_daemon('memcached', '-l', '127.0.0.1', '-p', port(8081), @memopts);
+$t->run();
+
+$t->waitforsocket('127.0.0.1:' . port(8081))
+	or die "Can't start memcached";
+
+###############################################################################
+
+my $memd = Cache::Memcached->new(servers => [ '127.0.0.1:' . port(8081) ],
+	connect_timeout => 1.0);
+$memd->set('/', 'SEE-THIS')
+	or die "can't put value into memcached: $!";
+
+like(http_get('/'), qr/SEE-THIS/, 'memcached request');
+
+like(http_get('/notfound'), qr/ 404 /, 'memcached not found');
+
+like(http_get('/next'), qr/ 404 /, 'not found with memcached_next_upstream');
+
+unlike(http_head('/'), qr/SEE-THIS/, 'memcached no data in HEAD');
+
+###############################################################################
diff --git a/tests/memcached_fake.t b/tests/memcached_fake.t
new file mode 100644
index 0000000..d231e41
--- /dev/null
+++ b/tests/memcached_fake.t
@@ -0,0 +1,106 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Test for memcached backend with fake daemon.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http rewrite memcached ssi/)->plan(3)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            set $memcached_key $uri;
+            memcached_pass 127.0.0.1:8081;
+        }
+
+        location /ssi {
+            default_type text/html;
+            ssi on;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('ssi.html',
+	'<!--#include virtual="/" set="blah" -->' .
+	'blah: <!--#echo var="blah" -->');
+
+$t->run_daemon(\&memcached_fake_daemon);
+$t->run();
+
+$t->waitforsocket('127.0.0.1:' . port(8081))
+	or die "Can't start fake memcached";
+
+###############################################################################
+
+like(http_get('/'), qr/SEE-THIS/, 'memcached split trailer');
+
+like(http_get('/ssi.html'), qr/SEE-THIS/, 'memcached ssi var');
+
+like(`grep -F '[error]' ${\($t->testdir())}/error.log`, qr/^$/s, 'no errors');
+
+###############################################################################
+
+sub memcached_fake_daemon {
+	my $server = IO::Socket::INET->new(
+		Proto => 'tcp',
+		LocalAddr => '127.0.0.1:' . port(8081),
+		Listen => 5,
+		Reuse => 1
+	)
+		or die "Can't create listening socket: $!\n";
+
+	local $SIG{PIPE} = 'IGNORE';
+
+	while (my $client = $server->accept()) {
+		$client->autoflush(1);
+
+		while (<$client>) {
+			last if (/\x0d\x0a$/);
+		}
+
+		print $client 'VALUE / 0 8' . CRLF;
+		print $client 'SEE-TH';
+		select(undef, undef, undef, 0.1);
+		print $client 'IS';
+		select(undef, undef, undef, 0.1);
+		print $client CRLF . 'EN';
+		select(undef, undef, undef, 0.1);
+		print $client 'D' . CRLF;
+		close $client;
+	}
+}
+
+###############################################################################
diff --git a/tests/memcached_keepalive.t b/tests/memcached_keepalive.t
new file mode 100644
index 0000000..aaf0224
--- /dev/null
+++ b/tests/memcached_keepalive.t
@@ -0,0 +1,193 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Test for memcached with keepalive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require Cache::Memcached; };
+plan(skip_all => 'Cache::Memcached not installed') if $@;
+
+my $t = Test::Nginx->new()->has(qw/http memcached upstream_keepalive rewrite/)
+	->has_daemon('memcached')->plan(15)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    upstream memd {
+        server 127.0.0.1:8081;
+        keepalive 1;
+    }
+
+    upstream memd3 {
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8082;
+        keepalive 1;
+    }
+
+    upstream memd4 {
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8082;
+        keepalive 10;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            set $memcached_key $uri;
+            memcached_pass memd;
+        }
+
+        location /next {
+            set $memcached_key $uri;
+            memcached_next_upstream  not_found;
+            memcached_pass memd;
+        }
+
+        location /memd3 {
+            set $memcached_key "/";
+            memcached_pass memd3;
+        }
+
+        location /memd4 {
+            set $memcached_key "/";
+            memcached_pass memd4;
+        }
+    }
+}
+
+EOF
+
+my $memhelp = `memcached -h`;
+my @memopts1 = ();
+my @memopts2 = ();
+
+if ($memhelp =~ /repcached/) {
+	# repcached patches adds additional listen socket memcached
+	# that should be different too
+
+	push @memopts1, '-X', port(8083);
+	push @memopts2, '-X', port(8084);
+}
+if ($memhelp =~ /-U/) {
+	# UDP ports no longer off by default in memcached 1.2.7+
+
+	push @memopts1, '-U', '0';
+	push @memopts2, '-U', '0';
+}
+if ($memhelp =~ /-t/) {
+	# for connection stats consistency in threaded memcached 1.3+
+
+	push @memopts1, '-t', '1';
+	push @memopts2, '-t', '1';
+}
+
+$t->run_daemon('memcached', '-l', '127.0.0.1', '-p', port(8081), @memopts1);
+$t->run_daemon('memcached', '-l', '127.0.0.1', '-p', port(8082), @memopts2);
+
+$t->run();
+
+$t->waitforsocket('127.0.0.1:' . port(8081))
+	or die "Unable to start memcached";
+$t->waitforsocket('127.0.0.1:' . port(8082))
+	or die "Unable to start second memcached";
+
+###############################################################################
+
+my $memd1 = Cache::Memcached->new(servers => [ '127.0.0.1:' . port(8081) ],
+	connect_timeout => 1.0);
+my $memd2 = Cache::Memcached->new(servers => [ '127.0.0.1:' . port(8082) ],
+	connect_timeout => 1.0);
+
+$memd1->set('/', 'SEE-THIS');
+$memd2->set('/', 'SEE-THIS');
+$memd1->set('/big', 'X' x 1000000);
+
+my $total = $memd1->stats()->{total}->{total_connections};
+
+like(http_get('/'), qr/SEE-THIS/, 'keepalive memcached request');
+like(http_get('/notfound'), qr/ 404 /, 'keepalive memcached not found');
+like(http_get('/next'), qr/ 404 /,
+	'keepalive not found with memcached_next_upstream');
+like(http_get('/'), qr/SEE-THIS/, 'keepalive memcached request again');
+like(http_get('/'), qr/SEE-THIS/, 'keepalive memcached request again');
+like(http_get('/'), qr/SEE-THIS/, 'keepalive memcached request again');
+
+is($memd1->stats()->{total}->{total_connections}, $total + 1,
+	'only one connection used');
+
+# Since nginx doesn't read all data from connection in some situations (head
+# requests, post_action, errors writing to client) we have to close such
+# connections.  Check if we really do close them.
+
+$total = $memd1->stats()->{total}->{total_connections};
+
+unlike(http_head('/'), qr/SEE-THIS/, 'head request');
+like(http_get('/'), qr/SEE-THIS/, 'get after head');
+
+is($memd1->stats()->{total}->{total_connections}, $total + 1,
+	'head request closes connection');
+
+$total = $memd1->stats()->{total}->{total_connections};
+
+unlike(http_head('/big'), qr/XXX/, 'big head');
+like(http_get('/'), qr/SEE-THIS/, 'get after big head');
+
+is($memd1->stats()->{total}->{total_connections}, $total + 1,
+	'big head request closes connection');
+
+# two backends with maximum number of cached connections set to 1,
+# should establish new connection on each request
+
+$total = $memd1->stats()->{total}->{total_connections} +
+	$memd2->stats()->{total}->{total_connections};
+
+http_get('/memd3');
+http_get('/memd3');
+http_get('/memd3');
+
+is($memd1->stats()->{total}->{total_connections} +
+	$memd2->stats()->{total}->{total_connections}, $total + 3,
+	'3 connections should be established');
+
+# two backends with maximum number of cached connections set to 10,
+# should establish only two connections (1 per backend)
+
+$total = $memd1->stats()->{total}->{total_connections} +
+	$memd2->stats()->{total}->{total_connections};
+
+http_get('/memd4');
+http_get('/memd4');
+http_get('/memd4');
+
+is($memd1->stats()->{total}->{total_connections} +
+	$memd2->stats()->{total}->{total_connections}, $total + 2,
+	'connection per backend');
+
+###############################################################################
diff --git a/tests/memcached_keepalive_stale.t b/tests/memcached_keepalive_stale.t
new file mode 100644
index 0000000..c772a76
--- /dev/null
+++ b/tests/memcached_keepalive_stale.t
@@ -0,0 +1,121 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Test for stale events handling in upstream keepalive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require Cache::Memcached; };
+plan(skip_all => 'Cache::Memcached not installed') if $@;
+
+my $t = Test::Nginx->new()->has(qw/http memcached upstream_keepalive rewrite/)
+	->has_daemon('memcached')->plan(1)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+worker_processes 2;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    upstream memd {
+        server 127.0.0.1:8081;
+        keepalive 1;
+    }
+
+    server {
+        listen       127.0.0.1:8080 sndbuf=32k;
+        server_name  localhost;
+
+        location / {
+            set $memcached_key $uri;
+            memcached_pass memd;
+        }
+    }
+}
+
+EOF
+
+my $memhelp = `memcached -h`;
+my @memopts1 = ();
+
+if ($memhelp =~ /repcached/) {
+	# repcached patches adds additional listen socket memcached
+	# that should be different too
+
+	push @memopts1, '-X', port(8082);
+}
+if ($memhelp =~ /-U/) {
+	# UDP ports no longer off by default in memcached 1.2.7+
+
+	push @memopts1, '-U', '0';
+}
+if ($memhelp =~ /-t/) {
+	# for connection stats consistency in threaded memcached 1.3+
+
+	push @memopts1, '-t', '1';
+}
+
+$t->run_daemon('memcached', '-l', '127.0.0.1', '-p', port(8081), @memopts1);
+
+$t->run();
+
+$t->waitforsocket('127.0.0.1:' . port(8081))
+	or die "Unable to start memcached";
+
+###############################################################################
+
+my $memd1 = Cache::Memcached->new(servers => [ '127.0.0.1:' . port(8081) ],
+	connect_timeout => 1.0);
+
+# It's possible that stale events occur, i.e. read event handler called
+# for just saved upstream connection without any data available for
+# read.  We shouldn't close upstream connection in such situation.
+#
+# This happens due to reading from upstream connection on downstream write
+# events.  More likely to happen with multiple workers due to use of posted
+# events.
+#
+# Stale event may only happen if reading response from upstream requires
+# entering event loop, i.e. response should be big enough.  On the other
+# hand, it is less likely to occur with full client's connection output
+# buffer.
+#
+# We use here 2 workers, 20k response and set output buffer on clients
+# connection to 32k.  This allows more or less reliably reproduce stale
+# events at least on FreeBSD testbed here.
+
+$memd1->set('/big', 'X' x 20480);
+
+my $total = $memd1->stats()->{total}->{total_connections};
+
+for (1 .. 100) {
+	http_get('/big');
+}
+
+cmp_ok($memd1->stats()->{total}->{total_connections}, '<=', $total + 2,
+	'only one connection per worker used');
+
+###############################################################################
diff --git a/tests/merge_slashes.t b/tests/merge_slashes.t
new file mode 100644
index 0000000..4447bbc
--- /dev/null
+++ b/tests/merge_slashes.t
@@ -0,0 +1,60 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for URI normalization, merge_slashes off.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http rewrite/)->plan(2)
+	->write_file_expand('nginx.conf', <<'EOF')->run();
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        merge_slashes off;
+
+        location / {
+            add_header  X-URI  "x $uri x";
+            return      204;
+        }
+    }
+}
+
+EOF
+
+###############################################################################
+
+local $TODO = 'not yet' unless $t->has_version('1.17.5');
+
+like(http_get('/foo//../bar'), qr!x /foo/bar x!, 'merge slashes');
+like(http_get('/foo///../bar'), qr!x /foo//bar x!, 'merge slashes 2');
+
+###############################################################################
diff --git a/tests/mirror.t b/tests/mirror.t
new file mode 100644
index 0000000..195734f
--- /dev/null
+++ b/tests/mirror.t
@@ -0,0 +1,86 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http mirror module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http mirror/)->plan(8);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    log_format test $uri;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            mirror /mirror;
+
+            location /off {
+                mirror off;
+            }
+        }
+
+        location /many {
+            mirror /mirror/1;
+            mirror /mirror/2;
+        }
+
+        location /mirror {
+            log_subrequest on;
+            access_log test$args.log test;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('index.html', '');
+$t->write_file('many', '');
+$t->write_file('off', '');
+$t->run();
+
+###############################################################################
+
+like(http_get('/index.html?1'), qr/200 OK/, 'request');
+like(http_get('/?2'), qr/200 OK/, 'internal redirect');
+like(http_get('/off?3'), qr/200 OK/, 'mirror off');
+like(http_get('/many?4'), qr/200 OK/, 'mirror many');
+
+$t->stop();
+
+is($t->read_file('test1.log'), "/mirror\n", 'log - request');
+is($t->read_file('test2.log'), "/mirror\n/mirror\n", 'log - redirect');
+ok(!-e $t->testdir() . '/test3.log', 'log - mirror off');
+is($t->read_file('test4.log'), "/mirror/1\n/mirror/2\n", 'log - mirror many');
+
+###############################################################################
diff --git a/tests/mirror_proxy.t b/tests/mirror_proxy.t
new file mode 100644
index 0000000..c347e25
--- /dev/null
+++ b/tests/mirror_proxy.t
@@ -0,0 +1,128 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http mirror module and it's interaction with proxy.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy mirror rewrite limit_req/);
+
+$t->write_file_expand('nginx.conf', <<'EOF')->plan(7);
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    limit_req_zone  $uri  zone=slow:1m  rate=30r/m;
+    log_format  test  $request_uri:$request_body;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            mirror /mirror;
+            proxy_pass http://127.0.0.1:8081;
+        }
+
+        location /off {
+            mirror /mirror/off;
+            mirror_request_body off;
+            proxy_pass http://127.0.0.1:8081;
+        }
+
+        location /mirror {
+            internal;
+            proxy_pass http://127.0.0.1:8082;
+            limit_req  zone=slow burst=1;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        listen       127.0.0.1:8082;
+        server_name  localhost;
+
+        location / {
+            client_body_timeout 1s;
+            proxy_pass http://127.0.0.1:$server_port/return204;
+            access_log %%TESTDIR%%/test.log test;
+            add_header X-Body $request_body;
+        }
+
+        location /return204 {
+            return 204;
+        }
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+like(http_post('/'), qr/X-Body: 1234567890\x0d?$/m, 'mirror proxy');
+like(http_post('/off'), qr/X-Body: 1234567890\x0d?$/m, 'mirror_request_body');
+
+# delayed subrequest should not affect main request processing nor stuck itself
+
+SKIP: {
+skip 'hang on win32', 1 if $^O eq 'MSWin32' and !$ENV{TEST_NGINX_UNSAFE};
+
+TODO: {
+local $TODO = 'not yet';
+
+like(http_post('/delay?1'), qr/X-Body: 1234567890\x0d?$/m, 'mirror delay');
+
+}
+
+}
+
+$t->todo_alerts() unless $^O eq 'MSWin32';
+$t->stop();
+
+my $log = $t->read_file('test.log');
+like($log, qr!^/:1234567890$!m, 'log - request body');
+like($log, qr!^/mirror:1234567890$!m, 'log - request body in mirror');
+like($log, qr!^/off:1234567890$!m, 'log - mirror_request_body off');
+like($log, qr!^/mirror/off:-$!m,, 'log - mirror_request_body off in mirror');
+
+###############################################################################
+
+sub http_post {
+	my ($url) = @_;
+
+	http(<<EOF);
+POST $url HTTP/1.0
+Host: localhost
+Content-Length: 10
+
+1234567890
+EOF
+}
+
+###############################################################################
diff --git a/tests/mp4.t b/tests/mp4.t
new file mode 100644
index 0000000..2cca40b
--- /dev/null
+++ b/tests/mp4.t
@@ -0,0 +1,167 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for mp4 module.
+# Ensures that requested stream duration is given with sane accuracy.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http mp4/)->has_daemon('ffprobe')
+	->has_daemon('ffmpeg')
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            mp4;
+        }
+    }
+}
+
+EOF
+
+plan(skip_all => 'no lavfi')
+	unless grep /lavfi/, `ffmpeg -loglevel quiet -formats`;
+system('ffmpeg -nostdin -loglevel quiet -y '
+	. '-f lavfi -i testsrc=duration=10:size=320x200:rate=15 '
+	. '-f lavfi -i testsrc=duration=20:size=320x200:rate=15 '
+	. '-map 0:0 -map 1:0 -pix_fmt yuv420p -g 15 -c:v libx264 '
+	. "${\($t->testdir())}/test.mp4") == 0
+	or die "Can't create mp4 file: $!";
+system('ffmpeg -nostdin -loglevel quiet -y '
+	. '-f lavfi -i testsrc=duration=10:size=320x200:rate=15 '
+	. '-f lavfi -i testsrc=duration=20:size=320x200:rate=15 '
+	. '-map 0:0 -map 1:0 -pix_fmt yuv420p -g 15 -c:v libx264 '
+	. '-movflags +faststart '
+	. "${\($t->testdir())}/no_mdat.mp4") == 0
+	or die "Can't create mp4 file: $!";
+
+my $sbad = <<'EOF';
+00000000:  00 00 00 1c 66 74 79 70  69 73 6f 6d 00 00 02 00  |....ftypisom....|
+00000010:  69 73 6f 6d 69 73 6f 32  6d 70 34 31 00 00 00 09  |isomiso2mp41....|
+00000020:  6d 64 61 74 00 00 00 00  94 6d 6f 6f 76 00 00 00  |mdat.....moov...|
+00000030:  8c 74 72 61 6b 00 00 00  84 6d 64 69 61 00 00 00  |.trak....mdia...|
+00000040:  7c 6d 69 6e 66 00 00 00  74 73 74 62 6c 00 00 00  ||minf...tstbl...|
+00000050:  18 73 74 74 73 00 00 00  00 00 00 00 01 00 00 03  |.stts...........|
+00000060:  3a 00 00 04 00 00 00 00  28 73 74 73 63 00 00 00  |:.......(stsc...|
+00000070:  00 00 00 00 02 00 00 00  01 00 00 03 0f 00 00 00  |................|
+00000080:  01 00 00 00 02 00 00 00  2b 00 00 00 01 00 00 00  |........+.......|
+00000090:  14 73 74 73 7a 00 00 00  00 00 00 05 a9 00 00 03  |.stsz...........|
+000000a0:  3b 00 00 00 18 63 6f 36  34 00 00 00 00 00 00 00  |;....co64.......|
+000000b0:  01 ff ff ff ff f0 0f fb  e7                       |.........|
+EOF
+
+$t->write_file('bad.mp4', unhex($sbad));
+$t->run()->plan(27);
+
+###############################################################################
+
+my $test_uri = '/test.mp4';
+
+again:
+
+is(durations($t, 0.0), '10.0 20.0', 'start zero');
+is(durations($t, 2), '8.0 18.0', 'start integer');
+is(durations($t, 7.1), '2.9 12.9', 'start float');
+
+is(durations($t, 6, 9), '3.0 3.0', 'start end integer');
+is(durations($t, 2.7, 5.6), '2.9 2.9', 'start end float');
+
+is(durations($t, undef, 9), '9.0 9.0', 'end integer');
+is(durations($t, undef, 5.6), '5.6 5.6', 'end float');
+
+# invalid range results in ignoring end argument
+
+like(http_head("$test_uri?start=1&end=1"), qr/200 OK/, 'zero range');
+like(http_head("$test_uri?start=1&end=0"), qr/200 OK/, 'negative range');
+
+# start/end values exceeding track/file duration
+
+unlike(http_head("$test_uri?end=11"), qr!HTTP/1.1 500!,
+	'end beyond short track');
+unlike(http_head("$test_uri?end=21"), qr!HTTP/1.1 500!, 'end beyond EOF');
+unlike(http_head("$test_uri?start=11"), qr!HTTP/1.1 500!,
+	'start beyond short track');
+like(http_head("$test_uri?start=21"), qr!HTTP/1.1 500!, 'start beyond EOF');
+
+$test_uri = '/no_mdat.mp4', goto again unless $test_uri eq '/no_mdat.mp4';
+
+# corrupted formats
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.17.9');
+
+like(http_get("/bad.mp4?start=0.5"), qr/500 Internal/, 'co64 chunk beyond EOF');
+
+}
+
+$t->todo_alerts() if $t->read_file('nginx.conf') =~ /sendfile on/
+	and !$t->has_version('1.17.9');
+
+###############################################################################
+
+sub durations {
+	my ($t, $start, $end) = @_;
+	my $path = $t->{_testdir} . '/frag.mp4';
+
+	my $uri = $test_uri;
+	if (defined $start) {
+		$uri .= "?start=$start";
+		if (defined $end) {
+			$uri .= "&end=$end";
+		}
+
+	} elsif (defined $end) {
+		$uri .= "?end=$end";
+	}
+
+	$t->write_file('frag.mp4', Test::Nginx::http_content(http_get($uri)));
+
+	my $r = `ffprobe -show_streams $path 2>/dev/null`;
+	Test::Nginx::log_core('||', $r);
+	sprintf "%.1f %.1f", $r =~ /duration=(\d+\.\d+)/g;
+}
+
+sub unhex {
+	my ($input) = @_;
+	my $buffer = '';
+
+	for my $l ($input =~ m/:  +((?:[0-9a-f]{2,4} +)+) /gms) {
+		for my $v ($l =~ m/[0-9a-f]{2}/g) {
+			$buffer .= chr(hex($v));
+		}
+	}
+
+	return $buffer;
+}
+
+###############################################################################
diff --git a/tests/mp4_ssi.t b/tests/mp4_ssi.t
new file mode 100644
index 0000000..d41fe37
--- /dev/null
+++ b/tests/mp4_ssi.t
@@ -0,0 +1,83 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Test for mp4 module in subrequests.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http mp4 ssi/)->has_daemon('ffprobe')
+	->has_daemon('ffmpeg')->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            ssi on;
+        }
+        location /ssi {
+            mp4;
+        }
+    }
+}
+
+EOF
+
+plan(skip_all => 'no lavfi')
+	unless grep /lavfi/, `ffmpeg -loglevel quiet -formats`;
+system('ffmpeg -nostdin -loglevel quiet -y '
+	. '-f lavfi -i testsrc=duration=10:size=320x200:rate=15 '
+	. '-f lavfi -i testsrc=duration=20:size=320x200:rate=15 '
+	. '-map 0:0 -map 1:0 -pix_fmt yuv420p -g 15 -c:v libx264 '
+	. "${\($t->testdir())}/ssi.mp4") == 0
+	or die "Can't create mp4 file: $!";
+
+$t->write_file('index.html', 'X<!--#include virtual="/ssi.mp4?end=1" -->X');
+
+$t->run()->plan(1);
+
+###############################################################################
+
+(my $r = get('/')) =~ s/([^\x20-\x7e])/sprintf('\\x%02x', ord($1))/gmxe;
+unlike($r, qr/\\x0d(\\x0a)?0\\x0d(\\x0a)?\\x0d(\\x0a)?\w/, 'only final chunk');
+
+###############################################################################
+
+sub get {
+	my ($url, $extra) = @_;
+	return http(<<EOF);
+GET $url HTTP/1.1
+Host: localhost
+Connection: close
+
+EOF
+}
+
+###############################################################################
diff --git a/tests/msie_refresh.t b/tests/msie_refresh.t
new file mode 100644
index 0000000..374f8b2
--- /dev/null
+++ b/tests/msie_refresh.t
@@ -0,0 +1,96 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Test for msie_refresh.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http rewrite ssi/)->plan(5)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        msie_refresh on;
+
+        location / {
+            return 301 text;
+        }
+
+        location /space {
+            return 301 "space ";
+        }
+
+        location /error_page {
+            return 301;
+            error_page 301 text;
+        }
+
+        location /off {
+            msie_refresh off;
+            return 301 text;
+        }
+
+        location /ssi {
+            ssi on;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('ssi.html', 'X<!--#include virtual="/" -->X');
+$t->run();
+
+###############################################################################
+
+like(get('/'), qr/Refresh.*URL=text"/, 'msie refresh');
+like(get('/space'), qr/URL=space%20"/, 'msie refresh escaped url');
+like(get('/error_page'), qr/URL=text"/, 'msie refresh error page');
+
+unlike(get('/off'), qr/Refresh/, 'msie refresh disabled');
+
+unlike(get('/ssi.html'), qr/^0\x0d\x0a?\x0d\x0a?\w/m, 'only final chunk');
+
+###############################################################################
+
+sub get {
+	my ($url, $extra) = @_;
+	return http(<<EOF);
+GET $url HTTP/1.1
+Host: localhost
+Connection: close
+User-Agent: MSIE foo
+
+EOF
+}
+
+###############################################################################
diff --git a/tests/not_modified.t b/tests/not_modified.t
new file mode 100644
index 0000000..7deceab
--- /dev/null
+++ b/tests/not_modified.t
@@ -0,0 +1,126 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for not modified filter module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has('http')->plan(15)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            if_modified_since before;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('t', '');
+
+$t->run();
+
+###############################################################################
+
+like(http_get_ims('/t', 'Wed, 08 Jul 2037 22:53:52 GMT'), qr/ 304 /,
+	'0x7F000000');
+like(http_get_ims('/t', 'Tue, 19 Jan 2038 03:14:07 GMT'), qr/ 304 /,
+	'0x7FFFFFFF');
+
+SKIP: {
+	skip "only for 32-bit time_t", 2 if (gmtime(0xFFFFFFFF))[5] == 206;
+
+	like(http_get_ims('/t', 'Tue, 19 Jan 2038 03:14:08 GMT'), qr/ 200 /,
+		'0x7FFFFFFF + 1');
+	like(http_get_ims('/t', 'Fri, 25 Feb 2174 09:42:23 GMT'), qr/ 200 /,
+		'0x17FFFFFFF');
+}
+
+# If-Match, If-None-Match tests
+
+my ($t1, $etag);
+
+$t1 = http_get('/t');
+$t1 =~ /ETag: (".*")/;
+$etag = $1;
+
+like(http_get_inm('/t', $etag), qr/ 304 /, 'if-none-match');
+like(http_get_inm('/t', '"foo"'), qr/ 200 /, 'if-none-match fail');
+like(http_get_inm('/t', '"foo", "bar", ' . $etag . ' , "baz"'), qr/ 304 /,
+	'if-none-match with complex list');
+like(http_get_inm('/t', '*'), qr/ 304 /, 'if-none-match all');
+like(http_get_inm('/t', 'W/' . $etag), qr/ 304 /, 'if-none-match weak');
+like(http_get_im('/t', $etag), qr/ 200 /, 'if-match');
+like(http_get_im('/t', '"foo"'), qr/ 412 /, 'if-match fail');
+like(http_get_im('/t', '"foo", "bar", ' . "\t" . $etag . ' , "baz"'),
+	qr/ 200 /, 'if-match with complex list');
+like(http_get_im('/t', '*'), qr/ 200 /, 'if-match all');
+like(http_get_im('/t', 'W/' . $etag), qr/ 412 /, 'if-match weak fail');
+
+# server MUST ignore precondition if its response wouldn't be 2xx or 412
+
+like(http_get_im('/nx', '"foo"'), qr/ 404 /, 'if-match ignored with 404');
+
+###############################################################################
+
+sub http_get_ims {
+	my ($url, $ims) = @_;
+	return http(<<EOF);
+GET $url HTTP/1.0
+Host: localhost
+If-Modified-Since: $ims
+
+EOF
+}
+
+sub http_get_inm {
+	my ($url, $inm) = @_;
+	return http(<<EOF);
+GET $url HTTP/1.0
+Host: localhost
+If-None-Match: $inm
+
+EOF
+}
+
+sub http_get_im {
+	my ($url, $inm) = @_;
+	return http(<<EOF);
+GET $url HTTP/1.0
+Host: localhost
+If-Match: $inm
+
+EOF
+}
+
+###############################################################################
diff --git a/tests/not_modified_finalize.t b/tests/not_modified_finalize.t
new file mode 100644
index 0000000..ae5d9ef
--- /dev/null
+++ b/tests/not_modified_finalize.t
@@ -0,0 +1,107 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for not modified filter and filter finalization.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy cache/)->plan(2)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    proxy_cache_path %%TESTDIR%%/cache keys_zone=cache:1m;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        error_page 412 /error412.html;
+
+        location / {
+            proxy_pass        http://127.0.0.1:8081;
+            proxy_cache       cache;
+            proxy_cache_lock  on;
+            proxy_cache_valid 1h;
+        }
+
+        location /error412 {
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+    }
+}
+
+EOF
+
+$t->write_file('t.html', 'test file');
+$t->write_file('error412.html', 'error412');
+
+$t->run();
+
+###############################################################################
+
+# we trigger filter finalization in not modified filter by using
+# the If-Unmodified-Since/If-Match header;
+# with cache enabled and updating bit set, this currently results in
+# "stalled cache updating" alerts
+
+like(http_match_get('/t.html'), qr//, 'request 412');
+
+$t->todo_alerts();
+
+# in addition, in 1.11.10 .. 1.17.1, if the response was previously
+# cached, such a request resulted in r->cache null pointer dereference
+# in ngx_http_upstream_cache_background_update(), after it was reset
+# during internal redirect
+
+http_get('/t.html');
+
+TODO: {
+todo_skip 'leaves coredump', 1 unless $ENV{TEST_NGINX_UNSAFE}
+	or $t->has_version('1.17.1');
+
+like(http_match_get('/t.html'), qr//, 'request 412 cached');
+
+}
+
+###############################################################################
+
+sub http_match_get {
+	my ($url, %extra) = @_;
+	return http(<<EOF, %extra);
+GET $url HTTP/1.0
+Host: localhost
+If-Match: tt
+
+EOF
+}
+
+###############################################################################
diff --git a/tests/not_modified_proxy.t b/tests/not_modified_proxy.t
new file mode 100644
index 0000000..04eb980
--- /dev/null
+++ b/tests/not_modified_proxy.t
@@ -0,0 +1,142 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for not modified filter module and it's interaction with proxy.
+#
+# Notably, requests which are proxied should be skipped (that is, if
+# a backend returned 200, we should pass 200 to a client without any
+# attempts to handle conditional headers in the request), but responses
+# from cache should be handled.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy cache/)->plan(12);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    proxy_cache_path %%TESTDIR%%/cache keys_zone=one:1m;
+
+    proxy_set_header If-Modified-Since "";
+    proxy_set_header If-Unmodified-Since "";
+    proxy_set_header If-None-Match "";
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+        }
+
+        location /etag {
+            add_header Last-Modified "";
+        }
+
+        location /proxy/ {
+            proxy_pass http://127.0.0.1:8080/;
+        }
+
+        location /cache/ {
+            proxy_pass http://127.0.0.1:8080/;
+            proxy_cache one;
+            proxy_cache_valid 200 1y;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('t', '');
+$t->write_file('etag', '');
+
+$t->run();
+
+###############################################################################
+
+my ($t1, $lm, $etag);
+
+$t1 = http_get('/cache/t');
+$t1 =~ /Last-Modified: (.*)/; $lm = $1;
+$t1 =~ /ETag: (.*)/; $etag = $1;
+
+like(http_get_ims('/t', $lm), qr/ 304 /, 'if-modified-since');
+like(http_get_ims('/proxy/t', $lm), qr/ 200 /, 'ims proxy ignored');
+like(http_get_ims('/cache/t', $lm), qr/ 304 /, 'ims from cache');
+
+$t1 = 'Fri, 05 Jul 1985 14:30:52 GMT';
+
+like(http_get_iums('/t', $t1), qr/ 412 /, 'if-unmodified-since');
+like(http_get_iums('/proxy/t', $t1), qr/ 200 /, 'iums proxy ignored');
+like(http_get_iums('/cache/t', $t1), qr/ 412 /, 'iums from cache');
+
+like(http_get_inm('/t', $etag), qr/ 304 /, 'if-none-match');
+like(http_get_inm('/proxy/t', $etag), qr/ 200 /, 'inm proxy ignored');
+like(http_get_inm('/cache/t', $etag), qr/ 304 /, 'inm from cache');
+
+# backend response with ETag only, no Last-Modified
+
+$t1 = http_get('/cache/etag');
+$t1 =~ /ETag: (.*)/; $etag = $1;
+
+like(http_get_inm('/etag', $etag), qr/ 304 /, 'if-none-match etag only');
+like(http_get_inm('/proxy/etag', $etag), qr/ 200 /, 'inm etag proxy ignored');
+like(http_get_inm('/cache/etag', $etag), qr/ 304 /, 'inm etag from cache');
+
+###############################################################################
+
+sub http_get_ims {
+	my ($url, $ims) = @_;
+	return http(<<EOF);
+GET $url HTTP/1.0
+Host: localhost
+If-Modified-Since: $ims
+
+EOF
+}
+
+sub http_get_iums {
+	my ($url, $ims) = @_;
+	return http(<<EOF);
+GET $url HTTP/1.0
+Host: localhost
+If-Unmodified-Since: $ims
+
+EOF
+}
+
+sub http_get_inm {
+	my ($url, $inm) = @_;
+	return http(<<EOF);
+GET $url HTTP/1.0
+Host: localhost
+If-None-Match: $inm
+
+EOF
+}
+
+###############################################################################
diff --git a/tests/perl.t b/tests/perl.t
new file mode 100644
index 0000000..0522c50
--- /dev/null
+++ b/tests/perl.t
@@ -0,0 +1,315 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for embedded perl module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http perl rewrite/)->plan(24)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            set $testvar "TEST";
+            perl 'sub {
+                use warnings;
+                use strict;
+
+                my $r = shift;
+
+                $r->status(204) if $r->args =~ /204/;
+
+                $r->send_http_header("text/plain");
+
+                return OK if $r->header_only;
+
+                my $v = $r->variable("testvar");
+
+                $r->print("testvar: $v\n");
+
+                $r->print("host: ", $r->header_in("Host"), "\n");
+                $r->print("xfoo: ", $r->header_in("X-Foo"), "\n");
+                $r->print("cookie: ", $r->header_in("Cookie"), "\n");
+                $r->print("xff: ", $r->header_in("X-Forwarded-For"), "\n");
+
+                return OK;
+            }';
+        }
+
+        location /range {
+            perl 'sub {
+                use warnings;
+                use strict;
+
+                my $r = shift;
+
+                $r->header_out("Content-Length", "42");
+                $r->allow_ranges();
+                $r->send_http_header("text/plain");
+
+                return OK if $r->header_only;
+
+                $r->print("x" x 42);
+
+                return OK;
+            }';
+        }
+
+        location /body {
+            perl 'sub {
+                use warnings;
+                use strict;
+
+                my $r = shift;
+
+                if ($r->has_request_body(\&post)) {
+                    return OK;
+                }
+
+                return HTTP_BAD_REQUEST;
+
+                sub post {
+                    my $r = shift;
+                    $r->send_http_header;
+                    $r->print("body: ", $r->request_body, "\n");
+                    $r->print("file: ", $r->request_body_file, "\n");
+                }
+            }';
+        }
+
+        location /discard {
+            perl 'sub {
+                use warnings;
+                use strict;
+
+                my $r = shift;
+
+                $r->discard_request_body;
+
+                $r->send_http_header("text/plain");
+
+                return OK if $r->header_only;
+
+                $r->print("host: ", $r->header_in("Host"), "\n");
+
+                return OK;
+            }';
+        }
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+like(http_get('/'), qr/ 200 .*TEST/s, 'perl response');
+like(http_head('/'), qr/ 200 (?!.*TEST)/s, 'perl header_only');
+like(http_get('/?204'), qr/ 204 (?!.*TEST)/s, 'perl status, args');
+
+# various $r->header_in() cases
+
+like(http(
+	'GET / HTTP/1.0' . CRLF
+	. 'Host: localhost' . CRLF . CRLF
+), qr/host: localhost/, 'perl header_in known');
+
+like(http(
+	'GET / HTTP/1.0' . CRLF
+	. 'X-Foo: foo' . CRLF
+	. 'Host: localhost' . CRLF . CRLF
+), qr/xfoo: foo/, 'perl header_in unknown');
+
+like(http(
+	'GET / HTTP/1.0' . CRLF
+	. 'Cookie: foo' . CRLF
+	. 'Host: localhost' . CRLF . CRLF
+), qr/cookie: foo/, 'perl header_in cookie');
+
+like(http(
+	'GET / HTTP/1.0' . CRLF
+	. 'Cookie: foo1' . CRLF
+	. 'Cookie: foo2' . CRLF
+	. 'Host: localhost' . CRLF . CRLF
+), qr/cookie: foo1; foo2/, 'perl header_in cookie2');
+
+like(http(
+	'GET / HTTP/1.0' . CRLF
+	. 'X-Forwarded-For: foo' . CRLF
+	. 'Host: localhost' . CRLF . CRLF
+), qr/xff: foo/, 'perl header_in xff');
+
+like(http(
+	'GET / HTTP/1.0' . CRLF
+	. 'X-Forwarded-For: foo1' . CRLF
+	. 'X-Forwarded-For: foo2' . CRLF
+	. 'Host: localhost' . CRLF . CRLF
+), qr/xff: foo1, foo2/, 'perl header_in xff2');
+
+# headers_out content-length tests with range filter
+
+like(http_get('/range'), qr/Content-Length: 42.*^x{42}$/ms,
+	'perl header_out content-length');
+
+like(http(
+	'GET /range HTTP/1.0' . CRLF
+	. 'Host: localhost' . CRLF
+	. 'Range: bytes=0-1' . CRLF . CRLF
+), qr/Content-Length: 2.*^xx$/ms, 'perl header_out content-length range');
+
+like(http(
+	'GET /range HTTP/1.0' . CRLF
+	. 'Host: localhost' . CRLF
+	. 'Range: bytes=0-1,3-5' . CRLF . CRLF
+), qr/Content-Length: (?!42).*^xx\x0d.*^xxx\x0d/ms,
+	'perl header_out content-length multipart');
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.17.2');
+
+like(http(
+	'GET /range HTTP/1.0' . CRLF
+	. 'Host: localhost' . CRLF
+	. 'Range: bytes=100000-' . CRLF . CRLF
+), qr|^\QHTTP/1.1 416\E.*(?!xxx)|ms, 'perl range not satisfiable');
+
+}
+
+TODO: {
+todo_skip 'leaves coredump', 1 unless $t->has_version('1.17.1')
+	or $ENV{TEST_NGINX_UNSAFE};
+
+like(http(
+	'GET / HTTP/1.0' . CRLF
+	. 'Host: localhost' . CRLF
+	. 'If-Match: tt' . CRLF . CRLF
+), qr|200 OK|ms, 'perl precondition failed');
+
+}
+
+# various request body tests
+
+like(http_get('/body'), qr/400 Bad Request/, 'perl no body');
+
+like(http(
+	'GET /body HTTP/1.0' . CRLF
+	. 'Host: localhost' . CRLF
+	. 'Content-Length: 10' . CRLF . CRLF
+	. '1234567890'
+), qr/body: 1234567890/, 'perl body preread');
+
+like(http(
+	'GET /body HTTP/1.0' . CRLF
+	. 'Host: localhost' . CRLF
+	. 'Content-Length: 10' . CRLF . CRLF,
+	sleep => 0.1,
+	body => '1234567890'
+), qr/body: 1234567890/, 'perl body late');
+
+like(http(
+	'GET /body HTTP/1.0' . CRLF
+	. 'Host: localhost' . CRLF
+	. 'Content-Length: 10' . CRLF . CRLF
+	. '12345',
+	sleep => 0.1,
+	body => '67890'
+), qr/body: 1234567890/, 'perl body split');
+
+like(http(
+	'GET /body HTTP/1.1' . CRLF
+	. 'Host: localhost' . CRLF
+	. 'Connection: close' . CRLF
+	. 'Transfer-Encoding: chunked' . CRLF . CRLF
+	. 'a' . CRLF
+	. '1234567890' . CRLF
+	. '0' . CRLF . CRLF
+), qr/body: 1234567890/, 'perl body chunked');
+
+like(http(
+	'GET /body HTTP/1.1' . CRLF
+	. 'Host: localhost' . CRLF
+	. 'Connection: close' . CRLF
+	. 'Transfer-Encoding: chunked' . CRLF . CRLF,
+	sleep => 0.1,
+	body => 'a' . CRLF . '1234567890' . CRLF . '0' . CRLF . CRLF
+), qr/body: 1234567890/, 'perl body chunked late');
+
+like(http(
+	'GET /body HTTP/1.1' . CRLF
+	. 'Host: localhost' . CRLF
+	. 'Connection: close' . CRLF
+	. 'Transfer-Encoding: chunked' . CRLF . CRLF
+	. 'a' . CRLF
+	. '12345',
+	sleep => 0.1,
+	body => '67890' . CRLF . '0' . CRLF . CRLF
+), qr/body: 1234567890/, 'perl body chunked split');
+
+like(http(
+	'GET /discard HTTP/1.1' . CRLF
+	. 'Host: localhost' . CRLF
+	. 'Connection: close' . CRLF
+	. 'Transfer-Encoding: chunked' . CRLF . CRLF
+	. 'a' . CRLF
+	. '1234567890' . CRLF
+	. '0' . CRLF . CRLF
+), qr/host: localhost/, 'perl body discard');
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.17.2');
+
+like(http(
+	'GET /discard HTTP/1.1' . CRLF
+	. 'Host: localhost' . CRLF
+	. 'Connection: close' . CRLF
+	. 'Transfer-Encoding: chunked' . CRLF . CRLF
+	. 'ak' . CRLF
+	. '1234567890' . CRLF
+	. '0' . CRLF . CRLF
+), qr/400 Bad Request/, 'perl body discard bad chunk');
+
+like(http(
+	'GET /body HTTP/1.1' . CRLF
+	. 'Host: localhost' . CRLF
+	. 'Connection: close' . CRLF
+	. 'Transfer-Encoding: chunked' . CRLF . CRLF
+	. 'ak' . CRLF
+	. '1234567890' . CRLF
+	. '0' . CRLF . CRLF
+), qr/400 Bad Request/, 'perl body bad chunk');
+
+}
+
+###############################################################################
diff --git a/tests/perl_gzip.t b/tests/perl_gzip.t
new file mode 100644
index 0000000..01700c4
--- /dev/null
+++ b/tests/perl_gzip.t
@@ -0,0 +1,83 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for embedded perl module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx qw/ :DEFAULT :gzip /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require IO::Compress::Gzip; };
+plan(skip_all => "IO::Compress::Gzip not found") if $@;
+
+my $t = Test::Nginx->new()->has(qw/http perl gzip/)->plan(2)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        gzip on;
+        gzip_types text/plain;
+
+        location / {
+            perl 'sub {
+                my $r = shift;
+                $r->send_http_header("text/plain");
+                return OK if $r->header_only;
+                $r->print("TEST");
+                return OK;
+            }';
+        }
+
+        location /gz {
+            perl 'sub {
+                my $r = shift;
+                $r->header_out("Content-Encoding", "gzip");
+                $r->send_http_header("text/plain");
+                return OK if $r->header_only;
+                use IO::Compress::Gzip;
+                my $in = "TEST";
+                my $out;
+                IO::Compress::Gzip::gzip(\\$in => \\$out);
+                $r->print($out);
+                return OK;
+            }';
+        }
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+http_gzip_like(http_gzip_request('/'), qr/TEST/, 'perl response gzipped');
+http_gzip_like(http_gzip_request('/gz'), qr/TEST/, 'not doublegzipped');
+
+###############################################################################
diff --git a/tests/perl_sleep.t b/tests/perl_sleep.t
new file mode 100644
index 0000000..6fdcf36
--- /dev/null
+++ b/tests/perl_sleep.t
@@ -0,0 +1,76 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for embedded perl module, $r->sleep().
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http perl ssi/)->plan(2)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            ssi on;
+            sendfile_max_chunk 100;
+            postpone_output 0;
+        }
+
+        location /sleep {
+            perl 'sub {
+                my $r = shift;
+
+                $r->sleep(100, sub {
+                    my $r = shift;
+                    $r->send_http_header;
+                    $r->print("it works");
+                    return OK;
+                });
+
+                return OK;
+            }';
+        }
+    }
+}
+
+EOF
+
+$t->write_file('subrequest.html', ('x' x 200) .
+	'X<!--#include virtual="/sleep" -->X');
+
+$t->run();
+
+###############################################################################
+
+like(http_get('/sleep'), qr/works/, 'perl sleep');
+like(http_get('/subrequest.html'), qr/works/, 'perl sleep in subrequest');
+
+###############################################################################
diff --git a/tests/perl_ssi.t b/tests/perl_ssi.t
new file mode 100644
index 0000000..9d6d377
--- /dev/null
+++ b/tests/perl_ssi.t
@@ -0,0 +1,65 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for embedded perl module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http perl ssi/)->plan(3)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            ssi on;
+        }
+
+        location /dummy {
+            perl 'sub foo { my $r = shift; $r->print(join ",", @_); }';
+        }
+    }
+}
+
+EOF
+
+$t->write_file('t1.html', 'X<!--#perl sub="foo" arg="arg1" -->X');
+$t->write_file('t2.html', 'X<!--#perl sub="foo" arg="arg1" arg="arg2" -->X');
+$t->write_file('noargs.html', 'X<!--#perl sub="foo" -->X');
+
+$t->run();
+
+###############################################################################
+
+like(http_get('/t1.html'), qr/Xarg1X/, 'perl ssi response');
+like(http_get('/t2.html'), qr/Xarg1,arg2X/, 'perl ssi two args');
+like(http_get('/noargs.html'), qr/XX/, 'perl ssi noargs');
+
+###############################################################################
diff --git a/tests/post_action.t b/tests/post_action.t
new file mode 100644
index 0000000..ab47a82
--- /dev/null
+++ b/tests/post_action.t
@@ -0,0 +1,81 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+# (C) Nginx, Inc.
+
+# Tests for nginx post_action directive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy/)->plan(5);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            post_action /post.html;
+        }
+
+        location /post.html {
+            # static
+        }
+
+        location /remote {
+            post_action /post.remote;
+        }
+
+        location /post.remote {
+            proxy_pass http://127.0.0.1:8080/post.html;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('index.html', 'SEE-THIS');
+$t->write_file('post.html', 'HIDDEN');
+$t->write_file('remote', 'SEE-THIS');
+
+$t->run();
+
+###############################################################################
+
+like(http_get('/'), qr/SEE-THIS/m, 'post action');
+unlike(http_get('/'), qr/HIDDEN/m, 'no additional body');
+
+like(http_get('/remote'), qr/SEE-THIS/m, 'post action proxy');
+unlike(http_get('/remote'), qr/HIDDEN/m, 'no additional body proxy');
+
+$t->stop();
+
+like(`cat ${\($t->testdir())}/access.log`, qr/post/, 'post action in logs');
+
+###############################################################################
diff --git a/tests/proxy.t b/tests/proxy.t
new file mode 100644
index 0000000..324e451
--- /dev/null
+++ b/tests/proxy.t
@@ -0,0 +1,292 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for http proxy module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy/)->plan(28);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    log_format time '$upstream_connect_time:$upstream_header_time:'
+                    '$upstream_response_time';
+
+    upstream u {
+        server 127.0.0.1:8081;
+    }
+
+    upstream u2 {
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8081;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        add_header X-Connect $upstream_connect_time;
+        add_header X-Header $upstream_header_time;
+        add_header X-Response $upstream_response_time;
+
+        location / {
+            proxy_pass http://127.0.0.1:8081;
+            proxy_read_timeout 2s;
+            proxy_connect_timeout 2s;
+        }
+
+        location /var {
+            proxy_pass http://$arg_b;
+            proxy_read_timeout 2s;
+            proxy_connect_timeout 2s;
+        }
+
+        location /timeout {
+            proxy_pass http://127.0.0.1:8081;
+            proxy_connect_timeout 2s;
+        }
+
+        location /time/ {
+            proxy_pass http://127.0.0.1:8081/;
+            access_log %%TESTDIR%%/time.log time;
+        }
+
+        location /pnu {
+            proxy_pass http://u2/bad;
+        }
+
+        location /vars {
+            proxy_pass http://127.0.0.1:8080/stub;
+
+            add_header X-Proxy-Host $proxy_host;
+            add_header X-Proxy-Port $proxy_port;
+            add_header X-Proxy-Forwarded $proxy_add_x_forwarded_for;
+        }
+
+        location /stub { }
+    }
+}
+
+EOF
+
+$t->write_file('stub', '');
+$t->run_daemon(\&http_daemon);
+$t->run()->waitforsocket('127.0.0.1:' . port(8081));
+
+###############################################################################
+
+like(http_get('/'), qr/SEE-THIS/, 'proxy request');
+like(http_get('/multi'), qr/AND-THIS/, 'proxy request with multiple packets');
+
+unlike(http_head('/'), qr/SEE-THIS/, 'proxy head request');
+
+like(http_get('/var?b=127.0.0.1:' . port(8081) . '/'), qr/SEE-THIS/,
+	'proxy with variables');
+like(http_get('/var?b=u/'), qr/SEE-THIS/, 'proxy with variables to upstream');
+
+like(http_get('/timeout'), qr/200 OK/, 'proxy connect timeout');
+
+my $re = qr/(\d\.\d{3})/;
+my $p0 = port(8080);
+my ($ct, $ht, $rt, $ct2, $ht2, $rt2, $ct3, $ht3, $rt3);
+
+like(http_get('/vars'), qr/X-Proxy-Host:\s127\.0\.0\.1:$p0/, 'proxy_host');
+like(http_get('/vars'), qr/X-Proxy-Port:\s$p0/, 'proxy_port');
+like(http_xff('/vars', '192.0.2.1'), qr/X-Proxy-Forwarded:.*192\.0\.2\.1/,
+	'proxy_add_x_forwarded_for');
+
+($ct, $ht) = get('/time/header');
+cmp_ok($ct, '<', 1, 'connect time - slow response header');
+cmp_ok($ht, '>=', 1, 'header time - slow response header');
+
+($ct, $ht) = get('/time/body');
+cmp_ok($ct, '<', 1, 'connect time - slow response body');
+cmp_ok($ht, '<', 1, 'header time - slow response body');
+
+my $s = http_get('/time/header', start => 1);
+select undef, undef, undef, 0.4;
+close ($s);
+
+# expect no header time in 1st (bad) upstream, no (yet) response time in 2nd
+
+$re = qr/(\d\.\d{3}|-)/;
+($ct, $ct2, $ht, $ht2, $rt, $rt2) = get('/pnu', many => 1);
+
+cmp_ok($ct, '<', 1, 'connect time - next');
+cmp_ok($ct2, '<', 1, 'connect time - next 2');
+
+is($ht, '-', 'header time - next');
+cmp_ok($ht2, '<', 1, 'header time - next 2');
+
+cmp_ok($rt, '>=', 1, 'response time - next');
+is($rt2, '-', 'response time - next 2');
+
+$t->stop();
+
+($ct, $ht, $rt, $ct2, $ht2, $rt2, $ct3, $ht3, $rt3)
+	= $t->read_file('time.log') =~ /^$re:$re:$re\n$re:$re:$re\n$re:$re:$re$/;
+
+cmp_ok($ct, '<', 1, 'connect time log - slow response header');
+cmp_ok($ct2, '<', 1, 'connect time log - slow response body');
+cmp_ok($ct3, '<', 1, 'connect time log - client close');
+
+cmp_ok($ht, '>=', 1, 'header time log - slow response header');
+cmp_ok($ht2, '<', 1, 'header time log - slow response body');
+is($ht3, '-', 'header time log - client close');
+
+cmp_ok($rt, '>=', 1, 'response time log - slow response header');
+cmp_ok($rt2, '>=', 1, 'response time log - slow response body');
+cmp_ok($rt3, '>', $ct3, 'response time log - client close');
+
+###############################################################################
+
+sub get {
+	my ($uri, %extra) = @_;
+	my $re = $extra{many} ? qr/$re, $re?/ : $re;
+	my $r = http_get($uri);
+	$r =~ /X-Connect: $re/, $r =~ /X-Header: $re/, $r =~ /X-Response: $re/;
+}
+
+sub http_xff {
+	my ($uri, $xff) = @_;
+	return http(<<EOF);
+GET $uri HTTP/1.0
+Host: localhost
+X-Forwarded-For: $xff
+
+EOF
+}
+
+sub http_daemon {
+	my $once = 1;
+	my $server = IO::Socket::INET->new(
+		Proto => 'tcp',
+		LocalHost => '127.0.0.1:' . port(8081),
+		Listen => 5,
+		Reuse => 1
+	)
+		or die "Can't create listening socket: $!\n";
+
+	local $SIG{PIPE} = 'IGNORE';
+
+	while (my $client = $server->accept()) {
+		$client->autoflush(1);
+
+		my $headers = '';
+		my $uri = '';
+
+		while (<$client>) {
+			$headers .= $_;
+			last if (/^\x0d?\x0a?$/);
+		}
+
+		$uri = $1 if $headers =~ /^\S+\s+([^ ]+)\s+HTTP/i;
+
+		if ($uri eq '/') {
+			print $client <<'EOF';
+HTTP/1.1 200 OK
+Connection: close
+
+EOF
+			print $client "TEST-OK-IF-YOU-SEE-THIS"
+				unless $headers =~ /^HEAD/i;
+
+		} elsif ($uri eq '/multi') {
+
+			print $client <<"EOF";
+HTTP/1.1 200 OK
+Connection: close
+
+TEST-OK-IF-YOU-SEE-THIS
+EOF
+
+			select undef, undef, undef, 0.1;
+			print $client 'AND-THIS';
+
+		} elsif ($uri eq '/timeout') {
+			sleep 3;
+
+			print $client <<"EOF";
+HTTP/1.1 200 OK
+Connection: close
+
+EOF
+
+		} elsif ($uri eq '/bad') {
+
+			if ($once) {
+				$once = 0;
+				select undef, undef, undef, 1.1;
+				next;
+			}
+
+			print $client <<EOF;
+HTTP/1.1 200 OK
+Connection: close
+
+SEE-THIS-AND-THIS
+EOF
+
+		} elsif ($uri eq '/header') {
+			select undef, undef, undef, 1.1;
+
+			print $client <<EOF;
+HTTP/1.1 200 OK
+Connection: close
+
+SEE-THIS-AND-THIS;
+EOF
+
+		} elsif ($uri eq '/body') {
+
+			print $client <<EOF;
+HTTP/1.1 200 OK
+Connection: close
+
+SEE-THIS-
+EOF
+
+			select undef, undef, undef, 1.1;
+			print $client 'AND-THIS';
+
+		} else {
+
+			print $client <<"EOF";
+HTTP/1.1 404 Not Found
+Connection: close
+
+Oops, '$uri' not found
+EOF
+		}
+
+		close $client;
+	}
+}
+
+###############################################################################
diff --git a/tests/proxy_bind.t b/tests/proxy_bind.t
new file mode 100644
index 0000000..437a29f
--- /dev/null
+++ b/tests/proxy_bind.t
@@ -0,0 +1,98 @@
+#!/usr/bin/perl
+
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+
+# Tests for http proxy_bind directive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+plan(skip_all => 'win32') if $^O eq 'MSWin32';
+plan(skip_all => '127.0.0.2 local address required')
+	unless defined IO::Socket::INET->new( LocalAddr => '127.0.0.2' );
+
+my $t = Test::Nginx->new()->has(qw/http proxy/)->plan(5)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen          127.0.0.1:8080;
+        server_name     localhost;
+
+        proxy_bind      127.0.0.2;
+
+        location / {
+            proxy_bind  127.0.0.1;
+            proxy_pass  http://127.0.0.1:8081/;
+        }
+
+        location /inherit {
+            proxy_pass  http://127.0.0.1:8081/;
+        }
+
+        location /off {
+            proxy_bind  off;
+            proxy_pass  http://127.0.0.1:8081/;
+        }
+
+        location /var {
+            proxy_bind  $arg_b;
+            proxy_pass  http://127.0.0.1:8081/;
+        }
+
+        location /port {
+            proxy_bind  127.0.0.2:$remote_port;
+            proxy_pass  http://127.0.0.1:8081/;
+            add_header  X-Client-Port $remote_port;
+        }
+    }
+
+    server {
+        listen          127.0.0.1:8081;
+        server_name     localhost;
+
+        location / {
+            add_header   X-IP $remote_addr;
+            add_header   X-Port $remote_port;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('index.html', '');
+$t->run();
+
+###############################################################################
+
+like(http_get('/'), qr/X-IP: 127.0.0.1/, 'bind');
+like(http_get('/inherit'), qr/X-IP: 127.0.0.2/, 'bind inherit');
+like(http_get('/off'), qr/X-IP: 127.0.0.1/, 'bind off');
+like(http_get('/var?b=127.0.0.2'), qr/X-IP: 127.0.0.2/, 'bind var');
+like(http_get('/port'), qr/Port: (\d+)(?!\d).*Port: \1/s, 'bind port');
+
+###############################################################################
diff --git a/tests/proxy_bind_transparent.t b/tests/proxy_bind_transparent.t
new file mode 100644
index 0000000..73113fd
--- /dev/null
+++ b/tests/proxy_bind_transparent.t
@@ -0,0 +1,71 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http proxy_bind transparent.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+plan(skip_all => 'win32') if $^O eq 'MSWin32';
+plan(skip_all => 'must be root') if $> != 0;
+plan(skip_all => '127.0.0.2 local address required')
+	unless defined IO::Socket::INET->new( LocalAddr => '127.0.0.2' );
+
+my $t = Test::Nginx->new()->has(qw/http proxy/)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen          127.0.0.1:8080;
+        server_name     localhost;
+
+        location / {
+            proxy_bind  127.0.0.2 transparent;
+            proxy_pass  http://127.0.0.1:8081/;
+        }
+    }
+
+    server {
+        listen          127.0.0.1:8081;
+        server_name     localhost;
+
+        location / {
+            add_header   X-IP $remote_addr always;
+        }
+    }
+}
+
+EOF
+
+$t->run()->plan(1);
+
+###############################################################################
+
+like(http_get('/'), qr/X-IP: 127.0.0.2/, 'transparent');
+
+###############################################################################
diff --git a/tests/proxy_bind_transparent_capability.t b/tests/proxy_bind_transparent_capability.t
new file mode 100644
index 0000000..626944f
--- /dev/null
+++ b/tests/proxy_bind_transparent_capability.t
@@ -0,0 +1,72 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http proxy_bind transparent with Linux CAP_NET_RAW capability.
+# Ensure that such configuration isn't broken under a non-priveleged user.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+plan(skip_all => 'no linux capability') if $^O ne 'linux';
+plan(skip_all => 'must be root') if $> != 0;
+plan(skip_all => '127.0.0.2 local address required')
+	unless defined IO::Socket::INET->new( LocalAddr => '127.0.0.2' );
+
+my $t = Test::Nginx->new()->has(qw/http proxy/)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen          127.0.0.1:8080;
+        server_name     localhost;
+
+        location / {
+            proxy_bind  127.0.0.2 transparent;
+            proxy_pass  http://127.0.0.1:8081/;
+        }
+    }
+
+    server {
+        listen          127.0.0.1:8081;
+        server_name     localhost;
+
+        location / {
+            add_header   X-IP $remote_addr always;
+        }
+    }
+}
+
+EOF
+
+$t->run()->plan(1);
+
+###############################################################################
+
+like(http_get('/'), qr/X-IP: 127.0.0.2/, 'transparent');
+
+###############################################################################
diff --git a/tests/proxy_cache.t b/tests/proxy_cache.t
new file mode 100644
index 0000000..614bcb7
--- /dev/null
+++ b/tests/proxy_cache.t
@@ -0,0 +1,144 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for http proxy cache.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx qw/ :DEFAULT :gzip /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy cache gzip/)->plan(15)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    proxy_cache_path   %%TESTDIR%%/cache  levels=1:2
+                       keys_zone=NAME:1m;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        gzip on;
+        gzip_min_length 0;
+
+        location / {
+            proxy_pass    http://127.0.0.1:8081;
+
+            proxy_cache   NAME;
+
+            proxy_cache_valid   200 302  2s;
+            proxy_cache_valid   301      1d;
+            proxy_cache_valid   any      1m;
+
+            proxy_cache_min_uses  1;
+
+            proxy_cache_use_stale  error timeout invalid_header http_500
+                                   http_404;
+
+            proxy_no_cache  $arg_e;
+
+            add_header X-Cache-Status $upstream_cache_status;
+        }
+    }
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location / {
+            limit_rate 512;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('t.html', 'SEE-THIS');
+$t->write_file('t2.html', 'SEE-THIS');
+$t->write_file('empty.html', '');
+$t->write_file('big.html', 'x' x 1024);
+
+$t->run();
+
+###############################################################################
+
+like(http_get('/t.html'), qr/SEE-THIS/, 'proxy request');
+
+$t->write_file('t.html', 'NOOP');
+like(http_get('/t.html'), qr/SEE-THIS/, 'proxy request cached');
+
+unlike(http_head('/t2.html'), qr/SEE-THIS/, 'head request');
+like(http_get('/t2.html'), qr/SEE-THIS/, 'get after head');
+unlike(http_head('/t2.html'), qr/SEE-THIS/, 'head after get');
+
+like(http_head('/empty.html?head'), qr/MISS/, 'empty head first');
+like(http_head('/empty.html?head'), qr/HIT/, 'empty head second');
+
+like(http_get_range('/t.html', 'Range: bytes=4-'), qr/^THIS/m, 'cached range');
+like(http_get_range('/t.html', 'Range: bytes=0-2,4-'), qr/^SEE.*^THIS/ms,
+	'cached multipart range');
+
+like(http_get('/empty.html'), qr/MISS/, 'empty get first');
+like(http_get('/empty.html'), qr/HIT/, 'empty get second');
+
+select(undef, undef, undef, 3.1);
+unlink $t->testdir() . '/t.html';
+like(http_gzip_request('/t.html'),
+	qr/HTTP.*STALE.*1c\x0d\x0a.{28}\x0d\x0a0\x0d\x0a\x0d\x0a\z/s,
+	'non-empty get stale');
+
+unlink $t->testdir() . '/empty.html';
+like(http_gzip_request('/empty.html'),
+	qr/HTTP.*STALE.*14\x0d\x0a.{20}\x0d\x0a0\x0d\x0a\x0d\x0a\z/s,
+	'empty get stale');
+
+# no client connection close with response on non-cacheable HEAD requests
+# see 545b5e4d83b2 in nginx for detailed explanation
+
+my $s = http(<<EOF, start => 1);
+HEAD /big.html?e=1 HTTP/1.1
+Host: localhost
+
+EOF
+
+my $r = http_get('/t.html', socket => $s);
+
+like($r, qr/Connection: keep-alive/, 'non-cacheable head - keepalive');
+like($r, qr/SEE-THIS/, 'non-cacheable head - second');
+
+###############################################################################
+
+sub http_get_range {
+	my ($url, $extra) = @_;
+	return http(<<EOF);
+GET $url HTTP/1.1
+Host: localhost
+Connection: close
+$extra
+
+EOF
+}
+
+###############################################################################
diff --git a/tests/proxy_cache_bypass.t b/tests/proxy_cache_bypass.t
new file mode 100644
index 0000000..68edc43
--- /dev/null
+++ b/tests/proxy_cache_bypass.t
@@ -0,0 +1,98 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for http proxy cache, proxy_cache_bypass.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy cache rewrite/)->plan(8)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    proxy_cache_path %%TESTDIR%%/cache keys_zone=one:1m;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            proxy_pass http://127.0.0.1:8081;
+
+            proxy_cache one;
+            proxy_cache_key $uri;
+            proxy_cache_bypass $arg_bypass;
+            proxy_cache_valid any 1y;
+
+            proxy_intercept_errors on;
+            error_page 404 = @fallback;
+        }
+
+        location @fallback {
+            return 403;
+        }
+
+        add_header X-Cache-Status $upstream_cache_status;
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location / {
+        }
+    }
+}
+
+EOF
+
+$t->write_file('t', 'SEE-THIS');
+
+$t->run();
+
+###############################################################################
+
+like(http_get('/t'), qr/SEE-THIS/, 'request');
+
+$t->write_file('t', 'NOOP');
+
+like(http_get('/t'), qr/SEE-THIS/, 'request cached');
+like(http_get('/t?bypass=1'), qr/NOOP/, 'cache bypassed');
+like(http_get('/t'), qr/NOOP/, 'cached after bypass');
+
+# ticket #827, cache item "error" field was not cleared
+# on cache bypass
+
+like(http_get('/t2'), qr/403 Forbidden/, 'intercepted error');
+
+$t->write_file('t2', 'NOOP');
+
+like(http_get('/t2'), qr/403 Forbidden/, 'error cached');
+like(http_get('/t2?bypass=1'), qr/NOOP/, 'error cache bypassed');
+like(http_get('/t2'), qr/NOOP/, 'error cached after bypass');
+
+###############################################################################
diff --git a/tests/proxy_cache_chunked.t b/tests/proxy_cache_chunked.t
new file mode 100644
index 0000000..4df0019
--- /dev/null
+++ b/tests/proxy_cache_chunked.t
@@ -0,0 +1,102 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Test for proxy cache with Transfer-Encoding: chunked.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy cache/)->plan(2);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    proxy_cache_path %%TESTDIR%%/cache keys_zone=NAME:1m;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            proxy_pass http://127.0.0.1:8081;
+            proxy_http_version 1.1;
+            proxy_cache NAME;
+            proxy_cache_valid any 1m;
+            add_header X-Status $upstream_cache_status;
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&http_chunked_daemon);
+$t->run()->waitforsocket('127.0.0.1:' . port(8081));
+
+###############################################################################
+
+like(http_get("/"), qr/SEE-THIS/s, "chunked");
+like(http_get("/"), qr/SEE-THIS.*HIT/s, "chunked cached");
+
+###############################################################################
+
+sub http_chunked_daemon {
+	my $server = IO::Socket::INET->new(
+		Proto => 'tcp',
+		LocalAddr => '127.0.0.1:' . port(8081),
+		Listen => 5,
+		Reuse => 1
+	)
+		or die "Can't create listening socket: $!\n";
+
+	local $SIG{PIPE} = 'IGNORE';
+
+	while (my $client = $server->accept()) {
+		$client->autoflush(1);
+
+		while (<$client>) {
+			last if (/^\x0d?\x0a?$/);
+		}
+
+		print $client <<'EOF';
+HTTP/1.1 200 OK
+X-Test: SEE-THIS
+Connection: close
+Transfer-Encoding: chunked
+
+EOF
+		print $client "85" . CRLF;
+		select undef, undef, undef, 0.1;
+		print $client "FOO" . ("0123456789abcdef" x 8) . CRLF . CRLF;
+
+		print $client "0" . CRLF . CRLF;
+		close $client;
+	}
+}
+
+###############################################################################
diff --git a/tests/proxy_cache_convert_head.t b/tests/proxy_cache_convert_head.t
new file mode 100644
index 0000000..cb1e46c
--- /dev/null
+++ b/tests/proxy_cache_convert_head.t
@@ -0,0 +1,96 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http proxy cache with proxy_cache_convert_head directive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy cache/)->plan(8)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    proxy_cache_path   %%TESTDIR%%/cache  levels=1:2
+                       keys_zone=NAME:1m;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        proxy_cache   NAME;
+
+        proxy_cache_key $request_uri;
+
+        proxy_cache_valid   200 302  2s;
+
+        add_header X-Cache-Status $upstream_cache_status;
+
+        location / {
+            proxy_pass http://127.0.0.1:8081/t.html;
+            proxy_cache_convert_head   off;
+
+            location /inner {
+                proxy_pass http://127.0.0.1:8081/t.html;
+                proxy_cache_convert_head on;
+            }
+        }
+
+        location /on {
+            proxy_pass http://127.0.0.1:8081/t.html;
+            proxy_cache_convert_head on;
+        }
+    }
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location / {
+            add_header X-Method $request_method;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('t.html', 'SEE-THIS');
+$t->run();
+
+###############################################################################
+
+like(http_get('/'), qr/X-Method: GET/, 'get');
+like(http_head('/?2'), qr/X-Method: HEAD/, 'head');
+like(http_head('/?2'), qr/HIT/, 'head cached');
+unlike(http_get('/?2'), qr/SEE-THIS/, 'get after head');
+
+like(http_get('/on'), qr/X-Method: GET/, 'on - get');
+like(http_head('/on?2'), qr/X-Method: GET/, 'on - head');
+
+like(http_get('/inner'), qr/X-Method: GET/, 'inner - get');
+like(http_head('/inner?2'), qr/X-Method: GET/, 'inner - head');
+
+###############################################################################
diff --git a/tests/proxy_cache_error.t b/tests/proxy_cache_error.t
new file mode 100644
index 0000000..2ac2d7e
--- /dev/null
+++ b/tests/proxy_cache_error.t
@@ -0,0 +1,86 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for http proxy cache, "header already sent" alerts on backend errors,
+# http://mailman.nginx.org/pipermail/nginx-devel/2018-January/010737.html.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy cache/)->plan(1)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    proxy_cache_path   %%TESTDIR%%/cache  levels=1:2
+                       keys_zone=NAME:1m;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            proxy_pass    http://127.0.0.1:8081;
+            proxy_cache   NAME;
+
+            proxy_read_timeout 500ms;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location / {
+            postpone_output 0;
+            limit_rate 512;
+            expires 1m;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('big.html', 'x' x 1024);
+
+$t->run();
+
+###############################################################################
+
+# make a HEAD request; since cache is enabled, nginx converts HEAD to GET
+# and will set u->pipe->downstream_error to suppress sending the response
+# body to the client
+
+like(http_head('/big.html'), qr/200 OK/, 'head request');
+
+# once proxy_read_timeout expires, nginx will call
+# ngx_http_finalize_upstream_request() with u->pipe->downstream_error set
+# and rc = NGX_HTTP_GATEWAY_BAD_GATEWAY; after revision ad3f342f14ba046c this
+# will result in ngx_http_finalize_request(NGX_HTTP_GATEWAY_BAD_GATEWAY),
+# leading to an attempt to return additional error response and
+# the "header already sent" alert; fixed in 93abb5a855d6
+
+###############################################################################
diff --git a/tests/proxy_cache_lock.t b/tests/proxy_cache_lock.t
new file mode 100644
index 0000000..976a07d
--- /dev/null
+++ b/tests/proxy_cache_lock.t
@@ -0,0 +1,164 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for http proxy cache lock.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx qw/ :DEFAULT http_end /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy cache/)->plan(17)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    proxy_cache_path   %%TESTDIR%%/cache  levels=1:2
+                       keys_zone=NAME:1m;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            proxy_pass    http://127.0.0.1:8081;
+            proxy_cache   NAME;
+
+            proxy_cache_lock on;
+        }
+
+        location /timeout {
+            proxy_pass    http://127.0.0.1:8081;
+            proxy_cache   NAME;
+
+            proxy_cache_lock on;
+            proxy_cache_lock_timeout 200ms;
+        }
+
+        location /nolock {
+            proxy_pass    http://127.0.0.1:8081;
+            proxy_cache   NAME;
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&http_fake_daemon);
+
+$t->run();
+
+$t->waitforsocket('127.0.0.1:' . port(8081));
+
+###############################################################################
+
+# sequential requests
+
+for my $i (1 .. 5) {
+	like(http_get('/seq'), qr/request 1/, 'sequential request ' . $i);
+}
+
+# parallel requests
+
+my @sockets;
+
+for my $i (1 .. 5) {
+	$sockets[$i] = http_get('/par1', start => 1);
+}
+
+for my $i (1 .. 5) {
+	like(http_end($sockets[$i]), qr/request 1/, 'parallel request ' . $i);
+}
+
+like(http_get('/par1'), qr/request 1/, 'first request cached');
+
+# since 1.7.8, parallel requests with cache lock timeout expired are not cached
+
+for my $i (1 .. 3) {
+	$sockets[$i] = http_get('/timeout', start => 1);
+}
+
+like(http_end($sockets[1]), qr/request 1/, 'lock timeout - first');
+
+my $rest = http_end($sockets[2]);
+$rest .= http_end($sockets[3]);
+
+like($rest, qr/request (2.*request 3|3.*request 2)/s, 'lock timeout - rest');
+like(http_get('/timeout'), qr/request 1/, 'lock timeout - first only cached');
+
+# no lock
+
+for my $i (1 .. 3) {
+	$sockets[$i] = http_get('/nolock', start => 1);
+}
+
+$rest = join '', map { http_end($sockets[$_]) } (1 .. 3);
+
+like($rest, qr/request 1/, 'nolock - first');
+like($rest, qr/request 3/, 'nolock - last');
+like(http_get('/nolock'), qr/request 3/, 'nolock - last cached');
+
+###############################################################################
+
+sub http_fake_daemon {
+	my $server = IO::Socket::INET->new(
+		Proto => 'tcp',
+		LocalAddr => '127.0.0.1:' . port(8081),
+		Listen => 5,
+		Reuse => 1
+	)
+		or die "Can't create listening socket: $!\n";
+
+	my $num = 0;
+	my $uri = '';
+
+	while (my $client = $server->accept()) {
+		$client->autoflush(1);
+
+		while (<$client>) {
+			if (/GET (.*) HTTP/ && $1 ne $uri) {
+				$uri = $1;
+				$num = 0;
+			}
+
+			$uri = $1 if /GET (.*) HTTP/;
+			last if /^\x0d?\x0a?$/;
+		}
+
+		next unless $uri;
+
+		select(undef, undef, undef, 1.1);
+
+		$num++;
+		print $client <<"EOF";
+HTTP/1.1 200 OK
+Cache-Control: max-age=300
+Connection: close
+
+request $num
+EOF
+	}
+}
+
+###############################################################################
diff --git a/tests/proxy_cache_lock_age.t b/tests/proxy_cache_lock_age.t
new file mode 100644
index 0000000..12fe87a
--- /dev/null
+++ b/tests/proxy_cache_lock_age.t
@@ -0,0 +1,151 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http proxy cache lock aged.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use IO::Select;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx qw/ :DEFAULT http_end /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy cache/)->plan(4)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    proxy_cache_path   %%TESTDIR%%/cache  levels=1:2
+                       keys_zone=NAME:1m;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            proxy_pass    http://127.0.0.1:8081;
+            proxy_cache   NAME;
+
+            proxy_cache_lock on;
+            proxy_cache_lock_age 100ms;
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&http_daemon, port(8081));
+$t->run()->waitforsocket('127.0.0.1:' . port(8081));
+
+###############################################################################
+
+my $s = http_get('/', start => 1);
+
+like(http_get('/'), qr/request 2/, 'request');
+like(http_get('/'), qr/request 2/, 'request cached');
+
+http_get('/close');
+
+like(http_end($s), qr/request 1/, 'request aged');
+like(http_get('/'), qr/request 1/, 'request aged cached');
+
+###############################################################################
+
+sub http_daemon {
+	my (@ports) = @_;
+	my @socks;
+
+	for my $port (@ports) {
+		my $server = IO::Socket::INET->new(
+			Proto => 'tcp',
+			LocalHost => "127.0.0.1:$port",
+			Listen => 5,
+			Reuse => 1
+		)
+			or die "Can't create listening socket: $!\n";
+		push @socks, $server;
+	}
+
+	my $sel = IO::Select->new(@socks);
+	my $num = 0;
+	my $s;
+
+	local $SIG{PIPE} = 'IGNORE';
+
+	while (my @ready = $sel->can_read) {
+		foreach my $fh (@ready) {
+			if (grep $_ == $fh, @socks) {
+				my $new = $fh->accept;
+				$new->autoflush(1);
+				$sel->add($new);
+
+			} elsif (process_socket($fh, \$num, \$s)) {
+				$sel->remove($fh);
+				$fh->close;
+			}
+		}
+	}
+}
+
+# Returns true to close connection
+
+sub process_socket {
+	my ($client, $num, $s) = @_;
+
+	my $headers = '';
+	my $uri = '';
+
+	while (<$client>) {
+		$headers .= $_;
+		last if (/^\x0d?\x0a?$/);
+	}
+	return 1 if $headers eq '';
+
+	$uri = $1 if $headers =~ /^\S+\s+([^ ]+)\s+HTTP/i;
+	return 1 if $uri eq '';
+
+	# finish a previously saved socket
+	close $$s if $uri eq '/close';
+
+	$$num++;
+
+	print $client <<EOF;
+HTTP/1.1 200 OK
+Cache-Control: max-age=300
+Connection: close
+
+request $$num
+EOF
+
+	# save socket and wait
+	if ($$num == 1) {
+		$$s = $client;
+		return 0;
+	}
+
+	return 1;
+}
+
+###############################################################################
diff --git a/tests/proxy_cache_lock_ssi.t b/tests/proxy_cache_lock_ssi.t
new file mode 100644
index 0000000..332cb78
--- /dev/null
+++ b/tests/proxy_cache_lock_ssi.t
@@ -0,0 +1,105 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for http proxy cache lock with subrequests.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx qw/ :DEFAULT http_end /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy cache ssi/)
+	->write_file_expand('nginx.conf', <<'EOF')->plan(2);
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    proxy_cache_path   %%TESTDIR%%/cache  levels=1:2
+                       keys_zone=NAME:1m;
+
+    limit_req_zone $binary_remote_addr zone=one:1m rate=1r/m;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            proxy_pass    http://127.0.0.1:8081;
+            proxy_cache   NAME;
+
+            proxy_cache_lock on;
+            proxy_cache_lock_timeout 100ms;
+
+            proxy_read_timeout 3s;
+        }
+
+        location = /ssi.html {
+            ssi on;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+        limit_req zone=one burst=5;
+    }
+
+}
+
+EOF
+
+$t->write_file('ssi.html',
+	'<!--#include virtual="/active" -->' .
+	'<!--#include virtual="/locked" -->' .
+	'end'
+);
+
+$t->write_file('active', 'active');
+$t->write_file('locked', 'locked');
+
+$t->run();
+
+###############################################################################
+
+# problem: if proxy cache lock wakeup happens in an inactive
+# subrequest, just a connection write event may not trigger any
+# further work
+
+# main request -> subrequest /active (waiting for a backend),
+#              -> subrequest /locked (locked by another request)
+
+# this doesn't result in an infinite timeout as second subrequest
+# is woken up by the postpone filter once first subrequest completes,
+# but this is suboptimal behaviour
+
+http_get('/charge');
+my $start = time();
+
+my $s = http_get('/locked', start => 1);
+select undef, undef, undef, 0.2;
+
+like(http_get('/ssi.html'), qr/end/, 'cache lock ssi');
+http_end($s);
+cmp_ok(time() - $start, '<=', 5, 'parallel execution after lock timeout');
+
+###############################################################################
diff --git a/tests/proxy_cache_manager.t b/tests/proxy_cache_manager.t
new file mode 100644
index 0000000..058474c
--- /dev/null
+++ b/tests/proxy_cache_manager.t
@@ -0,0 +1,119 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http proxy cache, manager parameters.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+plan(skip_all => 'long test') unless $ENV{TEST_NGINX_UNSAFE};
+
+plan(skip_all => 'page size is not appropriate') unless
+        POSIX::sysconf(&POSIX::_SC_PAGESIZE) == 4096;
+
+my $t = Test::Nginx->new()->has(qw/http proxy cache/)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    proxy_cache_path   %%TESTDIR%%/cache  max_size=0  keys_zone=NAME:1m
+                       manager_sleep=5  manager_files=2  manager_threshold=10;
+
+    proxy_cache_path   %%TESTDIR%%/water  keys_zone=NAM2:16k
+                       manager_sleep=5;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            proxy_pass    http://127.0.0.1:8081;
+            proxy_cache   NAME;
+
+            proxy_cache_valid   any   1m;
+        }
+
+        location /water/ {
+            proxy_pass    http://127.0.0.1:8081/t.html;
+            proxy_cache   NAM2;
+
+            proxy_cache_valid   any   1m;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location / { }
+    }
+}
+
+EOF
+
+$t->write_file('t.html', 'SEE-THIS');
+$t->run()->plan(3);
+
+###############################################################################
+
+my $d = $t->testdir();
+
+# wait for cache manager start
+
+sleep 1;
+
+http_get("/t.html?$_") for (1 .. 5);
+
+# pretend we could not fit into zone
+
+http_get("/water/?$_") for (1 .. 100);
+
+my $n = files("$d/water");
+
+# wait for cache manager process
+
+sleep 10;
+
+cmp_ok(files("$d/water"), '<', $n, 'manager watermark');
+
+is(files("$d/cache"), 3, 'manager files');
+
+sleep 5;
+
+is(files("$d/cache"), 1, 'manager sleep');
+
+###############################################################################
+
+sub files {
+	my ($path) = @_;
+	my $dh;
+
+	opendir($dh, $path);
+	return scalar grep { ! /^\./ } readdir($dh);
+}
+
+###############################################################################
diff --git a/tests/proxy_cache_max_range_offset.t b/tests/proxy_cache_max_range_offset.t
new file mode 100644
index 0000000..666f5ce
--- /dev/null
+++ b/tests/proxy_cache_max_range_offset.t
@@ -0,0 +1,119 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http proxy cache, proxy_cache_max_range_offset directive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy cache/)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    proxy_cache_path   %%TESTDIR%%/cache  levels=1:2
+                       keys_zone=NAME:1m;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            proxy_pass    http://127.0.0.1:8081/;
+            proxy_cache   NAME;
+            proxy_cache_valid 200 1m;
+            proxy_cache_max_range_offset 2;
+        }
+
+        location /zero/ {
+            proxy_pass    http://127.0.0.1:8081/;
+            proxy_cache   NAME;
+            proxy_cache_valid 200 1m;
+            proxy_cache_max_range_offset 0;
+        }
+
+        location /min_uses/ {
+            proxy_pass    http://127.0.0.1:8081/;
+            proxy_cache   NAME;
+            proxy_cache_valid 200 1m;
+            proxy_cache_max_range_offset 2;
+            proxy_cache_min_uses 2;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location / {
+            add_header X-Range $http_range;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('t.html', 'SEE-THIS');
+$t->run()->plan(8);
+
+###############################################################################
+
+unlike(get('/t.html?1', 'bytes=1-'), qr/X-Range/, 'range - below');
+like(get('/t.html?2', 'bytes=3-'), qr/X-Range/, 'range - above');
+like(get('/t.html?3', 'bytes=-1'), qr/X-Range/, 'range - last');
+
+TODO: {
+local $TODO = 'not yet';
+
+like(get('/t.html?4', 'bytes=1-1,3-'), qr/X-Range/, 'range - multipart above');
+
+}
+
+like(get('/zero/t.html?5', 'bytes=0-0'), qr/X-Range/, 'always non-cacheable');
+like(get('/min_uses/t.html?6', 'bytes=1-'), qr/X-Range/, 'below min_uses');
+
+# no range in client request
+
+like(http_get('/t.html'), qr/SEE-THIS/, 'no range');
+
+$t->write_file('t.html', 'NOOP');
+like(http_get('/t.html'), qr/SEE-THIS/, 'no range - cached');
+
+###############################################################################
+
+sub get {
+	my ($url, $extra) = @_;
+	return http(<<EOF);
+GET $url HTTP/1.1
+Host: localhost
+Connection: close
+Range: $extra
+
+EOF
+}
+
+###############################################################################
diff --git a/tests/proxy_cache_path.t b/tests/proxy_cache_path.t
new file mode 100644
index 0000000..cac7913
--- /dev/null
+++ b/tests/proxy_cache_path.t
@@ -0,0 +1,87 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http proxy cache with use_temp_path parameter.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy cache/)->plan(6)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    proxy_cache_path   %%TESTDIR%%/cache1
+                       keys_zone=ON:1m      use_temp_path=on;
+    proxy_cache_path   %%TESTDIR%%/cache2
+                       keys_zone=OFF:1m     use_temp_path=off;
+    proxy_cache_path   %%TESTDIR%%/cache4   levels=1:2
+                       keys_zone=LEVELS:1m  use_temp_path=off;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            proxy_pass    http://127.0.0.1:8081;
+
+            proxy_cache   $arg_c;
+
+            proxy_cache_valid   any      1m;
+
+            add_header X-Cache-Status $upstream_cache_status;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location / {
+        }
+    }
+}
+
+EOF
+
+$t->write_file('t', 'SEE-THIS');
+
+$t->run();
+
+###############################################################################
+
+like(http_get('/t?c=ON'), qr/MISS.*SEE-THIS/ms, 'temp path');
+like(http_get('/t?c=OFF'), qr/MISS.*SEE-THIS/ms, 'temp path off');
+like(http_get('/t?c=LEVELS'), qr/MISS.*SEE-THIS/ms, 'temp path levels');
+
+$t->write_file('t', 'SEE-THAT');
+
+like(http_get('/t?c=ON'), qr/HIT.*SEE-THIS/ms, 'temp path cached');
+like(http_get('/t?c=OFF'), qr/HIT.*SEE-THIS/ms, 'temp path cached off');
+like(http_get('/t?c=LEVELS'), qr/HIT.*SEE-THIS/ms, 'temp path cached levels');
+
+###############################################################################
diff --git a/tests/proxy_cache_range.t b/tests/proxy_cache_range.t
new file mode 100644
index 0000000..f540095
--- /dev/null
+++ b/tests/proxy_cache_range.t
@@ -0,0 +1,121 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for http proxy cache and range filter.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy cache/)->plan(7)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    proxy_cache_path   %%TESTDIR%%/cache  levels=1:2
+                       keys_zone=NAME:1m;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            proxy_pass    http://127.0.0.1:8081;
+            proxy_cache   NAME;
+            proxy_cache_valid 200 1m;
+        }
+
+        location /min_uses {
+            proxy_pass    http://127.0.0.1:8081/;
+            proxy_cache   NAME;
+            proxy_cache_valid 200 1m;
+            proxy_cache_min_uses 2;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location / {
+        }
+
+        location /tbig.html {
+            limit_rate 50k;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('t.html', 'SEE-THIS');
+
+# should not fit in a single proxy buffer
+
+$t->write_file('tbig.html',
+	join('', map { sprintf "XX%06dXX", $_ } (1 .. 7000)));
+
+$t->run();
+
+###############################################################################
+
+like(http_get_range('/t.html?1', 'Range: bytes=4-'), qr/^THIS/m,
+	'range on first request');
+
+{
+local $TODO = 'not yet';
+
+like(http_get_range('/t.html?2', 'Range: bytes=0-2,4-'), qr/^SEE.*^THIS/ms,
+	'multipart range on first request');
+}
+
+like(http_get_range('/t.html?1', 'Range: bytes=4-'), qr/^THIS/m,
+	'cached range');
+like(http_get_range('/t.html?1', 'Range: bytes=0-2,4-'), qr/^SEE.*^THIS/ms,
+	'cached multipart range');
+
+like(http_get_range('/min_uses/t.html?3', 'Range: bytes=4-'),
+	qr/^THIS/m, 'range below min_uses');
+
+like(http_get_range('/min_uses/t.html?4', 'Range: bytes=0-2,4-'),
+	qr/^SEE.*^THIS/ms, 'multipart range below min_uses');
+
+like(http_get_range('/tbig.html', 'Range: bytes=0-19'),
+	qr/^XX000001XXXX000002XX$/ms, 'range of response received in parts');
+
+###############################################################################
+
+sub http_get_range {
+	my ($url, $extra) = @_;
+	return http(<<EOF);
+GET $url HTTP/1.1
+Host: localhost
+Connection: close
+$extra
+
+EOF
+}
+
+###############################################################################
diff --git a/tests/proxy_cache_revalidate.t b/tests/proxy_cache_revalidate.t
new file mode 100644
index 0000000..ff828a2
--- /dev/null
+++ b/tests/proxy_cache_revalidate.t
@@ -0,0 +1,168 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for http proxy cache revalidation with conditional requests.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy cache rewrite/)->plan(23)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    proxy_cache_path   %%TESTDIR%%/cache  levels=1:2
+                       keys_zone=one:1m;
+
+    proxy_cache_revalidate on;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            proxy_pass    http://127.0.0.1:8081;
+            proxy_cache   one;
+
+            proxy_cache_valid  200 404  2s;
+
+            add_header X-Cache-Status $upstream_cache_status;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location / { }
+        location /etag/ {
+            proxy_pass http://127.0.0.1:8081/;
+            proxy_hide_header Last-Modified;
+        }
+        location /201 {
+            add_header Last-Modified "Mon, 02 Mar 2015 17:20:58 GMT";
+            add_header Cache-Control "max-age=1";
+            add_header X-If-Modified-Since $http_if_modified_since;
+            return 201;
+        }
+    }
+}
+
+EOF
+
+my $d = $t->testdir();
+
+$t->write_file('t', 'SEE-THIS');
+$t->write_file('t2', 'SEE-THIS');
+$t->write_file('t3', 'SEE-THIS');
+
+$t->run();
+
+###############################################################################
+
+# request documents and make sure they are cached
+
+like(http_get('/t'), qr/X-Cache-Status: MISS.*SEE/ms, 'request');
+like(http_get('/t'), qr/X-Cache-Status: HIT.*SEE/ms, 'request cached');
+
+like(http_get('/t2'), qr/X-Cache-Status: MISS.*SEE/ms, '2nd request');
+like(http_get('/t2'), qr/X-Cache-Status: HIT.*SEE/ms, '2nd request cached');
+
+like(http_get('/etag/t'), qr/X-Cache-Status: MISS.*SEE/ms, 'etag');
+like(http_get('/etag/t'), qr/X-Cache-Status: HIT.*SEE/ms, 'etag cached');
+
+like(http_get('/etag/t2'), qr/X-Cache-Status: MISS.*SEE/ms, 'etag2');
+like(http_get('/etag/t2'), qr/X-Cache-Status: HIT.*SEE/ms, 'etag2 cached');
+
+like(http_get('/201'), qr/X-Cache-Status: MISS/, 'other status');
+like(http_get('/201'), qr/X-Cache-Status: HIT/, 'other status cached');
+
+like(http_get('/t3'), qr/SEE/, 'cache before 404');
+
+# wait for a while for cached responses to expire
+
+select undef, undef, undef, 3.5;
+
+# 1st document isn't modified, and should be revalidated on first request
+# (a 304 status code will appear in backend's logs), then cached again
+
+like(http_get('/t'), qr/X-Cache-Status: REVALIDATED.*SEE/ms, 'revalidated');
+like(http_get('/t'), qr/X-Cache-Status: HIT.*SEE/ms, 'cached again');
+
+rename("$d/t3", "$d/t3_moved");
+
+like(http_get('/t3'), qr/ 404 /, 'cache 404 response');
+
+select undef, undef, undef, 0.1;
+like($t->read_file('access.log'), qr/ 304 /, 'not modified');
+
+# 2nd document is recreated with a new content
+
+$t->write_file('t2', 'NEW');
+like(http_get('/t2'), qr/X-Cache-Status: EXPIRED.*NEW/ms, 'revalidate failed');
+like(http_get('/t2'), qr/X-Cache-Status: HIT.*NEW/ms, 'new response cached');
+
+# the same for etag:
+# 1st document isn't modified
+# 2nd document is recreated
+
+like(http_get('/etag/t'), qr/X-Cache-Status: REVALIDATED.*SEE/ms,
+	'etag revalidated');
+like(http_get('/etag/t'), qr/X-Cache-Status: HIT.*SEE/ms,
+	'etag cached again');
+like(http_get('/etag/t2'), qr/X-Cache-Status: EXPIRED.*NEW/ms,
+	'etag2 revalidate failed');
+like(http_get('/etag/t2'), qr/X-Cache-Status: HIT.*NEW/ms,
+	'etag2 new response cached');
+
+# check that conditional requests are only used for 200/206 responses
+
+# d0ce06cb9be1 in 1.7.3 changed to ignore header filter's work to strip
+# the Last-Modified header when storing non-200/206 in cache;
+# 1573fc7875fa in 1.7.9 effectively turned it back.
+
+unlike(http_get('/201'), qr/X-If-Modified/, 'other status no revalidation');
+
+# wait for a while for a cached 404 response to expire
+
+select undef, undef, undef, 3.5;
+
+# check that conditional requests are not used to revalidate 404 response
+
+# before fd283aa92e04 introduced in 1.7.7, this test passed by chance because
+# of the If-Modified-Since header that was sent with Epoch in revalidation
+# of responses cached without the Last-Modified header;
+# fd283aa92e04 leaved (an legitimate) successful revalidation of 404 by ETag
+# (introduced by 44b9ab7752e3 in 1.7.3), which caused the test to fail;
+# 1573fc7875fa in 1.7.9 changed to not revalidate non-200/206 responses but
+# leaked Last-Modified and ETag into 404 inherited from stale 200/206 response;
+# 174512857ccf in 1.7.11 fixed the leak and allowed the test to pass.
+
+rename("$d/t3_moved", "$d/t3");
+
+like(http_get('/t3'), qr/SEE/, 'no 404 revalidation after stale 200');
+
+###############################################################################
diff --git a/tests/proxy_cache_use_stale.t b/tests/proxy_cache_use_stale.t
new file mode 100644
index 0000000..57ec351
--- /dev/null
+++ b/tests/proxy_cache_use_stale.t
@@ -0,0 +1,297 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http proxy cache, proxy_cache_use_stale.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use IO::Select;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx qw/ :DEFAULT http_end /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy cache rewrite limit_req ssi/)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    proxy_cache_path   %%TESTDIR%%/cache  levels=1:2  keys_zone=NAME:1m;
+
+    limit_req_zone  $binary_remote_addr  zone=one:1m  rate=10r/m;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /ssi.html {
+            ssi on;
+            sendfile_max_chunk  4k;
+        }
+
+        location /escape {
+            proxy_pass    http://127.0.0.1:8081;
+            proxy_cache   NAME;
+            proxy_cache_background_update  on;
+            add_header X-Cache-Status $upstream_cache_status;
+        }
+
+        location / {
+            proxy_pass    http://127.0.0.1:8081;
+
+            proxy_cache   NAME;
+
+            proxy_cache_key  $uri;
+
+            proxy_cache_revalidate  on;
+
+            proxy_cache_background_update  on;
+
+            add_header X-Cache-Status $upstream_cache_status;
+
+            location /t4.html {
+                proxy_pass    http://127.0.0.1:8081/t.html;
+
+                proxy_cache_revalidate  off;
+            }
+
+            location /t5.html {
+                proxy_pass    http://127.0.0.1:8081/t.html;
+
+                proxy_cache_background_update  off;
+            }
+
+            location ~ /(reg)(?P<name>exp).html {
+                proxy_pass    http://127.0.0.1:8081/$1$name.html;
+
+                proxy_cache_background_update  on;
+            }
+
+            location /updating/ {
+                proxy_pass    http://127.0.0.1:8081/;
+
+                proxy_cache_use_stale  updating;
+            }
+
+            location /t7.html {
+                proxy_pass    http://127.0.0.1:8081;
+
+                sendfile_max_chunk  4k;
+            }
+
+            location /t8.html {
+                proxy_pass    http://127.0.0.1:8081/t.html;
+
+                proxy_cache_valid  1s;
+            }
+
+            if ($arg_if) {
+                # nothing
+            }
+        }
+    }
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        add_header Cache-Control $http_x_cache_control;
+
+        if ($arg_lim) {
+            set $limit_rate 1k;
+        }
+
+        if ($arg_e) {
+            return 500;
+        }
+
+        location / { }
+
+        location /t6.html {
+            limit_req zone=one burst=2;
+        }
+
+        location /t9.html {
+            add_header Cache-Control "max-age=1, stale-while-revalidate=10";
+        }
+    }
+}
+
+EOF
+
+$t->write_file('t.html', 'SEE-THIS');
+$t->write_file('tt.html', 'SEE-THIS');
+$t->write_file('t2.html', 'SEE-THIS');
+$t->write_file('t3.html', 'SEE-THIS');
+$t->write_file('t6.html', 'SEE-THIS');
+$t->write_file('t7.html', 'SEE-THIS' x 1024);
+$t->write_file('t9.html', 'SEE-THIS' x 1024);
+$t->write_file('ssi.html', 'xxx <!--#include virtual="/t9.html" --> xxx');
+$t->write_file('escape.html', 'SEE-THIS');
+$t->write_file('escape html', 'SEE-THIS');
+$t->write_file('regexp.html', 'SEE-THIS');
+
+$t->run()->plan(35);
+
+###############################################################################
+
+like(get('/t.html', 'max-age=1, stale-if-error=5'), qr/MISS/, 'stale-if-error');
+like(http_get('/t.html?e=1'), qr/HIT/, 's-i-e - cached');
+
+like(get('/t2.html', 'max-age=1, stale-while-revalidate=10'), qr/MISS/,
+	'stale-while-revalidate');
+like(http_get('/t2.html'), qr/HIT/, 's-w-r - cached');
+
+get('/tt.html', 'max-age=1, stale-if-error=3');
+get('/t3.html', 'max-age=1, stale-while-revalidate=2');
+get('/t4.html', 'max-age=1, stale-while-revalidate=3');
+get('/t5.html', 'max-age=1, stale-while-revalidate=3');
+get('/t6.html', 'max-age=1, stale-while-revalidate=4');
+get('/t7.html', 'max-age=1, stale-while-revalidate=10');
+http_get('/ssi.html');
+get('/updating/t.html', 'max-age=1');
+get('/updating/t2.html', 'max-age=1, stale-while-revalidate=2');
+get('/t8.html', 'stale-while-revalidate=10');
+get('/escape.htm%6C', 'max-age=1, stale-while-revalidate=10');
+get('/escape html', 'max-age=1, stale-while-revalidate=10');
+get('/regexp.html', 'max-age=1, stale-while-revalidate=10');
+
+sleep 2;
+
+like(http_get('/t.html?e=1'), qr/STALE/, 's-i-e - stale');
+like(http_get('/tt.html?e=1'), qr/STALE/, 's-i-e - stale 2');
+like(http_get('/t.html'), qr/REVALIDATED/, 's-i-e - revalidated');
+
+like(http_get('/t2.html?e=1'), qr/STALE/, 's-w-r - revalidate error');
+like(http_get('/t2.html'), qr/STALE/, 's-w-r - stale while revalidate');
+like(http_get('/t2.html'), qr/HIT/, 's-w-r - revalidated');
+
+like(get('/t4.html', 'max-age=1, stale-while-revalidate=2'), qr/STALE/,
+	's-w-r - unconditional revalidate');
+like(http_get('/t4.html'), qr/HIT/, 's-w-r - unconditional revalidated');
+
+like(http_get('/t5.html?e=1'), qr/STALE/,
+	's-w-r - foreground revalidate error');
+like(http_get('/t5.html'), qr/REVALIDATED/, 's-w-r - foreground revalidated');
+
+# proxy_pass to regular expression with named and positional captures
+
+like(http_get('/regexp.html'), qr/STALE/, 's-w-r - regexp background update');
+like(http_get('/regexp.html'), qr/HIT/, 's-w-r - regexp revalidated');
+
+# UPDATING while s-w-r
+
+$t->write_file('t6.html', 'SEE-THAT');
+
+my $s = get('/t6.html', 'max-age=1, stale-while-revalidate=2', start => 1);
+select undef, undef, undef, 0.2;
+like(http_get('/t6.html'), qr/UPDATING.*SEE-THIS/s, 's-w-r - updating');
+like(http_end($s), qr/STALE.*SEE-THIS/s, 's-w-r - updating stale');
+like(http_get('/t6.html'), qr/HIT.*SEE-THAT/s, 's-w-r - updating revalidated');
+
+# stale-while-revalidate with proxy_cache_use_stale updating
+
+like(http_get('/updating/t.html'), qr/STALE/,
+	's-w-r - use_stale updating stale');
+like(http_get('/updating/t.html'), qr/HIT/,
+	's-w-r - use_stale updating revalidated');
+
+# stale-while-revalidate with proxy_cache_valid
+
+like(http_get('/t8.html'), qr/STALE/, 's-w-r - proxy_cache_valid revalidate');
+like(http_get('/t8.html'), qr/HIT/, 's-w-r - proxy_cache_valid revalidated');
+
+sleep 2;
+
+like(http_get('/t2.html?e=1'), qr/STALE/, 's-w-r - stale after revalidate');
+like(http_get('/t3.html?e=1'), qr/ 500 /, 's-w-r - ceased');
+like(http_get('/tt.html?e=1'), qr/ 500 /, 's-i-e - ceased');
+like(http_get('/updating/t2.html'), qr/STALE/,
+	's-w-r - overriden with use_stale updating');
+
+# stale response not blocked by background update.
+# before 1.13.1, if stale response was not sent in one pass, its remaining
+# part was blocked and not sent until background update has been finished
+
+$t->write_file('t7.html', 'SEE-THAT' x 1024);
+
+my $r = read_all(get('/t7.html?lim=1', 'max-age=1', start => 1));
+like($r, qr/STALE.*^(SEE-THIS){1024}$/ms, 's-w-r - stale response not blocked');
+
+$t->write_file('t9.html', 'SEE-THAT' x 1024);
+$t->write_file('ssi.html', 'xxx <!--#include virtual="/t9.html?lim=1" --> xxx');
+
+$r = read_all(http_get('/ssi.html', start => 1));
+like($r, qr/^xxx (SEE-THIS){1024} xxx$/ms, 's-w-r - not blocked in subrequest');
+
+# "aio_write" is used to produce "open socket ... left in connection" alerts.
+
+$t->todo_alerts() if $t->read_file('nginx.conf') =~ /aio_write on/
+        and $t->read_file('nginx.conf') =~ /aio threads/ and $^O eq 'freebsd';
+
+# due to the missing content_handler inheritance in a cloned subrequest,
+# this used to access a static file in the update request
+
+like(http_get('/t2.html?if=1'), qr/STALE/, 'background update in if');
+like(http_get('/t2.html?if=1'), qr/HIT/, 'background update in if - updated');
+
+# ticket #1430, uri escaping in cloned subrequests
+
+$t->write_file('escape.html', 'SEE-THAT');
+$t->write_file('escape html', 'SEE-THAT');
+
+get('/escape.htm%6C', 'max-age=1');
+get('/escape html', 'max-age=1');
+
+like(http_get('/escape.htm%6C'), qr/HIT/, 'escaped after escaped');
+like(http_get('/escape.html'), qr/MISS/, 'unescaped after escaped');
+like(http_get('/escape html'), qr/HIT/, 'space after escaped space');
+like(http_get('/escape%20html'), qr/HIT/, 'escaped space after escaped space');
+
+###############################################################################
+
+sub get {
+	my ($url, $extra, %extra) = @_;
+	return http(<<EOF, %extra);
+GET $url HTTP/1.1
+Host: localhost
+Connection: close
+X-Cache-Control: $extra
+
+EOF
+}
+
+# background update is known to postpone closing connection with client
+
+sub read_all {
+	my ($s) = @_;
+	my $r = '';
+	while (IO::Select->new($s)->can_read(1)) {
+		$s->sysread(my $buf, 8192) or last;
+		log_in($buf);
+		$r .= $buf;
+	}
+	return $r;
+}
+
+###############################################################################
diff --git a/tests/proxy_cache_valid.t b/tests/proxy_cache_valid.t
new file mode 100644
index 0000000..3536bc9
--- /dev/null
+++ b/tests/proxy_cache_valid.t
@@ -0,0 +1,132 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http proxy cache, the proxy_cache_valid directive
+# used with the caching parameters set in the response header.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy cache rewrite/)->plan(12)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    proxy_cache_path   %%TESTDIR%%/cache  levels=1:2
+                       keys_zone=NAME:1m;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            proxy_pass    http://127.0.0.1:8081;
+            proxy_cache   NAME;
+
+            proxy_cache_valid  200 401  1m;
+
+            proxy_intercept_errors on;
+            error_page 404 401 = @fallback;
+
+            add_header X-Cache-Status $upstream_cache_status;
+        }
+
+        location @fallback {
+            return 403;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location / {
+            add_header Cache-Control $http_x_cc always;
+            error_page 403 = /index-no-cache;
+        }
+
+        location /index-no-cache {
+            add_header Cache-Control no-cache always;
+            return 401;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('t.html', 'SEE-THIS');
+$t->run();
+
+###############################################################################
+
+like(get('/t.html?1', 'X-CC: max-age=1'), qr/MISS/, 'max-age');
+like(get('/t.html?2', 'X-CC: max-age=1, s-maxage=10'), qr/MISS/, 's-maxage');
+like(http_get('/t.html?3'), qr/MISS/, 'proxy_cache_valid');
+
+$t->write_file('t.html', 'NOOP');
+
+like(http_get('/t.html?1'), qr/HIT/, 'max-age cached');
+like(http_get('/t.html?2'), qr/HIT/, 's-maxage cached');
+like(http_get('/t.html?3'), qr/HIT/, 'proxy_cache_valid cached');
+
+select undef, undef, undef, 2.1;
+
+# Cache-Control in the response header overrides proxy_cache_valid
+
+like(http_get('/t.html?1'), qr/EXPIRED/, 'max-age ceased');
+like(http_get('/t.html?2'), qr/HIT/, 's-maxage overrides max-age');
+
+# ticket #1382, cache item "error" field was not set from Cache-Control: max-age
+
+like(get('/t2.html', 'X-CC: max-age=1'), qr/403 Forbidden/, 'intercept error');
+
+$t->write_file('t2.html', 'NOOP');
+
+like(http_get('/t2.html'), qr/403 Forbidden/, 'error cached from max-age');
+
+# ticket #1382, cache item "error" field was set regardless of u->cacheable.
+
+like(http_get('/'), qr/403 Forbidden/, 'error no-cache');
+
+$t->write_file('index.html', '');
+
+like(http_get('/'), qr/200 OK/, 'error no-cache - not cacheable');
+
+###############################################################################
+
+sub get {
+	my ($url, $extra) = @_;
+	return http(<<EOF);
+GET $url HTTP/1.1
+Host: localhost
+Connection: close
+$extra
+
+EOF
+}
+
+###############################################################################
diff --git a/tests/proxy_cache_variables.t b/tests/proxy_cache_variables.t
new file mode 100644
index 0000000..5206637
--- /dev/null
+++ b/tests/proxy_cache_variables.t
@@ -0,0 +1,94 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http proxy cache, proxy_cache directive with variables.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy cache/)->plan(8)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    proxy_cache_path   %%TESTDIR%%/cache1  levels=1:2
+                       keys_zone=NAME1:1m;
+    proxy_cache_path   %%TESTDIR%%/cache2  levels=1:2
+                       keys_zone=NAME2:1m;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            proxy_pass    http://127.0.0.1:8081;
+
+            proxy_cache   $arg_c;
+
+            proxy_cache_valid   any      1m;
+
+            add_header X-Cache-Status $upstream_cache_status;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location / {
+        }
+    }
+}
+
+EOF
+
+$t->write_file('index.html', 'SEE-THIS');
+
+$t->run();
+
+###############################################################################
+
+like(http_get('/?c=NAME1'), qr/MISS.*SEE-THIS/ms, 'proxy request');
+like(http_get('/?c=NAME1'), qr/HIT.*SEE-THIS/ms, 'proxy request cached');
+
+unlike(http_head('/?c=NAME1'), qr/SEE-THIS/, 'head request');
+
+$t->write_file('index.html', 'SEE-THAT');
+
+like(http_get('/?c=NAME2'), qr/MISS.*SEE-THAT/ms, 'proxy request 2');
+like(http_get('/?c=NAME2'), qr/HIT.*SEE-THAT/ms, 'proxy request 2 cached');
+
+# some invalid cases
+
+like(http_get('/?c=NAME'), qr/ 500 /, 'proxy_cache unknown');
+like(http_get('/'), qr/(?<!X-Cache).*SEE-THAT/ms, 'proxy_cache empty');
+
+$t->write_file('index.html', 'SEE-THOSE');
+
+like(http_get('/'), qr/SEE-THOSE/, 'proxy_cache empty - not cached');
+
+###############################################################################
diff --git a/tests/proxy_cache_vary.t b/tests/proxy_cache_vary.t
new file mode 100644
index 0000000..a087a40
--- /dev/null
+++ b/tests/proxy_cache_vary.t
@@ -0,0 +1,264 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for http proxy cache, the Vary header.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy cache gzip rewrite/)
+	->plan(42)->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    proxy_cache_path   %%TESTDIR%%/cache keys_zone=one:1m inactive=5s;
+    proxy_cache_key    $uri;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        add_header X-Cache-Status $upstream_cache_status;
+
+        location / {
+            proxy_pass    http://127.0.0.1:8081/;
+            proxy_cache   one;
+        }
+
+        location /replace/ {
+            proxy_pass    http://127.0.0.1:8081/;
+            proxy_cache   one;
+        }
+
+        location /revalidate/ {
+            proxy_pass    http://127.0.0.1:8081/;
+            proxy_cache   one;
+            proxy_cache_revalidate on;
+        }
+
+        location /ignore/ {
+            proxy_pass    http://127.0.0.1:8081/;
+            proxy_cache   one;
+            proxy_ignore_headers Vary;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        gzip on;
+        gzip_min_length 0;
+        gzip_http_version 1.0;
+        gzip_vary on;
+
+        expires 2s;
+
+        location / {
+            if ($args = "novary") {
+                return 200 "the only variant\n";
+            }
+        }
+
+        location /asterisk {
+            gzip off;
+            add_header Vary "*";
+        }
+
+        location /complex {
+            gzip off;
+            add_header Vary ",, Accept-encoding , ,";
+        }
+    }
+}
+
+EOF
+
+$t->write_file('index.html', 'SEE-THIS');
+$t->write_file('asterisk', 'SEE-THIS');
+$t->write_file('complex', 'SEE-THIS');
+
+$t->run();
+
+###############################################################################
+
+like(get('/', 'gzip'), qr/MISS/ms, 'first request');
+like(get('/', 'gzip'), qr/HIT/ms, 'vary match cached');
+like(get('/', 'deflate'), qr/MISS/ms, 'vary mismatch');
+like(get('/', 'deflate'), qr/HIT/ms, 'vary mismatch cached');
+like(get('/', 'foo'), qr/MISS/ms, 'vary mismatch 2');
+like(get('/', 'foo'), qr/HIT/ms, 'vary mismatch 2 cached');
+like(get('/', 'gzip'), qr/HIT/ms, 'multiple representations cached');
+
+SKIP: {
+skip 'long tests', 6 unless $ENV{TEST_NGINX_UNSAFE};
+
+# make sure all variants are properly expire
+# and removed after inactive timeout
+
+sleep(3);
+
+like(get('/', 'gzip'), qr/EXPIRED/ms, 'first expired');
+like(get('/', 'deflate'), qr/EXPIRED/ms, 'second variant expired');
+
+like(get('/', 'gzip'), qr/HIT/ms, 'first cached after expire');
+like(get('/', 'deflate'), qr/HIT/ms, 'second cached after expire');
+
+sleep(12);
+
+like(get('/', 'gzip'), qr/MISS/ms, 'first inactive removed');
+like(get('/', 'deflate'), qr/MISS/ms, 'second variant removed');
+
+}
+
+SKIP: {
+skip 'long tests', 6 unless $ENV{TEST_NGINX_UNSAFE};
+
+# check if the variant which was loaded first will be properly
+# removed if it's not requested (but another variant is requested
+# at the same time)
+
+sleep(3);
+like(get('/', 'deflate'), qr/EXPIRED/ms, 'bump1');
+sleep(3);
+like(get('/', 'deflate'), qr/EXPIRED/ms, 'bump2');
+sleep(3);
+like(get('/', 'deflate'), qr/EXPIRED/ms, 'bump3');
+sleep(3);
+like(get('/', 'deflate'), qr/EXPIRED/ms, 'bump4');
+
+TODO: {
+local $TODO = 'not yet';
+
+like(get('/', 'gzip'), qr/MISS/ms, 'first not bumped by second requests');
+
+}
+
+like(get('/', 'deflate'), qr/HIT/ms, 'second variant cached');
+
+}
+
+# if a response without Vary is returned to replace previously returned
+# responses with Vary, make sure it is then used in all cases
+
+like(get('/replace/', 'gzip'), qr/MISS/, 'replace first');
+like(get('/replace/', 'deflate'), qr/MISS/, 'replace second');
+
+sleep(3);
+
+like(get('/replace/?novary', 'deflate'), qr/EXPIRED/, 'replace novary');
+like(get('/replace/?zztest', 'gzip'), qr/HIT/, 'all replaced');
+
+# make sure revalidation of variants works fine
+
+like(get('/revalidate/', 'gzip'), qr/MISS/, 'revalidate first');
+like(get('/revalidate/', 'deflate'), qr/MISS/, 'revalidate second');
+
+sleep(3);
+
+like(get('/revalidate/', 'gzip'), qr/REVALIDATED/, 'revalidated first');
+like(get('/revalidate/', 'deflate'), qr/REVALIDATED/, 'revalidated second');
+like(get('/revalidate/', 'gzip'), qr/HIT/, 'revalidate first after');
+like(get('/revalidate/', 'deflate'), qr/HIT/, 'revalidate second after');
+
+# if the Vary header is ignored, cached version can be returned
+# regardless of request headers
+
+like(get('/ignore/', 'gzip'), qr/MISS/ms, 'another request');
+like(get('/ignore/', 'deflate'), qr/HIT/ms, 'vary ignored');
+
+# check parsing of Vary with multiple headers listed
+
+like(get('/complex', 'gzip'), qr/MISS/ms, 'vary complex first');
+like(get('/complex', 'deflate'), qr/MISS/ms, 'vary complex second');
+like(get('/complex', 'gzip'), qr/HIT/ms, 'vary complex first cached');
+like(get('/complex', 'deflate'), qr/HIT/ms, 'vary complex second cached');
+
+# From RFC 7231, "7.1.4. Vary",
+# http://tools.ietf.org/html/rfc7231#section-7.1.4:
+#
+#    A Vary field value of "*" signals that anything about the request
+#    might play a role in selecting the response representation, possibly
+#    including elements outside the message syntax (e.g., the client's
+#    network address).  A recipient will not be able to determine whether
+#    this response is appropriate for a later request without forwarding
+#    the request to the origin server.
+#
+# In theory, If-None-Match can be used to check if the representation
+# present in the cache is appropriate.  This seems to be only possible
+# with strong entity tags though, as representation with different
+# content condings may share the same weak entity tag.
+
+like(get('/asterisk', 'gzip'), qr/MISS/ms, 'vary asterisk first');
+like(get('/asterisk', 'gzip'), qr/MISS/ms, 'vary asterisk second');
+
+# From RFC 7234, "4.1. Calculating Secondary Keys with Vary",
+# http://tools.ietf.org/html/rfc7234#section-4.1:
+#
+#    The selecting header fields from two requests are defined to match if
+#    and only if those in the first request can be transformed to those in
+#    the second request by applying any of the following:
+#
+#    o  adding or removing whitespace, where allowed in the header field's
+#       syntax
+#
+#    o  combining multiple header fields with the same field name (see
+#       Section 3.2 of [RFC7230])
+#
+#    o  normalizing both header field values in a way that is known to
+#       have identical semantics, according to the header field's
+#       specification (e.g., reordering field values when order is not
+#       significant; case-normalization, where values are defined to be
+#       case-insensitive)
+#
+# Only whitespace normalization is currently implemented.
+
+like(get('/', 'foo, bar'), qr/MISS/ms, 'normalize first');
+like(get('/', 'foo,bar'), qr/HIT/ms, 'normalize whitespace');
+like(get('/', 'foo,,  ,bar , '), qr/HIT/ms, 'normalize empty');
+like(get('/', 'foobar'), qr/MISS/ms, 'normalize no whitespace mismatch');
+
+TODO: {
+local $TODO = 'not yet';
+
+like(get('/', 'bar,foo'), qr/HIT/ms, 'normalize order');
+
+}
+
+###############################################################################
+
+sub get {
+	my ($url, $extra) = @_;
+	return http(<<EOF);
+GET $url HTTP/1.1
+Host: localhost
+Connection: close
+Accept-Encoding: $extra
+
+EOF
+}
+
+###############################################################################
diff --git a/tests/proxy_chunked.t b/tests/proxy_chunked.t
new file mode 100644
index 0000000..32c7b3c
--- /dev/null
+++ b/tests/proxy_chunked.t
@@ -0,0 +1,111 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Test for http backend returning response with Transfer-Encoding: chunked.
+
+# Since nginx uses HTTP/1.0 in requests to backend it's backend bug, but we
+# want to handle this gracefully.  And anyway chunked support will be required
+# for HTTP/1.1 backend connections.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy ssi/)->plan(3);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            proxy_pass http://127.0.0.1:8081;
+            proxy_read_timeout 1s;
+        }
+        location /nobuffering {
+            proxy_pass http://127.0.0.1:8081;
+            proxy_read_timeout 1s;
+            proxy_buffering off;
+        }
+        location /inmemory.html {
+            ssi on;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('inmemory.html',
+	'<!--#include virtual="/" set="one" --><!--#echo var="one" -->');
+
+$t->run_daemon(\&http_chunked_daemon);
+$t->run()->waitforsocket('127.0.0.1:' . port(8081));
+
+###############################################################################
+
+like(http_get('/'), qr/\x0d\x0aSEE-THIS$/s, 'chunked');
+like(http_get('/nobuffering'), qr/\x0d\x0aSEE-THIS$/s, 'chunked nobuffering');
+like(http_get('/inmemory.html'), qr/\x0d\x0aSEE-THIS$/s, 'chunked inmemory');
+
+###############################################################################
+
+sub http_chunked_daemon {
+	my $server = IO::Socket::INET->new(
+		Proto => 'tcp',
+		LocalAddr => '127.0.0.1:' . port(8081),
+		Listen => 5,
+		Reuse => 1
+	)
+		or die "Can't create listening socket: $!\n";
+
+	local $SIG{PIPE} = 'IGNORE';
+
+	while (my $client = $server->accept()) {
+		$client->autoflush(1);
+
+		while (<$client>) {
+			last if (/^\x0d?\x0a?$/);
+		}
+
+		print $client <<'EOF';
+HTTP/1.1 200 OK
+Connection: close
+Transfer-Encoding: chunked
+
+9
+SEE-THIS
+
+0
+
+EOF
+
+		close $client;
+	}
+}
+
+###############################################################################
diff --git a/tests/proxy_cookie.t b/tests/proxy_cookie.t
new file mode 100644
index 0000000..7e541b1
--- /dev/null
+++ b/tests/proxy_cookie.t
@@ -0,0 +1,112 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+# (C) Valentin Bartenev
+
+# Tests for the proxy_cookie_domain and proxy_cookie_path directives.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy rewrite/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            proxy_pass http://127.0.0.1:8081;
+
+            proxy_cookie_domain www.example.org .example.com;
+            proxy_cookie_domain .$server_name.com en.$server_name.org;
+            proxy_cookie_domain ~^(.+)\.com$ $1.org;
+
+            proxy_cookie_path /path/ /new/;
+            proxy_cookie_path /$server_name/ /new/$server_name/;
+            proxy_cookie_path ~^/regex/(.+)$ /$1;
+            proxy_cookie_path ~*^/caseless/(.+)$ /$1;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location / {
+            if ($arg_domain) {
+                set $sc_domain "; Domain=$arg_domain";
+            }
+            if ($arg_path) {
+                set $sc_path "; Path=$arg_path";
+            }
+            add_header Set-Cookie v=path=domain=$sc_domain$sc_path;
+            return 200 OK;
+        }
+    }
+}
+
+EOF
+
+$t->run()->plan(8);
+
+###############################################################################
+
+my $port = port(8080);
+
+is(http_get_set_cookie('/?domain=www.Example.org'),
+	'v=path=domain=; Domain=example.com', 'domain rewrite');
+is(http_get_set_cookie('/?domain=.LocalHost.com'),
+	'v=path=domain=; Domain=.en.localhost.org',
+	'domain rewrite with vars');
+is(http_get_set_cookie('/?domain=www.example.COM'),
+	'v=path=domain=; Domain=www.example.org', 'domain regex rewrite');
+
+is(http_get_set_cookie('/?path=/path/test.html'),
+	'v=path=domain=; Path=/new/test.html', 'path rewrite');
+is(http_get_set_cookie('/?path=/localhost/test.html'),
+	'v=path=domain=; Path=/new/localhost/test.html',
+	'path rewrite with vars');
+is(http_get_set_cookie('/?path=/regex/test.html'),
+	'v=path=domain=; Path=/test.html', 'path regex rewrite');
+is(http_get_set_cookie('/?path=/CASEless/test.html'),
+	'v=path=domain=; Path=/test.html', 'path caseless regex rewrite');
+
+is(http_get_set_cookie('/?domain=www.example.org&path=/path/test.html'),
+	'v=path=domain=; Domain=example.com; Path=/new/test.html',
+	'domain and path rewrite');
+
+###############################################################################
+
+sub http_get_set_cookie {
+	my ($uri) = @_;
+	http_get("http://127.0.0.1:$port$uri") =~ /^Set-Cookie:\s(.+?)\x0d?$/mi;
+	return $1;
+}
+
+###############################################################################
diff --git a/tests/proxy_force_ranges.t b/tests/proxy_force_ranges.t
new file mode 100644
index 0000000..2cc910d
--- /dev/null
+++ b/tests/proxy_force_ranges.t
@@ -0,0 +1,133 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http proxy cache and range filter.
+# proxy_force_ranges enables partial response regardless Accept-Ranges.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/ $CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy cache/)->plan(7)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    proxy_cache_path   %%TESTDIR%%/cache  levels=1:2
+                       keys_zone=NAME:1m;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            proxy_pass    http://127.0.0.1:8081;
+        }
+
+        location /proxy/ {
+            proxy_pass    http://127.0.0.1:8081/;
+            proxy_force_ranges on;
+            add_trailer X-Trailer "";
+        }
+
+        location /cache/ {
+            proxy_pass    http://127.0.0.1:8081/;
+            proxy_cache   NAME;
+            proxy_cache_valid 200 1m;
+
+            proxy_force_ranges on;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location / {
+            max_ranges 0;
+            add_header Last-Modified "Mon, 28 Sep 1970 06:00:00 GMT";
+            add_header ETag '"59a5401c-8"';
+        }
+    }
+}
+
+EOF
+
+$t->write_file('t.html', 'SEE-THIS');
+$t->run();
+
+###############################################################################
+
+# serving range requests requires Accept-Ranges by default
+
+unlike(http_get_range('/t.html', 'Range: bytes=4-'), qr/^THIS/m,
+	'range without Accept-Ranges');
+
+like(http_get_range('/cache/t.html', 'Range: bytes=4-'), qr/^THIS/m,
+	'uncached range');
+like(http_get_range('/cache/t.html', 'Range: bytes=4-'), qr/^THIS/m,
+	'cached range');
+like(http_get_range('/cache/t.html', 'Range: bytes=0-2,4-'), qr/^SEE.*^THIS/ms,
+	'cached multipart range');
+
+# If-Range HTTP-date request
+
+like(http_get_range('/proxy/t.html',
+	"Range: bytes=4-\nIf-Range: Mon, 28 Sep 1970 06:00:00 GMT"),
+	qr/^THIS/m, 'if-range last-modified proxy');
+
+# If-Range entity-tag request
+
+like(http_get_range('/proxy/t.html',
+	"Range: bytes=4-\nIf-Range: \"59a5401c-8\""),
+	qr/^THIS/m, 'if-range etag proxy');
+
+# range sent using chunked transfer encoding
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.17.0');
+
+like(http_get_range('/proxy/t.html', 'Range: bytes=-2'),
+	qr/2${CRLF}IS${CRLF}0$CRLF$CRLF$/, 'no dublicate final chunk');
+
+}
+
+###############################################################################
+
+sub http_get_range {
+	my ($url, $extra) = @_;
+	return http(<<EOF);
+GET $url HTTP/1.1
+Host: localhost
+Connection: close
+$extra
+
+EOF
+}
+
+###############################################################################
diff --git a/tests/proxy_if.t b/tests/proxy_if.t
new file mode 100644
index 0000000..6146a41
--- /dev/null
+++ b/tests/proxy_if.t
@@ -0,0 +1,241 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for http proxy module related to use with the "if" directive.
+# See http://wiki.nginx.org/IfIsEvil for more details.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy rewrite http_ssl/)
+	->has_daemon('openssl')->plan(15);
+
+$t->write_file_expand('nginx.conf', <<'EOF')->todo_alerts();
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            proxy_pass http://127.0.0.1:8081/;
+        }
+
+        # request was sent to backend without uri changed
+        # to '/' due to if
+
+        location /proxy-pass-uri {
+            proxy_pass http://127.0.0.1:8081/replacement;
+
+            if ($arg_if) {
+                # nothing
+            }
+
+            location /proxy-pass-uri/inner {
+                # no proxy_pass here, static
+
+                if ($arg_if) {
+                    # nothing
+                }
+            }
+        }
+
+        # same as the above, but there is a special handling
+        # in configuration merge; it used to do wrong things with
+        # nested locations though
+
+        location /proxy-pass-uri-lmt {
+            proxy_pass http://127.0.0.1:8081/replacement;
+
+            limit_except POST {
+                # nothing
+            }
+
+            location /proxy-pass-uri-lmt/inner {
+                # no proxy_pass here, static
+
+                limit_except POST {
+                    # nothing
+                }
+            }
+        }
+
+        location /proxy-pass-uri-lmt-different {
+            proxy_pass http://127.0.0.1:8081/replacement;
+
+            limit_except POST {
+                proxy_pass http://127.0.0.1:8081;
+            }
+        }
+
+        # segmentation fault in old versions,
+        # fixed to return 500 Internal Error in nginx 1.3.10
+
+        location /proxy-inside-if-crash {
+
+            set $true 1;
+
+            if ($true) {
+                # proxy_pass inside if
+                proxy_pass http://127.0.0.1:8081;
+            }
+
+            if ($true) {
+                # no handler here
+            }
+        }
+
+        # normal proxy_pass and proxy_pass with variables
+        # use distinct field, and inheritance should be mutually
+        # exclusive
+
+        location /variables {
+            proxy_pass http://127.0.0.1:8081/outer/$host;
+
+            if ($arg_if) {
+                proxy_pass http://127.0.0.1:8081;
+            }
+
+            location /variables/inner {
+                proxy_pass http://127.0.0.1:8081;
+            }
+        }
+
+        # ssl context shouldn't be inherited into nested
+        # locations with different proxy_pass, but should
+        # be correctly inherited into if's
+
+        location /ssl {
+            proxy_pass https://127.0.0.1:8082/outer;
+
+            if ($arg_if) {
+                # inherited from outer
+            }
+
+            location /ssl/inner {
+                proxy_pass http://127.0.0.1:8081;
+            }
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        listen       127.0.0.1:8082 ssl;
+        server_name  localhost;
+
+        ssl_certificate localhost.crt;
+        ssl_certificate_key localhost.key;
+
+        return 200 "uri:$uri\n";
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('localhost') {
+	system('openssl req -x509 -new '
+		. "-config $d/openssl.conf -subj /CN=$name/ "
+		. "-out $d/$name.crt -keyout $d/$name.key "
+		. ">>$d/openssl.out 2>&1") == 0
+		or die "Can't create certificate for $name: $!\n";
+}
+
+$t->run();
+
+###############################################################################
+
+like(http_get('/'), qr!uri:/$!, 'proxy request');
+
+like(http_get('/proxy-pass-uri'), qr!uri:/replacement$!,
+	'proxy_pass uri changed');
+
+# due to missing information about an original location where
+# proxy_pass was specified, this used to pass request with
+# original unmodified uri
+
+like(http_get('/proxy-pass-uri?if=1'), qr!uri:/replacement$!,
+	'proxy_pass uri changed in if');
+
+like(http_get('/proxy-pass-uri/inner'), qr!404 Not Found!,
+	'proxy_pass uri changed inner');
+like(http_get('/proxy-pass-uri/inner?if=1'), qr!404 Not Found!,
+	'proxy_pass uri changed inner in if');
+
+# limit_except
+
+like(http_get('/proxy-pass-uri-lmt'), qr!uri:/replacement$!,
+	'proxy_pass uri and limit_except');
+
+# special handling of limit_except resulted in wrong handling
+# of requests in nested locations
+
+like(http_get('/proxy-pass-uri-lmt/inner'), qr!404 Not Found!,
+	'proxy_pass uri and limit_except, inner');
+
+like(http_get('/proxy-pass-uri-lmt-different'),
+	qr!uri:/proxy-pass-uri-lmt-different!,
+	'proxy_pass and limit_except with different proxy_pass');
+
+# segmentation fault in old versions,
+# fixed to return 500 Internal Error in nginx 1.3.10
+
+like(http_get('/proxy-inside-if-crash'), qr!500 Internal Server Error!,
+	'proxy_pass inside if');
+
+# normal proxy_pass and proxy_pass with variables
+# use distinct field, and inheritance should be mutually
+# exclusive, see ticket #645
+
+like(http_get('/variables'), qr!uri:/outer!,
+	'proxy_pass variables');
+like(http_get('/variables?if=1'), qr!uri:/variables!,
+	'proxy_pass variables if');
+like(http_get('/variables/inner'), qr!uri:/variables/inner!,
+	'proxy_pass variables nested');
+
+# ssl context shouldn't be inherited into nested
+# locations with different proxy_pass, but should
+# be correctly inherited into if's
+
+like(http_get('/ssl'), qr!uri:/outer!,
+	'proxy_pass ssl');
+like(http_get('/ssl?if=1'), qr!uri:/outer!,
+	'proxy_pass ssl inside if');
+like(http_get('/ssl/inner'), qr!uri:/ssl/inner!,
+	'proxy_pass nossl inside ssl');
+
+###############################################################################
diff --git a/tests/proxy_keepalive.t b/tests/proxy_keepalive.t
new file mode 100644
index 0000000..3b29491
--- /dev/null
+++ b/tests/proxy_keepalive.t
@@ -0,0 +1,356 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for proxy with keepalive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use IO::Socket::INET;
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy upstream_keepalive ssi rewrite/)
+	->plan(49)->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    upstream backend {
+        server 127.0.0.1:8081;
+        keepalive 1;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        proxy_http_version 1.1;
+        proxy_set_header Connection "";
+
+        location / {
+            proxy_pass http://backend;
+        }
+
+        location /unbuffered/ {
+            proxy_pass http://backend;
+            proxy_buffering off;
+        }
+
+        location /inmemory/ {
+            ssi on;
+            rewrite ^ /ssi.html break;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('ssi.html',
+	'<!--#include virtual="/include$request_uri" set="x" -->' .
+	'set: <!--#echo var="x" -->');
+
+$t->run_daemon(\&http_daemon);
+$t->run();
+
+$t->waitforsocket('127.0.0.1:' . port(8081))
+	or die "Can't start test backend";
+
+###############################################################################
+
+# There are 3 mostly independent modes of upstream operation:
+#
+# 1. Buffered, i.e. normal mode with "proxy_buffering on;"
+# 2. Unbuffered, i.e. "proxy_buffering off;".
+# 3. In memory, i.e. ssi <!--#include ... set -->
+#
+# These all should be tested.
+
+my ($r, $n);
+
+# buffered
+
+like($r = http_get('/buffered/length1'), qr/SEE-THIS/, 'buffered');
+$r =~ m/X-Connection: (\d+)/; $n = $1;
+like(http_get('/buffered/length2'), qr/X-Connection: $n.*SEE/ms, 'buffered 2');
+
+like($r = http_get('/buffered/chunked1'), qr/SEE-THIS/, 'buffered chunked');
+$r =~ m/X-Connection: (\d+)/; $n = $1;
+like(http_get('/buffered/chunked2'), qr/X-Connection: $n/,
+	'buffered chunked 2');
+
+like($r = http_get('/buffered/complex1'), qr/(0123456789){100}/,
+	'buffered complex chunked');
+$r =~ m/X-Connection: (\d+)/; $n = $1;
+like(http_get('/buffered/complex2'), qr/X-Connection: $n/,
+	'buffered complex chunked 2');
+
+like($r = http_get('/buffered/chunk01'), qr/200 OK/, 'buffered 0 chunk');
+$r =~ m/X-Connection: (\d+)/; $n = $1;
+like(http_get('/buffered/chunk02'), qr/X-Connection: $n/, 'buffered 0 chunk 2');
+
+like($r = http_head('/buffered/length/head1'), qr/(?!SEE-THIS)/,
+	'buffered head');
+$r =~ m/X-Connection: (\d+)/; $n = $1;
+like(http_head('/buffered/length/head2'), qr/X-Connection: $n/,
+	'buffered head 2');
+
+like($r = http_get('/buffered/empty1'), qr/200 OK/, 'buffered empty');
+$r =~ m/X-Connection: (\d+)/; $n = $1;
+like(http_get('/buffered/empty2'), qr/X-Connection: $n/, 'buffered empty 2');
+
+like($r = http_get('/buffered/304nolen1'), qr/304 Not/, 'buffered 304');
+$r =~ m/X-Connection: (\d+)/; $n = $1;
+like(http_get('/buffered/304nolen2'), qr/X-Connection: $n/, 'buffered 304 2');
+
+like($r = http_get('/buffered/304len1'), qr/304 Not/,
+	'buffered 304 with length');
+$r =~ m/X-Connection: (\d+)/; $n = $1;
+like(http_get('/buffered/304len2'), qr/X-Connection: $n/,
+	'buffered 304 with length 2');
+
+# unbuffered
+
+like($r = http_get('/unbuffered/length1'), qr/SEE-THIS/, 'unbuffered');
+$r =~ m/X-Connection: (\d+)/; $n = $1;
+like(http_get('/unbuffered/length2'), qr/X-Connection: $n/, 'unbuffered 2');
+
+like($r = http_get('/unbuffered/chunked1'), qr/SEE-THIS/, 'unbuffered chunked');
+$r =~ m/X-Connection: (\d+)/; $n = $1;
+like(http_get('/unbuffered/chunked2'), qr/X-Connection: $n/,
+	'unbuffered chunked 2');
+
+like($r = http_get('/unbuffered/complex1'), qr/(0123456789){100}/,
+	'unbuffered complex chunked');
+$r =~ m/X-Connection: (\d+)/; $n = $1;
+like(http_get('/unbuffered/complex2'), qr/X-Connection: $n/,
+	'unbuffered complex chunked 2');
+
+like($r = http_get('/unbuffered/chunk01'), qr/200 OK/, 'unbuffered 0 chunk');
+$r =~ m/X-Connection: (\d+)/; $n = $1;
+like(http_get('/unbuffered/chunk02'), qr/X-Connection: $n/,
+	'unbuffered 0 chunk 2');
+
+like($r = http_get('/unbuffered/empty1'), qr/200 OK/, 'unbuffered empty');
+$r =~ m/X-Connection: (\d+)/; $n = $1;
+like(http_get('/unbuffered/empty2'), qr/X-Connection: $n/,
+	'unbuffered empty 2');
+
+like($r = http_head('/unbuffered/length/head1'), qr/(?!SEE-THIS)/,
+	'unbuffered head');
+$r =~ m/X-Connection: (\d+)/; $n = $1;
+like(http_head('/unbuffered/length/head2'), qr/X-Connection: $n/,
+	'unbuffered head 2');
+
+like($r = http_get('/unbuffered/304nolen1'), qr/304 Not/, 'unbuffered 304');
+$r =~ m/X-Connection: (\d+)/; $n = $1;
+like(http_get('/unbuffered/304nolen2'), qr/X-Connection: $n/,
+	'unbuffered 304 2');
+
+like($r = http_get('/unbuffered/304len1'), qr/304 Not/,
+	'unbuffered 304 with length');
+$r =~ m/X-Connection: (\d+)/; $n = $1;
+like(http_get('/unbuffered/304len2'), qr/X-Connection: $n/,
+	'unbuffered 304 with length 2');
+
+# in memory
+
+like($r = http_get('/inmemory/length1'), qr/SEE-THIS/, 'inmemory');
+$r =~ m/SEE-THIS(\d+)/; $n = $1;
+like(http_get('/inmemory/length2'), qr/SEE-THIS$n/, 'inmemory 2');
+
+like($r = http_get('/inmemory/empty1'), qr/200 OK/, 'inmemory empty');
+$r =~ m/SEE-THIS(\d+)/; $n = $1;
+like(http_get('/inmemory/empty2'), qr/200 OK/, 'inmemory empty 2');
+
+like($r = http_get('/inmemory/chunked1'), qr/SEE-THIS/, 'inmemory chunked');
+$r =~ m/SEE-THIS(\d+)/; $n = $1;
+like(http_get('/inmemory/chunked2'), qr/SEE-THIS$n/, 'inmemory chunked 2');
+
+like($r = http_get('/inmemory/complex1'), qr/(0123456789){100}/,
+	'inmemory complex chunked');
+$r =~ m/SEE-THIS(\d+)/; $n = $1;
+like(http_get('/inmemory/complex2'), qr/SEE-THIS$n/,
+	'inmemory complex chunked 2');
+
+like(http_get('/inmemory/chunk01'), qr/set: $/, 'inmemory 0 chunk');
+like(http_get('/inmemory/chunk02'), qr/set: $/, 'inmemory 0 chunk 2');
+
+# closed connection tests
+
+like(http_get('/buffered/closed1'), qr/200 OK/, 'buffered closed 1');
+like(http_get('/buffered/closed2'), qr/200 OK/, 'buffered closed 2');
+like(http_get('/unbuffered/closed1'), qr/200 OK/, 'unbuffered closed 1');
+like(http_get('/unbuffered/closed2'), qr/200 OK/, 'unbuffered closed 2');
+like(http_get('/inmemory/closed1'), qr/200 OK/, 'inmemory closed 1');
+like(http_get('/inmemory/closed2'), qr/200 OK/, 'inmemory closed 2');
+
+# check for errors, shouldn't be any
+
+like(`grep -F '[error]' ${\($t->testdir())}/error.log`, qr/^$/s, 'no errors');
+
+###############################################################################
+
+sub http_daemon {
+	my $server = IO::Socket::INET->new(
+		Proto => 'tcp',
+		LocalHost => '127.0.0.1:' . port(8081),
+		Listen => 5,
+		Reuse => 1
+	)
+		or die "Can't create listening socket: $!\n";
+
+	my $ccount = 0;
+	my $rcount = 0;
+
+	# dumb server which is able to keep connections alive
+
+	while (my $client = $server->accept()) {
+		Test::Nginx::log_core('||',
+			"connection from " . $client->peerhost());
+		$client->autoflush(1);
+		$ccount++;
+
+		while (1) {
+			my $headers = '';
+			my $uri = '';
+
+			while (<$client>) {
+				Test::Nginx::log_core('||', $_);
+				$headers .= $_;
+				last if (/^\x0d?\x0a?$/);
+			}
+
+			last if $headers eq '';
+			$rcount++;
+
+			$uri = $1 if $headers =~ /^\S+\s+([^ ]+)\s+HTTP/i;
+
+			if ($uri =~ m/length/) {
+				print $client
+					"HTTP/1.1 200 OK" . CRLF .
+					"X-Request: $rcount" . CRLF .
+					"X-Connection: $ccount" . CRLF .
+					"Content-Length: 26" . CRLF . CRLF;
+				print $client "TEST-OK-IF-YOU-SEE-THIS" .
+					sprintf("%03d", $ccount)
+					unless $headers =~ /^HEAD/i;
+
+			} elsif ($uri =~ m/empty/) {
+				print $client
+					"HTTP/1.1 200 OK" . CRLF .
+					"X-Request: $rcount" . CRLF .
+					"X-Connection: $ccount" . CRLF .
+					"Content-Length: 0" . CRLF . CRLF;
+
+			} elsif ($uri =~ m/304nolen/) {
+				print $client
+					"HTTP/1.1 304 Not Modified" . CRLF .
+					"X-Request: $rcount" . CRLF .
+					"X-Connection: $ccount" . CRLF . CRLF;
+
+			} elsif ($uri =~ m/304len/) {
+				print $client
+					"HTTP/1.1 304 Not Modified" . CRLF .
+					"X-Request: $rcount" . CRLF .
+					"X-Connection: $ccount" . CRLF .
+					"Content-Length: 100" . CRLF . CRLF;
+
+			} elsif ($uri =~ m/chunked/) {
+				print $client
+					"HTTP/1.1 200 OK" . CRLF .
+					"X-Request: $rcount" . CRLF .
+					"X-Connection: $ccount" . CRLF .
+					"Transfer-Encoding: chunked" . CRLF .
+					CRLF;
+				print $client
+					"1a" . CRLF .
+					"TEST-OK-IF-YOU-SEE-THIS" .
+					sprintf("%03d", $ccount) . CRLF .
+					"0" . CRLF . CRLF
+					unless $headers =~ /^HEAD/i;
+
+			} elsif ($uri =~ m/complex/) {
+				print $client
+					"HTTP/1.1 200 OK" . CRLF .
+					"X-Request: $rcount" . CRLF .
+					"X-Connection: $ccount" . CRLF .
+					"Transfer-Encoding: chunked" . CRLF .
+					CRLF;
+
+				if ($headers !~ /^HEAD/i) {
+					for my $n (1..100) {
+						print $client
+							"a" . CRLF .
+							"0123456789" . CRLF;
+						select undef, undef, undef, 0.01
+							if $n % 50 == 0;
+					}
+					print $client
+						"1a" . CRLF .
+						"TEST-OK-IF-YOU-SEE-THIS" .
+						sprintf("%03d", $ccount) .
+						CRLF .
+						"0" . CRLF;
+					select undef, undef, undef, 0.05;
+					print $client CRLF;
+				}
+
+			} elsif ($uri =~ m/chunk0/) {
+				print $client
+					"HTTP/1.1 200 OK" . CRLF .
+					"X-Request: $rcount" . CRLF .
+					"X-Connection: $ccount" . CRLF .
+					"Transfer-Encoding: chunked" . CRLF .
+					CRLF;
+				print $client
+					"0" . CRLF . CRLF
+					unless $headers =~ /^HEAD/i;
+
+			} elsif ($uri =~ m/closed/) {
+				print $client
+					"HTTP/1.1 200 OK" . CRLF .
+					"X-Request: $rcount" . CRLF .
+					"X-Connection: $ccount" . CRLF .
+					"Connection: close" . CRLF .
+					"Content-Length: 12" . CRLF . CRLF .
+					"0123456789" . CRLF;
+				last;
+
+			} else {
+				print $client
+					"HTTP/1.1 404 Not Found" . CRLF .
+					"X-Request: $rcount" . CRLF .
+					"X-Connection: $ccount" . CRLF .
+					"Connection: close" . CRLF . CRLF .
+					"Oops, '$uri' not found" . CRLF;
+				last;
+			}
+		}
+
+		close $client;
+	}
+}
+
+###############################################################################
diff --git a/tests/proxy_limit_rate.t b/tests/proxy_limit_rate.t
new file mode 100644
index 0000000..5fde715
--- /dev/null
+++ b/tests/proxy_limit_rate.t
@@ -0,0 +1,92 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for the proxy_limit_rate directive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy upstream_keepalive/)->plan(4);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    upstream u {
+        server 127.0.0.1:8080;
+        keepalive 1;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            proxy_pass http://127.0.0.1:8080/data;
+            proxy_buffer_size 4k;
+            proxy_limit_rate 20000;
+            add_header X-Msec $msec;
+        }
+
+        location /keepalive {
+            proxy_http_version 1.1;
+            proxy_set_header Connection "";
+            proxy_pass http://u/data;
+            proxy_buffer_size 4k;
+            proxy_limit_rate 20000;
+            add_header X-Msec $msec;
+        }
+
+        location /data {
+        }
+    }
+}
+
+EOF
+
+$t->write_file('data', 'X' x 40000);
+$t->run();
+
+###############################################################################
+
+my $r = http_get('/');
+
+my ($t1) = $r =~ /X-Msec: (\d+)/;
+my $diff = time() - $t1;
+
+# four chunks are split with three 1s delays
+
+cmp_ok($diff, '>=', 1, 'proxy_limit_rate');
+like($r, qr/^(XXXXXXXXXX){4000}\x0d?\x0a?$/m, 'response body');
+
+# in case keepalive connection was saved with the delayed flag,
+# the read timer used to be a delay timer in the next request
+
+like(http_get('/keepalive'), qr/200 OK/, 'keepalive');
+like(http_get('/keepalive'), qr/200 OK/, 'keepalive 2');
+
+###############################################################################
diff --git a/tests/proxy_merge_headers.t b/tests/proxy_merge_headers.t
new file mode 100644
index 0000000..434e9d1
--- /dev/null
+++ b/tests/proxy_merge_headers.t
@@ -0,0 +1,114 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for proxy_set_header inheritance.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy cache rewrite/)->plan(7)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    proxy_cache_path   %%TESTDIR%%/cache  levels=1:2
+                       keys_zone=NAME:1m;
+
+    proxy_set_header X-Blah "blah";
+    proxy_hide_header X-Hidden;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        proxy_cache  NAME;
+
+        location / {
+            proxy_pass    http://127.0.0.1:8081;
+
+            location /nested/ {
+                proxy_pass   http://127.0.0.1:8081;
+                proxy_pass_header X-Pad;
+            }
+        }
+
+        location /no/ {
+            proxy_pass    http://127.0.0.1:8081;
+            proxy_cache   off;
+        }
+
+        location /setbody/ {
+            proxy_pass    http://127.0.0.1:8081;
+            proxy_set_body "body";
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location / {
+            add_header X-Hidden "hidden";
+            add_header X-Pad "passed";
+            return 200 "ims=$http_if_modified_since;blah=$http_x_blah;";
+        }
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+like(http_get_ims('/'), qr/ims=;blah=blah;/,
+	'if-modified-since cleared with cache');
+
+like(http_get_ims('/no/'), qr/ims=blah;blah=blah;/,
+	'if-modified-since preserved without cache');
+
+like(http_get_ims('/setbody/'), qr/blah=blah;/,
+	'proxy_set_header inherited with proxy_set_body');
+
+unlike(http_get('/'), qr/X-Pad/, 'proxy_pass_header default');
+like(http_get('/nested/'), qr/X-Pad/, 'proxy_pass_header nested');
+unlike(http_get('/'), qr/X-Hidden/, 'proxy_hide_header inherited');
+unlike(http_get('/nested/'), qr/X-Hidden/, 'proxy_hide_header nested');
+
+###############################################################################
+
+sub http_get_ims {
+	my ($url) = @_;
+	return http(<<EOF);
+GET $url HTTP/1.0
+Host: localhost
+Connection: close
+If-Modified-Since: blah
+
+EOF
+}
+
+###############################################################################
diff --git a/tests/proxy_method.t b/tests/proxy_method.t
new file mode 100644
index 0000000..6cdc0b4
--- /dev/null
+++ b/tests/proxy_method.t
@@ -0,0 +1,86 @@
+#!/usr/bin/perl
+
+# (C) Dmitry Lazurkin
+
+# Tests for proxy_method.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy rewrite/)->plan(4)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /preserve {
+            proxy_pass http://127.0.0.1:8080/get-method;
+        }
+
+        location /const {
+            proxy_pass http://127.0.0.1:8080/get-method;
+            proxy_method POST;
+        }
+
+        location /var {
+            proxy_pass http://127.0.0.1:8080/get-method;
+            proxy_method $arg_method;
+        }
+
+        location /parent {
+            proxy_method POST;
+            location /parent/child {
+                proxy_pass http://127.0.0.1:8080/get-method;
+            }
+        }
+
+        location /get-method {
+            return 200 "request_method=$request_method";
+        }
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+like(http_get('/preserve'), qr/request_method=GET/,
+	'proxy_method from request');
+
+like(http_get('/const'), qr/request_method=POST/,
+	'proxy_method from constant');
+
+like(http_get('/var?method=POST'), qr/request_method=POST/,
+	'proxy_method from variable');
+
+like(http_get('/parent/child'), qr/request_method=POST/,
+	'proxy_method from parent');
+
+###############################################################################
diff --git a/tests/proxy_next_upstream.t b/tests/proxy_next_upstream.t
new file mode 100644
index 0000000..6d6da11
--- /dev/null
+++ b/tests/proxy_next_upstream.t
@@ -0,0 +1,136 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for http proxy module, proxy_next_upstream directive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy rewrite/)->plan(7);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    upstream u {
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8082;
+    }
+
+    upstream u2 {
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8082;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            proxy_pass http://u;
+            proxy_next_upstream http_500 http_404;
+        }
+
+        location /all/ {
+            proxy_pass http://u2;
+            proxy_next_upstream http_500 http_404;
+            error_page 404 /all/404;
+            proxy_intercept_errors on;
+        }
+
+        location /all/404 {
+            return 200 "$upstream_addr\n";
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location / {
+            return 404;
+        }
+        location /ok {
+            return 200 "AND-THIS\n";
+        }
+        location /500 {
+            return 500;
+        }
+
+        location /all/ {
+            return 404;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8082;
+        server_name  localhost;
+
+        location / {
+            return 200 "TEST-OK-IF-YOU-SEE-THIS\n";
+        }
+
+        location /all/ {
+            return 404;
+        }
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+my ($p1, $p2) = (port(8081), port(8082));
+
+# check if both request fallback to a backend
+# which returns valid response
+
+like(http_get('/'), qr/SEE-THIS/, 'proxy request');
+like(http_get('/'), qr/SEE-THIS/, 'second request');
+
+# make sure backend isn't switched off after
+# proxy_next_upstream http_404
+
+like(http_get('/ok') . http_get('/ok'), qr/AND-THIS/, 'not down');
+
+# next upstream on http_500
+
+like(http_get('/500'), qr/SEE-THIS/, 'request 500');
+like(http_get('/500'), qr/SEE-THIS/, 'request 500 second');
+
+# make sure backend switched off with http_500
+
+unlike(http_get('/ok') . http_get('/ok'), qr/AND-THIS/, 'down after 500');
+
+# make sure all backends are tried once
+
+like(http_get('/all/rr'),
+	qr/^127.0.0.1:($p1, 127.0.0.1:$p2|$p2, 127.0.0.1:$p1)$/mi,
+	'all tried once');
+
+###############################################################################
diff --git a/tests/proxy_next_upstream_tries.t b/tests/proxy_next_upstream_tries.t
new file mode 100644
index 0000000..e7b3a03
--- /dev/null
+++ b/tests/proxy_next_upstream_tries.t
@@ -0,0 +1,258 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http proxy module, proxy_next_upstream_tries
+# and proxy_next_upstream_timeout directives.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy rewrite/)->plan(8);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    upstream u {
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8081;
+    }
+
+    upstream u2 {
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8081 backup;
+        server 127.0.0.1:8081 backup;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        proxy_next_upstream http_404;
+        proxy_intercept_errors on;
+        error_page 404 /404;
+
+        location /tries {
+            proxy_pass http://u;
+            proxy_next_upstream_tries 2;
+        }
+
+        location /tries/backup {
+            proxy_pass http://u2;
+            proxy_next_upstream_tries 2;
+        }
+
+        location /tries/resolver {
+            resolver 127.0.0.1:%%PORT_8982_UDP%%;
+
+            proxy_pass http://$host:%%PORT_8081%%;
+            proxy_next_upstream_tries 2;
+        }
+
+        location /tries/zero {
+            proxy_pass http://u;
+            proxy_next_upstream_tries 0;
+        }
+
+        location /timeout {
+            proxy_pass http://u/w2;
+            proxy_next_upstream_timeout 3800ms;
+        }
+
+        location /timeout/backup {
+            proxy_pass http://u2/w2;
+            proxy_next_upstream_timeout 3800ms;
+        }
+
+        location /timeout/resolver {
+            resolver 127.0.0.1:%%PORT_8982_UDP%%;
+
+            proxy_pass http://$host:%%PORT_8081%%/w2;
+            proxy_next_upstream_timeout 3800ms;
+        }
+
+        location /timeout/zero {
+            proxy_pass http://u/w;
+            proxy_next_upstream_timeout 0;
+        }
+
+        location /404 {
+            return 200 x${upstream_status}x;
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&http_daemon, port(8081));
+$t->run_daemon(\&dns_daemon, port(8982), $t);
+$t->run();
+
+$t->waitforsocket('127.0.0.1:' . port(8081));
+$t->waitforfile($t->testdir . '/' . port(8982));
+
+###############################################################################
+
+like(http_get('/tries'), qr/x404, 404x/, 'tries');
+like(http_get('/tries/backup'), qr/x404, 404x/, 'tries backup');
+like(http_get('/tries/resolver'), qr/x404, 404x/, 'tries resolved');
+like(http_get('/tries/zero'), qr/x404, 404, 404x/, 'tries zero');
+
+# two tries fit into 1.9s
+
+SKIP: {
+skip 'long tests', 4 unless $ENV{TEST_NGINX_UNSAFE};
+
+like(http_get('/timeout'), qr/x404, 404x/, 'timeout');
+like(http_get('/timeout/backup'), qr/x404, 404x/, 'timeout backup');
+like(http_get('/timeout/resolver'), qr/x404, 404x/, 'timeout resolved');
+like(http_get('/timeout/zero'), qr/x404, 404, 404x/, 'timeout zero');
+
+}
+
+###############################################################################
+
+sub http_daemon {
+	my ($port) = @_;
+
+	my $server = IO::Socket::INET->new(
+		Proto => 'tcp',
+		LocalHost => '127.0.0.1',
+		LocalPort => $port,
+		Listen => 5,
+		Reuse => 1
+	)
+		or die "Can't create listening socket: $!\n";
+
+	local $SIG{PIPE} = 'IGNORE';
+
+	while (my $client = $server->accept()) {
+		$client->autoflush(1);
+
+		my $headers = '';
+		my $uri = '';
+
+		while (<$client>) {
+			$headers .= $_;
+			last if (/^\x0d?\x0a?$/);
+		}
+
+		next if $headers eq '';
+
+		$uri = $1 if $headers =~ /^\S+\s+([^ ]+)\s+HTTP/i;
+
+		if ($uri eq '/w') {
+			Test::Nginx::log_core('||', "$port: sleep(1)");
+			select undef, undef, undef, 1;
+		}
+
+		if ($uri eq '/w2') {
+			Test::Nginx::log_core('||', "$port: sleep(2)");
+			select undef, undef, undef, 2;
+		}
+
+		Test::Nginx::log_core('||', "$port: response, 404");
+		print $client <<EOF;
+HTTP/1.1 404 Not Found
+Connection: close
+
+EOF
+
+	} continue {
+		close $client;
+	}
+}
+
+sub reply_handler {
+	my ($recv_data) = @_;
+
+	my (@name, @rdata);
+
+	use constant NOERROR	=> 0;
+	use constant A		=> 1;
+	use constant IN		=> 1;
+
+	# default values
+
+	my ($hdr, $rcode, $ttl) = (0x8180, NOERROR, 3600);
+
+	# decode name
+
+	my ($len, $offset) = (undef, 12);
+	while (1) {
+		$len = unpack("\@$offset C", $recv_data);
+		last if $len == 0;
+		$offset++;
+		push @name, unpack("\@$offset A$len", $recv_data);
+		$offset += $len;
+	}
+
+	$offset -= 1;
+	my ($id, $type, $class) = unpack("n x$offset n2", $recv_data);
+
+	@rdata = map { rd_addr($ttl, '127.0.0.1') } (1 .. 3) if $type == A;
+
+	$len = @name;
+	pack("n6 (C/a*)$len x n2", $id, $hdr | $rcode, 1, scalar @rdata,
+		0, 0, @name, $type, $class) . join('', @rdata);
+}
+
+sub rd_addr {
+	my ($ttl, $addr) = @_;
+
+	my $code = 'split(/\./, $addr)';
+
+	return pack 'n3N', 0xc00c, A, IN, $ttl if $addr eq '';
+
+	pack 'n3N nC4', 0xc00c, A, IN, $ttl, eval "scalar $code", eval($code);
+}
+
+sub dns_daemon {
+	my ($port, $t) = @_;
+
+	my ($data, $recv_data);
+	my $socket = IO::Socket::INET->new(
+		LocalAddr => '127.0.0.1',
+		LocalPort => $port,
+		Proto => 'udp',
+	)
+		or die "Can't create listening socket: $!\n";
+
+	# signal we are ready
+
+	open my $fh, '>', $t->testdir() . '/' . $port;
+	close $fh;
+
+	while (1) {
+		$socket->recv($recv_data, 65536);
+		$data = reply_handler($recv_data);
+		$socket->send($data);
+	}
+}
+
+###############################################################################
diff --git a/tests/proxy_noclose.t b/tests/proxy_noclose.t
new file mode 100644
index 0000000..dd8d204
--- /dev/null
+++ b/tests/proxy_noclose.t
@@ -0,0 +1,151 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Test for http backend not closing connection properly after sending full
+# reply.  This is in fact backend bug, but it seems common, and anyway
+# correct handling is required to support persistent connections.
+
+# There are actually 2 nginx problems here:
+#
+# 1. It doesn't send reply in-time even if got Content-Length and all the data.
+#
+# 2. If upstream times out some data may be left in input buffer and won't be
+#    sent to downstream.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use IO::Select;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy/)->plan(4);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            proxy_pass http://127.0.0.1:8081;
+            proxy_read_timeout 2s;
+        }
+
+        location /uselen {
+            proxy_pass http://127.0.0.1:8081;
+
+            # test will wait only 2s for reply, we it will fail if
+            # Content-Length not used as a hint
+
+            proxy_read_timeout 10s;
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&http_noclose_daemon);
+$t->run()->waitforsocket('127.0.0.1:' . port(8081));
+
+###############################################################################
+
+like(http_get('/'), qr/SEE-THIS/, 'request to bad backend');
+like(http_get('/multi'), qr/AND-THIS/, 'bad backend - multiple packets');
+like(http_get('/uselen'), qr/SEE-THIS/, 'content-length actually used');
+
+TODO: {
+local $TODO = 'not yet';
+local $SIG{__WARN__} = sub {};
+
+like(http_get('/nolen'), qr/SEE-THIS/, 'bad backend - no content length');
+
+}
+
+###############################################################################
+
+sub http_noclose_daemon {
+	my $server = IO::Socket::INET->new(
+		Proto => 'tcp',
+		LocalAddr => '127.0.0.1:' . port(8081),
+		Listen => 5,
+		Reuse => 1
+	)
+		or die "Can't create listening socket: $!\n";
+
+	local $SIG{PIPE} = 'IGNORE';
+
+	while (my $client = $server->accept()) {
+		$client->autoflush(1);
+
+		my $multi = 0;
+		my $nolen = 0;
+
+		while (<$client>) {
+			$multi = 1 if /multi/;
+			$nolen = 1 if /nolen/;
+			last if (/^\x0d?\x0a?$/);
+		}
+
+		if ($nolen) {
+
+			print $client <<'EOF';
+HTTP/1.1 200 OK
+Connection: close
+
+TEST-OK-IF-YOU-SEE-THIS
+EOF
+		} elsif ($multi) {
+
+			print $client <<"EOF";
+HTTP/1.1 200 OK
+Content-Length: 32
+Connection: close
+
+TEST-OK-IF-YOU-SEE-THIS
+EOF
+
+			select undef, undef, undef, 0.1;
+			print $client 'AND-THIS';
+
+		} else {
+
+			print $client <<"EOF";
+HTTP/1.1 200 OK
+Content-Length: 24
+Connection: close
+
+TEST-OK-IF-YOU-SEE-THIS
+EOF
+		}
+
+		my $select = IO::Select->new($client);
+		$select->can_read(10);
+		close $client;
+	}
+}
+
+###############################################################################
diff --git a/tests/proxy_non_idempotent.t b/tests/proxy_non_idempotent.t
new file mode 100644
index 0000000..51edc2d
--- /dev/null
+++ b/tests/proxy_non_idempotent.t
@@ -0,0 +1,136 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+# (C) Nginx, Inc.
+
+# Tests for proxy_next_upstream non_idempotent.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy rewrite upstream_keepalive/)
+	->plan(8);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    upstream u {
+        server 127.0.0.1:8081 max_fails=0;
+        server 127.0.0.1:8081 max_fails=0;
+    }
+
+    upstream uk {
+        server 127.0.0.1:8081 max_fails=0;
+        server 127.0.0.1:8081 max_fails=0;
+        keepalive 10;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        add_header X-IP $upstream_addr always;
+
+        location / {
+            proxy_pass http://u;
+            proxy_next_upstream error timeout http_404;
+        }
+
+        location /non {
+            proxy_pass http://u;
+            proxy_next_upstream error timeout non_idempotent;
+        }
+
+        location /keepalive {
+            proxy_pass http://uk;
+            proxy_next_upstream error timeout;
+            proxy_http_version 1.1;
+            proxy_set_header Connection "";
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location / {
+            return 444;
+        }
+
+        location /404 {
+            return 404 SEE-THIS;
+        }
+
+        location /keepalive/establish {
+            return 204;
+        }
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+# non-idempotent requests should not be retried by default
+# if a request has been sent to a backend
+
+like(http_get('/'), qr/X-IP: (\S+), \1\x0d?$/m, 'get');
+like(http_post('/'), qr/X-IP: (\S+)\x0d?$/m, 'post');
+
+# non-idempotent requests should not be retried by default,
+# in particular, not emit builtin error page due to next upstream
+
+like(http_get('/404'), qr/X-IP: (\S+), \1.*SEE-THIS/s, 'get 404');
+like(http_post('/404'), qr/X-IP: (\S++)(?! ).*SEE-THIS/s, 'post 404');
+
+# with "proxy_next_upstream non_idempotent" there is no
+# difference between idempotent and non-idempotent requests,
+# non-idempotent requests are retried as usual
+
+like(http_get('/non'), qr/X-IP: (\S+), \1\x0d?$/m, 'get non_idempotent');
+like(http_post('/non'), qr/X-IP: (\S+), \1\x0d?$/m, 'post non_idempotent');
+
+# cached connections follow the same rules
+
+like(http_get('/keepalive/establish'), qr/204 No Content/m, 'keepalive');
+like(http_post('/keepalive/drop'), qr/X-IP: (\S+)\x0d?$/m, 'keepalive post');
+
+###############################################################################
+
+sub http_post {
+	my ($uri, %extra) = @_;
+	my $cl = $extra{cl} || 0;
+
+	http(<<"EOF");
+POST $uri HTTP/1.0
+Content-Length: $cl
+
+EOF
+}
+
+###############################################################################
diff --git a/tests/proxy_pass_request.t b/tests/proxy_pass_request.t
new file mode 100644
index 0000000..d695893
--- /dev/null
+++ b/tests/proxy_pass_request.t
@@ -0,0 +1,138 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for proxy_pass_request_headers, proxy_pass_request_body directives.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy/)->plan(3);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        proxy_pass_request_headers off;
+
+        location / {
+            proxy_pass http://127.0.0.1:8081;
+        }
+
+        location /body {
+            proxy_pass http://127.0.0.1:8081;
+            proxy_pass_request_headers on;
+            proxy_pass_request_body off;
+        }
+
+        location /both {
+            proxy_pass http://127.0.0.1:8081;
+            proxy_pass_request_headers off;
+            proxy_pass_request_body off;
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&http_daemon);
+$t->run()->waitforsocket('127.0.0.1:' . port(8081));
+
+###############################################################################
+
+like(get('/', 'foo', 'bar'), qr/Header: none.*Body: bar/s, 'no headers');
+like(get('/body', 'foo', 'bar'), qr/Header: foo.*Body: none/s, 'no body');
+like(get('/both', 'foo', 'bar'), qr/Header: none.*Body: none/s, 'both');
+
+###############################################################################
+
+sub get {
+	my ($uri, $header, $body) = @_;
+	my $cl = length("$body\n");
+
+	http(<<EOF);
+GET $uri HTTP/1.0
+Host: localhost
+X-Header: $header
+Content-Length: $cl
+
+$body
+EOF
+}
+
+sub http_daemon {
+	my $server = IO::Socket::INET->new(
+		Proto => 'tcp',
+		LocalHost => '127.0.0.1:' . port(8081),
+		Listen => 5,
+		Reuse => 1
+	)
+		or die "Can't create listening socket: $!\n";
+
+	local $SIG{PIPE} = 'IGNORE';
+
+	while (my $client = $server->accept()) {
+		$client->autoflush(1);
+
+		my $r = '';
+
+		eval {
+			local $SIG{ALRM} = sub { die "timeout\n" };
+			local $SIG{PIPE} = sub { die "sigpipe\n" };
+			alarm(2);
+			$client->sysread($r, 4096);
+			alarm(0);
+		};
+		alarm(0);
+		if ($@) {
+			log_in("died: $@");
+			next;
+		}
+
+		next if $r eq '';
+
+		Test::Nginx::log_core('|| <<', $r);
+
+		my $header = $r =~ /x-header: (\S+)/i && $1 || 'none';
+		my $body = $r =~ /\x0d\x0a?\x0d\x0a?(.+)/ && $1 || 'none';
+
+		print $client <<"EOF";
+HTTP/1.1 200 OK
+Connection: close
+X-Header: $header
+X-Body: $body
+
+EOF
+
+		close $client;
+	}
+}
+
+###############################################################################
diff --git a/tests/proxy_protocol.t b/tests/proxy_protocol.t
new file mode 100644
index 0000000..0f73814
--- /dev/null
+++ b/tests/proxy_protocol.t
@@ -0,0 +1,141 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for haproxy protocol.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http access realip/);
+
+$t->write_file_expand('nginx.conf', <<'EOF')->plan(20);
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    log_format pp $remote_addr:$remote_port;
+
+    server {
+        listen       127.0.0.1:8080 proxy_protocol;
+        server_name  localhost;
+
+        set_real_ip_from  127.0.0.1/32;
+        add_header X-IP $remote_addr!$remote_port;
+        add_header X-PP $proxy_protocol_addr!$proxy_protocol_port;
+
+        location /pp {
+            real_ip_header proxy_protocol;
+            error_page 404 =200 /t1;
+
+            location /pp_4 {
+                deny 192.0.2.1/32;
+                access_log %%TESTDIR%%/pp4.log pp;
+            }
+
+            location /pp_6 {
+                deny 2001:DB8::1/128;
+                access_log %%TESTDIR%%/pp6.log pp;
+            }
+        }
+
+        location / { }
+    }
+}
+
+EOF
+
+$t->write_file('t1', 'SEE-THIS');
+$t->run();
+
+###############################################################################
+
+my $tcp4 = 'PROXY TCP4 192.0.2.1 192.0.2.2 123 5678' . CRLF;
+my $tcp6 = 'PROXY TCP6 2001:Db8::1 2001:Db8::2 123 5678' . CRLF;
+my $unk1 = 'PROXY UNKNOWN' . CRLF;
+my $unk2 = 'PROXY UNKNOWN 1 2 3 4 5 6' . CRLF;
+my $r;
+
+# no realip, just PROXY header parsing
+
+$r = pp_get('/t1', $tcp4);
+like($r, qr/SEE-THIS/, 'tcp4 request');
+like($r, qr/X-PP: 192.0.2.1!123\x0d/, 'tcp4 proxy');
+unlike($r, qr/X-IP: (192.0.2.1|[^!]+!123\x0d)/, 'tcp4 client');
+
+$r = pp_get('/t1', $tcp6);
+like($r, qr/SEE-THIS/, 'tcp6 request');
+like($r, qr/X-PP: 2001:DB8::1!123\x0d/i, 'tcp6 proxy');
+unlike($r, qr/X-IP: (2001:DB8::1|[^!]+!123\x0d)/i, 'tcp6 client');
+
+$r = pp_get('/t1', $unk1);
+like($r, qr/SEE-THIS/, 'unknown request 1');
+like($r, qr/X-PP: !\x0d/, 'unknown proxy 1');
+
+$r = pp_get('/t1', $unk2);
+like($r, qr/SEE-THIS/, 'unknown request 2');
+like($r, qr/X-PP: !\x0d/, 'unknown proxy 2');
+
+# realip
+
+$r = pp_get('/pp', $tcp4);
+like($r, qr/SEE-THIS/, 'tcp4 request realip');
+like($r, qr/X-PP: 192.0.2.1!123\x0d/, 'tcp4 proxy realip');
+like($r, qr/X-IP: 192.0.2.1!123\x0d/, 'tcp4 client realip');
+
+$r = pp_get('/pp', $tcp6);
+like($r, qr/SEE-THIS/, 'tcp6 request realip');
+like($r, qr/X-PP: 2001:DB8::1!123\x0d/i, 'tcp6 proxy realip');
+like($r, qr/X-IP: 2001:DB8::1!123\x0d/i, 'tcp6 client realip');
+
+# access
+
+$r = pp_get('/pp_4', $tcp4);
+like($r, qr/403 Forbidden/, 'tcp4 access');
+
+$r = pp_get('/pp_6', $tcp6);
+like($r, qr/403 Forbidden/, 'tcp6 access');
+
+# client address in access.log
+
+$t->stop();
+
+is($t->read_file('pp4.log'), "192.0.2.1:123\n", 'tcp4 log');
+is($t->read_file('pp6.log'), "2001:db8::1:123\n", 'tcp6 log');
+
+###############################################################################
+
+sub pp_get {
+	my ($url, $proxy) = @_;
+	return http($proxy . <<EOF);
+GET $url HTTP/1.0
+Host: localhost
+
+EOF
+}
+
+###############################################################################
diff --git a/tests/proxy_protocol2.t b/tests/proxy_protocol2.t
new file mode 100644
index 0000000..084adab
--- /dev/null
+++ b/tests/proxy_protocol2.t
@@ -0,0 +1,147 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for haproxy protocol.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http access realip/);
+
+$t->write_file_expand('nginx.conf', <<'EOF')->plan(23);
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    log_format pp $remote_addr:$remote_port;
+
+    server {
+        listen       127.0.0.1:8080 proxy_protocol;
+        server_name  localhost;
+
+        set_real_ip_from  127.0.0.1/32;
+        add_header X-IP $remote_addr!$remote_port;
+        add_header X-PP $proxy_protocol_addr!$proxy_protocol_port;
+
+        location /pp {
+            real_ip_header proxy_protocol;
+            error_page 404 =200 /t1;
+
+            location /pp_4 {
+                deny 192.0.2.1/32;
+                access_log %%TESTDIR%%/pp4.log pp;
+            }
+
+            location /pp_6 {
+                deny 2001:DB8::1/128;
+                access_log %%TESTDIR%%/pp6.log pp;
+            }
+        }
+
+        location / { }
+    }
+}
+
+EOF
+
+$t->write_file('t1', 'SEE-THIS');
+$t->run();
+
+###############################################################################
+
+my $p = pack("N3C", 0x0D0A0D0A, 0x000D0A51, 0x5549540A, 0x21);
+my $tcp4 = $p . pack("CnN2n2", 0x11, 12, 0xc0000201, 0xc0000202, 123, 5678);
+my $tcp6 = $p . pack("CnNx8NNx8Nn2", 0x21, 36,
+	0x20010db8, 0x00000001, 0x20010db8, 0x00000002, 123, 5678);
+my $tlv = $p . pack("CnN2n2x9", 0x11, 21, 0xc0000201, 0xc0000202, 123, 5678);
+my $unk1 = $p . pack("Cxx", 0x01);
+my $unk2 = $p . pack("CnC4", 0x41, 4, 1, 2, 3, 4);
+my $r;
+
+# no realip, just PROXY header parsing
+
+$r = pp_get('/t1', $tcp4);
+like($r, qr/SEE-THIS/, 'tcp4 request');
+like($r, qr/X-PP: 192.0.2.1!123\x0d/, 'tcp4 proxy');
+unlike($r, qr/X-IP: (192.0.2.1|[^!]+!123\x0d)/, 'tcp4 client');
+
+$r = pp_get('/t1', $tcp6);
+like($r, qr/SEE-THIS/, 'tcp6 request');
+like($r, qr/X-PP: 2001:DB8::1!123\x0d/i, 'tcp6 proxy');
+unlike($r, qr/X-IP: (2001:DB8::1|[^!]+!123\x0d)/i, 'tcp6 client');
+
+$r = pp_get('/t1', $tlv);
+like($r, qr/SEE-THIS/, 'tlv request');
+like($r, qr/X-PP: 192.0.2.1!123\x0d/, 'tlv proxy');
+unlike($r, qr/X-IP: (192.0.2.1|[^!]+!123\x0d)/, 'tlv client');
+
+$r = pp_get('/t1', $unk1);
+like($r, qr/SEE-THIS/, 'unknown request 1');
+like($r, qr/X-PP: !\x0d/, 'unknown proxy 1');
+
+$r = pp_get('/t1', $unk2);
+like($r, qr/SEE-THIS/, 'unknown request 2');
+like($r, qr/X-PP: !\x0d/, 'unknown proxy 2');
+
+# realip
+
+$r = pp_get('/pp', $tcp4);
+like($r, qr/SEE-THIS/, 'tcp4 request realip');
+like($r, qr/X-PP: 192.0.2.1!123\x0d/, 'tcp4 proxy realip');
+like($r, qr/X-IP: 192.0.2.1!123\x0d/, 'tcp4 client realip');
+
+$r = pp_get('/pp', $tcp6);
+like($r, qr/SEE-THIS/, 'tcp6 request realip');
+like($r, qr/X-PP: 2001:DB8::1!123\x0d/i, 'tcp6 proxy realip');
+like($r, qr/X-IP: 2001:DB8::1!123\x0d/i, 'tcp6 client realip');
+
+# access
+
+$r = pp_get('/pp_4', $tcp4);
+like($r, qr/403 Forbidden/, 'tcp4 access');
+
+$r = pp_get('/pp_6', $tcp6);
+like($r, qr/403 Forbidden/, 'tcp6 access');
+
+# client address in access.log
+
+$t->stop();
+
+is($t->read_file('pp4.log'), "192.0.2.1:123\n", 'tcp4 log');
+is($t->read_file('pp6.log'), "2001:db8::1:123\n", 'tcp6 log');
+
+###############################################################################
+
+sub pp_get {
+	my ($url, $proxy) = @_;
+	return http($proxy . <<EOF);
+GET $url HTTP/1.0
+Host: localhost
+
+EOF
+}
+
+###############################################################################
diff --git a/tests/proxy_protocol2_server.t b/tests/proxy_protocol2_server.t
new file mode 100644
index 0000000..7d4f36e
--- /dev/null
+++ b/tests/proxy_protocol2_server.t
@@ -0,0 +1,154 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for haproxy protocol.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http access realip/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    log_format pp $remote_addr:$remote_port;
+
+    add_header X-IP $remote_addr!$remote_port;
+    add_header X-PP $proxy_protocol_addr!$proxy_protocol_port;
+    add_header X-PPS $proxy_protocol_server_addr!$proxy_protocol_server_port;
+
+    server {
+        listen       127.0.0.1:8080 proxy_protocol;
+        server_name  localhost;
+
+        set_real_ip_from  127.0.0.1/32;
+
+        location /pp {
+            real_ip_header proxy_protocol;
+            error_page 404 =200 /t1;
+
+            location /pp_4 {
+                deny 192.0.2.1/32;
+                access_log %%TESTDIR%%/pp4.log pp;
+            }
+
+            location /pp_6 {
+                deny 2001:DB8::1/128;
+                access_log %%TESTDIR%%/pp6.log pp;
+            }
+        }
+
+        location / { }
+    }
+}
+
+EOF
+
+$t->write_file('t1', 'SEE-THIS');
+$t->try_run('no proxy_protocol_server_addr')->plan(28);
+
+###############################################################################
+
+my $p = pack("N3C", 0x0D0A0D0A, 0x000D0A51, 0x5549540A, 0x21);
+my $tcp4 = $p . pack("CnN2n2", 0x11, 12, 0xc0000201, 0xc0000202, 123, 567);
+my $tcp6 = $p . pack("CnNx8NNx8Nn2", 0x21, 36,
+	0x20010db8, 0x00000001, 0x20010db8, 0x00000002, 123, 567);
+my $tlv = $p . pack("CnN2n2x9", 0x11, 21, 0xc0000201, 0xc0000202, 123, 567);
+my $unk1 = $p . pack("Cxx", 0x01);
+my $unk2 = $p . pack("CnC4", 0x41, 4, 1, 2, 3, 4);
+my $r;
+
+# no realip, just PROXY header parsing
+
+$r = pp_get('/t1', $tcp4);
+like($r, qr/SEE-THIS/, 'tcp4 request');
+like($r, qr/X-PP: 192.0.2.1!123\x0d/, 'tcp4 proxy');
+like($r, qr/X-PPS: 192.0.2.2!567\x0d/, 'tcp4 proxy server');
+unlike($r, qr/X-IP: (192.0.2.1|[^!]+!123\x0d)/, 'tcp4 client');
+
+$r = pp_get('/t1', $tcp6);
+like($r, qr/SEE-THIS/, 'tcp6 request');
+like($r, qr/X-PP: 2001:DB8::1!123\x0d/i, 'tcp6 proxy');
+like($r, qr/X-PPS: 2001:DB8::2!567\x0d/i, 'tcp6 proxy server');
+unlike($r, qr/X-IP: (2001:DB8::1|[^!]+!123\x0d)/i, 'tcp6 client');
+
+$r = pp_get('/t1', $tlv);
+like($r, qr/SEE-THIS/, 'tlv request');
+like($r, qr/X-PP: 192.0.2.1!123\x0d/, 'tlv proxy');
+like($r, qr/X-PPS: 192.0.2.2!567\x0d/, 'tlv proxy server');
+unlike($r, qr/X-IP: (192.0.2.1|[^!]+!123\x0d)/, 'tlv client');
+
+$r = pp_get('/t1', $unk1);
+like($r, qr/SEE-THIS/, 'unknown request 1');
+like($r, qr/X-PP: !\x0d/, 'unknown proxy 1');
+like($r, qr/X-PPS: !\x0d/, 'unknown proxy server 1');
+
+$r = pp_get('/t1', $unk2);
+like($r, qr/SEE-THIS/, 'unknown request 2');
+like($r, qr/X-PP: !\x0d/, 'unknown proxy 2');
+like($r, qr/X-PPS: !\x0d/, 'unknown proxy server 2');
+
+# realip
+
+$r = pp_get('/pp', $tcp4);
+like($r, qr/SEE-THIS/, 'tcp4 request realip');
+like($r, qr/X-PP: 192.0.2.1!123\x0d/, 'tcp4 proxy realip');
+like($r, qr/X-IP: 192.0.2.1!123\x0d/, 'tcp4 client realip');
+
+$r = pp_get('/pp', $tcp6);
+like($r, qr/SEE-THIS/, 'tcp6 request realip');
+like($r, qr/X-PP: 2001:DB8::1!123\x0d/i, 'tcp6 proxy realip');
+like($r, qr/X-IP: 2001:DB8::1!123\x0d/i, 'tcp6 client realip');
+
+# access
+
+$r = pp_get('/pp_4', $tcp4);
+like($r, qr/403 Forbidden/, 'tcp4 access');
+
+$r = pp_get('/pp_6', $tcp6);
+like($r, qr/403 Forbidden/, 'tcp6 access');
+
+# client address in access.log
+
+$t->stop();
+
+is($t->read_file('pp4.log'), "192.0.2.1:123\n", 'tcp4 log');
+is($t->read_file('pp6.log'), "2001:db8::1:123\n", 'tcp6 log');
+
+###############################################################################
+
+sub pp_get {
+	my ($url, $proxy) = @_;
+	return http($proxy . <<EOF);
+GET $url HTTP/1.0
+Host: localhost
+
+EOF
+}
+
+###############################################################################
diff --git a/tests/proxy_protocol_ipv6.t b/tests/proxy_protocol_ipv6.t
new file mode 100644
index 0000000..da126a1
--- /dev/null
+++ b/tests/proxy_protocol_ipv6.t
@@ -0,0 +1,78 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for haproxy protocol on IPv6 listening socket.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http realip stream/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       [::1]:%%PORT_8080%% proxy_protocol;
+        server_name  localhost;
+
+        add_header X-IP $remote_addr;
+        add_header X-PP $proxy_protocol_addr;
+        real_ip_header proxy_protocol;
+
+        location / { }
+        location /pp {
+            set_real_ip_from ::1/128;
+            error_page 404 =200 /t;
+        }
+    }
+}
+
+stream {
+    server {
+        listen      127.0.0.1:8080;
+        proxy_pass  [::1]:%%PORT_8080%%;
+
+        proxy_protocol on;
+    }
+}
+
+EOF
+
+$t->write_file('t', 'SEE-THIS');
+$t->try_run('no inet6 support')->plan(3);
+
+###############################################################################
+
+my $r = http_get('/t');
+like($r, qr/X-IP: ::1/, 'realip');
+like($r, qr/X-PP: 127.0.0.1/, 'proxy protocol');
+
+$r = http_get('/pp');
+like($r, qr/X-IP: 127.0.0.1/, 'proxy protocol realip');
+
+###############################################################################
diff --git a/tests/proxy_protocol_server.t b/tests/proxy_protocol_server.t
new file mode 100644
index 0000000..da26669
--- /dev/null
+++ b/tests/proxy_protocol_server.t
@@ -0,0 +1,147 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for haproxy protocol.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http access realip/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    log_format pp $remote_addr:$remote_port;
+
+    add_header X-IP $remote_addr!$remote_port;
+    add_header X-PP $proxy_protocol_addr!$proxy_protocol_port;
+    add_header X-PPS $proxy_protocol_server_addr!$proxy_protocol_server_port;
+
+    server {
+        listen       127.0.0.1:8080 proxy_protocol;
+        server_name  localhost;
+
+        set_real_ip_from  127.0.0.1/32;
+
+        location /pp {
+            real_ip_header proxy_protocol;
+            error_page 404 =200 /t1;
+
+            location /pp_4 {
+                deny 192.0.2.1/32;
+                access_log %%TESTDIR%%/pp4.log pp;
+            }
+
+            location /pp_6 {
+                deny 2001:DB8::1/128;
+                access_log %%TESTDIR%%/pp6.log pp;
+            }
+        }
+
+        location / { }
+    }
+}
+
+EOF
+
+$t->write_file('t1', 'SEE-THIS');
+$t->try_run('no proxy_protocol_server_addr')->plan(24);
+
+###############################################################################
+
+my $tcp4 = 'PROXY TCP4 192.0.2.1 192.0.2.2 123 567' . CRLF;
+my $tcp6 = 'PROXY TCP6 2001:Db8::1 2001:Db8::2 123 567' . CRLF;
+my $unk1 = 'PROXY UNKNOWN' . CRLF;
+my $unk2 = 'PROXY UNKNOWN 1 2 3 4 5 6' . CRLF;
+my $r;
+
+# no realip, just PROXY header parsing
+
+$r = pp_get('/t1', $tcp4);
+like($r, qr/SEE-THIS/, 'tcp4 request');
+like($r, qr/X-PP: 192.0.2.1!123\x0d/, 'tcp4 proxy');
+like($r, qr/X-PPS: 192.0.2.2!567\x0d/, 'tcp4 proxy server');
+unlike($r, qr/X-IP: (192.0.2.1|[^!]+!123\x0d)/, 'tcp4 client');
+
+$r = pp_get('/t1', $tcp6);
+like($r, qr/SEE-THIS/, 'tcp6 request');
+like($r, qr/X-PP: 2001:DB8::1!123\x0d/i, 'tcp6 proxy');
+like($r, qr/X-PPS: 2001:DB8::2!567\x0d/i, 'tcp6 proxy server');
+unlike($r, qr/X-IP: (2001:DB8::1|[^!]+!123\x0d)/i, 'tcp6 client');
+
+$r = pp_get('/t1', $unk1);
+like($r, qr/SEE-THIS/, 'unknown request 1');
+like($r, qr/X-PP: !\x0d/, 'unknown proxy 1');
+like($r, qr/X-PPS: !\x0d/, 'unknown proxy server 1');
+
+$r = pp_get('/t1', $unk2);
+like($r, qr/SEE-THIS/, 'unknown request 2');
+like($r, qr/X-PP: !\x0d/, 'unknown proxy 2');
+like($r, qr/X-PPS: !\x0d/, 'unknown proxy server 2');
+
+# realip
+
+$r = pp_get('/pp', $tcp4);
+like($r, qr/SEE-THIS/, 'tcp4 request realip');
+like($r, qr/X-PP: 192.0.2.1!123\x0d/, 'tcp4 proxy realip');
+like($r, qr/X-IP: 192.0.2.1!123\x0d/, 'tcp4 client realip');
+
+$r = pp_get('/pp', $tcp6);
+like($r, qr/SEE-THIS/, 'tcp6 request realip');
+like($r, qr/X-PP: 2001:DB8::1!123\x0d/i, 'tcp6 proxy realip');
+like($r, qr/X-IP: 2001:DB8::1!123\x0d/i, 'tcp6 client realip');
+
+# access
+
+$r = pp_get('/pp_4', $tcp4);
+like($r, qr/403 Forbidden/, 'tcp4 access');
+
+$r = pp_get('/pp_6', $tcp6);
+like($r, qr/403 Forbidden/, 'tcp6 access');
+
+# client address in access.log
+
+$t->stop();
+
+is($t->read_file('pp4.log'), "192.0.2.1:123\n", 'tcp4 log');
+is($t->read_file('pp6.log'), "2001:db8::1:123\n", 'tcp6 log');
+
+###############################################################################
+
+sub pp_get {
+	my ($url, $proxy) = @_;
+	return http($proxy . <<EOF);
+GET $url HTTP/1.0
+Host: localhost
+
+EOF
+}
+
+###############################################################################
diff --git a/tests/proxy_redirect.t b/tests/proxy_redirect.t
new file mode 100644
index 0000000..6078f58
--- /dev/null
+++ b/tests/proxy_redirect.t
@@ -0,0 +1,153 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+# (C) Valentin Bartenev
+
+# Tests for the proxy_redirect directive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy rewrite/)->plan(15);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            set $some_var var_here;
+
+            proxy_pass http://127.0.0.1:8081;
+
+            proxy_redirect http://127.0.0.1:8081/var_in_second/
+                           /$some_var/;
+            proxy_redirect http://127.0.0.1:8081/$some_var/ /replaced/;
+
+            proxy_redirect ~^(.+)/regex_w_([^/]+) $1/$2/test.html;
+            proxy_redirect ~*re+gexp? /replaced/test.html;
+        }
+
+        location /expl_default/ {
+            proxy_pass http://127.0.0.1:8081/replace_this/;
+            proxy_redirect wrong wrong;
+            proxy_redirect default;
+        }
+
+        location /impl_default/ {
+            proxy_pass http://127.0.0.1:8081/replace_this/;
+        }
+
+        location /off/ {
+            proxy_pass http://127.0.0.1:8081/;
+            proxy_redirect off;
+
+            location /off/on/ {
+                proxy_pass http://127.0.0.1:8081;
+                proxy_redirect http://127.0.0.1:8081/off/ /;
+
+                location /off/on/on/ {
+                    proxy_pass http://127.0.0.1:8081;
+                }
+            }
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location / {
+            add_header Refresh "7; url=http://127.0.0.1:8081$uri";
+            return http://127.0.0.1:8081$uri;
+        }
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+my ($p0, $p1) = (port(8080), port(8081));
+
+is(http_get_location("http://127.0.0.1:$p0/impl_default/test.html"),
+	"http://127.0.0.1:$p0/impl_default/test.html", 'implicit default');
+is(http_get_location("http://127.0.0.1:$p0/expl_default/test.html"),
+	"http://127.0.0.1:$p0/expl_default/test.html", 'explicit default');
+
+is(http_get_refresh("http://127.0.0.1:$p0/impl_default/test.html"),
+	'7; url=/impl_default/test.html', 'implicit default (refresh)');
+is(http_get_refresh("http://127.0.0.1:$p0/expl_default/test.html"),
+	'7; url=/expl_default/test.html', 'explicit default (refresh)');
+
+is(http_get_location("http://127.0.0.1:$p0/var_in_second/test.html"),
+	"http://127.0.0.1:$p0/var_here/test.html", 'variable in second arg');
+is(http_get_refresh("http://127.0.0.1:$p0/var_in_second/test.html"),
+	'7; url=/var_here/test.html', 'variable in second arg (refresh)');
+
+is(http_get_location("http://127.0.0.1:$p0/off/test.html"),
+	"http://127.0.0.1:$p1/test.html", 'rewrite off');
+is(http_get_location("http://127.0.0.1:$p0/off/on/test.html"),
+	"http://127.0.0.1:$p0/on/test.html", 'rewrite off overwrite');
+
+is(http_get_location("http://127.0.0.1:$p0/off/on/on/test.html"),
+	"http://127.0.0.1:$p0/on/on/test.html", 'rewrite inheritance');
+
+is(http_get_location("http://127.0.0.1:$p0/var_here/test.html"),
+	"http://127.0.0.1:$p0/replaced/test.html", 'variable in first arg');
+is(http_get_refresh("http://127.0.0.1:$p0/var_here/test.html"),
+	'7; url=/replaced/test.html', 'variable in first arg (refresh)');
+
+is(http_get_location("http://127.0.0.1:$p0/ReeegEX/test.html"),
+	"http://127.0.0.1:$p0/replaced/test.html", 'caseless regexp');
+is(http_get_location("http://127.0.0.1:$p0/regex_w_captures/test.html"),
+	"http://127.0.0.1:$p1/captures/test.html", 'regexp w/captures');
+
+is(http_get_refresh("http://127.0.0.1:$p0/ReeegEX/test.html"),
+	'7; url=/replaced/test.html', 'caseless regexp (refresh)');
+is(http_get_refresh("http://127.0.0.1:$p0/regex_w_captures/test.html"),
+	"7; url=http://127.0.0.1:$p1/captures/test.html",
+	'regexp w/captures (refresh)');
+
+###############################################################################
+
+sub http_get_location {
+	my ($url) = @_;
+	http_get($url) =~ /^Location:\s(.+?)\x0d?$/mi;
+	return $1;
+}
+
+sub http_get_refresh {
+	my ($url) = @_;
+	http_get($url) =~ /^Refresh:\s(.+?)\x0d?$/mi;
+	return $1;
+}
+
+###############################################################################
diff --git a/tests/proxy_request_buffering.t b/tests/proxy_request_buffering.t
new file mode 100644
index 0000000..b64a61b
--- /dev/null
+++ b/tests/proxy_request_buffering.t
@@ -0,0 +1,288 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for unbuffered request body.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy rewrite/)->plan(18);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        client_header_buffer_size 1k;
+        proxy_request_buffering off;
+
+        location / {
+            client_body_buffer_size 2k;
+            add_header X-Body "$request_body";
+            proxy_pass http://127.0.0.1:8081;
+        }
+        location /small {
+            client_body_in_file_only on;
+            proxy_pass http://127.0.0.1:8080/;
+        }
+        location /single {
+            client_body_in_single_buffer on;
+            add_header X-Body "$request_body";
+            proxy_pass http://127.0.0.1:8081;
+        }
+        location /discard {
+            return 200 "TEST\n";
+        }
+        location /preread {
+            proxy_pass http://127.0.0.1:8082/;
+        }
+        location /error_page {
+            proxy_pass http://127.0.0.1:8081/404;
+            error_page 404 /404;
+            proxy_intercept_errors on;
+        }
+        location /404 {
+            return 200 "$request_body\n";
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location / {
+            proxy_pass http://127.0.0.1:8080/discard;
+        }
+        location /404 { }
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+unlike(http_get('/'), qr/X-Body:/ms, 'no body');
+
+like(http_get_body('/', '0123456789'),
+	qr/X-Body: 0123456789\x0d?$/ms, 'body');
+
+like(http_get_body('/', '0123456789' x 128),
+	qr/X-Body: (0123456789){128}\x0d?$/ms, 'body in two buffers');
+
+like(http_get_body('/single', '0123456789' x 128),
+	qr/X-Body: (0123456789){128}\x0d?$/ms, 'body in single buffer');
+
+like(http_get_body('/error_page', '0123456789'),
+	qr/^0123456789$/m, 'body in error page');
+
+# pipelined requests
+
+like(http_get_body('/', '0123456789', '0123456789' x 128, '0123456789' x 512,
+	'foobar'), qr/X-Body: foobar\x0d?$/ms, 'body pipelined');
+like(http_get_body('/', '0123456789' x 128, '0123456789' x 512, '0123456789',
+	'foobar'), qr/X-Body: foobar\x0d?$/ms, 'body pipelined 2');
+
+like(http_get_body('/discard', '0123456789', '0123456789' x 128,
+	'0123456789' x 512, 'foobar'), qr/(TEST.*){4}/ms,
+	'body discard');
+like(http_get_body('/discard', '0123456789' x 128, '0123456789' x 512,
+	'0123456789', 'foobar'), qr/(TEST.*){4}/ms,
+	'body discard 2');
+
+# proxy with file only is disabled in unbuffered mode
+
+like(http_get_body('/small', '0123456789'),
+	qr/X-Body: 0123456789\x0d?$/ms, 'small body in file only');
+
+# interactive tests
+
+my $s = get_body('/preread', port(8082), 10);
+ok($s, 'no preread');
+
+SKIP: {
+skip 'no preread failed', 3 unless $s;
+
+is($s->{upload}('01234'), '01234', 'no preread - body part');
+is($s->{upload}('56789'), '56789', 'no preread - body part 2');
+
+like($s->{http_end}(), qr/200 OK/, 'no preread - response');
+
+}
+
+$s = get_body('/preread', port(8082), 10, '01234');
+ok($s, 'preread');
+
+SKIP: {
+skip 'preread failed', 3 unless $s;
+
+is($s->{preread}, '01234', 'preread - preread');
+is($s->{upload}('56789'), '56789', 'preread - body');
+
+like($s->{http_end}(), qr/200 OK/, 'preread - response');
+
+}
+
+###############################################################################
+
+sub http_get_body {
+	my $uri = shift;
+	my $last = pop;
+	return http( join '', (map {
+		my $body = $_;
+		"GET $uri HTTP/1.1" . CRLF
+		. "Host: localhost" . CRLF
+		. "Content-Length: " . (length $body) . CRLF . CRLF
+		. $body
+	} @_),
+		"GET $uri HTTP/1.1" . CRLF
+		. "Host: localhost" . CRLF
+		. "Connection: close" . CRLF
+		. "Content-Length: " . (length $last) . CRLF . CRLF
+		. $last
+	);
+}
+
+sub get_body {
+	my ($url, $port, $length, $body) = @_;
+	my ($server, $client, $s);
+
+	$server = IO::Socket::INET->new(
+		Proto => 'tcp',
+		LocalHost => '127.0.0.1',
+		LocalPort => $port,
+		Listen => 5,
+		Reuse => 1
+	)
+		or die "Can't create listening socket: $!\n";
+
+	my $r = <<EOF;
+GET $url HTTP/1.1
+Host: localhost
+Connection: close
+Content-Length: $length
+
+EOF
+
+	if (defined $body) {
+		$r .= $body;
+	}
+
+	$s = http($r, start => 1);
+
+	eval {
+		local $SIG{ALRM} = sub { die "timeout\n" };
+		local $SIG{PIPE} = sub { die "sigpipe\n" };
+		alarm(5);
+
+		$client = $server->accept();
+
+		log2c("(new connection $client)");
+
+		alarm(0);
+	};
+	alarm(0);
+	if ($@) {
+		log_in("died: $@");
+		return undef;
+	}
+
+	$client->sysread(my $buf, 1024);
+	log2i($buf);
+
+	$buf =~ s/.*?\x0d\x0a?\x0d\x0a?(.*)/$1/ms;
+
+	my $f = { preread => $buf };
+	$f->{upload} = sub {
+		my $buf = shift;
+
+		eval {
+			local $SIG{ALRM} = sub { die "timeout\n" };
+			local $SIG{PIPE} = sub { die "sigpipe\n" };
+			alarm(5);
+
+			log_out($buf);
+			$s->write($buf);
+
+			$client->sysread($buf, 1024);
+			log2i($buf);
+
+			alarm(0);
+		};
+		alarm(0);
+		if ($@) {
+			log_in("died: $@");
+			return undef;
+		}
+
+		return $buf;
+	};
+	$f->{http_end} = sub {
+		my $buf = '';
+
+		$client->write(<<EOF);
+HTTP/1.1 200 OK
+Connection: close
+X-Port: $port
+
+OK
+EOF
+
+		$client->close;
+
+		eval {
+			local $SIG{ALRM} = sub { die "timeout\n" };
+			local $SIG{PIPE} = sub { die "sigpipe\n" };
+			alarm(5);
+
+			$s->sysread($buf, 1024);
+			log_in($buf);
+
+			alarm(0);
+		};
+		alarm(0);
+		if ($@) {
+			log_in("died: $@");
+			return undef;
+		}
+
+		return $buf;
+	};
+	return $f;
+}
+
+sub log2i { Test::Nginx::log_core('|| <<', @_); }
+sub log2o { Test::Nginx::log_core('|| >>', @_); }
+sub log2c { Test::Nginx::log_core('||', @_); }
+
+###############################################################################
diff --git a/tests/proxy_request_buffering_chunked.t b/tests/proxy_request_buffering_chunked.t
new file mode 100644
index 0000000..3cbf7a5
--- /dev/null
+++ b/tests/proxy_request_buffering_chunked.t
@@ -0,0 +1,339 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for unbuffered request body, chunked transfer-encoding.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy rewrite/)->plan(22);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        client_header_buffer_size 1k;
+        proxy_request_buffering off;
+        proxy_http_version 1.1;
+
+        location / {
+            client_body_buffer_size 2k;
+            add_header X-Body "$request_body";
+            proxy_pass http://127.0.0.1:8081;
+        }
+        location /small {
+            client_body_in_file_only on;
+            proxy_pass http://127.0.0.1:8080/;
+        }
+        location /single {
+            client_body_in_single_buffer on;
+            add_header X-Body "$request_body";
+            proxy_pass http://127.0.0.1:8081;
+        }
+        location /discard {
+            return 200 "TEST\n";
+        }
+        location /preread {
+            proxy_pass http://127.0.0.1:8082/;
+        }
+        location /error_page {
+            proxy_pass http://127.0.0.1:8081/404;
+            error_page 404 /404;
+            proxy_intercept_errors on;
+        }
+        location /404 {
+            return 200 "$request_body\n";
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location / {
+            proxy_pass http://127.0.0.1:8080/discard;
+        }
+        location /404 { }
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+unlike(http_get('/'), qr/X-Body:/ms, 'no body');
+
+like(http_get_body('/', '0123456789'),
+	qr/X-Body: 0123456789\x0d?$/ms, 'body');
+
+like(http_get_body('/', '0123456789' x 128),
+	qr/X-Body: (0123456789){128}\x0d?$/ms, 'body in two buffers');
+
+like(http_get_body('/single', '0123456789' x 128),
+	qr/X-Body: (0123456789){128}\x0d?$/ms, 'body in single buffer');
+
+like(http_get_body('/error_page', '0123456789'),
+	qr/^0123456789$/m, 'body in error page');
+
+# pipelined requests
+
+like(http_get_body('/', '0123456789', '0123456789' x 128, '0123456789' x 512,
+	'foobar'), qr/X-Body: foobar\x0d?$/ms, 'body pipelined');
+like(http_get_body('/', '0123456789' x 128, '0123456789' x 512, '0123456789',
+	'foobar'), qr/X-Body: foobar\x0d?$/ms, 'body pipelined 2');
+
+like(http_get_body('/discard', '0123456789', '0123456789' x 128,
+	'0123456789' x 512, 'foobar'), qr/(TEST.*){4}/ms,
+	'body discard');
+like(http_get_body('/discard', '0123456789' x 128, '0123456789' x 512,
+	'0123456789', 'foobar'), qr/(TEST.*){4}/ms,
+	'body discard 2');
+
+# proxy with file only is disabled in unbuffered mode
+
+like(http_get_body('/small', '0123456789'),
+	qr/X-Body: 0123456789\x0d?$/ms, 'small body in file only');
+
+# interactive tests
+
+my $s = get_body('/preread', port(8082));
+ok($s, 'no preread');
+
+SKIP: {
+skip 'no preread failed', 3 unless $s;
+
+is($s->{upload}('01234'), '5' . CRLF . '01234' . CRLF,
+	'no preread - body part');
+is($s->{upload}('56789', last => 1),
+	'5' . CRLF . '56789' . CRLF . '0' . CRLF . CRLF,
+	'no preread - body part 2');
+
+like($s->{http_end}(), qr/200 OK/, 'no preread - response');
+
+}
+
+$s = get_body('/preread', port(8082), '01234');
+ok($s, 'preread');
+
+SKIP: {
+skip 'preread failed', 3 unless $s;
+
+is($s->{preread}, '5' . CRLF . '01234' . CRLF, 'preread - preread');
+is($s->{upload}('56789', last => 1),
+	'5' . CRLF . '56789' . CRLF . '0' . CRLF . CRLF, 'preread - body');
+
+like($s->{http_end}(), qr/200 OK/, 'preread - response');
+
+}
+
+$s = get_body('/preread', port(8082), '01234', many => 1);
+ok($s, 'chunks');
+
+SKIP: {
+skip 'chunks failed', 3 unless $s;
+
+is($s->{preread}, '9' . CRLF . '01234many' . CRLF, 'chunks - preread');
+is($s->{upload}('56789', many => 1, last => 1),
+	'9' . CRLF . '56789many' . CRLF . '0' . CRLF . CRLF, 'chunks - body');
+
+like($s->{http_end}(), qr/200 OK/, 'chunks - response');
+
+}
+
+###############################################################################
+
+sub http_get_body {
+	my $uri = shift;
+	my $last = pop;
+	return http( join '', (map {
+		my $body = $_;
+		"GET $uri HTTP/1.1" . CRLF
+		. "Host: localhost" . CRLF
+		. "Transfer-Encoding: chunked" . CRLF . CRLF
+		. sprintf("%x", length $body) . CRLF
+		. $body . CRLF
+		. "0" . CRLF . CRLF
+	} @_),
+		"GET $uri HTTP/1.1" . CRLF
+		. "Host: localhost" . CRLF
+		. "Connection: close" . CRLF
+		. "Transfer-Encoding: chunked" . CRLF . CRLF
+		. sprintf("%x", length $last) . CRLF
+		. $last . CRLF
+		. "0" . CRLF . CRLF
+	);
+}
+
+sub get_body {
+	my ($url, $port, $body, %extra) = @_;
+	my ($server, $client, $s);
+	my ($last, $many) = (0, 0);
+
+	$last = $extra{last} if defined $extra{last};
+	$many = $extra{many} if defined $extra{many};
+
+	$server = IO::Socket::INET->new(
+		Proto => 'tcp',
+		LocalHost => '127.0.0.1',
+		LocalPort => $port,
+		Listen => 5,
+		Reuse => 1
+	)
+		or die "Can't create listening socket: $!\n";
+
+	my $r = <<EOF;
+GET $url HTTP/1.1
+Host: localhost
+Connection: close
+Transfer-Encoding: chunked
+
+EOF
+
+	if (defined $body) {
+		$r .= sprintf("%x", length $body) . CRLF;
+		$r .= $body . CRLF;
+	}
+	if (defined $body && $many) {
+		$r .= sprintf("%x", length 'many') . CRLF;
+		$r .= 'many' . CRLF;
+	}
+	if ($last) {
+		$r .= "0" . CRLF . CRLF;
+	}
+
+	$s = http($r, start => 1);
+
+	eval {
+		local $SIG{ALRM} = sub { die "timeout\n" };
+		local $SIG{PIPE} = sub { die "sigpipe\n" };
+		alarm(5);
+
+		$client = $server->accept();
+
+		log2c("(new connection $client)");
+
+		alarm(0);
+	};
+	alarm(0);
+	if ($@) {
+		log_in("died: $@");
+		return undef;
+	}
+
+	$client->sysread(my $buf, 1024);
+	log2i($buf);
+
+	$buf =~ s/.*?\x0d\x0a?\x0d\x0a?(.*)/$1/ms;
+
+	my $f = { preread => $buf };
+	$f->{upload} = sub {
+		my ($body, %extra) = @_;
+		my ($last, $many) = (0, 0);
+
+		$last = $extra{last} if defined $extra{last};
+		$many = $extra{many} if defined $extra{many};
+
+		my $buf = sprintf("%x", length $body) . CRLF;
+		$buf .= $body . CRLF;
+		if ($many) {
+			$buf .= sprintf("%x", length 'many') . CRLF;
+			$buf .= 'many' . CRLF;
+		}
+		if ($last) {
+			$buf .= "0" . CRLF . CRLF;
+		}
+
+		eval {
+			local $SIG{ALRM} = sub { die "timeout\n" };
+			local $SIG{PIPE} = sub { die "sigpipe\n" };
+			alarm(5);
+
+			log_out($buf);
+			$s->write($buf);
+
+			$client->sysread($buf, 1024);
+			log2i($buf);
+
+			alarm(0);
+		};
+		alarm(0);
+		if ($@) {
+			log_in("died: $@");
+			return undef;
+		}
+
+		return $buf;
+	};
+	$f->{http_end} = sub {
+		my $buf = '';
+
+		$client->write(<<EOF);
+HTTP/1.1 200 OK
+Connection: close
+X-Port: $port
+
+OK
+EOF
+
+		$client->close;
+
+		eval {
+			local $SIG{ALRM} = sub { die "timeout\n" };
+			local $SIG{PIPE} = sub { die "sigpipe\n" };
+			alarm(5);
+
+			$s->sysread($buf, 1024);
+			log_in($buf);
+
+			$s->close();
+
+			alarm(0);
+		};
+		alarm(0);
+		if ($@) {
+			log_in("died: $@");
+			return undef;
+		}
+
+		return $buf;
+	};
+	return $f;
+}
+
+sub log2i { Test::Nginx::log_core('|| <<', @_); }
+sub log2o { Test::Nginx::log_core('|| >>', @_); }
+sub log2c { Test::Nginx::log_core('||', @_); }
+
+###############################################################################
diff --git a/tests/proxy_request_buffering_keepalive.t b/tests/proxy_request_buffering_keepalive.t
new file mode 100644
index 0000000..7fe47b7
--- /dev/null
+++ b/tests/proxy_request_buffering_keepalive.t
@@ -0,0 +1,87 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for unbuffered request body and proxy with keepalive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy upstream_keepalive/)->plan(1);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    upstream backend {
+        server 127.0.0.1:8081;
+        keepalive 1;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        proxy_http_version 1.1;
+        proxy_set_header Connection "";
+
+        location / {
+            proxy_pass http://backend;
+            add_header X-Body $request_body;
+            proxy_request_buffering off;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location / { }
+    }
+}
+
+EOF
+
+$t->write_file('t1', 'SEE-THIS');
+$t->run();
+
+###############################################################################
+
+# We emulate an early upstream server response while proxy is still
+# transmitting the request body.  In this case, the request body is
+# discarded by proxy, and 2nd request will be processed by upstream
+# as remain request body.
+
+http(<<EOF);
+GET /t1 HTTP/1.0
+Host: localhost
+Content-Length: 10
+
+EOF
+
+like(http_get('/t1'), qr/200 OK.*SEE/ms, 'keepalive after discarded');
+
+###############################################################################
diff --git a/tests/proxy_request_buffering_ssl.t b/tests/proxy_request_buffering_ssl.t
new file mode 100644
index 0000000..5fd7f3c
--- /dev/null
+++ b/tests/proxy_request_buffering_ssl.t
@@ -0,0 +1,309 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for unbuffered request body to ssl backend.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http http_ssl proxy rewrite/)
+	->has_daemon('openssl')->plan(18);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        client_header_buffer_size 1k;
+        proxy_request_buffering off;
+
+        location / {
+            client_body_buffer_size 2k;
+            add_header X-Body "$request_body";
+            proxy_pass https://127.0.0.1:8081;
+        }
+        location /single {
+            client_body_in_single_buffer on;
+            add_header X-Body "$request_body";
+            proxy_pass https://127.0.0.1:8081;
+        }
+        location /discard {
+            return 200 "TEST\n";
+        }
+        location /preread {
+            proxy_pass https://127.0.0.1:8081;
+        }
+        location /error_page {
+            proxy_pass https://127.0.0.1:8081/404;
+            error_page 404 /404;
+            proxy_intercept_errors on;
+        }
+        location /404 {
+            return 200 "$request_body\n";
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081 ssl;
+        server_name  localhost;
+
+        ssl_certificate_key localhost.key;
+        ssl_certificate localhost.crt;
+
+        location /preread {
+            client_body_buffer_size 2k;
+            add_header X-Body "$request_body";
+            proxy_pass http://127.0.0.1:8082/;
+            proxy_request_buffering off;
+        }
+
+        location / {
+            proxy_pass http://127.0.0.1:8080/discard;
+        }
+        location /404 { }
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('localhost') {
+	system('openssl req -x509 -new '
+		. "-config $d/openssl.conf -subj /CN=$name/ "
+		. "-out $d/$name.crt -keyout $d/$name.key "
+		. ">>$d/openssl.out 2>&1") == 0
+		or die "Can't create certificate for $name: $!\n";
+}
+
+$t->run();
+
+###############################################################################
+
+unlike(http_get('/'), qr/X-Body:/ms, 'no body');
+
+like(http_get_body('/', '0123456789'),
+	qr/X-Body: 0123456789\x0d?$/ms, 'body');
+
+like(http_get_body('/', '0123456789' x 128),
+	qr/X-Body: (0123456789){128}\x0d?$/ms, 'body in two buffers');
+
+like(http_get_body('/single', '0123456789' x 128),
+	qr/X-Body: (0123456789){128}\x0d?$/ms, 'body in single buffer');
+
+like(http_get_body('/error_page', '0123456789'),
+	qr/^0123456789$/m, 'body in error page');
+
+# pipelined requests
+
+like(http_get_body('/', '0123456789', '0123456789' x 128, '0123456789' x 512,
+	'foobar'), qr/X-Body: foobar\x0d?$/ms, 'body pipelined');
+like(http_get_body('/', '0123456789' x 128, '0123456789' x 512, '0123456789',
+	'foobar'), qr/X-Body: foobar\x0d?$/ms, 'body pipelined 2');
+
+like(http_get_body('/discard', '0123456789', '0123456789' x 128,
+	'0123456789' x 512, 'foobar'), qr/(TEST.*){4}/ms,
+	'body discard');
+like(http_get_body('/discard', '0123456789' x 128, '0123456789' x 512,
+	'0123456789', 'foobar'), qr/(TEST.*){4}/ms,
+	'body discard 2');
+
+# interactive tests
+
+my $s = get_body('/preread', port(8082), 10);
+ok($s, 'no preread');
+
+SKIP: {
+skip 'no preread failed', 3 unless $s;
+
+is($s->{upload}('01234'), '01234', 'no preread - body part');
+is($s->{upload}('56789'), '56789', 'no preread - body part 2');
+
+like($s->{http_end}(), qr/200 OK/, 'no preread - response');
+
+}
+
+$s = get_body('/preread', port(8082), 15, '01234');
+ok($s, 'preread');
+
+SKIP: {
+skip 'preread failed', 3 unless $s;
+
+is($s->{preread}, '01234', 'preread - preread');
+is($s->{upload}('56789'), '56789', 'preread - body part');
+is($s->{upload}('abcde'), 'abcde', 'preread - body part 2');
+
+like($s->{http_end}(), qr/200 OK/, 'preread - response');
+
+}
+
+###############################################################################
+
+sub http_get_body {
+	my $uri = shift;
+	my $last = pop;
+	return http( join '', (map {
+		my $body = $_;
+		"GET $uri HTTP/1.1" . CRLF
+		. "Host: localhost" . CRLF
+		. "Content-Length: " . (length $body) . CRLF . CRLF
+		. $body
+	} @_),
+		"GET $uri HTTP/1.1" . CRLF
+		. "Host: localhost" . CRLF
+		. "Connection: close" . CRLF
+		. "Content-Length: " . (length $last) . CRLF . CRLF
+		. $last
+	);
+}
+
+sub get_body {
+	my ($url, $port, $length, $body) = @_;
+	my ($server, $client, $s);
+
+	$server = IO::Socket::INET->new(
+		Proto => 'tcp',
+		LocalHost => '127.0.0.1',
+		LocalPort => $port,
+		Listen => 5,
+		Reuse => 1
+	)
+		or die "Can't create listening socket: $!\n";
+
+	my $r = <<EOF;
+GET $url HTTP/1.1
+Host: localhost
+Connection: close
+Content-Length: $length
+
+EOF
+
+	if (defined $body) {
+		$r .= $body;
+	}
+
+	$s = http($r, start => 1);
+
+	eval {
+		local $SIG{ALRM} = sub { die "timeout\n" };
+		local $SIG{PIPE} = sub { die "sigpipe\n" };
+		alarm(5);
+
+		$client = $server->accept();
+
+		log2c("(new connection $client)");
+
+		alarm(0);
+	};
+	alarm(0);
+	if ($@) {
+		log_in("died: $@");
+		return undef;
+	}
+
+	$client->sysread(my $buf, 1024);
+	log2i($buf);
+
+	$buf =~ s/.*?\x0d\x0a?\x0d\x0a?(.*)/$1/ms;
+
+	my $f = { preread => $buf };
+	$f->{upload} = sub {
+		my $buf = shift;
+
+		eval {
+			local $SIG{ALRM} = sub { die "timeout\n" };
+			local $SIG{PIPE} = sub { die "sigpipe\n" };
+			alarm(5);
+
+			log_out($buf);
+			$s->write($buf);
+
+			$client->sysread($buf, 1024);
+			log2i($buf);
+
+			alarm(0);
+		};
+		alarm(0);
+		if ($@) {
+			log_in("died: $@");
+			return undef;
+		}
+
+		return $buf;
+	};
+	$f->{http_end} = sub {
+		my $buf = '';
+
+		$client->write(<<EOF);
+HTTP/1.1 200 OK
+Connection: close
+X-Port: $port
+
+OK
+EOF
+
+		$client->close;
+
+		eval {
+			local $SIG{ALRM} = sub { die "timeout\n" };
+			local $SIG{PIPE} = sub { die "sigpipe\n" };
+			alarm(5);
+
+			$s->sysread($buf, 1024);
+			log_in($buf);
+
+			alarm(0);
+		};
+		alarm(0);
+		if ($@) {
+			log_in("died: $@");
+			return undef;
+		}
+
+		return $buf;
+	};
+	return $f;
+}
+
+sub log2i { Test::Nginx::log_core('|| <<', @_); }
+sub log2o { Test::Nginx::log_core('|| >>', @_); }
+sub log2c { Test::Nginx::log_core('||', @_); }
+
+###############################################################################
diff --git a/tests/proxy_set_body.t b/tests/proxy_set_body.t
new file mode 100644
index 0000000..00fc7dc
--- /dev/null
+++ b/tests/proxy_set_body.t
@@ -0,0 +1,81 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for proxy_set_body.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy rewrite/)->plan(2)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            proxy_pass http://127.0.0.1:8080/body;
+            proxy_set_body "body";
+        }
+
+        location /p1 {
+            proxy_pass http://127.0.0.1:8080/x1;
+            proxy_set_body "body";
+        }
+
+        location /p2 {
+            proxy_pass http://127.0.0.1:8080/body;
+            proxy_set_body "body two";
+        }
+
+        location /x1 {
+            add_header X-Accel-Redirect /p2;
+            return 204;
+        }
+
+        location /body {
+            add_header X-Body $request_body;
+            proxy_pass http://127.0.0.1:8080/empty;
+        }
+
+        location /empty {
+            return 204;
+        }
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+like(http_get('/'), qr/X-Body: body/, 'proxy_set_body');
+like(http_get('/p1'), qr/X-Body: body two/, 'proxy_set_body twice');
+
+###############################################################################
diff --git a/tests/proxy_ssi_body.t b/tests/proxy_ssi_body.t
new file mode 100644
index 0000000..9df7daf
--- /dev/null
+++ b/tests/proxy_ssi_body.t
@@ -0,0 +1,84 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Test for proxied subrequest with request body in file.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy ssi/)->plan(1);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+        }
+
+        location /proxy {
+            proxy_pass http://127.0.0.1:8080/;
+            client_body_in_file_only on;
+            ssi on;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('ssi.html', 'X<!--# include virtual="test.html" -->X');
+$t->write_file('test.html', 'YY');
+
+$t->run();
+
+###############################################################################
+
+# Request body cache file is released once a response is got.
+# If later a subrequest tries to use body, it fails.
+
+like(http_get_body('/proxy/ssi.html', "1234567890"), qr/^XYYX$/m,
+	'body in file in proxied subrequest');
+
+###############################################################################
+
+sub http_get_body {
+	my ($url, $body, %extra) = @_;
+
+	my $p = "GET $url HTTP/1.0" . CRLF
+		. "Host: localhost" . CRLF
+		. "Content-Length: " . (length $body) . CRLF . CRLF
+		. $body;
+
+	return http($p, %extra);
+}
+
+###############################################################################
diff --git a/tests/proxy_ssl.t b/tests/proxy_ssl.t
new file mode 100644
index 0000000..70888e6
--- /dev/null
+++ b/tests/proxy_ssl.t
@@ -0,0 +1,188 @@
+#!/usr/bin/perl
+
+# (C) Nginx, Inc.
+
+# Tests for proxy to ssl backend.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require IO::Socket::SSL; };
+plan(skip_all => 'IO::Socket::SSL not installed') if $@;
+
+my $t = Test::Nginx->new()->has(qw/http proxy http_ssl/)->has_daemon('openssl')
+	->plan(8)->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen 127.0.0.1:8081 ssl;
+
+        ssl_certificate_key localhost.key;
+        ssl_certificate localhost.crt;
+        ssl_session_cache builtin;
+
+        location / {
+            add_header X-Session $ssl_session_reused;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /ssl_reuse {
+            proxy_pass https://127.0.0.1:8081/;
+            proxy_ssl_session_reuse on;
+        }
+
+        location /ssl {
+            proxy_pass https://127.0.0.1:8081/;
+            proxy_ssl_session_reuse off;
+        }
+
+        location /timeout {
+            proxy_pass https://127.0.0.1:8082;
+            proxy_connect_timeout 3s;
+        }
+
+        location /timeout_h {
+            proxy_pass https://127.0.0.1:8083;
+            proxy_connect_timeout 1s;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+$t->write_file('big.html', 'xxxxxxxxxx' x 72000);
+$t->write_file('index.html', '');
+
+my $d = $t->testdir();
+
+foreach my $name ('localhost') {
+	system('openssl req -x509 -new '
+		. "-config $d/openssl.conf -subj /CN=$name/ "
+		. "-out $d/$name.crt -keyout $d/$name.key "
+		. ">>$d/openssl.out 2>&1") == 0
+		or die "Can't create certificate for $name: $!\n";
+}
+
+$t->run_daemon(\&http_daemon, port(8082));
+$t->run_daemon(\&http_daemon, port(8083));
+$t->run();
+$t->waitforsocket('127.0.0.1:' . port(8082));
+$t->waitforsocket('127.0.0.1:' . port(8083));
+
+###############################################################################
+
+like(http_get('/ssl'), qr/200 OK.*X-Session: \./s, 'ssl');
+like(http_get('/ssl'), qr/200 OK.*X-Session: \./s, 'ssl 2');
+like(http_get('/ssl_reuse'), qr/200 OK.*X-Session: \./s, 'ssl session new');
+like(http_get('/ssl_reuse'), qr/200 OK.*X-Session: r/s, 'ssl session reused');
+like(http_get('/ssl_reuse'), qr/200 OK.*X-Session: r/s, 'ssl session reused 2');
+
+SKIP: {
+skip 'long test', 1 unless $ENV{TEST_NGINX_UNSAFE};
+
+like(http_get('/timeout'), qr/200 OK/, 'proxy connect timeout');
+
+}
+
+like(http_get('/timeout_h'), qr/504 Gateway/, 'proxy handshake timeout');
+
+is(length(Test::Nginx::http_content(http_get('/ssl/big.html'))), 720000,
+	'big length');
+
+###############################################################################
+
+sub http_daemon {
+	my ($port) = @_;
+	my $server = IO::Socket::INET->new(
+		Proto => 'tcp',
+		LocalHost => '127.0.0.1:' . $port,
+		Listen => 5,
+		Reuse => 1
+	)
+		or die "Can't create listening socket: $!\n";
+
+	local $SIG{PIPE} = 'IGNORE';
+
+	while (my $client = $server->accept()) {
+		$client->autoflush(1);
+
+		if ($port == port(8083)) {
+			sleep 3;
+
+			close $client;
+			next;
+		}
+
+		my $headers = '';
+		my $uri = '';
+
+		# would fail on waitforsocket
+
+		eval {
+			IO::Socket::SSL->start_SSL($client,
+				SSL_server => 1,
+				SSL_cert_file => "$d/localhost.crt",
+				SSL_key_file => "$d/localhost.key",
+				SSL_error_trap => sub { die $_[1] }
+			);
+		};
+		next if $@;
+
+		while (<$client>) {
+			$headers .= $_;
+			last if (/^\x0d?\x0a?$/);
+		}
+
+		$uri = $1 if $headers =~ /^\S+\s+([^ ]+)\s+HTTP/i;
+		next if $uri eq '';
+
+		if ($uri eq '/timeout') {
+			sleep 4;
+
+			print $client <<EOF;
+HTTP/1.1 200 OK
+Connection: close
+
+EOF
+		}
+
+		close $client;
+	}
+}
+
+###############################################################################
diff --git a/tests/proxy_ssl_certificate.t b/tests/proxy_ssl_certificate.t
new file mode 100644
index 0000000..5a2ce63
--- /dev/null
+++ b/tests/proxy_ssl_certificate.t
@@ -0,0 +1,147 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http proxy module with proxy certificate to ssl backend.
+# The proxy_ssl_certificate and proxy_ssl_password_file directives.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http http_ssl proxy/)
+	->has_daemon('openssl')->plan(5);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        proxy_ssl_session_reuse off;
+
+        location /verify {
+            proxy_pass https://127.0.0.1:8081/;
+            proxy_ssl_certificate 1.example.com.crt;
+            proxy_ssl_certificate_key 1.example.com.key;
+        }
+
+        location /fail {
+            proxy_pass https://127.0.0.1:8081/;
+            proxy_ssl_certificate 2.example.com.crt;
+            proxy_ssl_certificate_key 2.example.com.key;
+        }
+
+        location /encrypted {
+            proxy_pass https://127.0.0.1:8082/;
+            proxy_ssl_certificate 3.example.com.crt;
+            proxy_ssl_certificate_key 3.example.com.key;
+            proxy_ssl_password_file password;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081 ssl;
+        server_name  localhost;
+
+        ssl_certificate 2.example.com.crt;
+        ssl_certificate_key 2.example.com.key;
+
+        ssl_verify_client optional_no_ca;
+        ssl_trusted_certificate 1.example.com.crt;
+
+        location / {
+            add_header X-Verify $ssl_client_verify;
+            add_header X-Name   $ssl_client_s_dn;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8082 ssl;
+        server_name  localhost;
+
+        ssl_certificate 1.example.com.crt;
+        ssl_certificate_key 1.example.com.key;
+
+        ssl_verify_client optional_no_ca;
+        ssl_trusted_certificate 3.example.com.crt;
+
+        location / {
+            add_header X-Verify $ssl_client_verify;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('1.example.com', '2.example.com') {
+	system('openssl req -x509 -new '
+		. "-config $d/openssl.conf -subj /CN=$name/ "
+		. "-out $d/$name.crt -keyout $d/$name.key "
+		. ">>$d/openssl.out 2>&1") == 0
+		or die "Can't create certificate for $name: $!\n";
+}
+
+foreach my $name ('3.example.com') {
+	system("openssl genrsa -out $d/$name.key -passout pass:$name "
+		. "-aes128 2048 >>$d/openssl.out 2>&1") == 0
+		or die "Can't create private key: $!\n";
+	system('openssl req -x509 -new '
+		. "-config $d/openssl.conf -subj /CN=$name/ "
+		. "-out $d/$name.crt "
+		. "-key $d/$name.key -passin pass:$name"
+		. ">>$d/openssl.out 2>&1") == 0
+		or die "Can't create certificate for $name: $!\n";
+}
+
+sleep 1 if $^O eq 'MSWin32';
+
+$t->write_file('password', '3.example.com');
+$t->write_file('index.html', '');
+
+$t->run();
+
+###############################################################################
+
+like(http_get('/verify'), qr/X-Verify: SUCCESS/ms, 'verify certificate');
+like(http_get('/fail'), qr/X-Verify: FAILED/ms, 'fail certificate');
+like(http_get('/encrypted'), qr/X-Verify: SUCCESS/ms, 'with encrypted key');
+
+like(http_get('/verify'), qr!X-Name: /?CN=1.example!, 'valid certificate');
+unlike(http_get('/fail'), qr!X-Name: /?CN=1.example!, 'invalid certificate');
+
+###############################################################################
diff --git a/tests/proxy_ssl_keepalive.t b/tests/proxy_ssl_keepalive.t
new file mode 100644
index 0000000..526c018
--- /dev/null
+++ b/tests/proxy_ssl_keepalive.t
@@ -0,0 +1,106 @@
+#!/usr/bin/perl
+
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+
+# Tests for proxy with keepalive to ssl backend.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require IO::Socket::SSL; };
+plan(skip_all => 'IO::Socket::SSL not installed') if $@;
+
+my $t = Test::Nginx->new()->has(qw/http http_ssl proxy upstream_keepalive/)
+	->has_daemon('openssl')->plan(3)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    upstream u {
+        server 127.0.0.1:8081;
+        keepalive 1;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        proxy_http_version 1.1;
+
+        location / {
+            proxy_pass https://u/;
+            proxy_set_header Connection $args;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081 ssl;
+        server_name  localhost;
+
+        ssl_certificate_key localhost.key;
+        ssl_certificate localhost.crt;
+
+        location / {
+            add_header X-Connection $connection;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('localhost') {
+	system('openssl req -x509 -new '
+		. "-config $d/openssl.conf -subj /CN=$name/ "
+		. "-out $d/$name.crt -keyout $d/$name.key "
+		. ">>$d/openssl.out 2>&1") == 0
+		or die "Can't create certificate for $name: $!\n";
+}
+
+$t->write_file('index.html', 'SEE-THIS');
+$t->run();
+
+###############################################################################
+
+my ($r, $n);
+
+like($r = http_get('/'), qr/200 OK.*SEE-THIS/ms, 'first');
+$r =~ m/X-Connection: (\d+)/; $n = $1;
+like(http_get('/'), qr/X-Connection: $n[^\d].*SEE-THIS/ms, 'second');
+
+http_get('/?close');
+unlike(http_get('/'), qr/X-Connection: $n[^\d]/, 'close');
+
+###############################################################################
diff --git a/tests/proxy_ssl_name.t b/tests/proxy_ssl_name.t
new file mode 100644
index 0000000..00245ba
--- /dev/null
+++ b/tests/proxy_ssl_name.t
@@ -0,0 +1,153 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+# (C) Nginx, Inc.
+
+# Tests for proxy to ssl backend, use of Server Name Indication
+# (proxy_ssl_name, proxy_ssl_server_name directives).
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http http_ssl sni proxy/)
+	->has_daemon('openssl')
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    upstream backend {
+        server 127.0.0.1:8081;
+    }
+
+    upstream backend2 {
+        server 127.0.0.1:8081;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        # session reuse is off, as sessions are cached
+        # for a particular upstream, and resumed session
+        # will use server name previously negotiated
+
+        proxy_ssl_session_reuse off;
+
+        location /1 {
+            proxy_pass https://127.0.0.1:8081/;
+            proxy_ssl_name 1.example.com;
+            proxy_ssl_server_name on;
+        }
+
+        location /2 {
+            proxy_pass https://127.0.0.1:8081/;
+            proxy_ssl_name 2.example.com;
+            proxy_ssl_server_name on;
+
+        }
+
+        location /off {
+            proxy_pass https://backend/;
+            proxy_ssl_server_name off;
+        }
+
+        location /default {
+            proxy_pass https://backend/;
+            proxy_ssl_server_name on;
+        }
+
+        location /default2 {
+            proxy_pass https://backend2/;
+            proxy_ssl_server_name on;
+        }
+
+        location /port {
+            proxy_pass https://backend/;
+            proxy_ssl_server_name on;
+            proxy_ssl_name backend:123;
+        }
+
+        location /ip {
+            proxy_pass https://127.0.0.1:8081/;
+            proxy_ssl_server_name on;
+        }
+
+        location /ip6 {
+            proxy_pass https://[::1]:%%PORT_8081%%/;
+            proxy_ssl_server_name on;
+        }
+    }
+
+    server {
+        listen 127.0.0.1:8081 ssl;
+        listen [::1]:%%PORT_8081%% ssl;
+        server_name 1.example.com;
+
+        ssl_certificate localhost.crt;
+        ssl_certificate_key localhost.key;
+
+        add_header X-Name $ssl_server_name,;
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('localhost') {
+	system('openssl req -x509 -new '
+		. "-config $d/openssl.conf -subj /commonName=$name/ "
+		. "-out $d/$name.crt -keyout $d/$name.key "
+		. ">>$d/openssl.out 2>&1") == 0
+		or die "Can't create certificate for $name: $!\n";
+}
+
+$t->write_file('index.html', '');
+
+$t->try_run('no inet6 support')->plan(9);
+
+###############################################################################
+
+like(http_get('/1'), qr/200 OK.*X-Name: 1.example.com,/ms, 'name 1');
+like(http_get('/2'), qr/200 OK.*X-Name: 2.example.com,/ms, 'name 2');
+like(http_get('/off'), qr/200 OK.*X-Name: ,/ms, 'no name');
+
+like(http_get('/default'), qr/200 OK.*X-Name: backend,/ms, 'default');
+like(http_get('/default2'), qr/200 OK.*X-Name: backend2,/ms, 'default2');
+like(http_get('/default'), qr/200 OK.*X-Name: backend,/ms, 'default again');
+
+like(http_get('/port'), qr/200 OK.*X-Name: backend,/ms, 'no port in name');
+like(http_get('/ip'), qr/200 OK.*X-Name: ,/ms, 'no ip');
+like(http_get('/ip6'), qr/200 OK.*X-Name: ,/ms, 'no ipv6');
+
+###############################################################################
diff --git a/tests/proxy_ssl_verify.t b/tests/proxy_ssl_verify.t
new file mode 100644
index 0000000..5d8a3f5
--- /dev/null
+++ b/tests/proxy_ssl_verify.t
@@ -0,0 +1,168 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+# (C) Nginx, Inc.
+
+# Tests for proxy to ssl backend, backend certificate verification.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http http_ssl proxy/)
+	->has_daemon('openssl')->plan(6)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /verify {
+            proxy_pass https://127.0.0.1:8081/;
+            proxy_ssl_name example.com;
+            proxy_ssl_verify on;
+            proxy_ssl_trusted_certificate 1.example.com.crt;
+        }
+
+        location /wildcard {
+            proxy_pass https://127.0.0.1:8081/;
+            proxy_ssl_name foo.example.com;
+            proxy_ssl_verify on;
+            proxy_ssl_trusted_certificate 1.example.com.crt;
+        }
+
+        location /fail {
+            proxy_pass https://127.0.0.1:8081/;
+            proxy_ssl_name no.match.example.com;
+            proxy_ssl_verify on;
+            proxy_ssl_trusted_certificate 1.example.com.crt;
+        }
+
+        location /cn {
+            proxy_pass https://127.0.0.1:8082/;
+            proxy_ssl_name 2.example.com;
+            proxy_ssl_verify on;
+            proxy_ssl_trusted_certificate 2.example.com.crt;
+        }
+
+        location /cn/fail {
+            proxy_pass https://127.0.0.1:8082/;
+            proxy_ssl_name bad.example.com;
+            proxy_ssl_verify on;
+            proxy_ssl_trusted_certificate 2.example.com.crt;
+        }
+
+        location /untrusted {
+            proxy_pass https://127.0.0.1:8082/;
+            proxy_ssl_verify on;
+            proxy_ssl_trusted_certificate 1.example.com.crt;
+            proxy_ssl_session_reuse off;
+        }
+    }
+
+    server {
+        listen 127.0.0.1:8081 ssl;
+        server_name 1.example.com;
+
+        ssl_certificate 1.example.com.crt;
+        ssl_certificate_key 1.example.com.key;
+
+        add_header X-Name $ssl_server_name;
+    }
+
+    server {
+        listen 127.0.0.1:8082 ssl;
+        server_name 2.example.com;
+
+        ssl_certificate 2.example.com.crt;
+        ssl_certificate_key 2.example.com.key;
+
+        add_header X-Name $ssl_server_name;
+    }
+}
+
+EOF
+
+$t->write_file('openssl.1.example.com.conf', <<EOF);
+[ req ]
+prompt = no
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+x509_extensions = v3_req
+
+[ req_distinguished_name ]
+commonName=no.match.example.com
+
+[ v3_req ]
+subjectAltName = DNS:example.com,DNS:*.example.com
+EOF
+
+$t->write_file('openssl.2.example.com.conf', <<EOF);
+[ req ]
+prompt = no
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+
+[ req_distinguished_name ]
+commonName=2.example.com
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('1.example.com', '2.example.com') {
+	system('openssl req -x509 -new '
+		. "-config $d/openssl.$name.conf "
+		. "-out $d/$name.crt -keyout $d/$name.key "
+		. ">>$d/openssl.out 2>&1") == 0
+		or die "Can't create certificate for $name: $!\n";
+}
+
+sleep 1 if $^O eq 'MSWin32';
+
+$t->write_file('index.html', '');
+
+$t->run();
+
+###############################################################################
+
+# subjectAltName
+
+like(http_get('/verify'), qr/200 OK/ms, 'verify');
+like(http_get('/wildcard'), qr/200 OK/ms, 'verify wildcard');
+like(http_get('/fail'), qr/502 Bad/ms, 'verify fail');
+
+# commonName
+
+like(http_get('/cn'), qr/200 OK/ms, 'verify cn');
+like(http_get('/cn/fail'), qr/502 Bad/ms, 'verify cn fail');
+
+# untrusted
+
+like(http_get('/untrusted'), qr/502 Bad/ms, 'untrusted');
+
+###############################################################################
diff --git a/tests/proxy_store.t b/tests/proxy_store.t
new file mode 100644
index 0000000..eae18cf
--- /dev/null
+++ b/tests/proxy_store.t
@@ -0,0 +1,102 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for proxy_store functionality.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new();
+
+$t->write_file_expand('nginx.conf', <<'EOF')->has(qw/http proxy ssi/)->plan(9);
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /store- {
+            proxy_pass http://127.0.0.1:8080/;
+            proxy_store on;
+        }
+        location /store-string- {
+            proxy_pass http://127.0.0.1:8080/;
+            proxy_store %%TESTDIR%%$uri;
+        }
+        location /ssi.html {
+            ssi on;
+        }
+        location /index-big.html {
+            limit_rate  200k;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('index.html', 'SEE-THIS');
+$t->write_file('index-nostore.html', 'SEE-THIS');
+$t->write_file('index-big.html', 'x' x (100 << 10));
+$t->write_file('ssi.html',
+	'<!--#include virtual="/store-index-big.html?1" -->' .
+	'<!--#include virtual="/store-index-big.html?2" -->'
+);
+$t->run();
+
+###############################################################################
+
+like(http_get('/store-index.html'), qr/SEE-THIS/, 'proxy request');
+ok(-e $t->testdir() . '/store-index.html', 'result stored');
+
+like(http_get('/store-string-index.html'), qr/SEE-THIS/,
+	'proxy string path request');
+ok(-e $t->testdir() . '/store-string-index.html', 'string path result stored');
+
+like(http_head('/store-index-nostore.html'), qr/200 OK/, 'head request');
+ok(!-e $t->testdir() . '/store-index-nostore.html', 'result not stored');
+
+ok(scalar @{[ glob $t->testdir() . '/proxy_temp/*' ]} == 0, 'no temp files');
+
+http_get('/store-index-big.html', aborted => 1, sleep => 0.1);
+
+select(undef, undef, undef, 0.5);
+select(undef, undef, undef, 2.5)
+	if scalar @{[ glob $t->testdir() . '/proxy_temp/*' ]};
+
+ok(scalar @{[ glob $t->testdir() . '/proxy_temp/*' ]} == 0,
+	'no temp files after aborted request');
+
+http_get('/ssi.html', aborted => 1, sleep => 0.1);
+
+select(undef, undef, undef, 0.5);
+select(undef, undef, undef, 2.5)
+	if scalar @{[ glob $t->testdir() . '/proxy_temp/*' ]};
+
+ok(scalar @{[ glob $t->testdir() . '/proxy_temp/*' ]} == 0,
+	'no temp files after aborted ssi');
+
+###############################################################################
diff --git a/tests/proxy_unfinished.t b/tests/proxy_unfinished.t
new file mode 100644
index 0000000..0fbb543
--- /dev/null
+++ b/tests/proxy_unfinished.t
@@ -0,0 +1,260 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for http proxy and prematurely closed connections.  Incomplete
+# responses shouldn't loose information about their incompleteness.
+
+# In particular, incomplete responses:
+#
+# - shouldn't be cached
+#
+# - if a response is sent using chunked transfer encoding,
+#   final chunk shouldn't be sent
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy cache sub/)->plan(15);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    proxy_cache_path   %%TESTDIR%%/cache  levels=1:2
+                       keys_zone=one:1m;
+
+    server {
+        listen       127.0.0.1:8080 sndbuf=32k;
+        server_name  localhost;
+
+        location / {
+            sub_filter foo bar;
+            sub_filter_types *;
+            proxy_pass http://127.0.0.1:8081;
+        }
+
+        location /un/ {
+            sub_filter foo bar;
+            sub_filter_types *;
+            proxy_pass http://127.0.0.1:8081/;
+            proxy_buffering off;
+        }
+
+        location /cache/ {
+            proxy_pass http://127.0.0.1:8081/;
+            proxy_cache one;
+            add_header X-Cache-Status $upstream_cache_status;
+        }
+
+        location /proxy/ {
+            sub_filter foo bar;
+            sub_filter_types *;
+            proxy_pass http://127.0.0.1:8080/local/;
+            proxy_buffer_size 1k;
+            proxy_buffers 4 1k;
+        }
+
+        location /local/ {
+            alias %%TESTDIR%%/;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('big.html', 'X' x (1024 * 1024) . 'finished');
+
+$t->run_daemon(\&http_daemon);
+$t->run()->waitforsocket('127.0.0.1:' . port(8081));
+
+###############################################################################
+
+http_get('/cache/length');
+like(http_get('/cache/length'), qr/MISS/, 'unfinished not cached');
+
+# chunked encoding has enough information to don't cache a response,
+# much like with Content-Length available
+
+http_get('/cache/chunked');
+like(http_get('/cache/chunked'), qr/MISS/, 'unfinished chunked');
+
+# make sure there is no final chunk in unfinished responses
+
+like(http_get_11('/length'), qr/unfinished(?!.*\x0d\x0a?0\x0d\x0a?)/s,
+	'length no final chunk');
+like(http_get_11('/chunked'), qr/unfinished(?!.*\x0d\x0a?0\x0d\x0a?)/s,
+	'chunked no final chunk');
+
+# but there is final chunk in complete responses
+
+like(http_get_11('/length/ok'), qr/finished.*\x0d\x0a?0\x0d\x0a?/s,
+	'length final chunk');
+like(http_get_11('/chunked/ok'), qr/finished.*\x0d\x0a?0\x0d\x0a?/s,
+	'chunked final chunk');
+
+# the same with proxy_buffering set to off
+
+like(http_get_11('/un/length'), qr/unfinished(?!.*\x0d\x0a?0\x0d\x0a?)/s,
+	'unbuffered length no final chunk');
+like(http_get_11('/un/chunked'), qr/unfinished(?!.*\x0d\x0a?0\x0d\x0a?)/s,
+	'unbuffered chunked no final chunk');
+
+like(http_get_11('/un/length/ok'), qr/finished.*\x0d\x0a?0\x0d\x0a?/s,
+	'unbuffered length final chunk');
+like(http_get_11('/un/chunked/ok'), qr/finished.*\x0d\x0a?0\x0d\x0a?/s,
+	'unbuffered chunked final chunk');
+
+# big responses
+
+like(http_get('/big', sleep => 0.1), qr/unfinished/s, 'big unfinished');
+like(http_get('/big/ok', sleep => 0.1), qr/finished/s, 'big finished');
+like(http_get('/un/big', sleep => 0.1), qr/unfinished/s, 'big unfinished un');
+like(http_get('/un/big/ok', sleep => 0.1), qr/finished/s, 'big finished un');
+
+# if disk buffering fails for some reason, there should be
+# no final chunk
+
+chmod(0000, $t->testdir() . '/proxy_temp');
+
+my $r = http_get_11('/proxy/big.html', sleep => 0.5);
+
+SKIP: {
+skip 'finished', 1 if length(Test::Nginx::http_content($r)) == 1024 * 1024 + 8;
+
+like($r, qr/X(?!.*\x0d\x0a?0\x0d\x0a?)/s, 'no proxy temp');
+
+}
+
+chmod(0700, $t->testdir() . '/proxy_temp');
+
+###############################################################################
+
+sub http_get_11 {
+	my ($uri, %extra) = @_;
+
+	return http(
+		"GET $uri HTTP/1.1" . CRLF .
+		"Connection: close" . CRLF .
+		"Host: localhost" . CRLF . CRLF,
+		%extra
+	);
+}
+
+###############################################################################
+
+sub http_daemon {
+	my $server = IO::Socket::INET->new(
+		Proto => 'tcp',
+		LocalAddr => '127.0.0.1:' . port(8081),
+		Listen => 5,
+		Reuse => 1
+	)
+		or die "Can't create listening socket: $!\n";
+
+	local $SIG{PIPE} = 'IGNORE';
+
+	while (my $client = $server->accept()) {
+		$client->autoflush(1);
+
+		my $headers = '';
+		my $uri = '';
+
+		while (<$client>) {
+			$headers .= $_;
+			last if (/^\x0d?\x0a?$/);
+		}
+
+		$uri = $1 if $headers =~ /^\S+\s+([^ ]+)\s+HTTP/i;
+
+		if ($uri eq '/length') {
+			print $client
+				"HTTP/1.1 200 OK" . CRLF .
+				"Content-Length: 100" . CRLF .
+				"Cache-Control: max-age=300" . CRLF .
+				"Connection: close" . CRLF .
+				CRLF .
+				"unfinished" . CRLF;
+
+		} elsif ($uri eq '/length/ok') {
+			print $client
+				"HTTP/1.1 200 OK" . CRLF .
+				"Content-Length: 10" . CRLF .
+				"Cache-Control: max-age=300" . CRLF .
+				"Connection: close" . CRLF .
+				CRLF .
+				"finished" . CRLF;
+
+		} elsif ($uri eq '/big') {
+			print $client
+				"HTTP/1.1 200 OK" . CRLF .
+				"Content-Length: 1000100" . CRLF .
+				"Cache-Control: max-age=300" . CRLF .
+				"Connection: close" . CRLF .
+				CRLF;
+			for (1 .. 10000) {
+				print $client ("X" x 98) . CRLF;
+			}
+			print $client "unfinished" . CRLF;
+
+		} elsif ($uri eq '/big/ok') {
+			print $client
+				"HTTP/1.1 200 OK" . CRLF .
+				"Content-Length: 1000010" . CRLF .
+				"Cache-Control: max-age=300" . CRLF .
+				"Connection: close" . CRLF .
+				CRLF;
+			for (1 .. 10000) {
+				print $client ("X" x 98) . CRLF;
+			}
+			print $client "finished" . CRLF;
+
+		} elsif ($uri eq '/chunked') {
+			print $client
+				"HTTP/1.1 200 OK" . CRLF .
+				"Transfer-Encoding: chunked" . CRLF .
+				"Cache-Control: max-age=300" . CRLF .
+				"Connection: close" . CRLF .
+				CRLF .
+				"ff" . CRLF .
+				"unfinished" . CRLF;
+
+		} elsif ($uri eq '/chunked/ok') {
+			print $client
+				"HTTP/1.1 200 OK" . CRLF .
+				"Transfer-Encoding: chunked" . CRLF .
+				"Cache-Control: max-age=300" . CRLF .
+				"Connection: close" . CRLF .
+				CRLF .
+				"a" . CRLF .
+				"finished" . CRLF .
+				CRLF . "0" . CRLF . CRLF;
+		}
+	}
+}
+
+###############################################################################
diff --git a/tests/proxy_unix.t b/tests/proxy_unix.t
new file mode 100644
index 0000000..bf8d4b6
--- /dev/null
+++ b/tests/proxy_unix.t
@@ -0,0 +1,155 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http proxy module with unix socket.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require IO::Socket::UNIX; };
+plan(skip_all => 'IO::Socket::UNIX not installed') if $@;
+
+my $t = Test::Nginx->new()->has(qw/http proxy unix/)->plan(5);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    upstream u {
+        server unix:%%TESTDIR%%/unix.sock;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            proxy_pass http://unix:%%TESTDIR%%/unix.sock;
+            proxy_read_timeout 1s;
+            proxy_connect_timeout 2s;
+        }
+
+        location /var {
+            proxy_pass http://$arg_b;
+            proxy_read_timeout 1s;
+        }
+
+        location /u {
+            proxy_pass http://u;
+            proxy_read_timeout 1s;
+        }
+    }
+}
+
+EOF
+
+my $path = $t->testdir() . '/unix.sock';
+
+$t->run_daemon(\&http_daemon, $path);
+$t->run();
+
+# wait for unix socket to appear
+
+for (1 .. 50) {
+	last if -S $path;
+	select undef, undef, undef, 0.1;
+}
+
+###############################################################################
+
+like(http_get('/'), qr/SEE-THIS/, 'proxy request');
+like(http_get('/multi'), qr/AND-THIS/, 'proxy request with multiple packets');
+
+unlike(http_head('/'), qr/SEE-THIS/, 'proxy head request');
+
+like(http_get("/var?b=unix:$path:/"), qr/SEE-THIS/, 'proxy with variables');
+
+like(http_get('/u'), qr/SEE-THIS/, 'proxy implicit upstream');
+
+###############################################################################
+
+sub http_daemon {
+	my $server = IO::Socket::UNIX->new(
+		Proto => 'tcp',
+		Local => shift,
+		Listen => 5,
+		Reuse => 1
+	)
+		or die "Can't create listening socket: $!\n";
+
+	local $SIG{PIPE} = 'IGNORE';
+
+	while (my $client = $server->accept()) {
+		$client->autoflush(1);
+
+		my $headers = '';
+		my $uri = '';
+
+		while (<$client>) {
+			$headers .= $_;
+			last if (/^\x0d?\x0a?$/);
+		}
+
+		$uri = $1 if $headers =~ /^\S+\s+([^ ]+)\s+HTTP/i;
+
+		if (grep { $uri eq $_ } ('/', '/u')) {
+			print $client <<'EOF';
+HTTP/1.1 200 OK
+Connection: close
+
+EOF
+			print $client "TEST-OK-IF-YOU-SEE-THIS"
+				unless $headers =~ /^HEAD/i;
+
+		} elsif ($uri eq '/multi') {
+
+			print $client <<"EOF";
+HTTP/1.1 200 OK
+Connection: close
+
+TEST-OK-IF-YOU-SEE-THIS
+EOF
+
+			select undef, undef, undef, 0.1;
+			print $client 'AND-THIS';
+
+		} else {
+
+			print $client <<"EOF";
+HTTP/1.1 404 Not Found
+Connection: close
+
+Oops, '$uri' not found
+EOF
+		}
+
+		close $client;
+	}
+}
+
+###############################################################################
diff --git a/tests/proxy_upgrade.t b/tests/proxy_upgrade.t
new file mode 100644
index 0000000..83cb153
--- /dev/null
+++ b/tests/proxy_upgrade.t
@@ -0,0 +1,344 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for http proxy upgrade support.
+# In contrast to proxy_websocket.t, this test doesn't try to use binary
+# WebSocket protocol, but uses simple plain text protocol instead.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use IO::Poll;
+use IO::Select;
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy ssi/)
+	->write_file_expand('nginx.conf', <<'EOF')->plan(31);
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    log_format test "$bytes_sent $body_bytes_sent $sent_http_connection";
+    access_log %%TESTDIR%%/cc.log test;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            proxy_pass    http://127.0.0.1:8081;
+            proxy_http_version 1.1;
+            proxy_set_header Upgrade $http_upgrade;
+            proxy_set_header Connection "Upgrade";
+            proxy_read_timeout 2s;
+            send_timeout 2s;
+        }
+
+        location /ssi.html {
+            ssi on;
+        }
+    }
+}
+
+EOF
+
+my $d = $t->testdir();
+
+$t->write_file('ssi.html', '<!--#include virtual="/upgrade" --> SEE-THIS');
+
+$t->run_daemon(\&upgrade_fake_daemon);
+$t->run();
+
+$t->waitforsocket('127.0.0.1:' . port(8081))
+	or die "Can't start test backend";
+
+###############################################################################
+
+# establish connection
+
+my @r;
+my $s = upgrade_connect();
+ok($s, "handshake");
+
+SKIP: {
+	skip "handshake failed", 22 unless $s;
+
+	# send a frame
+
+	upgrade_write($s, 'foo');
+	is(upgrade_read($s), 'bar', "upgrade response");
+
+	# send some big frame
+
+	upgrade_write($s, 'foo' x 16384);
+	like(upgrade_read($s), qr/^(bar){16384}$/, "upgrade big response");
+
+	# send multiple frames
+
+	for my $i (1 .. 10) {
+		upgrade_write($s, ('foo' x 16384) . $i, continue => 1);
+		upgrade_write($s, 'bazz' . $i, continue => $i != 10);
+	}
+
+	for my $i (1 .. 10) {
+		like(upgrade_read($s), qr/^(bar){16384}\d+$/, "upgrade $i");
+		is(upgrade_read($s), 'bazz' . $i, "upgrade small $i");
+	}
+}
+
+push @r, $s ? ${*$s}->{_upgrade_private}->{r} : 'failed';
+undef $s;
+
+# establish connection with some pipelined data
+# and make sure they are correctly passed upstream
+
+$s = upgrade_connect(message => "foo");
+ok($s, "handshake pipelined");
+
+SKIP: {
+	skip "handshake failed", 2 unless $s;
+
+	is(upgrade_read($s), "bar", "response pipelined");
+
+	upgrade_write($s, "foo");
+	is(upgrade_read($s), "bar", "next to pipelined");
+}
+
+push @r, $s ? ${*$s}->{_upgrade_private}->{r} : 'failed';
+undef $s;
+
+# connection should not be upgraded unless upgrade was actually
+# requested and allowed by configuration
+
+$s = upgrade_connect(noheader => 1);
+ok(!$s, "handshake noupgrade");
+
+# connection upgrade in subrequests shouldn't cause a segfault
+
+$s = upgrade_connect(uri => '/ssi.html');
+ok(!$s, "handshake in subrequests");
+
+# bytes sent on upgraded connection
+# verify with 1) data actually read by client, 2) expected data from backend
+
+$t->stop();
+
+open my $f, '<', "$d/cc.log" or die "Can't open cc.log: $!";
+
+is($f->getline(), shift (@r) . " 540793 upgrade\n", 'log - bytes');
+is($f->getline(), shift (@r) . " 22 upgrade\n", 'log - bytes pipelined');
+like($f->getline(), qr/\d+ 0 /, 'log - bytes noupgrade');
+
+###############################################################################
+
+sub upgrade_connect {
+	my (%opts) = @_;
+
+	my $s = IO::Socket::INET->new(
+		Proto => 'tcp',
+		PeerAddr => '127.0.0.1:' . port(8080),
+	)
+		or die "Can't connect to nginx: $!\n";
+
+	# send request, $h->to_string
+
+	my $uri = $opts{uri} || '/';
+
+	my $buf = "GET $uri HTTP/1.1" . CRLF
+		. "Host: localhost" . CRLF
+		. ($opts{noheader} ? '' : "Upgrade: foo" . CRLF)
+		. "Connection: Upgrade" . CRLF . CRLF;
+
+	$buf .= $opts{message} . CRLF . 'FIN' if defined $opts{message};
+
+	local $SIG{PIPE} = 'IGNORE';
+
+	log_out($buf);
+	$s->syswrite($buf);
+
+	# read response
+
+	my $got = '';
+	$buf = '';
+
+	while (1) {
+		$buf = upgrade_getline($s);
+		last unless defined $buf and length $buf;
+		log_in($buf);
+		$got .= $buf;
+		last if $got =~ /\x0d?\x0a\x0d?\x0a$/;
+	}
+
+	# parse server response
+
+	return if $got !~ m!HTTP/1.1 101!;
+
+	# make sure next line is "handshaked"
+
+	$buf = upgrade_read($s);
+
+	return if !defined $buf or $buf ne 'handshaked';
+	return $s;
+}
+
+sub upgrade_getline {
+	my ($s) = @_;
+	my ($h, $buf);
+
+	${*$s}->{_upgrade_private} ||= { b => '', r => 0 };
+	$h = ${*$s}->{_upgrade_private};
+
+	if ($h->{b} =~ /^(.*?\x0a)(.*)/ms) {
+		$h->{b} = $2;
+		return $1;
+	}
+
+	$s->blocking(0);
+	while (IO::Select->new($s)->can_read(3)) {
+		my $n = $s->sysread($buf, 1024);
+		last unless $n;
+
+		$h->{b} .= $buf;
+		$h->{r} += $n;
+
+		if ($h->{b} =~ /^(.*?\x0a)(.*)/ms) {
+			$h->{b} = $2;
+			return $1;
+		}
+	};
+}
+
+sub upgrade_write {
+	my ($s, $message, %extra) = @_;
+
+	$message = $message . CRLF;
+	$message = $message . 'FIN' unless $extra{continue};
+
+	local $SIG{PIPE} = 'IGNORE';
+
+	$s->blocking(0);
+	while (IO::Select->new($s)->can_write(1.5)) {
+		my $n = $s->syswrite($message);
+		last unless $n;
+		$message = substr($message, $n);
+		last unless length $message;
+	}
+
+	if (length $message) {
+		$s->close();
+	}
+}
+
+sub upgrade_read {
+	my ($s) = @_;
+	my $m = upgrade_getline($s);
+	$m =~ s/\x0d?\x0a// if defined $m;
+	log_in($m);
+	return $m;
+}
+
+###############################################################################
+
+sub upgrade_fake_daemon {
+	my $server = IO::Socket::INET->new(
+		Proto => 'tcp',
+		LocalAddr => '127.0.0.1:' . port(8081),
+		Listen => 5,
+		Reuse => 1
+	)
+		or die "Can't create listening socket: $!\n";
+
+	while (my $client = $server->accept()) {
+		upgrade_handle_client($client);
+	}
+}
+
+sub upgrade_handle_client {
+	my ($client) = @_;
+
+	$client->autoflush(1);
+	$client->blocking(0);
+
+	my $poll = IO::Poll->new;
+
+	my $handshake = 1;
+	my $unfinished = '';
+	my $buffer = '';
+	my $n;
+
+	log2c("(new connection $client)");
+
+	while (1) {
+		$poll->mask($client => ($buffer ? POLLIN|POLLOUT : POLLIN));
+		my $p = $poll->poll(0.5);
+		log2c("(poll $p)");
+
+		foreach my $reader ($poll->handles(POLLIN)) {
+			$n = $client->sysread(my $chunk, 65536);
+			return unless $n;
+
+			log2i($chunk);
+
+			if ($handshake) {
+				$buffer .= $chunk;
+				next unless $buffer =~ /\x0d?\x0a\x0d?\x0a$/;
+
+				log2c("(handshake done)");
+
+				$handshake = 0;
+				$buffer = 'HTTP/1.1 101 Switching' . CRLF
+					. 'Upgrade: foo' . CRLF
+					. 'Connection: Upgrade' . CRLF . CRLF
+					. 'handshaked' . CRLF;
+
+				log2o($buffer);
+
+				next;
+			}
+
+			$unfinished .= $chunk;
+
+			if ($unfinished =~ m/\x0d?\x0aFIN\z/) {
+				$unfinished =~ s/FIN\z//;
+				$unfinished =~ s/foo/bar/g;
+				log2o($unfinished);
+				$buffer .= $unfinished;
+				$unfinished = '';
+			}
+		}
+
+		foreach my $writer ($poll->handles(POLLOUT)) {
+			next unless length $buffer;
+			$n = $writer->syswrite($buffer);
+			substr $buffer, 0, $n, '';
+		}
+	}
+}
+
+sub log2i { Test::Nginx::log_core('|| <<', @_); }
+sub log2o { Test::Nginx::log_core('|| >>', @_); }
+sub log2c { Test::Nginx::log_core('||', @_); }
+
+###############################################################################
diff --git a/tests/proxy_upstream_cookie.t b/tests/proxy_upstream_cookie.t
new file mode 100644
index 0000000..4ae9bd8
--- /dev/null
+++ b/tests/proxy_upstream_cookie.t
@@ -0,0 +1,119 @@
+#!/usr/bin/perl
+
+# (C) Nginx, Inc.
+
+# Tests for the $upstream_cookie_<name> variables.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy rewrite/)->plan(19);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            add_header X-Upstream-Cookie $upstream_cookie_tc;
+            proxy_pass http://127.0.0.1:8081;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location / {
+            add_header Set-Cookie $http_x_test_cookie;
+            return 204;
+        }
+
+        # embed multiline cookie with add_header
+        location /mcomma {
+            add_header Set-Cookie "tc=one,two,three";
+            add_header Set-Cookie "tc=four,five,six";
+            return 204;
+        }
+        location /msemicolon {
+            add_header Set-Cookie "tc=one;two;three";
+            add_header Set-Cookie "tc=four;five;six";
+            return 204;
+        }
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+is(http_get_uc('tc='), undef, 'value_none');
+is(http_get_uc('tc=;'), undef, 'semicolon');
+is(http_get_uc('tc= ;'), undef, 'space_semicolon');
+is(http_get_uc('tc =   ; Domain=example.com;'), undef, 'space_semicolon_more');
+
+is(http_get_uc('tc=x'), 'x', 'onechar');
+is(http_get_uc('tc=,'), ',', 'comma');
+is(http_get_uc('tc	=	content     ;'), undef, 'tabbed');
+is(http_get_uc('tc="content"'), '"content"', 'dquoted');
+is(http_get_uc('tc=content'), 'content', 'normal');
+is(http_get_uc('tc=con  tent; Domain=example.com'), 'con  tent',
+	'internal_space');
+is(http_get_uc('tc = content'), 'content', 'separated');
+
+is(http_get_uc('tc=1.2.3'), '1.2.3', 'dots');
+is(http_get_uc('tc==abc'), '=abc', 'deq');
+is(http_get_uc('tc==;abc'), '=', 'deqsemi');
+is(http_get_uc('=tc=content'), undef, 'eqfirst');
+is(http_get_uc('tc=first,tc=second'), 'first,tc=second', 'two_comma');
+is(http_get_uc('tc=first;tc=second'), 'first', 'two_semicolon');
+
+like(http_get('/mcomma'), qr/^X-Upstream-Cookie: one,two,three\x0d?$/mi,
+	'multiline comma');
+like(http_get('/msemicolon'), qr/^X-Upstream-Cookie: one\x0d?$/mi,
+	'multiline semicolon');
+
+###############################################################################
+
+sub http_get_uc {
+	my ($cookie) = @_;
+
+	http(<<EOF) =~ qr/^X-Upstream-Cookie:\s(.+?)\x0d?$/mi;
+GET / HTTP/1.1
+Host: localhost
+Connection: close
+X-Test-Cookie: $cookie
+
+EOF
+
+	return $1;
+}
+
+###############################################################################
diff --git a/tests/proxy_variables.t b/tests/proxy_variables.t
new file mode 100644
index 0000000..f275fd9
--- /dev/null
+++ b/tests/proxy_variables.t
@@ -0,0 +1,134 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http proxy module with upstream variables.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy/)->plan(4)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    log_format u $uri:$upstream_response_length:$upstream_bytes_received:
+                 $upstream_bytes_sent:$upstream_http_x_len;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            proxy_pass http://127.0.0.1:8081;
+            access_log %%TESTDIR%%/test.log u;
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&http_daemon, port(8081));
+$t->run();
+
+$t->waitforsocket('127.0.0.1:' . port(8081));
+
+###############################################################################
+
+my $r;
+
+my ($l1) = ($r = http_get('/')) =~ /X-Len: (\d+)/;
+like($r, qr/SEE-THIS/, 'proxy request');
+
+my ($l2) = ($r = http_get('/multi')) =~ /X-Len: (\d+)/;
+like($r, qr/AND-THIS/, 'proxy request with multiple packets');
+
+$t->stop();
+
+my $f = $t->read_file('test.log');
+Test::Nginx::log_core('||', $f);
+
+like($f, qr!^/:23:68:$l1:$l1!m, 'log - response length');
+like($f, qr!^/multi:32:77:$l2:$l2!m, 'log - response length - multi packets');
+
+###############################################################################
+
+sub http_daemon {
+	my ($port) = @_;
+	my $server = IO::Socket::INET->new(
+		Proto => 'tcp',
+		LocalHost => '127.0.0.1',
+		LocalPort => $port,
+		Listen => 5,
+		Reuse => 1
+	)
+		or die "Can't create listening socket: $!\n";
+
+	local $SIG{PIPE} = 'IGNORE';
+
+	while (my $client = $server->accept()) {
+		$client->autoflush(1);
+
+		my $headers = '';
+		my $uri = '';
+
+		while (<$client>) {
+			$headers .= $_;
+			last if (/^\x0d?\x0a?$/);
+		}
+
+		$uri = $1 if $headers =~ /^\S+\s+([^ ]+)\s+HTTP/i;
+		my $len = length($headers);
+
+		if ($uri eq '/') {
+			print $client <<"EOF";
+HTTP/1.1 200 OK
+Connection: close
+X-Len: $len
+
+EOF
+			print $client "TEST-OK-IF-YOU-SEE-THIS"
+				unless $headers =~ /^HEAD/i;
+
+		} elsif ($uri eq '/multi') {
+
+			print $client <<"EOF";
+HTTP/1.1 200 OK
+Connection: close
+X-Len: $len
+
+TEST-OK-IF-YOU-SEE-THIS
+EOF
+
+			select undef, undef, undef, 0.1;
+			print $client 'AND-THIS';
+		}
+
+		close $client;
+	}
+}
+
+###############################################################################
diff --git a/tests/proxy_websocket.t b/tests/proxy_websocket.t
new file mode 100644
index 0000000..e559bb1
--- /dev/null
+++ b/tests/proxy_websocket.t
@@ -0,0 +1,302 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for http proxy websockets support.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use IO::Poll;
+use IO::Select;
+use IO::Socket::INET;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval {
+	require Protocol::WebSocket::Handshake::Client;
+	require Protocol::WebSocket::Handshake::Server;
+	require Protocol::WebSocket::Frame;
+};
+
+plan(skip_all => 'Protocol::WebSocket not installed') if $@;
+
+my $t = Test::Nginx->new()->has(qw/http proxy/)
+	->write_file_expand('nginx.conf', <<'EOF')->plan(26);
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            proxy_pass    http://127.0.0.1:8081;
+            proxy_http_version 1.1;
+            proxy_set_header Upgrade $http_upgrade;
+            proxy_set_header Connection "Upgrade";
+            proxy_read_timeout 2s;
+            send_timeout 2s;
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&websocket_fake_daemon);
+$t->run();
+
+$t->waitforsocket('127.0.0.1:' . port(8081))
+	or die "Can't start test backend";
+
+###############################################################################
+
+# establish websocket connection
+
+my $s = websocket_connect();
+ok($s, "websocket handshake");
+
+SKIP: {
+	skip "handshake failed", 22 unless $s;
+
+	# send a frame
+
+	websocket_write($s, 'foo');
+	is(websocket_read($s), 'bar', "websocket response");
+
+	# send some big frame
+
+	websocket_write($s, 'foo' x 16384);
+	like(websocket_read($s), qr/^(bar){16384}$/, "websocket big response");
+
+	# send multiple frames
+
+	for my $i (1 .. 10) {
+		websocket_write($s, ('foo' x 16384) . $i);
+		websocket_write($s, 'bazz' . $i);
+	}
+
+	for my $i (1 .. 10) {
+		like(websocket_read($s), qr/^(bar){16384}\d+$/, "websocket $i");
+		is(websocket_read($s), 'bazz' . $i, "websocket small $i");
+	}
+}
+
+# establish websocket connection with some pipelined data
+# and make sure they are correctly passed upstream
+
+undef $s;
+$s = websocket_connect("foo");
+ok($s, "handshake pipelined");
+
+SKIP: {
+	skip "handshake failed", 2 unless $s;
+
+	is(websocket_read($s), "bar", "response pipelined");
+
+	websocket_write($s, "foo");
+	is(websocket_read($s), "bar", "next to pipelined");
+}
+
+###############################################################################
+
+sub websocket_connect {
+	my ($message) = @_;
+
+	my $s = IO::Socket::INET->new(
+		Proto => 'tcp',
+		PeerAddr => '127.0.0.1:' . port(8080)
+	)
+		or die "Can't connect to nginx: $!\n";
+
+	my $h = Protocol::WebSocket::Handshake::Client->new(
+		url => 'ws://localhost');
+
+	# send request, $h->to_string
+
+	my $buf = $h->to_string;
+	$buf .= Protocol::WebSocket::Frame->new($message)->to_bytes
+		if $message;
+
+	local $SIG{PIPE} = 'IGNORE';
+
+	log_out($buf);
+	$s->syswrite($buf);
+
+	# read response
+
+	my $got = '';
+	$buf = '';
+
+	$s->blocking(0);
+	while (IO::Select->new($s)->can_read(1.5)) {
+		my $n = $s->sysread($buf, 1024);
+		last unless $n;
+		log_in($buf);
+		$got .= $buf;
+		last if $got =~ /\x0d?\x0a\x0d?\x0a$/;
+	}
+
+	# parse server response
+
+	$h->parse($got);
+
+	# store the rest for later websocket_read()
+	# see websocket_read() for details
+
+	${*$s}->{_websocket_frame} ||= Protocol::WebSocket::Frame->new();
+	${*$s}->{_websocket_frame}->append($got);
+
+	return $s if $h->is_done;
+}
+
+sub websocket_write {
+	my ($s, $message) = @_;
+	my $frame = Protocol::WebSocket::Frame->new($message);
+
+	local $SIG{PIPE} = 'IGNORE';
+	$s->blocking(1);
+
+	log_out($frame->to_bytes);
+	$s->syswrite($frame->to_bytes);
+}
+
+sub websocket_read {
+	my ($s) = @_;
+	my ($buf, $got);
+
+	# store frame object in socket itself to simplify things
+	# this works as $s is IO::Handle, see man IO::Handle
+
+	${*$s}->{_websocket_frame} ||= Protocol::WebSocket::Frame->new();
+	my $frame = ${*$s}->{_websocket_frame};
+
+	$s->blocking(0);
+	$got = $frame->next();
+	return $got if defined $got;
+
+	while (IO::Select->new($s)->can_read(1.5)) {
+		my $n = $s->sysread($buf, 65536);
+		return $got unless $n;
+		log_in($buf);
+		$frame->append($buf);
+		$got = $frame->next();
+		return $got if defined $got;
+	}
+}
+
+###############################################################################
+
+sub websocket_fake_daemon {
+	my $server = IO::Socket::INET->new(
+		Proto => 'tcp',
+		LocalAddr => '127.0.0.1:' . port(8081),
+		Listen => 5,
+		Reuse => 1
+	)
+		or die "Can't create listening socket: $!\n";
+
+	while (my $client = $server->accept()) {
+		websocket_handle_client($client);
+	}
+}
+
+sub websocket_handle_client {
+	my ($client) = @_;
+
+	$client->autoflush(1);
+	$client->blocking(0);
+
+	my $poll = IO::Poll->new;
+
+	my $hs = Protocol::WebSocket::Handshake::Server->new;
+	my $frame = Protocol::WebSocket::Frame->new;
+	my $buffer = '';
+	my $closed;
+	my $n;
+
+	log2c("(new connection $client)");
+
+	while (1) {
+		$poll->mask($client => ($buffer ? POLLIN|POLLOUT : POLLIN));
+		my $p = $poll->poll(0.5);
+		log2c("(poll $p)");
+
+		foreach ($poll->handles(POLLIN)) {
+			$n = $client->sysread(my $chunk, 65536);
+			return unless $n;
+
+			log2i($chunk);
+
+			if (!$hs->is_done) {
+				unless (defined $hs->parse($chunk)) {
+					log2c("(error: " . $hs->error . ")");
+					return;
+				}
+
+				if ($hs->is_done) {
+					$buffer = $hs->to_string;
+					log2o($buffer);
+				}
+
+				log2c("(parse: $chunk)");
+			}
+
+			$frame->append($chunk);
+
+			while (defined(my $message = $frame->next)) {
+				my $f;
+
+				if ($frame->is_close) {
+					log2c("(close frame)");
+					$closed = 1;
+					$f = $frame->new(type => 'close')
+						->to_bytes;
+				} else {
+					$message =~ s/foo/bar/g;
+					$f = $frame->new($message)->to_bytes;
+				}
+
+				log2o($f);
+				$buffer .= $f;
+			}
+		}
+
+		foreach my $writer ($poll->handles(POLLOUT)) {
+			next unless length $buffer;
+			$n = $writer->syswrite($buffer);
+			substr $buffer, 0, $n, '';
+		}
+
+		if ($closed && length $buffer == 0) {
+			log2c("(closed)");
+			return;
+		}
+	}
+}
+
+sub log2i { Test::Nginx::log_core('|| <<', @_); }
+sub log2o { Test::Nginx::log_core('|| >>', @_); }
+sub log2c { Test::Nginx::log_core('||', @_); }
+
+###############################################################################
diff --git a/tests/proxy_xar.t b/tests/proxy_xar.t
new file mode 100644
index 0000000..490eda6
--- /dev/null
+++ b/tests/proxy_xar.t
@@ -0,0 +1,124 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for proxy X-Accel-Redirect functionality.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy rewrite/)->plan(16);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        # catch safe and unhandled unsafe URIs,
+        # bypassed with redirect to named location
+        if ($upstream_http_x_accel_redirect) {
+            return 200 "xar: $upstream_http_x_accel_redirect uri: $uri
+                        method: $request_method";
+        }
+
+        location /proxy {
+            proxy_pass http://127.0.0.1:8080/return-xar;
+        }
+        location /return-xar {
+            add_header  X-Accel-Redirect     $arg_xar;
+
+            # this headers will be preserved on
+            # X-Accel-Redirect
+
+            add_header  Content-Type         text/blah;
+            add_header  Set-Cookie           blah=blah;
+            add_header  Content-Disposition  attachment;
+            add_header  Cache-Control        no-cache;
+            add_header  Expires              fake;
+            add_header  Accept-Ranges        parrots;
+
+            # others won't be
+            add_header  Something            other;
+
+            return 204;
+        }
+        location @named {
+            return 200 "named xar: $upstream_http_x_accel_redirect uri: $uri";
+        }
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+my $r = http_get('/proxy?xar=/index.html');
+like($r, qr/xar: \/index.html uri: \/index.html/, 'X-Accel-Redirect works');
+like($r, qr/^Content-Type: text\/blah/m, 'Content-Type preserved');
+like($r, qr/^Set-Cookie: blah=blah/m, 'Set-Cookie preserved');
+like($r, qr/^Content-Disposition: attachment/m, 'Content-Disposition preserved');
+like($r, qr/^Cache-Control: no-cache/m, 'Cache-Control preserved');
+like($r, qr/^Expires: fake/m, 'Expires preserved');
+like($r, qr/^Accept-Ranges: parrots/m, 'Accept-Ranges preserved');
+unlike($r, qr/^Something/m, 'other headers stripped');
+
+like(http_post('/proxy?xar=/index.html'), qr/method: GET/,
+	'X-Accel-Redirect method name');
+
+# escaped characters
+
+like(http_get('/proxy?xar=/foo?bar'), qr/200 OK.*xar: \/foo\?bar/s,
+	'X-Accel-Redirect value unchanged');
+unlike(http_get('/proxy?xar=..'), qr/200 OK/,
+	'X-Accel-Redirect unsafe dotdot');
+unlike(http_get('/proxy?xar=../foo'), qr/200 OK/,
+	'X-Accel-Redirect unsafe dotdotsep');
+unlike(http_get('/proxy?xar=/foo/..'), qr/200 OK/,
+	'X-Accel-Redirect unsafe sepdotdot');
+unlike(http_get('/proxy?xar=/foo/.%2e'), qr/200 OK/,
+	'X-Accel-Redirect unsafe unescaped');
+like(http_get('/proxy?xar=/foo%20bar'), qr/uri: \/foo bar/,
+	'X-Accel-Redirect unescaped');
+
+like(http_get('/proxy?xar=@named'),
+	qr!200 OK.*named xar: \@named uri: /proxy!s, 'in named location');
+
+###############################################################################
+
+sub http_post {
+	my ($url) = @_;
+	http(<<EOF);
+POST $url HTTP/1.0
+Host: localhost
+
+EOF
+}
+
+###############################################################################
diff --git a/tests/random_index.t b/tests/random_index.t
new file mode 100644
index 0000000..160ea3b
--- /dev/null
+++ b/tests/random_index.t
@@ -0,0 +1,64 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for random index module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http random_index symlink/)->plan(1)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            random_index on;
+        }
+    }
+}
+
+EOF
+
+my $d = $t->testdir();
+
+mkdir("$d/x");
+mkdir("$d/x/test-dir");
+symlink("$d/x/test-dir", "$d/x/test-dir-link");
+
+$t->write_file('test-file', 'RIGHT');
+symlink("$d/test-file", "$d/x/test-file-link");
+
+$t->run();
+
+###############################################################################
+
+like(http_get('/x/'), qr/RIGHT/s, 'file');
+
+###############################################################################
diff --git a/tests/range.t b/tests/range.t
new file mode 100644
index 0000000..1a349cb
--- /dev/null
+++ b/tests/range.t
@@ -0,0 +1,170 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for range filter module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http charset/)->plan(41);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    charset_map B A {
+        58 59; # X -> Y
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /t2.html {
+            charset A;
+            source_charset B;
+        }
+
+        location /t3.html {
+            max_ranges 2;
+        }
+
+        location /t4.html {
+            max_ranges 0;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('t1.html',
+	join('', map { sprintf "X%03dXXXXXX", $_ } (0 .. 99)));
+$t->write_file('t2.html',
+	join('', map { sprintf "X%03dXXXXXX", $_ } (0 .. 99)));
+$t->write_file('t3.html',
+	join('', map { sprintf "X%03dXXXXXX", $_ } (0 .. 99)));
+$t->write_file('t4.html',
+	join('', map { sprintf "X%03dXXXXXX", $_ } (0 .. 99)));
+$t->run();
+
+###############################################################################
+
+my $t1;
+
+$t1 = http_get_range('/t1.html', 'Range: bytes=0-8');
+like($t1, qr/ 206 /, 'range request - 206 partial reply');
+like($t1, qr/Content-Length: 9/, 'range request - correct length');
+like($t1, qr/Content-Range: bytes 0-8\/1000/, 'range request - content range');
+like($t1, qr/^X000XXXXX$/m, 'range request - correct content');
+
+$t1 = http_get_range('/t1.html', 'Range: bytes=-10');
+like($t1, qr/ 206 /, 'final bytes - 206 partial reply');
+like($t1, qr/Content-Length: 10/, 'final bytes - content length');
+like($t1, qr/Content-Range: bytes 990-999\/1000/,
+	'final bytes - content range');
+like($t1, qr/^X099XXXXXX$/m, 'final bytes - correct content');
+
+$t1 = http_get_range('/t1.html', 'Range: bytes=990-');
+like($t1, qr/ 206 /, 'final bytes explicit - 206 partial reply');
+like($t1, qr/Content-Length: 10/, 'final bytes explicit - content length');
+like($t1, qr/Content-Range: bytes 990-999\/1000/,
+	'final bytes explicit - content range');
+like($t1, qr/^X099XXXXXX$/m, 'final bytes explicit - correct content');
+
+$t1 = http_get_range('/t1.html', 'Range: bytes=990-1990');
+like($t1, qr/ 206 /, 'more than length - 206 partial reply');
+like($t1, qr/Content-Length: 10/, 'more than length - content length');
+like($t1, qr/Content-Range: bytes 990-999\/1000/,
+	'more than length - content range');
+like($t1, qr/^X099XXXXXX$/m, 'more than length - correct content');
+
+$t1 = http_get_range('/t2.html', 'Range: bytes=990-1990');
+like($t1, qr/ 206 /, 'recoded - 206 partial reply');
+like($t1, qr/Content-Length: 10/, 'recoded - content length');
+like($t1, qr/Content-Range: bytes 990-999\/1000/, 'recoded - content range');
+like($t1, qr/^Y099YYYYYY$/m, 'recoded - correct content');
+
+$t1 = http_get_range('/t1.html', 'Range: bytes=0-9, -10, 10-19');
+like($t1, qr/ 206 /, 'multipart - 206 partial reply');
+like($t1, qr/Content-Type: multipart\/byteranges; boundary=/,
+	'multipart - content type');
+like($t1, qr/X000XXXXXX/m, 'multipart - content 0-9');
+like($t1, qr/^X099XXXXXX\x0d?$/m, 'multipart - content -10 aka 990-999');
+like($t1, qr/X001XXXXXX\x0d?$/m, 'multipart - content 10-19');
+
+$t1 = http_get_range('/t1.html', 'Range: bytes=0-9, -10, 100000-, 10-19');
+like($t1, qr/ 206 /, 'multipart big - 206 partial reply');
+like($t1, qr/Content-Type: multipart\/byteranges; boundary=/,
+	'multipart big - content type');
+like($t1, qr/X000XXXXXX/m, 'multipart big - content 0-9');
+like($t1, qr/^X099XXXXXX\x0d?$/m, 'multipart big - content -10 aka 990-999');
+like($t1, qr/X001XXXXXX\x0d?$/m, 'multipart big - content 10-19');
+
+like(http_get_range('/t1.html', 'Range: bytes=100000-'), qr/ 416 /,
+	'not satisfiable - too big first byte pos');
+like(http_get_range('/t1.html', 'Range: bytes=alpha'), qr/ 416 /,
+	'not satisfiable - alpha in first byte pos');
+like(http_get_range('/t1.html', 'Range: bytes=10-alpha'), qr/ 416 /,
+	'not satisfiable - alpha in last byte pos');
+like(http_get_range('/t1.html', 'Range: bytes=10'), qr/ 416 /,
+	'not satisfiable - no hyphen');
+like(http_get_range('/t1.html', 'Range: bytes=10-11 12-'), qr/ 416 /,
+	'not satisfiable - no comma');
+
+# last-byte-pos is taken to be equal to one less than the current length
+# of the entity-body in bytes -- rfc2616 sec 14.35.
+
+like(http_get_range('/t1.html', 'Range: bytes=0-10001'), qr/ 206 /,
+	'satisfiable - last byte pos adjusted');
+
+# total size of all ranges is greater than source response size
+
+like(http_get_range('/t1.html', 'Range: bytes=0-10001, 0-0'), qr/ 200 /,
+	'not satisfiable - malicious byte ranges');
+
+like(http_get_range('/t3.html', 'Range: bytes=0-9, -10'), qr/ 206 /,
+	'max_ranges not reached');
+like(http_get_range('/t3.html', 'Range: bytes=0-9, -10, 10000-'), qr/ 206 /,
+	'max_ranges not reached bad range');
+unlike(http_get_range('/t3.html', 'Range: bytes=0-9, -10, 10-19'),
+	qr/ 206 /, 'max_ranges reached');
+unlike(http_get_range('/t4.html', 'Range: bytes=0-9'), qr/ 206 /,
+	'max_ranges zero');
+
+###############################################################################
+
+sub http_get_range {
+	my ($url, $extra) = @_;
+	return http(<<EOF);
+GET $url HTTP/1.1
+Host: localhost
+Connection: close
+$extra
+
+EOF
+}
+
+###############################################################################
diff --git a/tests/range_charset.t b/tests/range_charset.t
new file mode 100644
index 0000000..910f484
--- /dev/null
+++ b/tests/range_charset.t
@@ -0,0 +1,116 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for range filter on proxied response with charset.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy cache charset/)->plan(10)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    charset_map B A {
+        58 59; # X -> Y
+    }
+
+    proxy_cache_path   %%TESTDIR%%/cache  levels=1:2
+                       keys_zone=NAME:1m;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            proxy_pass    http://127.0.0.1:8081;
+            proxy_cache   NAME;
+            proxy_cache_valid 200 1m;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        charset B;
+
+        location /t2.html {
+            add_header X-Accel-Charset A;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('t1.html',
+	join('', map { sprintf "X%03dXXXXXX", $_ } (0 .. 99)));
+$t->write_file('t2.html',
+	join('', map { sprintf "X%03dXXXXXX", $_ } (0 .. 99)));
+$t->run();
+
+###############################################################################
+
+my $t1;
+
+# range request on proxied response with charset attribute in content-type
+# NB: to get partial content, requests need to be served from cache
+
+http_get('/t1.html');
+$t1 = http_get_range('/t1.html', 'Range: bytes=0-9, 10-19');
+like($t1, qr/ 206 /, 'charset - 206 partial reply');
+like($t1, qr/Content-Type: multipart\/byteranges; boundary=\w+\x0d\x0a/,
+	'charset - content type');
+like($t1, qr/Content-Type: text\/html; charset=B(?!; charset)/,
+	'charset - charset attribute');
+like($t1, qr/X000XXXXXX/m, 'charset - content 0-9');
+like($t1, qr/X001XXXXXX\x0d?$/m, 'charset - content 10-19');
+
+http_get('/t2.html');
+$t1 = http_get_range('/t2.html', 'Range: bytes=0-9, 10-19');
+like($t1, qr/ 206 /, 'x-accel-charset - 206 partial reply');
+like($t1, qr/Content-Type: multipart\/byteranges; boundary=\w+\x0d\x0a/,
+	'x-accel-charset - content type');
+like($t1, qr/Content-Type: text\/html; charset=A(?!; charset)/,
+	'x-accel-charset - charset attribute');
+like($t1, qr/Y000YYYYYY/m, 'x-accel-charset - content 0-9');
+like($t1, qr/Y001YYYYYY\x0d?$/m, 'x-accel-charset - content 10-19');
+
+###############################################################################
+
+sub http_get_range {
+	my ($url, $extra) = @_;
+	return http(<<EOF);
+GET $url HTTP/1.1
+Host: localhost
+Connection: close
+$extra
+
+EOF
+}
+
+###############################################################################
diff --git a/tests/range_flv.t b/tests/range_flv.t
new file mode 100644
index 0000000..86b642f
--- /dev/null
+++ b/tests/range_flv.t
@@ -0,0 +1,92 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for range filter module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http flv/)->plan(12);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+        location / {
+            flv;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('t1.flv',
+	join('', map { sprintf "X%03dXXXXXX", $_ } (0 .. 99)));
+$t->run();
+
+###############################################################################
+
+my $t1;
+
+# FLV has 13 byte header at start.
+
+$t1 = http_get_range('/t1.flv?start=100', 'Range: bytes=0-9');
+like($t1, qr/ 206 /, 'first bytes - 206 partial reply');
+like($t1, qr/Content-Length: 10/, 'first bytes - correct length');
+like($t1, qr/Content-Range: bytes 0-9\/913/, 'first bytes - content range');
+like($t1, qr/^FLV.{7}$/m, 'first bytes - correct content');
+
+$t1 = http_get_range('/t1.flv?start=100', 'Range: bytes=-10');
+like($t1, qr/ 206 /, 'final bytes - 206 partial reply');
+like($t1, qr/Content-Length: 10/, 'final bytes - content length');
+like($t1, qr/Content-Range: bytes 903-912\/913/,
+	'final bytes - content range');
+like($t1, qr/^X099XXXXXX$/m, 'final bytes - correct content');
+
+$t1 = http_get_range('/t1.flv?start=100', 'Range: bytes=0-99');
+like($t1, qr/ 206 /, 'multi buffers - 206 partial reply');
+like($t1, qr/Content-Length: 100/, 'multi buffers - content length');
+like($t1, qr/Content-Range: bytes 0-99\/913/, 'multi buffers - content range');
+like($t1, qr/^FLV.{10}X010XXXXXX(X01[1-7]XXXXXX){7}X018XXX$/m,
+	'multi buffers - correct content');
+
+###############################################################################
+
+sub http_get_range {
+	my ($url, $extra) = @_;
+	return http(<<EOF);
+GET $url HTTP/1.1
+Host: localhost
+Connection: close
+$extra
+
+EOF
+}
+
+###############################################################################
diff --git a/tests/range_if_range.t b/tests/range_if_range.t
new file mode 100644
index 0000000..5ca75fa
--- /dev/null
+++ b/tests/range_if_range.t
@@ -0,0 +1,108 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for range filter module with If-Range header.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http/)->plan(8);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /t2.html {
+            add_header Last-Modified "";
+        }
+
+        location /t3.html {
+            add_header Last-Modified "Mon, 28 Sep 1970 06:00:00 GMT";
+        }
+    }
+}
+
+EOF
+
+$t->write_file('t1.html',
+	join('', map { sprintf "X%03dXXXXXX", $_ } (0 .. 99)));
+$t->write_file('t2.html',
+	join('', map { sprintf "X%03dXXXXXX", $_ } (0 .. 99)));
+$t->write_file('t3.html',
+	join('', map { sprintf "X%03dXXXXXX", $_ } (0 .. 99)));
+$t->run();
+
+###############################################################################
+
+my $t1;
+
+# If-Range
+
+$t1 = http_get_range('/t1.html', "Range: bytes=0-9\nIf-Range: wrong");
+like($t1, qr/200 OK/, 'if-range wrong');
+like($t1, qr/Last-Modified: /, 'if-range wrong - last modified');
+
+$t1 =~ m/Last-Modified: (.*)/m;
+my $last = $1;
+
+$t1 = http_get_range('/t1.html', "Range: bytes=0-9\nIf-Range: $last");
+like($t1, qr/ 206 /, 'if-range');
+
+# If-Range + add_header Last-Modified ""
+
+$t1 = http_get_range('/t2.html', "Range: bytes=0-9\nIf-Range: wrong");
+like($t1, qr/200 OK/, 'if-range notime');
+unlike($t1, qr/Last-Modified: /, 'if-range notime - no last modified');
+
+# If-Range + add_header Last-Modified "Mon, 28 Sep 1970 06:00:00 GMT"
+
+$t1 = http_get_range('/t3.html', "Range: bytes=0-9\nIf-Range: wrong");
+like($t1, qr/200 OK/, 'if-range time wrong');
+like($t1, qr/Last-Modified: Mon, 28 Sep 1970 06:00:00 GMT/,
+	'if-range time wrong - last modified');
+
+$t1 = http_get_range('/t3.html',
+	"Range: bytes=0-9\nIf-Range: Mon, 28 Sep 1970 06:00:00 GMT");
+like($t1, qr/ 206 /, 'if-range time');
+
+###############################################################################
+
+sub http_get_range {
+	my ($url, $extra) = @_;
+	return http(<<EOF);
+GET $url HTTP/1.1
+Host: localhost
+Connection: close
+$extra
+
+EOF
+}
+
+###############################################################################
diff --git a/tests/range_mp4.t b/tests/range_mp4.t
new file mode 100644
index 0000000..7c87a61
--- /dev/null
+++ b/tests/range_mp4.t
@@ -0,0 +1,115 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for mp4 module with range filter module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http mp4/)->has_daemon('ffmpeg');
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+        location / {
+            mp4;
+        }
+    }
+}
+
+EOF
+
+plan(skip_all => 'no lavfi')
+	unless grep /lavfi/, `ffmpeg -nostdin -loglevel quiet -formats`;
+system('ffmpeg -loglevel quiet -y '
+	. '-f lavfi -i testsrc=duration=10:size=320x200:rate=15 '
+	. "-pix_fmt yuv420p -c:v libx264 ${\($t->testdir())}/test.mp4") == 0
+	or die "Can't create mp4 file: $!";
+
+$t->run()->plan(13);
+
+###############################################################################
+
+# simply ensure that mp4 start argument works, we rely on this in range tests
+
+my $fsz0 = http_head('/test.mp4') =~ /Content-Length: (\d+)/ && $1;
+my $fsz = http_head('/test.mp4?start=1') =~ /Content-Length: (\d+)/ && $1;
+isnt($fsz0, $fsz, 'mp4 start argument works');
+
+my $t1;
+
+# MP4 has minimally 16 byte ftyp object at start
+
+my $start = $fsz - 10;
+my $last = $fsz - 1;
+
+$t1 = http_get_range('/test.mp4?start=1', 'Range: bytes=0-9');
+like($t1, qr/ 206 /, 'first bytes - 206 partial reply');
+like($t1, qr/Content-Length: 10/, 'first bytes - content length');
+like($t1, qr/Content-Range: bytes 0-9\/$fsz/, 'first bytes - content range');
+
+$t1 = http_get_range('/test.mp4?start=1', 'Range: bytes=-10');
+like($t1, qr/ 206 /, 'final bytes - 206 partial reply');
+like($t1, qr/Content-Length: 10/, 'final bytes - content length');
+like($t1, qr/Content-Range: bytes $start-$last\/$fsz/,
+	'final bytes - content range');
+
+$t1 = http_get_range('/test.mp4?start=1', 'Range: bytes=0-99');
+like($t1, qr/ 206 /, 'multi buffers - 206 partial reply');
+like($t1, qr/Content-Length: 100/, 'multi buffers - content length');
+like($t1, qr/Content-Range: bytes 0-99\/$fsz/,
+	'multi buffers - content range');
+
+TODO: {
+local $TODO = 'multipart range on mp4';
+
+$t1 = http_get_range('/test.mp4?start=1', 'Range: bytes=0-10,11-99');
+like($t1, qr/ 206 /, 'multipart range - 206 partial reply');
+like($t1, qr/Content-Length: 100/, 'multipart range - content length');
+like($t1, qr/Content-Range: bytes 0-10,11-99\/$fsz/,
+	'multipart range - content range');
+
+}
+
+###############################################################################
+
+sub http_get_range {
+	my ($url, $extra) = @_;
+	return http(<<EOF);
+HEAD $url HTTP/1.1
+Host: localhost
+Connection: close
+$extra
+
+EOF
+}
+
+###############################################################################
diff --git a/tests/realip.t b/tests/realip.t
new file mode 100644
index 0000000..ae96470
--- /dev/null
+++ b/tests/realip.t
@@ -0,0 +1,143 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for nginx realip module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http realip rewrite/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    add_header X-IP $remote_addr;
+    set_real_ip_from  127.0.0.1/32;
+    set_real_ip_from  10.0.1.0/24;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / { }
+        location /custom {
+            real_ip_header    X-Real-IP-Custom;
+        }
+
+        location /1 {
+            real_ip_header    X-Forwarded-For;
+            real_ip_recursive off;
+        }
+
+        location /2 {
+            real_ip_header    X-Forwarded-For;
+            real_ip_recursive on;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        return 204;
+    }
+}
+
+EOF
+
+$t->write_file('index.html', '');
+$t->write_file('custom', '');
+$t->write_file('1', '');
+$t->write_file('2', '');
+$t->run();
+
+plan(skip_all => 'no 127.0.0.1 on host')
+	if http_get('/') !~ /X-IP: 127.0.0.1/m;
+
+$t->plan(8);
+
+###############################################################################
+
+like(http(<<EOF), qr/^X-IP: 192.0.2.1/m, 'realip');
+GET / HTTP/1.0
+Host: localhost
+X-Real-IP: 192.0.2.1
+
+EOF
+
+like(http(<<EOF), qr/^X-IP: 192.0.2.1/m, 'realip custom');
+GET /custom HTTP/1.0
+Host: localhost
+X-Real-IP-Custom: 192.0.2.1
+
+EOF
+
+like(http_xff('/1', '10.0.0.1, 192.0.2.1'), qr/^X-IP: 192.0.2.1/m,
+	'realip multi');
+like(http_xff('/1', '192.0.2.1, 10.0.1.1, 127.0.0.1'),
+	qr/^X-IP: 127.0.0.1/m, 'realip recursive off');
+like(http_xff('/2', '10.0.1.1, 192.0.2.1, 127.0.0.1'),
+	qr/^X-IP: 192.0.2.1/m, 'realip recursive on');
+
+like(http(<<EOF), qr/^X-IP: 10.0.1.1/m, 'realip multi xff recursive off');
+GET /1 HTTP/1.0
+Host: localhost
+X-Forwarded-For: 192.0.2.1
+X-Forwarded-For: 127.0.0.1, 10.0.1.1
+
+EOF
+
+like(http(<<EOF), qr/^X-IP: 192.0.2.1/m, 'realip multi xff recursive on');
+GET /2 HTTP/1.0
+Host: localhost
+X-Forwarded-For: 10.0.1.1
+X-Forwarded-For: 192.0.2.1
+X-Forwarded-For: 127.0.0.1
+
+EOF
+
+my $s = IO::Socket::INET->new('127.0.0.1:' . port(8081));
+like(http(<<EOF, socket => $s), qr/ 204 .*192.0.2.1/s, 'realip post read');
+GET / HTTP/1.0
+Host: localhost
+X-Real-IP: 192.0.2.1
+
+EOF
+
+###############################################################################
+
+sub http_xff {
+	my ($uri, $xff) = @_;
+	return http(<<EOF);
+GET $uri HTTP/1.0
+Host: localhost
+X-Forwarded-For: $xff
+
+EOF
+}
+
+###############################################################################
diff --git a/tests/realip_hostname.t b/tests/realip_hostname.t
new file mode 100644
index 0000000..48bbe7e
--- /dev/null
+++ b/tests/realip_hostname.t
@@ -0,0 +1,85 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for nginx realip module, 'unix:' and hostname in set_real_ip_from.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http realip proxy unix/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        listen       unix:%%TESTDIR%%/unix.sock;
+        server_name  localhost;
+
+        location /1 {
+            set_real_ip_from  localhost;
+            add_header X-IP $remote_addr;
+        }
+
+        location /2 {
+            set_real_ip_from  unix:;
+            add_header X-IP $remote_addr;
+        }
+
+        location /unix {
+            proxy_pass http://unix:%%TESTDIR%%/unix.sock:/;
+            proxy_set_header X-Real-IP 192.0.2.1;
+        }
+
+        location /ip {
+            proxy_pass http://127.0.0.1:8080/;
+            proxy_set_header X-Real-IP 192.0.2.1;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('1', '');
+$t->write_file('2', '');
+$t->run();
+
+plan(skip_all => 'no 127.0.0.1 on host')
+	if http_get('/1') !~ /X-IP: 127.0.0.1/m;
+
+$t->plan(4);
+
+###############################################################################
+
+like(http_get('/unix/2'), qr/X-IP: 192.0.2.1/, 'realip unix');
+unlike(http_get('/unix/1'), qr/X-IP: 192.0.2.1/, 'realip unix - no match');
+
+like(http_get('/ip/1'), qr/X-IP: 192.0.2.1/, 'realip hostname');
+unlike(http_get('/ip/2'), qr/X-IP: 192.0.2.1/, 'realip hostname - no match');
+
+###############################################################################
diff --git a/tests/realip_remote_addr.t b/tests/realip_remote_addr.t
new file mode 100644
index 0000000..ef4799b
--- /dev/null
+++ b/tests/realip_remote_addr.t
@@ -0,0 +1,85 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for nginx realip module, realip_remote_addr variable.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http realip/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    set_real_ip_from  127.0.0.1/32;
+    set_real_ip_from  192.0.2.1/32;
+    real_ip_header    X-Forwarded-For;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            add_header X-IP $remote_addr;
+            add_header X-Real-IP $realip_remote_addr;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('index.html', '');
+$t->write_file('1', '');
+$t->run();
+
+plan(skip_all => 'no 127.0.0.1 on host')
+	if http_get('/') !~ /X-IP: 127.0.0.1/m;
+
+$t->plan(4);
+
+###############################################################################
+
+like(http_get('/1'), qr/X-Real-IP: 127.0.0.1/m, 'request');
+like(http_get('/'), qr/X-Real-IP: 127.0.0.1/m, 'request redirect');
+
+like(http_xff('/1', '192.0.2.1'), qr/X-Real-IP: 127.0.0.1/m, 'realip');
+like(http_xff('/', '192.0.2.1'), qr/X-Real-IP: 127.0.0.1/m, 'realip redirect');
+
+###############################################################################
+
+sub http_xff {
+	my ($uri, $xff) = @_;
+	return http(<<EOF);
+GET $uri HTTP/1.0
+Host: localhost
+X-Forwarded-For: $xff
+
+EOF
+}
+
+###############################################################################
diff --git a/tests/realip_remote_port.t b/tests/realip_remote_port.t
new file mode 100644
index 0000000..2d433d5
--- /dev/null
+++ b/tests/realip_remote_port.t
@@ -0,0 +1,97 @@
+#!/usr/bin/perl
+
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+
+# Tests for nginx realip module, $realip_remote_port variable.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx qw/ :DEFAULT http_end /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http realip/)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    set_real_ip_from  127.0.0.1/32;
+    real_ip_header    X-Forwarded-For;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            add_header X-IP $remote_addr;
+            add_header X-Real-Port $realip_remote_port;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('index.html', '');
+$t->write_file('1', '');
+$t->run();
+
+plan(skip_all => 'no 127.0.0.1 on host')
+	if http_get('/') !~ /X-IP: 127.0.0.1/m;
+
+$t->plan(4);
+
+###############################################################################
+
+my ($sp, $data) = http_sp_get('/1');
+like($data, qr/X-Real-Port: $sp/, 'request');
+
+($sp, $data) = http_sp_get('/');
+like($data, qr/X-Real-Port: $sp/, 'request redirect');
+
+($sp, $data) = http_sp_xff('/1', '127.0.0.1:123');
+like($data, qr/X-Real-Port: $sp/, 'realip');
+
+($sp, $data) = http_sp_xff('/', '127.0.0.1:123');
+like($data, qr/X-Real-Port: $sp/, 'realip redirect');
+
+###############################################################################
+
+sub http_sp_get {
+	my $s = http_get(shift, start => 1);
+	return ($s->sockport(), http_end($s));
+}
+
+sub http_sp_xff {
+	my ($url, $xff) = @_;
+
+	my $s = http(<<EOF, start => 1);
+GET $url HTTP/1.0
+Host: localhost
+X-Forwarded-For: $xff
+
+EOF
+
+	return ($s->sockport(), http_end($s));
+}
+
+###############################################################################
diff --git a/tests/referer.t b/tests/referer.t
new file mode 100644
index 0000000..177c949
--- /dev/null
+++ b/tests/referer.t
@@ -0,0 +1,210 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+
+# Tests for referer module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http referer rewrite/)->plan(54);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  another;
+
+        valid_referers server_names;
+        return 200 "$host value $invalid_referer";
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  _;
+
+        location / {
+            valid_referers server_names;
+            return 200 "$host value $invalid_referer";
+        }
+        server_name  below;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost ~bar ~^anchoredre$;
+
+        location /blocked {
+            valid_referers blocked www.example.org;
+            return 200 "value $invalid_referer";
+        }
+        location /none {
+            valid_referers none www.example.org;
+            return 200 "value $invalid_referer";
+        }
+        location /simple {
+            valid_referers www.example.org;
+            return 200 "value $invalid_referer";
+        }
+        location /regex {
+            valid_referers ~example.org ~(?-i)example.net;
+            return 200 "value $invalid_referer";
+        }
+        location /regex2 {
+            valid_referers ~example.org/uri;
+            return 200 "value $invalid_referer";
+        }
+        location /regex3 {
+            valid_referers ~example.org$;
+            return 200 "value $invalid_referer";
+        }
+        location /uri {
+            valid_referers www.example.org/uri;
+            return 200 "value $invalid_referer";
+        }
+        location /sn {
+            valid_referers server_names;
+            return 200 "value $invalid_referer";
+        }
+        location /sn_blocked {
+            valid_referers blocked server_names;
+            return 200 "value $invalid_referer";
+        }
+        location /wc {
+            valid_referers *.example.com *.example.org www.example.* example.*;
+            return 200 "value $invalid_referer";
+        }
+        location /long {
+            valid_referers ~.*;
+            return 200 "value $invalid_referer";
+        }
+        location /wc2 {
+            valid_referers www.example.*/uri;
+            return 200 "value $invalid_referer";
+        }
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+ok(valid('/simple', 'http://www.example.org'), 'simple');
+ok(valid('/simple', 'http://www.example.org/uri'), 'simple uri');
+ok(valid('/simple', 'http://www.example.org:' . port(8080) . '/uri'),
+	'simple port uri');
+ok(!valid('/simple', 'localhost'), 'simple invalid');
+ok(valid('/simple', 'https://www.example.org'), 'https');
+ok(!valid('/simple', 'example.com'), 'no scheme');
+ok(!valid('/simple'), 'no none');
+ok(valid('/none'), 'none');
+ok(!valid('/none', ''), 'none empty');
+
+ok(valid('/blocked', 'www.example.org'), 'blocked');
+ok(valid('/blocked', 'www.example.com'), 'blocked 2');
+ok(valid('/blocked', 'http://su'), 'blocked short');
+ok(valid('/blocked', 'foobar'), 'blocked short no scheme');
+ok(valid('/blocked', ''), 'blocked empty');
+
+ok(!valid('/simple', 'foobar'), 'small');
+ok(valid('/simple', 'http://www.example.org/' . 'a' x 256), 'long uri');
+ok(!valid('/simple', 'http://www.example.' . 'a' x 256), 'long hostname');
+ok(!valid('/wc', 'http://example.' . 'a' x 256), 'long hostname wildcard');
+
+ok(valid('/long', 'http://' . 'a' x 255), 'long hostname 255');
+ok(valid('/long', 'http://' . 'a' x 256), 'long hostname 256');
+ok(!valid('/long', 'http://' . 'a' x 257), 'long hostname 257');
+
+ok(valid('/uri', 'http://www.example.org/uri'), 'uri');
+ok(valid('/uri', 'http://www.example.org/urii'), 'uri prefix');
+ok(!valid('/uri', 'http://www.example.org/uRi'), 'uri case');
+ok(valid('/uri', 'http://www.example.org:' . port(8080) . '/urii'), 'uri port');
+ok(!valid('/uri', 'http://www.example.org/ur'), 'uri invalid len');
+ok(!valid('/uri', 'http://www.example.org/urd'), 'uri invalid cmp');
+
+ok(valid('/regex', 'http://www.example.org'), 'regex');
+ok(valid('/regex', 'http://www.eXample.org'), 'regex caseless');
+ok(valid('/regex', 'http://www.example.org/uri'), 'regex uri');
+ok(!valid('/regex', 'http://www.example.com'), 'regex mismatch');
+ok(!valid('/regex', 'http://www.eXample.net'), 'regex case mismatch');
+
+ok(valid('/regex2', 'http://www.example.org/uri'), 'regex 2 uri');
+ok(!valid('/regex2', 'http://www.example.org'), 'regex 2 no uri');
+ok(valid('/regex2', 'http://www.example.org/uRI'), 'regex 2 uri caseless');
+ok(valid('/regex3', 'https://www.eXample.org'), 'regex https');
+
+ok(valid('/sn', 'http://localhost'), 'server_names');
+ok(valid('/sn', 'http://localHost'), 'server_names caseless');
+ok(valid('/sn', 'http://localhost/uri'), 'server_names uri');
+ok(valid('/sn', 'http://foobar'), 'server_names regex');
+ok(valid('/sn', 'http://foobAr'), 'server_names regex caseless');
+ok(valid('/sn', 'http://foobAr/uri'), 'server_names regex caseless uri');
+ok(valid('/sn', 'http://anchoredre/uri'), 'server_names regex anchored');
+ok(valid('/sn', 'http://foobar/uri'), 'server_names regex uri');
+ok(!valid('/sn', 'localhost'), 'server_names no scheme');
+ok(!valid('/sn', 'foobar'), 'server_names regex no scheme');
+ok(valid('/sn_blocked', 'localhost'), 'server_names no scheme blocked');
+
+ok(valid('/wc', 'http://www.example.org'), 'wildcard head');
+ok(valid('/wc', 'http://www.example.net'), 'wildcard tail');
+ok(valid('/wc2', 'http://www.example.net/uri'), 'wildcard uri');
+ok(valid('/wc2', 'http://www.example.net/urii'), 'wildcard uri prefix');
+ok(!valid('/wc2', 'http://www.example.net/uRI'), 'wildcard uri case');
+
+ok(valid('/', 'http://another', 'another'), 'server context');
+
+# server_name below valid_referers
+
+ok(valid('/', 'http://below', 'below'), 'server below');
+
+###############################################################################
+
+sub valid {
+	my ($uri, $referer, $host) = @_;
+	my $text;
+
+	$host = 'localhost' unless defined $host;
+
+	unless (defined $referer) {
+		$text = http_get($uri);
+	} else {
+		$text = http(<<EOF);
+GET $uri HTTP/1.0
+Host: $host
+Referer: $referer
+
+EOF
+	}
+
+	$text =~ /value 1/ && return 0;
+	$text =~ /value/ && return 1;
+	fail("no valid_referers in $uri");
+}
+
+###############################################################################
diff --git a/tests/request_id.t b/tests/request_id.t
new file mode 100644
index 0000000..35be946
--- /dev/null
+++ b/tests/request_id.t
@@ -0,0 +1,110 @@
+#!/usr/bin/perl
+
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+
+# Tests for request_id variable.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http rewrite ssi/)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    log_format id $request_id;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        add_header X-Request-Id $request_id;
+        add_header X-blah blah;
+
+        location / {
+            ssi on;
+        }
+        location /body {
+            return 200 $request_id;
+        }
+        location /log {
+            access_log %%TESTDIR%%/id.log id;
+            return 200;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('index.html', '');
+$t->write_file('add.html', '<!--#include virtual="/body" -->');
+$t->run()->plan(12);
+
+###############################################################################
+
+my ($id1) = http_get('/') =~ qr/^X-Request-Id: (.*)\x0d/m;
+my ($id2) = http_get('/') =~ qr/^X-Request-Id: (.*)\x0d/m;
+
+like($id1, qr/^[a-z0-9]{32}$/, 'format id 1');
+like($id2, qr/^[a-z0-9]{32}$/, 'format id 2');
+
+isnt($id1, $id2, 'different id');
+
+# same request
+
+($id1, $id2) = http_get('/body')
+	=~ qr/^X-Request-Id: (.*?)\x0d.*\x0d\x0a(.*)/ms;
+
+like($id1, qr/^[a-z0-9]{32}$/, 'format id 1 - same');
+like($id2, qr/^[a-z0-9]{32}$/, 'format id 2 - same');
+
+is($id1, $id2, 'equal id - same');
+
+# subrequest
+
+($id1, $id2) = http_get('/add.html')
+	=~ qr/^X-Request-Id: (.*?)\x0d.*\x0d\x0a(.*)/ms;
+
+like($id1, qr/^[a-z0-9]{32}$/, 'format id 1 - sub');
+like($id2, qr/^[a-z0-9]{32}$/, 'format id 2 - sub');
+
+is($id1, $id2, 'equal id - sub');
+
+# log
+
+($id1) = http_get('/log') =~ qr/^X-Request-Id: (.*)\x0d/m;
+
+$t->stop();
+
+$id2 = $t->read_file('/id.log');
+chomp $id2;
+
+like($id1, qr/^[a-z0-9]{32}$/, 'format id 1 - log');
+like($id2, qr/^[a-z0-9]{32}$/, 'format id 2 - log');
+
+is($id1, $id2, 'equal id - log');
+
+###############################################################################
diff --git a/tests/rewrite.t b/tests/rewrite.t
new file mode 100644
index 0000000..1bae290
--- /dev/null
+++ b/tests/rewrite.t
@@ -0,0 +1,249 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for rewrite module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http rewrite proxy/)->plan(23)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            rewrite ^ http://example.com/ redirect;
+        }
+
+        location /add {
+            rewrite ^ http://example.com/?c=d redirect;
+        }
+
+        location /no {
+            rewrite ^ http://example.com/?c=d? redirect;
+        }
+
+        location /return204 {
+            return 204;
+        }
+
+        location /return200 {
+            return 200;
+        }
+
+        location /return306 {
+            return 306;
+        }
+
+        location /return405 {
+            return 405;
+        }
+
+        location /error404return405 {
+            error_page 404 /return405;
+            return 404;
+        }
+
+        location /error405return204 {
+            error_page 405 /return204;
+            return 405;
+        }
+
+        location /error405return200 {
+            error_page 405 /return200;
+            return 405;
+        }
+
+        location /return200text {
+            return 200 "text";
+        }
+
+        location /return404text {
+            return 404 "text";
+        }
+
+        location /return302text {
+            return 302 "text";
+        }
+
+        location /error405return200text {
+            error_page 405 /return200text;
+            return 405;
+        }
+
+        location /error302return200text {
+            error_page 302 /return200text;
+            return 302 "text";
+        }
+
+        location /error405return302text {
+            error_page 405 /return302text;
+            return 405;
+        }
+
+        location /error405rewrite {
+            error_page 405 /;
+            return 405;
+        }
+
+        location /error405directory {
+            error_page 405 /directory;
+            return 405;
+        }
+
+        location /directory {
+        }
+
+        location /capture {
+            rewrite ^(.*) $1?c=d;
+            return 200 "uri:$uri args:$args";
+        }
+
+        location /capturedup {
+            rewrite ^(.*) $1?c=$1;
+            return 200 "uri:$uri args:$args";
+        }
+
+        location /break {
+            rewrite ^ /return200;
+            break;
+            proxy_pass http://127.0.0.1:8080/return204;
+        }
+    }
+}
+
+EOF
+
+mkdir($t->testdir() . '/directory');
+
+$t->run();
+
+###############################################################################
+
+like(http_get('/'), qr!^Location: http://example.com/\x0d?$!ms, 'simple');
+like(http_get('/?a=b'), qr!^Location: http://example.com/\?a=b\x0d?$!ms,
+	'simple with args');
+like(http_get('/add'), qr!^Location: http://example.com/\?c=d\x0d?$!ms,
+	'add args');
+
+like(http_get('/add?a=b'), qr!^Location: http://example.com/\?c=d&a=b\x0d?$!ms,
+	'add args with args');
+
+like(http_get('/no?a=b'), qr!^Location: http://example.com/\?c=d\x0d?$!ms,
+	'no args with args');
+
+like(http_get('/return204'), qr!204 No Content!, 'return 204');
+like(http_get('/return200'), qr!200 OK!, 'return 200');
+like(http_get('/return306'), qr!HTTP/1.1 306 !, 'return 306');
+like(http_get('/return405'), qr!HTTP/1.1 405.*body!ms, 'return 405');
+
+# this used to result in 404, but was changed in 1.15.4
+# to respond with 405 instead, much like a real error would do
+
+like(http_get('/error404return405'), qr!HTTP/1.1 405!, 'error 404 return 405');
+
+# status code should be 405, and entity body is expected (vs. normal 204
+# replies which doesn't expect to have body); use HTTP/1.1 for test
+# to make problem clear
+
+my $r = http(<<EOF);
+GET /error405return204 HTTP/1.1
+Host: localhost
+Connection: close
+
+EOF
+
+like($r, qr/HTTP\/1.1 405.*(Content-Length|\x0d\0a0\x0d\x0a)/ms,
+	'error 405 return 204');
+
+# the same test, but with return 200.  this doesn't have special
+# handling and returns builtin error page body (the same problem as
+# in /error405return200text below)
+
+like(http_get('/error405return200'), qr/HTTP\/1.1 405(?!.*body)/ms,
+	'error 405 return 200');
+
+# tests involving return with two arguments, as introduced in
+# 0.8.42
+
+like(http_get('/return200text'), qr!text\z!, 'return 200 text');
+like(http_get('/return404text'), qr!text\z!, 'return 404 text');
+
+like(http_get('/error405return200text'), qr!HTTP/1.1 405.*text\z!ms,
+	'error 405 to return 200 text');
+
+# return 302 is somewhat special: it adds Location header instead of
+# body text.  additionally it doesn't sent reply directly (as it's done for
+# other returns since 0.8.42) but instead returns NGX_HTTP_* code
+
+like(http_get('/return302text'), qr!HTTP/1.1 302.*Location: text!ms,
+	'return 302 text');
+
+like(http_get('/error302return200text'),
+	qr!HTTP/1.1 302.*Location: text.*text\z!ms,
+	'error 302 return 200 text');
+
+# in contrast to other return's this shouldn't preserve original status code
+# from error, and the same applies to "rewrite ... redirect" as an error
+# handler; both should in line with e.g. directory redirect as well
+
+like(http_get('/error405return302text'),
+	qr!HTTP/1.1 302.*Location: text!ms,
+	'error 405 return 302 text');
+
+like(http_get('/error405rewrite'),
+	qr!HTTP/1.1 302.*Location: http://example.com/!ms,
+	'error 405 rewrite redirect');
+
+like(http_get('/error405directory'),
+	qr!HTTP/1.1 301.*Location: http://!ms,
+	'error 405 directory redirect');
+
+# escaping of uri if there are args added in rewrite, and length
+# is actually calculated (ticket #162)
+
+like(http_get('/capture/%25?a=b'),
+	qr!^uri:/capture/% args:c=d&a=b$!ms,
+	'escape with added args');
+
+like(http_get('/capturedup/%25?a=b'),
+	qr!^uri:/capturedup/% args:c=/capturedup/%25&a=b$!ms,
+	'escape with added args');
+
+# break
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.17.8');
+
+like(http_get('/break'), qr/200/, 'valid_location reset');
+
+}
+
+###############################################################################
diff --git a/tests/rewrite_if.t b/tests/rewrite_if.t
new file mode 100644
index 0000000..32ef0cf
--- /dev/null
+++ b/tests/rewrite_if.t
@@ -0,0 +1,195 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for rewrite "if" condition.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http rewrite/)->plan(33)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            if ($arg_c) {
+                return 204;
+            }
+        }
+
+        location /sp {
+            if ( $arg_c ) {
+                return 204;
+            }
+        }
+
+        location /eq {
+            if ($arg_c = 1) {
+                return 204;
+            }
+        }
+
+        location /not {
+            if ($arg_c != 2) {
+                return 204;
+            }
+        }
+
+        location /pos {
+            if ($arg_c ~ foo) {
+                return 204;
+            }
+        }
+
+        location /cpos {
+            if ($arg_c ~* foo) {
+                return 204;
+            }
+        }
+
+        location /neg {
+            if ($arg_c !~ foo) {
+                return 204;
+            }
+        }
+
+        location /cneg {
+            if ($arg_c !~* foo) {
+                return 204;
+            }
+        }
+
+        location /plain {
+            if (-f %%TESTDIR%%/$arg_c) {
+                return 204;
+            }
+        }
+
+        location /dir {
+            if (-d %%TESTDIR%%/$arg_c) {
+                return 204;
+            }
+        }
+
+        location /exist {
+            if (-e %%TESTDIR%%/$arg_c) {
+                return 204;
+            }
+        }
+
+        location /exec {
+            if (-x %%TESTDIR%%/$arg_c) {
+                return 204;
+            }
+        }
+
+        location /not_plain {
+            if (!-f %%TESTDIR%%/$arg_c) {
+                return 204;
+            }
+        }
+
+        location /not_dir {
+            if (!-d %%TESTDIR%%/$arg_c) {
+                return 204;
+            }
+        }
+
+        location /not_exist {
+            if (!-e %%TESTDIR%%/$arg_c) {
+                return 204;
+            }
+        }
+
+        location /not_exec {
+            if (!-x %%TESTDIR%%/$arg_c) {
+                return 204;
+            }
+        }
+    }
+}
+
+EOF
+
+$t->write_file('file', '');
+mkdir($t->testdir() . '/dir');
+
+$t->run();
+
+###############################################################################
+
+like(http_get('/?c=1'), qr/ 204 /, 'var');
+unlike(http_get('/?c=0'), qr/ 204 /, 'false');
+like(http_get('/sp?c=1'), qr/ 204 /, 'spaces');
+
+like(http_get('/eq?c=1'), qr/ 204 /, 'equal');
+unlike(http_get('/eq?c=2'), qr/ 204 /, 'equal false');
+like(http_get('/not?c=1'), qr/ 204 /, 'not equal');
+unlike(http_get('/not?c=2'), qr/ 204 /, 'not equal false');
+
+like(http_get('/pos?c=food'), qr/ 204 /, 'match');
+like(http_get('/cpos?c=FooD'), qr/ 204 /, 'match case');
+like(http_get('/neg?c=FooD'), qr/ 204 /, 'match negative');
+like(http_get('/cneg?c=bar'), qr/ 204 /, 'match negative case');
+
+unlike(http_get('/pos?c=FooD'), qr/ 204 /, 'mismatch');
+unlike(http_get('/cpos?c=bar'), qr/ 204 /, 'mismatch case');
+unlike(http_get('/neg?c=food'), qr/ 204 /, 'mismatch negative');
+unlike(http_get('/cneg?c=FooD'), qr/ 204 /, 'mismatch negative case');
+
+like(http_get('/plain?c=file'), qr/ 204 /, 'plain file');
+unlike(http_get('/plain?c=dir'), qr/ 204 /, 'plain dir');
+unlike(http_get('/not_plain?c=file'), qr/ 204 /, 'not plain file');
+like(http_get('/not_plain?c=dir'), qr/ 204 /, 'not plain dir');
+
+unlike(http_get('/dir/?c=file'), qr/ 204 /, 'directory file');
+like(http_get('/dir?c=dir'), qr/ 204 /, 'directory dir');
+like(http_get('/not_dir?c=file'), qr/ 204 /, 'not directory file');
+unlike(http_get('/not_dir?c=dir'), qr/ 204 /, 'not directory dir');
+
+like(http_get('/exist?c=file'), qr/ 204 /, 'exist file');
+like(http_get('/exist?c=dir'), qr/ 204 /, 'exist dir');
+unlike(http_get('/exist?c=nx'), qr/ 204 /, 'exist non-existent');
+unlike(http_get('/not_exist?c=file'), qr/ 204 /, 'not exist file');
+unlike(http_get('/not_exist?c=dir'), qr/ 204 /, 'not exist dir');
+like(http_get('/not_exist?c=nx'), qr/ 204 /, 'not exist non-existent');
+
+SKIP: {
+skip 'no exec on win32', 4 if $^O eq 'MSWin32';
+
+unlike(http_get('/exec?c=file'), qr/ 204 /, 'executable file');
+like(http_get('/exec?c=dir'), qr/ 204 /, 'executable dir');
+like(http_get('/not_exec?c=file'), qr/ 204 /, 'not executable file');
+unlike(http_get('/not_exec?c=dir'), qr/ 204 /, 'not executable dir');
+
+}
+
+###############################################################################
diff --git a/tests/rewrite_set.t b/tests/rewrite_set.t
new file mode 100644
index 0000000..8596f1c
--- /dev/null
+++ b/tests/rewrite_set.t
@@ -0,0 +1,98 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for rewrite set.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http rewrite ssi/)->plan(4);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        ssi on;
+
+        location /t1 {
+            set $http_foo "set_foo";
+            return 200 'X<!--#echo var="http_foo" -->X';
+        }
+
+        location /t2 {
+            return 200 'X<!--#echo var="http_bar" -->X';
+        }
+
+        location /t3 {
+            return 200 'X<!--#echo var="http_baz" -->X';
+        }
+
+        location /t4 {
+            set $http_connection "bar";
+            return 200 "X${http_connection}X\n";
+        }
+
+        # set in other context
+        location /other {
+            set $http_bar "set_bar";
+        }
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+# prefixed variables
+
+like(http_get_extra('/t1.html', 'Foo: http_foo'), qr/Xset_fooX/,
+	'set in this context');
+like(http_get_extra('/t2.html', 'Bar: http_bar'), qr/Xhttp_barX/,
+	'set in other context');
+
+like(http_get_extra('/t3.html', 'Baz: http_baz'), qr/Xhttp_bazX/, 'not set');
+
+like(http_get('/t4.html'), qr/XbarX/, 'set get in return');
+
+###############################################################################
+
+sub http_get_extra {
+	my ($uri, $extra) = @_;
+	return http(<<EOF);
+GET $uri HTTP/1.0
+$extra
+
+EOF
+}
+
+###############################################################################
diff --git a/tests/rewrite_unescape.t b/tests/rewrite_unescape.t
new file mode 100644
index 0000000..ec15648
--- /dev/null
+++ b/tests/rewrite_unescape.t
@@ -0,0 +1,163 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for escaping/unescaping in rewrite module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http rewrite/)->plan(9)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /t1 {
+            rewrite ^ $arg_r? redirect;
+        }
+
+        location /t2 {
+            rewrite ^ http://example.com$request_uri? redirect;
+        }
+
+        location /t3 {
+            rewrite ^ http://example.com$uri redirect;
+        }
+
+        location /t4 {
+            rewrite ^(.*) http://example.com$1 redirect;
+        }
+
+        location /t5 {
+            rewrite ^ http://example.com/blah%20%3Fblah redirect;
+        }
+
+        location /t6 {
+            rewrite ^ http://example.com/blah%20%2Fblah redirect;
+        }
+    }
+}
+
+EOF
+
+mkdir($t->testdir() . '/directory');
+
+$t->run();
+
+###############################################################################
+
+# Some rewrites and expected (?) behaviour
+#
+# /t1?r=http%3A%2F%2Fexample.com%2F%3Ffrom
+# rewrite ^ $arg_r? redirect;
+# expected: http://example.com/?from
+# got:      http://example.com/?from
+#
+# /t1?r=http%3A%2F%2Fexample.com%0D%0Asplit
+# rewrite ^ $arg_r? redirect;
+# expected: http://example.com%0D%0Asplit
+# got:      http://example.com%0D%0Asplit
+#
+# /t1?r=http%3A%2F%2Fexample.com%2F%3Ffrom%3Dblah
+# rewrite ^ $arg_r? redirect;
+# expected: http://example.com/?from=blah
+# got:      http://example.com/?from%3Dblah
+#
+# /blah%3Fblah
+# rewrite ^ http://example.com$request_uri? redirect;
+# expected: http://example.com/blah%3Fblah
+# got:      http://example.com/blah?blah
+#
+# /blah%3Fblah
+# rewrite ^ http://example.com$uri redirect;
+# expected: http://example.com/blah%3Fblah
+# got:      http://example.com/blah?blah
+#
+# /blah%3Fblah
+# rewrite ^(.*) http://example.com$1 redirect;
+# expected: http://example.com/blah%3Fblah
+# got:      http://example.com/blah?blah
+#
+# /
+# rewrite ^ http://example.com/blah%3Fblah redirect;
+# expected: http://example.com/blah%3Fblah
+# got:      http://example.com/blah?blah
+#
+
+location('/t1?r=http%3A%2F%2Fexample.com%2F%3Ffrom',
+	'http://example.com/?from', 'escaped argument');
+
+location('/t1?r=http%3A%2F%2Fexample.com%0D%0Asplit',
+	'http://example.com%0D%0Asplit', 'escaped argument header splitting');
+
+TODO: {
+local $TODO = 'not yet';
+
+# Fixing this cases will require major changes to the whole approach and
+# likely to break some currently working cases.  On the other hand, current
+# behaviour is far from acceptable.  Should be carefully thought.
+
+location('/t1?r=http%3A%2F%2Fexample.com%2F%3Ffrom%3Dblah',
+	'http://example.com/?from=blah', 'escaped argument with complex query');
+
+location('/t2/blah%20%3Fblah',
+	'http://example.com/t2/blah%20%3Fblah', 'escaped $request_uri');
+
+location('/t3/blah%20%3Fblah',
+	'http://example.com/t3/blah%20%3Fblah', 'escaped $uri');
+
+location('/t4/blah%20%3Fblah',
+	'http://example.com/t4/blah%20%3Fblah', 'escaped $1');
+
+location('/t5',
+	'http://example.com/blah%20%3Fblah', 'escaped static');
+
+location('/t5?arg=blah',
+	'http://example.com/blah%20%3Fblah?arg=blah',
+	'escaped static with argument');
+
+location('/t6',
+	'http://example.com/blah%20%2Fblah', 'escaped static slash');
+
+}
+
+###############################################################################
+
+sub location {
+	my ($url, $value, $name) = @_;
+	my $data = http_get($url);
+	if ($data !~ qr!^Location: (.*?)\x0d?$!ms) {
+		fail($name);
+		return;
+	}
+	my $location = $1;
+	is($location, $value, $name);
+}
+
+###############################################################################
diff --git a/tests/scgi.t b/tests/scgi.t
new file mode 100644
index 0000000..66a93f0
--- /dev/null
+++ b/tests/scgi.t
@@ -0,0 +1,144 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Test for scgi backend.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require SCGI; };
+plan(skip_all => 'SCGI not installed') if $@;
+
+my $t = Test::Nginx->new()->has(qw/http scgi/)->plan(7)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    upstream u {
+        server 127.0.0.1:8081;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            scgi_pass 127.0.0.1:8081;
+            scgi_param SCGI 1;
+            scgi_param REQUEST_URI $request_uri;
+            scgi_param HTTP_X_BLAH "blah";
+        }
+
+        location /var {
+            scgi_pass $arg_b;
+            scgi_param SCGI 1;
+            scgi_param REQUEST_URI $request_uri;
+        }
+
+    }
+}
+
+EOF
+
+$t->run_daemon(\&scgi_daemon);
+$t->run()->waitforsocket('127.0.0.1:' . port(8081));
+
+###############################################################################
+
+like(http_get('/'), qr/SEE-THIS/, 'scgi request');
+like(http_get('/redir'), qr/ 302 /, 'scgi redirect');
+like(http_get('/'), qr/^3$/m, 'scgi third request');
+
+unlike(http_head('/'), qr/SEE-THIS/, 'no data in HEAD');
+
+like(http_get_headers('/headers'), qr/SEE-THIS/,
+	'scgi request with many ignored headers');
+
+like(http_get('/var?b=127.0.0.1:' . port(8081)), qr/SEE-THIS/,
+	'scgi with variables');
+like(http_get('/var?b=u'), qr/SEE-THIS/, 'scgi with variables to upstream');
+
+###############################################################################
+
+sub http_get_headers {
+	my ($url, %extra) = @_;
+	return http(<<EOF, %extra);
+GET $url HTTP/1.0
+Host: localhost
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+
+EOF
+}
+
+###############################################################################
+
+sub scgi_daemon {
+	my $server = IO::Socket::INET->new(
+		Proto => 'tcp',
+		LocalHost => '127.0.0.1:' . port(8081),
+		Listen => 5,
+		Reuse => 1
+	)
+		or die "Can't create listening socket: $!\n";
+
+	my $scgi = SCGI->new($server, blocking => 1);
+	my $count = 0;
+
+	while (my $request = $scgi->accept()) {
+		eval { $request->read_env(); };
+		next if $@;
+
+		$count++;
+
+		$request->connection()->print(<<EOF);
+Location: http://localhost/redirect
+Content-Type: text/html
+
+SEE-THIS
+$count
+EOF
+	}
+}
+
+###############################################################################
diff --git a/tests/scgi_body.t b/tests/scgi_body.t
new file mode 100644
index 0000000..2efeacd
--- /dev/null
+++ b/tests/scgi_body.t
@@ -0,0 +1,133 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Test for scgi backend with chunked request body.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require SCGI; };
+plan(skip_all => 'SCGI not installed') if $@;
+
+my $t = Test::Nginx->new()->has(qw/http scgi/)->plan(5)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            scgi_pass 127.0.0.1:8081;
+            scgi_param SCGI 1;
+            scgi_param REQUEST_URI $request_uri;
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&scgi_daemon);
+$t->run()->waitforsocket('127.0.0.1:' . port(8081));
+
+###############################################################################
+
+
+like(http_get('/'), qr/X-Body: /, 'scgi no body');
+
+like(http_get_length('/', ''), qr/X-Body: /, 'scgi empty body');
+like(http_get_length('/', 'foobar'), qr/X-Body: foobar/, 'scgi body');
+
+like(http(<<EOF), qr/X-Body: foobar/, 'scgi chunked');
+GET / HTTP/1.1
+Host: localhost
+Connection: close
+Transfer-Encoding: chunked
+
+6
+foobar
+0
+
+EOF
+
+like(http(<<EOF), qr/X-Body: /, 'scgi empty chunked');
+GET / HTTP/1.1
+Host: localhost
+Connection: close
+Transfer-Encoding: chunked
+
+0
+
+EOF
+
+###############################################################################
+
+sub http_get_length {
+	my ($url, $body) = @_;
+	my $length = length $body;
+	return http(<<EOF);
+GET $url HTTP/1.1
+Host: localhost
+Connection: close
+Content-Length: $length
+
+$body
+EOF
+}
+
+###############################################################################
+
+sub scgi_daemon {
+	my $server = IO::Socket::INET->new(
+		Proto => 'tcp',
+		LocalHost => '127.0.0.1:' . port(8081),
+		Listen => 5,
+		Reuse => 1
+	)
+		or die "Can't create listening socket: $!\n";
+
+	my $scgi = SCGI->new($server, blocking => 1);
+	my $body;
+
+	while (my $request = $scgi->accept()) {
+		eval { $request->read_env(); };
+		next if $@;
+
+		read($request->connection, $body,
+			$request->env->{CONTENT_LENGTH});
+
+		$request->connection()->print(<<EOF);
+Location: http://localhost/redirect
+Content-Type: text/html
+X-Body: $body
+
+SEE-THIS
+EOF
+	}
+}
+
+###############################################################################
diff --git a/tests/scgi_cache.t b/tests/scgi_cache.t
new file mode 100644
index 0000000..da07006
--- /dev/null
+++ b/tests/scgi_cache.t
@@ -0,0 +1,143 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for scgi_cache.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require SCGI; };
+plan(skip_all => 'SCGI not installed') if $@;
+
+my $t = Test::Nginx->new()->has(qw/http scgi cache/)->plan(10)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    scgi_cache_path  %%TESTDIR%%/cache  keys_zone=one:1m;
+    scgi_cache_key   $request_uri;
+
+    add_header       X-Cache-Status  $upstream_cache_status;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            scgi_pass 127.0.0.1:8081;
+            scgi_param SCGI 1;
+            scgi_param REQUEST_URI $uri;
+            scgi_cache one;
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&scgi_daemon);
+$t->run()->waitforsocket('127.0.0.1:' . port(8081));
+
+###############################################################################
+
+like(http_get('/len'), qr/MISS/, 'length');
+like(http_get('/len'), qr/HIT/, 'length cached');
+
+like(http_get('/nolen'), qr/MISS/, 'no length');
+like(http_get('/nolen'), qr/HIT/, 'no length cached');
+
+like(http_get('/len/empty'), qr/MISS/, 'empty length');
+like(http_get('/len/empty'), qr/HIT/, 'empty length cached');
+
+like(http_get('/nolen/empty'), qr/MISS/, 'empty no length');
+like(http_get('/nolen/empty'), qr/HIT/, 'empty no length cached');
+
+like(http_get('/unfinished'), qr/MISS/, 'unfinished');
+like(http_get('/unfinished'), qr/MISS/, 'unfinished not cached');
+
+###############################################################################
+
+sub scgi_daemon {
+	my $server = IO::Socket::INET->new(
+		Proto => 'tcp',
+		LocalHost => '127.0.0.1:' . port(8081),
+		Listen => 5,
+		Reuse => 1
+	)
+		or die "Can't create listening socket: $!\n";
+
+	my $scgi = SCGI->new($server, blocking => 1);
+	my %count;
+
+	while (my $request = $scgi->accept()) {
+		eval { $request->read_env(); };
+		next if $@;
+
+		my $uri = $request->env->{REQUEST_URI} || '';
+		my $c = $request->connection();
+
+		$count{$uri} ||= 0;
+		$count{$uri}++;
+
+		if ($uri eq '/len') {
+			$c->print(
+				"Content-Length: 9" . CRLF .
+				"Content-Type: text/html" . CRLF .
+				"Cache-Control: max-age=300" . CRLF . CRLF .
+				"test body"
+			);
+
+		} elsif ($uri eq '/nolen') {
+			$c->print(
+				"Content-Type: text/html" . CRLF .
+				"Cache-Control: max-age=300" . CRLF . CRLF .
+				"test body"
+			);
+
+		} elsif ($uri eq '/len/empty') {
+			$c->print(
+				"Content-Length: 0" . CRLF .
+				"Content-Type: text/html" . CRLF .
+				"Cache-Control: max-age=300" . CRLF . CRLF
+			);
+
+		} elsif ($uri eq '/nolen/empty') {
+			$c->print(
+				"Content-Type: text/html" . CRLF .
+				"Cache-Control: max-age=300" . CRLF . CRLF
+			);
+
+		} elsif ($uri eq '/unfinished') {
+			$c->print(
+				"Content-Length: 10" . CRLF .
+				"Content-Type: text/html" . CRLF .
+				"Cache-Control: max-age=300" . CRLF . CRLF
+			);
+		}
+	}
+}
+
+###############################################################################
diff --git a/tests/scgi_gzip.t b/tests/scgi_gzip.t
new file mode 100644
index 0000000..60244ab
--- /dev/null
+++ b/tests/scgi_gzip.t
@@ -0,0 +1,88 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Test for scgi backend and gzip.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx qw/ :DEFAULT :gzip /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require SCGI; };
+plan(skip_all => 'SCGI not installed') if $@;
+
+my $t = Test::Nginx->new()->has(qw/http scgi gzip/)->plan(1)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            gzip on;
+            scgi_pass 127.0.0.1:8081;
+            scgi_param SCGI 1;
+            scgi_param REQUEST_URI $request_uri;
+            scgi_param HTTP_X_BLAH "blah";
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&scgi_daemon);
+$t->run()->waitforsocket('127.0.0.1:' . port(8081));
+
+###############################################################################
+
+like(http_gzip_request('/'), qr/Content-Encoding: gzip/, 'scgi request');
+
+###############################################################################
+
+sub scgi_daemon {
+	my $server = IO::Socket::INET->new(
+		Proto => 'tcp',
+		LocalHost => '127.0.0.1:' . port(8081),
+		Listen => 5,
+		Reuse => 1
+	)
+		or die "Can't create listening socket: $!\n";
+
+	my $scgi = SCGI->new($server, blocking => 1);
+
+	while (my $request = $scgi->accept()) {
+		eval { $request->read_env(); };
+		next if $@;
+
+		$request->connection()->print(<<EOF);
+Content-Type: text/html
+
+SEE-THIS-1234567890-1234567890
+EOF
+	}
+}
+
+###############################################################################
diff --git a/tests/scgi_merge_params.t b/tests/scgi_merge_params.t
new file mode 100644
index 0000000..efa0e2a
--- /dev/null
+++ b/tests/scgi_merge_params.t
@@ -0,0 +1,143 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for scgi_param inheritance.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require SCGI; };
+plan(skip_all => 'SCGI not installed') if $@;
+
+my $t = Test::Nginx->new()->has(qw/http scgi cache/)->plan(9)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    scgi_cache_path  %%TESTDIR%%/cache  levels=1:2
+                     keys_zone=NAME:1m;
+
+    scgi_cache_key   stub;
+
+    scgi_param SCGI 1;
+    scgi_param HTTP_X_BLAH "blah";
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        scgi_cache  NAME;
+
+        location / {
+            scgi_pass    127.0.0.1:8081;
+        }
+
+        location /no/ {
+            scgi_pass    127.0.0.1:8081;
+            scgi_cache   off;
+        }
+
+        location /custom/ {
+            scgi_pass    127.0.0.1:8081;
+            scgi_param   SCGI 1;
+            scgi_param   HTTP_X_BLAH  "custom";
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&scgi_daemon);
+$t->run()->waitforsocket('127.0.0.1:' . port(8081));
+
+###############################################################################
+
+like(http_get_ims('/'), qr/ims=;/,
+	'if-modified-since cleared with cache');
+like(http_get_ims('/'), qr/iums=;/,
+	'if-unmodified-since cleared with cache');
+like(http_get_ims('/'), qr/blah=blah;/,
+	'custom params with cache');
+
+like(http_get_ims('/no/'), qr/ims=blah;/,
+	'if-modified-since preserved without cache');
+like(http_get_ims('/no/'), qr/iums=blah;/,
+	'if-unmodified-since preserved without cache');
+like(http_get_ims('/'), qr/blah=blah;/,
+	'custom params without cache');
+
+like(http_get_ims('/custom/'), qr/ims=;/,
+	'if-modified-since cleared with cache custom');
+like(http_get_ims('/custom/'), qr/iums=;/,
+	'if-unmodified-since cleared with cache custom');
+like(http_get_ims('/custom/'), qr/blah=custom;/,
+	'custom params with cache custom');
+
+###############################################################################
+
+sub http_get_ims {
+	my ($url) = @_;
+	return http(<<EOF);
+GET $url HTTP/1.0
+Host: localhost
+Connection: close
+If-Modified-Since: blah
+If-Unmodified-Since: blah
+
+EOF
+}
+
+###############################################################################
+
+sub scgi_daemon {
+	my $server = IO::Socket::INET->new(
+		Proto => 'tcp',
+		LocalHost => '127.0.0.1:' . port(8081),
+		Listen => 5,
+		Reuse => 1
+	)
+		or die "Can't create listening socket: $!\n";
+
+	my $scgi = SCGI->new($server, blocking => 1);
+
+	while (my $request = $scgi->accept()) {
+		eval { $request->read_env(); };
+		next if $@;
+
+		my $ims = $request->env->{HTTP_IF_MODIFIED_SINCE} || '';
+		my $iums = $request->env->{HTTP_IF_UNMODIFIED_SINCE} || '';
+		my $blah = $request->env->{HTTP_X_BLAH} || '';
+
+		$request->connection()->print(<<EOF);
+Location: http://localhost/redirect
+Content-Type: text/html
+
+ims=$ims;iums=$iums;blah=$blah;
+EOF
+	}
+}
+
+###############################################################################
diff --git a/tests/secure_link.t b/tests/secure_link.t
new file mode 100644
index 0000000..2bdc2ba
--- /dev/null
+++ b/tests/secure_link.t
@@ -0,0 +1,191 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for nginx secure_link module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Digest::MD5 qw/ md5 md5_hex /;
+use MIME::Base64 qw/ encode_base64 /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http secure_link rewrite/)->plan(19);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            # new style
+            # /test.html?hash=BASE64URL
+
+            secure_link      $arg_hash;
+            secure_link_md5  secret$uri;
+
+            # invalid hash
+            if ($secure_link = "") {
+                return 403;
+            }
+
+            # expired
+            if ($secure_link = "0") {
+                return 403;
+            }
+
+            # $secure_link = "1"
+        }
+
+        location = /expires.html {
+            # new style with expires
+            # /test.html?hash=BASE64URL&expires=12345678
+
+            add_header X-Expires $secure_link_expires;
+
+            secure_link      $arg_hash,$arg_expires;
+            secure_link_md5  secret$uri$arg_expires;
+
+            # invalid hash
+            if ($secure_link = "") {
+                return 403;
+            }
+
+            # expired
+            if ($secure_link = "0") {
+                return 403;
+            }
+
+            # $secure_link = "1"
+        }
+
+        location /p/ {
+            # old style
+            # /p/d8e8fca2dc0f896fd7cb4cb0031ba249/test.html
+
+            secure_link_secret secret;
+
+            if ($secure_link = "") {
+                return 403;
+            }
+
+            rewrite ^ /$secure_link break;
+        }
+
+        location /inheritance/ {
+            secure_link_secret secret;
+
+            location = /inheritance/test {
+                secure_link      Xr4ilOzQ4PCOq3aQ0qbuaQ==;
+                secure_link_md5  secret;
+
+                if ($secure_link = "1") {
+                    rewrite ^ /test.html break;
+                }
+
+                return 403;
+            }
+        }
+
+        location /stub {
+            return 200 x$secure_link${secure_link_expires}x;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('test.html', 'PASSED');
+$t->write_file('expires.html', 'PASSED');
+$t->run();
+
+###############################################################################
+
+# new style
+
+like(http_get('/test.html?hash=q-5vpkjBkRXXtkUMXiJVHA=='),
+	qr/PASSED/, 'request md5');
+like(http_get('/test.html?hash=q-5vpkjBkRXXtkUMXiJVHA'),
+	qr/PASSED/, 'request md5 no padding');
+like(http_get('/test.html?hash=q-5vpkjBkRXXtkUMXiJVHAQQ'),
+	qr/^HTTP.*403/, 'request md5 too long');
+like(http_get('/test.html?hash=q-5vpkjBkRXXtkUMXiJVHA-TOOLONG'),
+	qr/^HTTP.*403/, 'request md5 too long encoding');
+like(http_get('/test.html?hash=BADHASHLENGTH'),
+	qr/^HTTP.*403/, 'request md5 decode error');
+like(http_get('/test.html?hash=q-5vpkjBkRXXtkUMXiJVHX=='),
+	qr/^HTTP.*403/, 'request md5 mismatch');
+like(http_get('/test.html'), qr/^HTTP.*403/, 'request no hash');
+
+# new style with expires
+
+my ($expires, $hash);
+
+$expires = time() + 86400;
+$hash = encode_base64url(md5("secret/expires.html$expires"));
+like(http_get('/expires.html?hash=' . $hash . '&expires=' . $expires),
+	qr/PASSED/, 'request md5 not expired');
+like(http_get('/expires.html?hash=' . $hash . '&expires=' . $expires),
+	qr/X-Expires: $expires/, 'secure_link_expires variable');
+
+$expires = time() - 86400;
+$hash = encode_base64url(md5("secret/expires.html$expires"));
+like(http_get('/expires.html?hash=' . $hash . '&expires=' . $expires),
+	qr/^HTTP.*403/, 'request md5 expired');
+
+$expires = 0;
+$hash = encode_base64url(md5("secret/expires.html$expires"));
+like(http_get('/expires.html?hash=' . $hash . '&expires=' . $expires),
+	qr/^HTTP.*403/, 'request md5 invalid expiration');
+
+# old style
+
+like(http_get('/p/' . md5_hex('test.html' . 'secret') . '/test.html'),
+	qr/PASSED/, 'request old style');
+like(http_get('/p/' . md5_hex('fake') . '/test.html'), qr/^HTTP.*403/,
+	'request old style fake hash');
+like(http_get('/p/' . 'foo' . '/test.html'), qr/^HTTP.*403/,
+	'request old style short hash');
+like(http_get('/p/' . 'x' x 32 . '/test.html'), qr/^HTTP.*403/,
+	'request old style corrupt hash');
+like(http_get('/p%2f'), qr/^HTTP.*403/, 'request old style bad uri');
+like(http_get('/p/test.html'), qr/^HTTP.*403/, 'request old style no hash');
+like(http_get('/inheritance/test'), qr/PASSED/, 'inheritance');
+
+like(http_get('/stub'), qr/xx/, 'secure_link not found');
+
+###############################################################################
+
+sub encode_base64url {
+	my $e = encode_base64(shift, "");
+	$e =~ s/=+\z//;
+	$e =~ tr[+/][-_];
+	return $e;
+}
+
+###############################################################################
diff --git a/tests/server_tokens.t b/tests/server_tokens.t
new file mode 100644
index 0000000..ae9c611
--- /dev/null
+++ b/tests/server_tokens.t
@@ -0,0 +1,126 @@
+#!/usr/bin/perl
+
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+
+# Tests for server_tokens directive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http rewrite/)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /200 {
+            return 200;
+        }
+
+        location /404 {
+            return 404;
+        }
+
+        location /off {
+            server_tokens off;
+
+            location /off/200 {
+                return 200;
+            }
+
+            location /off/404 {
+                return 404;
+            }
+        }
+
+        location /on {
+            server_tokens on;
+
+            location /on/200 {
+                return 200;
+            }
+
+            location /on/404 {
+                return 404;
+            }
+        }
+
+        location /b {
+            server_tokens build;
+
+            location /b/200 {
+                return 200;
+            }
+
+            location /b/404 {
+                return 404;
+            }
+        }
+    }
+}
+
+EOF
+
+$t->run()->plan(12);
+
+###############################################################################
+
+my $re = qr/nginx\/\d+\.\d+\.\d+/;
+
+like(http_get_server('/200'), $re, 'tokens default 200');
+like(http_get_server('/404'), $re, 'tokens default 404');
+like(http_body('/404'), $re, 'tokens default 404 body');
+
+is(http_get_server('/off/200'), 'nginx', 'tokens off 200');
+is(http_get_server('/off/404'), 'nginx', 'tokens off 404');
+like(http_body('/off/404'), qr/nginx(?!\/)/, 'tokens off 404 body');
+
+like(http_get_server('/on/200'), $re, 'tokens on 200');
+like(http_get_server('/on/404'), $re, 'tokens on 404');
+like(http_body('/on/404'), $re, 'tokens on 404 body');
+
+$re = qr/$re \Q($1)\E/ if $t->{_configure_args} =~ /--build=(\S+)/;
+
+like(http_get_server('/b/200'), $re, 'tokens build 200');
+like(http_get_server('/b/404'), $re, 'tokens build 404');
+like(http_body('/b/404'), $re, 'tokens build 404 body');
+
+###############################################################################
+
+sub http_body {
+	my ($uri) = shift;
+	return http_get($uri) =~ /.*?\x0d\x0a?\x0d\x0a?(.*)/ms && $1;
+}
+
+sub http_get_server {
+	my ($url) = @_;
+	return http_get($url) =~ /^Server:\s(.+?)\x0d?$/mi && $1 || undef;
+}
+
+###############################################################################
diff --git a/tests/slice.t b/tests/slice.t
new file mode 100644
index 0000000..3bab3bc
--- /dev/null
+++ b/tests/slice.t
@@ -0,0 +1,330 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for slice filter.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx qw/ :DEFAULT http_end /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy cache fastcgi slice rewrite/)
+	->plan(76);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    proxy_cache_path   %%TESTDIR%%/cache  keys_zone=NAME:1m;
+    proxy_cache_path   %%TESTDIR%%/cach3  keys_zone=NAME3:1m;
+    proxy_cache_key    $uri$is_args$args$slice_range;
+
+    fastcgi_cache_path   %%TESTDIR%%/cache2  keys_zone=NAME2:1m;
+    fastcgi_cache_key    $uri$is_args$args$slice_range;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / { }
+
+        location /proxy/ {
+            slice 2;
+
+            proxy_pass    http://127.0.0.1:8081/;
+
+            proxy_set_header   Range  $slice_range;
+        }
+
+        location /cache/ {
+            slice 2;
+
+            proxy_pass    http://127.0.0.1:8081/;
+
+            proxy_cache   NAME;
+
+            proxy_set_header   Range  $slice_range;
+
+            proxy_cache_valid   200 206  1h;
+
+            add_header X-Cache-Status $upstream_cache_status;
+        }
+
+        location /fastcgi {
+            slice 2;
+
+            fastcgi_pass    127.0.0.1:8082;
+
+            fastcgi_cache   NAME2;
+
+            fastcgi_param   Range $slice_range;
+
+            fastcgi_cache_valid   200 206  1h;
+
+            fastcgi_force_ranges  on;
+
+            add_header X-Cache-Status $upstream_cache_status;
+        }
+
+        location /cache-redirect {
+            error_page 404 = @fallback;
+        }
+
+        location @fallback {
+            slice 2;
+
+            proxy_pass    http://127.0.0.1:8081/t$is_args$args;
+
+            proxy_cache   NAME3;
+
+            proxy_set_header   Range  $slice_range;
+
+            proxy_cache_valid   200 206  1h;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location / {
+            if ($http_range = "") {
+                set $limit_rate 100;
+	    }
+        }
+    }
+}
+
+EOF
+
+$t->write_file('t', '0123456789abcdef');
+$t->run();
+
+###############################################################################
+
+my $r;
+
+like(http_get('/cache/nx'), qr/ 404 /, 'not found');
+like(http_get('/cache/t'), qr/ 200 .*0123456789abcdef$/ms, 'no range');
+
+$r = get('/cache/t?single', "Range: bytes=0-0");
+like($r, qr/ 206 /, 'single - 206 partial reply');
+like($r, qr/^0$/m, 'single - correct content');
+like($r, qr/Status: MISS/m, 'single - cache status');
+
+$r = get('/cache/t?single', "Range: bytes=0-0");
+like($r, qr/ 206 /, 'single cached - 206 partial reply');
+like($r, qr/^0$/m, 'single cached - correct content');
+like($r, qr/Status: HIT/m, 'single cached - cache status');
+
+$r = get('/cache/t?single', "Range: bytes=1-1");
+like($r, qr/ 206 /, 'single next - 206 partial reply');
+like($r, qr/^1$/m, 'single next - correct content');
+like($r, qr/Status: HIT/m, 'single next - cache status');
+
+$r = get('/cache/t?single', "Range: bytes=2-2");
+like($r, qr/ 206 /, 'slice next - 206 partial reply');
+like($r, qr/^2$/m, 'slice next - correct content');
+like($r, qr/Status: MISS/m, 'slice next - cache status');
+
+$r = get('/cache/t?single', "Range: bytes=2-2");
+like($r, qr/ 206 /, 'slice next cached - 206 partial reply');
+like($r, qr/^2$/m, 'slice next cached - correct content');
+like($r, qr/Status: HIT/m, 'slice next cached - cache status');
+
+$r = get('/cache/t?median', "Range: bytes=2-2");
+like($r, qr/ 206 /, 'slice median - 206 partial reply');
+like($r, qr/^2$/m, 'slice median - correct content');
+like($r, qr/Status: MISS/m, 'slice median - cache status');
+
+$r = get('/cache/t?median', "Range: bytes=0-0");
+like($r, qr/ 206 /, 'before median - 206 partial reply');
+like($r, qr/^0$/m, 'before median - correct content');
+like($r, qr/Status: MISS/m, 'before median - cache status');
+
+# range span to multiple slices
+
+$r = get('/cache/t?range', "Range: bytes=1-2");
+like($r, qr/ 206 /, 'slice range - 206 partial reply');
+like($r, qr/^12$/m, 'slice range - correct content');
+like($r, qr/Status: MISS/m, 'slice range - cache status');
+
+$r = get('/cache/t?range', "Range: bytes=0-0");
+like($r, qr/ 206 /, 'slice 1st - 206 partial reply');
+like($r, qr/^0$/m, 'slice 1st - correct content');
+like($r, qr/Status: HIT/m, 'slice 1st - cache status');
+
+$r = get('/cache/t?range', "Range: bytes=2-2");
+like($r, qr/ 206 /, 'slice 2nd - 206 partial reply');
+like($r, qr/^2$/m, 'slice 2nd - correct content');
+like($r, qr/Status: HIT/m, 'slice 2nd - cache status');
+
+$r = get('/cache/t?mrange', "Range: bytes=3-4");
+like($r, qr/ 206 /, 'range median - 206 partial reply');
+like($r, qr/^34$/m, 'range median - correct content');
+like($r, qr/Status: MISS/m, 'range median - cache status');
+
+$r = get('/cache/t?mrange', "Range: bytes=2-3");
+like($r, qr/ 206 /, 'range prev - 206 partial reply');
+like($r, qr/^23$/m, 'range prev - correct content');
+like($r, qr/Status: HIT/m, 'range prev - cache status');
+
+$r = get('/cache/t?mrange', "Range: bytes=4-5");
+like($r, qr/ 206 /, 'range next - 206 partial reply');
+like($r, qr/^45$/m, 'range next - correct content');
+like($r, qr/Status: HIT/m, 'range next - cache status');
+
+$r = get('/cache/t?first', "Range: bytes=2-");
+like($r, qr/ 206 /, 'first bytes - 206 partial reply');
+like($r, qr/^23456789abcdef$/m, 'first bytes - correct content');
+like($r, qr/Status: MISS/m, 'first bytes - cache status');
+
+$r = get('/cache/t?first', "Range: bytes=4-");
+like($r, qr/ 206 /, 'first bytes cached - 206 partial reply');
+like($r, qr/^456789abcdef$/m, 'first bytes cached - correct content');
+like($r, qr/Status: HIT/m, 'first bytes cached - cache status');
+
+# multiple ranges
+# we want 206, but 200 is also fine
+
+$r = get('/cache/t?many', "Range: bytes=3-3,4-4");
+like($r, qr/200 OK/, 'many - 206 partial reply');
+like($r, qr/^0123456789abcdef$/m, 'many - correct content');
+
+$r = get('/cache/t?last', "Range: bytes=-10");
+like($r, qr/206 /, 'last bytes - 206 partial reply');
+like($r, qr/^6789abcdef$/m, 'last bytes - correct content');
+
+# respect not modified and range filters
+
+my ($etag) = http_get('/t') =~ /ETag: (.*)/;
+
+like(get('/cache/t?inm', "If-None-Match: $etag"), qr/ 304 /, 'inm');
+like(get('/cache/t?inm', "If-None-Match: bad"), qr/ 200 /, 'inm bad');
+
+like(get('/cache/t?im', "If-Match: $etag"), qr/ 200 /, 'im');
+like(get('/cache/t?im', "If-Match: bad"), qr/ 412 /, 'im bad');
+
+$r = get('/cache/t?if', "Range: bytes=3-4\nIf-Range: $etag");
+like($r, qr/ 206 /, 'if-range - 206 partial reply');
+like($r, qr/^34$/m, 'if-range - correct content');
+
+# respect Last-Modified from non-cacheable response with If-Range
+
+my ($lm) = http_get('/t') =~ /Last-Modified: (.*)/;
+$r = get('/proxy/t', "Range: bytes=3-4\nIf-Range: $lm");
+like($r, qr/ 206 /, 'if-range last-modified proxy - 206 partial reply');
+like($r, qr/^34$/m, 'if-range last-modified proxy - correct content');
+
+$r = get('/cache/t?ifb', "Range: bytes=3-4\nIf-Range: bad");
+like($r, qr/ 200 /, 'if-range bad - 200 ok');
+like($r, qr/^0123456789abcdef$/m, 'if-range bad - correct content');
+
+# first slice isn't known
+
+$r = get('/cache/t?skip', "Range: bytes=6-7\nIf-Range: $etag");
+like($r, qr/ 206 /, 'if-range skip slice - 206 partial reply');
+like($r, qr/^67$/m, 'if-range skip slice - correct content');
+
+$r = get('/cache/t?skip', "Range: bytes=6-7\nIf-Range: $etag");
+like($r, qr/ 206 /, 'if-range skip slice - cached - 206 partial reply');
+like($r, qr/^67$/m, 'if-range skip slice - cached - correct content');
+like($r, qr/HIT/, 'if-range skip bytes - cached - cache status');
+
+$r = get('/cache/t?skip', "Range: bytes=2-3");
+like($r, qr/ 206 /, 'if-range skip slice - skipped - 206 partial reply');
+like($r, qr/^23$/m, 'if-range skip slice - skipped - correct content');
+like($r, qr/MISS/, 'if-range skip bytes - skipped - cache status');
+
+SKIP: {
+	eval { require FCGI; };
+	skip 'FCGI not installed', 5 if $@;
+	skip 'win32', 5 if $^O eq 'MSWin32';
+
+	$t->run_daemon(\&fastcgi_daemon);
+	$t->waitforsocket('127.0.0.1:' . port(8082));
+
+	like(http_get('/fastcgi'), qr/200 OK.*MISS.*^012345678$/ms, 'fastcgi');
+	like(http_get('/fastcgi'), qr/200 OK.*HIT.*^012345678$/ms,
+		'fastcgi cached');
+
+	like(get("/fastcgi?1", "Range: bytes=0-0"), qr/ 206 .*MISS.*^0$/ms,
+		'fastcgi slice');
+	like(get("/fastcgi?1", "Range: bytes=1-1"), qr/ 206 .*HIT.*^1$/ms,
+		'fastcgi slice cached');
+	like(get("/fastcgi?1", "Range: bytes=2-2"), qr/ 206 .*MISS.*^2$/ms,
+		'fastcgi slice next');
+}
+
+# slicing in named location
+
+$r = http_get('/cache-redirect');
+
+like($r, qr/ 200 .*^0123456789abcdef$/ms, 'in named location');
+is(scalar @{[ glob $t->testdir() . '/cach3/*' ]}, 8,
+	'in named location - cache entries');
+
+###############################################################################
+
+sub get {
+	my ($url, $extra) = @_;
+	return http(<<EOF);
+GET $url HTTP/1.1
+Host: localhost
+Connection: close
+$extra
+
+EOF
+}
+
+###############################################################################
+
+sub fastcgi_daemon {
+	my $socket = FCGI::OpenSocket('127.0.0.1:' . port(8082), 5);
+	my $request = FCGI::Request(\*STDIN, \*STDOUT, \*STDERR, \%ENV,
+		$socket);
+
+	my $body = '012345678';
+	my $len = length($body);
+
+	while ($request->Accept() >= 0) {
+		my ($start, $stop) = $ENV{Range} =~ /bytes=(\d+)-(\d+)/;
+		my $body = substr($body, $start, ($stop - $start) + 1);
+		$stop = $len - 1 if $stop > $len - 1;
+
+		print <<EOF;
+Status: 206
+Content-Type: text/html
+Content-Range: bytes $start-$stop/$len
+
+EOF
+
+		print $body;
+	}
+
+	FCGI::CloseSocket($socket);
+}
+
+###############################################################################
diff --git a/tests/split_clients.t b/tests/split_clients.t
new file mode 100644
index 0000000..7666e1c
--- /dev/null
+++ b/tests/split_clients.t
@@ -0,0 +1,85 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for split_client module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http split_clients/)->plan(1);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    split_clients $connection $variant {
+        51.2%  ".one";
+        10%    ".two";
+        *      ".three";
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            index index${variant}.html;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('index.one.html', 'first');
+$t->write_file('index.two.html', 'second');
+$t->write_file('index.three.html', 'third');
+
+$t->run();
+
+###############################################################################
+
+# NB: split_clients distribution is a subject to implementation details
+
+like(many('/', 20), qr/first: 12, second: 2, third: 6/, 'split');
+
+###############################################################################
+
+sub many {
+	my ($uri, $count) = @_;
+	my %dist;
+
+	for (1 .. $count) {
+		if (http_get($uri) =~ /(first|second|third)/) {
+			$dist{$1} = 0 unless defined $dist{$1};
+			$dist{$1}++;
+		}
+	}
+
+	return join ', ', map { $_ . ": " . $dist{$_} } sort keys %dist;
+}
+
+###############################################################################
diff --git a/tests/ssi.t b/tests/ssi.t
new file mode 100644
index 0000000..9f696dc
--- /dev/null
+++ b/tests/ssi.t
@@ -0,0 +1,193 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for nginx ssi module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http ssi cache proxy rewrite/)
+	->plan(27);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    proxy_cache_path       %%TESTDIR%%/cache levels=1:2
+                           keys_zone=NAME:1m;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        if ($args = "found") {
+            return 204;
+        }
+
+        location / {
+            ssi on;
+        }
+        location /proxy/ {
+            ssi on;
+            proxy_pass http://127.0.0.1:8080/local/;
+        }
+        location /cache/ {
+            proxy_pass http://127.0.0.1:8080/local/;
+            proxy_cache NAME;
+            proxy_cache_valid 200 1h;
+        }
+        location /local/ {
+            ssi off;
+            alias %%TESTDIR%%/;
+        }
+        location = /test-empty-postpone.html {
+            ssi on;
+            postpone_output 0;
+        }
+        location /var {
+            ssi on;
+            add_header X-Var x${date_gmt}x;
+        }
+        location /var_noformat {
+            ssi on;
+            add_header X-Var x${date_gmt}x;
+            return 200;
+        }
+        location /var_nossi {
+            add_header X-Var x${date_gmt}x;
+            return 200;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('test1.html', 'X<!--#echo var="arg_test" -->X');
+$t->write_file('test2.html',
+	'X<!--#include virtual="/test1.html?test=test" -->X');
+$t->write_file('test3.html',
+	'X<!--#set var="blah" value="test" --><!--#echo var="blah" -->X');
+$t->write_file('test-args-rewrite.html',
+	'X<!--#include virtual="/check?found" -->X');
+$t->write_file('test-empty1.html', 'X<!--#include virtual="/empty.html" -->X');
+$t->write_file('test-empty2.html',
+	'X<!--#include virtual="/local/empty.html" -->X');
+$t->write_file('test-empty3.html',
+	'X<!--#include virtual="/cache/empty.html" -->X');
+$t->write_file('test-empty-postpone.html',
+	'X<!--#include virtual="/proxy/empty.html" -->X');
+$t->write_file('empty.html', '');
+
+$t->write_file('unescape.html?', 'SEE-THIS') unless $^O eq 'MSWin32';
+$t->write_file('unescape1.html',
+	'X<!--#include virtual="/tes%741.html?test=test" -->X');
+$t->write_file('unescape2.html',
+	'X<!--#include virtual="/unescape.html%3f" -->X');
+$t->write_file('unescape3.html',
+	'X<!--#include virtual="/test1.html%3ftest=test" -->X');
+
+$t->write_file('var_format.html',
+	'x<!--#if expr="$arg_custom" -->'
+		. '<!--#config timefmt="%A, %H:%M:%S" -->'
+		. '<!--#set var="v" value="$date_gmt" -->'
+		. '<!--#echo var="v" -->'
+	. '<!--#else -->'
+		. '<!--#set var="v" value="$date_gmt" -->'
+		. '<!--#echo var="v" -->'
+	. '<!--#endif -->x');
+
+$t->run();
+
+###############################################################################
+
+like(http_get('/test1.html'), qr/^X\(none\)X$/m, 'echo no argument');
+like(http_get('/test1.html?test='), qr/^XX$/m, 'empty argument');
+like(http_get('/test1.html?test=test'), qr/^XtestX$/m, 'argument');
+like(http_get('/test1.html?test=test&a=b'), qr/^XtestX$/m, 'argument 2');
+like(http_get('/test1.html?a=b&test=test'), qr/^XtestX$/m, 'argument 3');
+like(http_get('/test1.html?a=b&test=test&d=c'), qr/^XtestX$/m, 'argument 4');
+like(http_get('/test1.html?atest=a&testb=b&ctestc=c&test=test'), qr/^XtestX$/m,
+	'argument 5');
+
+like(http_get('/test2.html'), qr/^XXtestXX$/m, 'argument via include');
+
+like(http_get('/test3.html'), qr/^XtestX$/m, 'set');
+
+# args should be in subrequest even if original request has no args and that
+# was queried somehow (e.g. by server rewrites)
+
+like(http_get('/test-args-rewrite.html'), qr/^XX$/m, 'args only subrequest');
+
+like(http_get('/test-args-rewrite.html?wasargs'), qr/^XX$/m,
+	'args was in main request');
+
+# Last-Modified and Accept-Ranges headers should be cleared
+
+unlike(http_get('/test1.html'), qr/Last-Modified|Accept-Ranges/im,
+	'cleared headers');
+unlike(http_get('/proxy/test1.html'), qr/Last-Modified|Accept-Ranges/im,
+	'cleared headers from proxy');
+
+# empty subrequests
+
+like(http_get('/test-empty1.html'), qr/HTTP/, 'empty with ssi');
+like(http_get('/test-empty2.html'), qr/HTTP/, 'empty without ssi');
+like(http_get('/test-empty3.html'), qr/HTTP/, 'empty with proxy');
+like(http_get('/test-empty3.html'), qr/HTTP/, 'empty with proxy cached');
+
+like(http_get('/test-empty-postpone.html'), qr/HTTP.*XX/ms,
+	'empty with postpone_output 0');
+
+# handling of escaped URIs
+
+like(http_get('/unescape1.html'), qr/^XXtestXX$/m, 'escaped in path');
+
+SKIP: {
+skip 'incorrect filename on win32', 2 if $^O eq 'MSWin32';
+
+like(http_get('/unescape2.html'), qr/^XSEE-THISX$/m,
+	'escaped question in path');
+like(http_get('/unescape3.html'), qr/404 Not Found/,
+	'escaped query separator');
+
+}
+
+# handling of embedded date variables
+
+my $re_date_gmt = qr/X-Var: x.+, \d\d-.+-\d{4} \d\d:\d\d:\d\d .+x/;
+
+like(http_get('/var_nossi.html'), $re_date_gmt, 'no ssi');
+like(http_get('/var_noformat.html'), $re_date_gmt, 'no format');
+
+like(http_get('/var_format.html?custom=1'), $re_date_gmt, 'custom header');
+like(http_get('/var_format.html'), $re_date_gmt, 'default header');
+
+like(http_get('/var_format.html?custom=1'),
+	qr/x.+, \d\d:\d\d:\d\dx/, 'custom ssi');
+like(http_get('/var_format.html'),
+	qr/x.+, \d\d-.+-\d{4} \d\d:\d\d:\d\d .+x/, 'default ssi');
+
+###############################################################################
diff --git a/tests/ssi_delayed.t b/tests/ssi_delayed.t
new file mode 100644
index 0000000..3d4d23a
--- /dev/null
+++ b/tests/ssi_delayed.t
@@ -0,0 +1,118 @@
+#!/usr/bin/perl
+
+# (C) Andrey Zelenkov
+# (C) Roman Arutyunyan
+# (C) Nginx, Inc.
+
+# Test for subrequest bug with delay (see 903fb1ddc07f for details).
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy ssi/)->plan(1);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / { }
+        location /delayed.html {
+            ssi on;
+            sendfile_max_chunk 100;
+            postpone_output 0;
+        }
+
+        location /1 {
+            proxy_buffers 3 256;
+            proxy_buffer_size 256;
+            proxy_max_temp_file_size 0;
+            proxy_pass http://127.0.0.1:8081;
+        }
+    }
+}
+
+EOF
+
+
+$t->write_file('delayed.html', ('x' x 100) . '<!--#include virtual="/1"-->');
+
+$t->run_daemon(\&http_daemon);
+$t->run()->waitforsocket('127.0.0.1:' . port(8081));
+
+###############################################################################
+
+# If a response sending is delayed by sendfile_max_chunk, and
+# then we've switched to a different subrequest, which is not yet
+# ready to handle corresponding write event, wev->delayed won't be
+# cleared.  This results in the subrequest response not being
+# sent to the client, and the whole request will hang if all proxy
+# buffers will be exhausted.  Fixed in 1.11.13 (903fb1ddc07f).
+
+like(http_get('/delayed.html'), qr/x{100}y{1024}SEE-THIS/, 'delayed');
+
+###############################################################################
+
+sub http_daemon {
+	my ($t) = @_;
+
+	my $server = IO::Socket::INET->new(
+		Proto => 'tcp',
+		LocalHost => '127.0.0.1',
+		LocalPort => port(8081),
+		Listen => 5,
+		Reuse => 1
+	)
+		or die "Can't create listening socket: $!\n";
+
+	local $SIG{PIPE} = 'IGNORE';
+
+	my $data = ('y' x 1024) . 'SEE-THIS';
+
+	while (my $client = $server->accept()) {
+		$client->autoflush(1);
+
+		my $headers = '';
+
+		while (<$client>) {
+			$headers .= $_;
+			last if (/^\x0d?\x0a?$/);
+		}
+
+		select undef, undef, undef, 0.5;
+
+		print $client <<EOF;
+HTTP/1.1 200 OK
+Connection: close
+
+$data
+EOF
+	}
+}
+
+###############################################################################
diff --git a/tests/ssi_if.t b/tests/ssi_if.t
new file mode 100644
index 0000000..a5fdf02
--- /dev/null
+++ b/tests/ssi_if.t
@@ -0,0 +1,273 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+# (C) Valentin Bartenev
+
+# Tests for nginx ssi module, "if" statement.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http ssi/)->plan(43);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+        location / {
+            ssi on;
+        }
+    }
+}
+
+EOF
+
+
+my $if_elif_else =
+	'<!--#if expr="$arg_if" -->IF'
+	. '<!--#elif expr="$arg_elif" -->ELIF'
+	. '<!--#else -->ELSE'
+	. '<!--#endif -->';
+
+my $zig = 'GOOD';
+my $zag = 'GOOD';
+
+foreach my $i (reverse 1 .. 15) {
+	if ($i % 2) {
+		$zig =
+		"<!--#if expr='\$arg_$i' -->$i<!--#else -->$zig<!--#endif -->";
+		$zag =
+		"<!--#if expr='\$arg_$i' -->$zag<!--#else -->$i<!--#endif -->";
+	} else {
+		$zig =
+		"<!--#if expr='\$arg_$i' -->$zig<!--#else -->$i<!--#endif -->";
+		$zag =
+		"<!--#if expr='\$arg_$i' -->$i<!--#else -->$zag<!--#endif -->";
+	}
+}
+
+$t->run();
+
+###############################################################################
+
+$t->write_file('if_var.html', 'x<!--#if expr="$arg_v" -->OK<!--#endif -->x');
+
+like(http_get('/if_var.html?v=1'), qr/^xOKx$/m, 'if variable exists');
+like(http_get('/if_var.html'), qr/^xx$/m, 'if variable not exists');
+
+
+$t->write_file('if_eq.html',
+	'x<!--#if expr="$arg_v = equal" -->OK<!--#endif -->x');
+
+like(http_get('/if_eq.html?v=equal'), qr/^xOKx$/m, 'if var = text');
+like(http_get('/if_eq.html?v=notequal'), qr/^xx$/m, 'if var = text (false)');
+
+
+$t->write_file('if_neq.html',
+	'x<!--#if expr="equal != $arg_v" -->OK<!--#endif -->x');
+
+like(http_get('/if_neq.html?v=notequal'), qr/^xOKx$/m, 'if text != var');
+like(http_get('/if_neq.html?v=equal'), qr/^xx$/m, 'if text != var (false)');
+
+
+SKIP: {
+	# PCRE may not be available unless we have rewrite module
+
+	skip 'no PCRE', 4 unless $t->has_module('rewrite');
+
+	$t->write_file('if_eq_re.html',
+		'x<!--#if expr="$arg_v = /re+gexp?/" -->OK<!--#endif -->x');
+
+	like(http_get('/if_eq_re.html?v=XreeeegexX'), qr/^xOKx$/m,
+		'if var = /regex/');
+	like(http_get('/if_eq_re.html?v=XrgxX'), qr/^xx$/m,
+		'if var = /regex/ (false)');
+
+
+	$t->write_file('if_neq_re.html',
+		'x<!--#if expr="$arg_v != /re+gexp?/" -->OK<!--#endif -->x');
+
+	like(http_get('/if_neq_re.html?v=XrgxX'), qr/^xOKx$/m,
+		'if var != /regex/');
+	like(http_get('/if_neq_re.html?v=XreeeegexX'), qr/^xx$/m,
+		'if var != /regex/ (false)');
+}
+
+
+$t->write_file('if_varvar.html',
+	'x<!--#if expr="$arg_v = var$arg_v2" -->OK<!--#endif -->x');
+
+like(http_get('/if_varvar.html?v=varHERE&v2=HERE'), qr/^xOKx$/m,
+	'if var = complex');
+
+
+SKIP: {
+	# PCRE may not be available unless we have rewrite module
+
+	skip 'no PCRE', 2 unless $t->has_module('rewrite');
+
+	$t->write_file('if_cap_re.html',
+		'x<!--#if expr="$arg_v = /(CAP\d).*(CAP\d)/" -->'
+			. '<!--#echo var="1" -->x<!--#echo var="2" -->'
+		. '<!--#endif -->x');
+
+	like(http_get('/if_cap_re.html?v=hereCAP1andCAP2'), qr/^xCAP1xCAP2x$/m,
+		'if regex with captures');
+
+
+	$t->write_file('if_ncap_re.html',
+		'x<!--#if expr="$arg_v = /(?P<ncap>HERE)/" -->'
+			. '<!--#echo var="ncap" -->'
+		. '<!--#endif -->x');
+
+	like(http_get('/if_ncap_re.html?v=captureHEREeee'), qr/^xHEREx$/m,
+		'if regex with named capture');
+}
+
+
+$t->write_file('if.html', 'x' . $if_elif_else . 'x');
+
+like(http_get('/if.html?if=1'), qr/^xIFx$/m, 'if');
+like(http_get('/if.html?if=1&elif=1'), qr/^xIFx$/m, 'if suppresses elif');
+like(http_get('/if.html?elif=1'), qr/^xELIFx$/m, 'elif');
+like(http_get('/if.html'), qr/^xELSEx$/m, 'else');
+
+
+$t->write_file('if_multi.html',
+	'x<!--#if expr="$arg_1" -->IF1<!--#else -->ELSE1<!--#endif -->'
+	. 'x<!--#if expr="$arg_2" -->IF2<!--#else -->ELSE2<!--#endif -->'
+	. 'x<!--#if expr="$arg_3" -->IF3<!--#else -->ELSE3<!--#endif -->'
+	. 'x<!--#if expr="$arg_4" -->IF4<!--#else -->ELSE4<!--#endif -->'
+	. 'x<!--#if expr="$arg_5" -->IF5<!--#else -->ELSE5<!--#endif -->x');
+
+like(http_get('/if_multi.html?1=t&2=t&3=t&4=t&5=t'),
+	qr/^xIF1xIF2xIF3xIF4xIF5x$/m, 'multiple if (sequentially)');
+like(http_get('/if_multi.html?1=t&3=t&5=t'), qr/^xIF1xELSE2xIF3xELSE4xIF5x$/m,
+	'multiple if (interlaced)');
+like(http_get('/if_multi.html?2=t&4=t'), qr/^xELSE1xIF2xELSE3xIF4xELSE5x$/m,
+	'multiple if (interlaced reversed)');
+
+
+$t->write_file('if_in_block.html',
+	'<!--#block name="one" -->' . $if_elif_else . '<!--#endblock -->'
+	. 'x<!--#include virtual="/404?$args" stub="one" -->x');
+
+like(http_get('/if_in_block.html?if=1'), qr/^xIFx$/m, 'if (in block)');
+like(http_get('/if_in_block.html?if=1&elif=1'), qr/^xIFx$/m,
+	'if suppresses elif (in block)');
+like(http_get('/if_in_block.html?elif=1'), qr/^xELIFx$/m, 'elif (in block)');
+like(http_get('/if_in_block.html'), qr/^xELSEx$/m, 'else (in block)');
+
+
+$t->write_file('if_config_set_echo.html',
+	'x<!--#if expr="$arg_if" -->'
+		. '<!--#config timefmt="IF" -->'
+		. '<!--#set var="v" value="$date_gmt" -->'
+		. '<!--#echo var="v" -->'
+	. '<!--#else -->'
+		. '<!--#config timefmt="ELSE" -->'
+		. '<!--#set var="v" value="$date_gmt" -->'
+		. '<!--#echo var="v" -->'
+	. '<!--#endif -->x');
+
+like(http_get('/if_config_set_echo.html?if=1'), qr/^xIFx$/m,
+	'if config-set-echo');
+like(http_get('/if_config_set_echo.html'), qr/^xELSEx$/m,
+	'else config-set-echo');
+
+
+$t->write_file('if_include.html',
+	'x<!--#if expr="$arg_if" -->'
+		. '<!--#include virtual="/if.html?if=1" -->'
+	. '<!--#else -->'
+		. '<!--#include virtual="/if.html" -->'
+	. '<!--#endif -->x');
+
+like(http_get('/if_include.html?if=1'), qr/^xxIFxx$/m,
+	'if include');
+like(http_get('/if_include.html'), qr/^xxELSExx$/m,
+	'else include');
+
+
+$t->write_file('if_block.html',
+	'<!--#if expr="$arg_if" -->'
+		. '<!--#block name="one" -->IF<!--#endblock -->'
+	. '<!--#else -->'
+		. '<!--#block name="one" -->ELSE<!--#endblock -->'
+	. '<!--#endif -->'
+	. 'x<!--#include virtual="/404" stub="one" -->x');
+
+like(http_get('/if_block.html?if=1'), qr/^xIFx$/m, 'if block');
+like(http_get('/if_block.html'), qr/^xELSEx$/m, 'else block');
+
+
+TODO: {
+local $TODO = 'support for nested ifs';
+
+$t->write_file('ifif.html',
+	'x<!--#if expr="$arg__if" -->IFx' . $if_elif_else
+	. '<!--#elif expr="$arg__elif" -->ELIFx' . $if_elif_else
+	. '<!--#else -->ELSEx' . $if_elif_else
+	. '<!--#endif -->x');
+
+like(http_get('/ifif.html?_if=1&if=1'), qr/^xIFxIFx$/m, 'if if');
+like(http_get('/ifif.html?_if=1&elif=1'), qr/^xIFxELIFx$/m, 'if elif');
+like(http_get('/ifif.html?_if=1'), qr/^xIFxELSEx$/m, 'if else');
+
+like(http_get('/ifif.html?_elif=1&if=1'), qr/^xELIFxIFx$/m, 'elif if');
+like(http_get('/ifif.html?_elif=1&elif=1'), qr/^xELIFxELIFx$/m, 'elif elif');
+like(http_get('/ifif.html?_elif=1'), qr/^xELIFxELSEx$/m, 'elif else');
+
+like(http_get('/ifif.html?if=1'), qr/^xELSExIFx$/m, 'else if');
+like(http_get('/ifif.html?elif=1'), qr/^xELSExELIFx$/m, 'else elif');
+like(http_get('/ifif.html'), qr/^xELSExELSEx$/m, 'else else');
+
+
+$t->write_file('zigzag.html',
+	"x<!--#if expr='\$arg_0' -->$zig<!--#else -->$zag<!--#endif -->x");
+
+like(http_get('/zigzag.html?0=t&2=t&4=t&6=t&8=t&10=t&12=t&14=t'),
+	qr/^xGOODx$/m, 'zigzag');
+like(http_get('/zigzag.html?1=t&3=t&5=t&7=t&9=t&11=t&13=t&15=t'),
+	qr/^xGOODx$/m, 'zagzig');
+
+
+$t->write_file('zigzag_block.html',
+	'<!--#block name="one" -->'
+	. "x<!--#if expr='\$arg_0' -->$zig<!--#else -->$zag<!--#endif -->x"
+	. '<!--#endblock -->'
+	. 'x<!--#include virtual="/404?$args" stub="one" -->x');
+
+like(http_get('/zigzag_block.html?0=t&2=t&4=t&6=t&8=t&10=t&12=t&14=t'),
+	qr/^xGOODx$/m, 'zigzag block');
+like(http_get('/zigzag_block.html?1=t&3=t&5=t&7=t&9=t&11=t&13=t&15=t'),
+	qr/^xGOODx$/m, 'zagzig block');
+
+}
+
+###############################################################################
diff --git a/tests/ssi_include_big.t b/tests/ssi_include_big.t
new file mode 100644
index 0000000..ed1f2c1
--- /dev/null
+++ b/tests/ssi_include_big.t
@@ -0,0 +1,89 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for nginx ssi bug with big includes.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx qw/ :DEFAULT :gzip /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http ssi rewrite gzip proxy/)->plan(8);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    output_buffers  2 512;
+    ssi on;
+    gzip on;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /proxy/ {
+            proxy_pass http://127.0.0.1:8080/local/;
+        }
+        location = /local/blah {
+            return 204;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('c1.html', 'X' x 1023);
+$t->write_file('c2.html', 'X' x 1024);
+$t->write_file('c3.html', 'X' x 1025);
+$t->write_file('test1.html', '<!--#include virtual="/proxy/blah" -->'
+	. '<!--#include virtual="/c1.html" -->');
+$t->write_file('test2.html', '<!--#include virtual="/proxy/blah" -->'
+	. '<!--#include virtual="/c2.html" -->');
+$t->write_file('test3.html', '<!--#include virtual="/proxy/blah" -->'
+	. '<!--#include virtual="/c3.html" -->');
+$t->write_file('test4.html', '<!--#include virtual="/proxy/blah" -->'
+	. ('X' x 1025));
+
+$t->run();
+
+###############################################################################
+
+my $t1 = http_gzip_request('/test1.html');
+ok(defined $t1, 'small included file (less than output_buffers)');
+http_gzip_like($t1, qr/^X{1023}\Z/, 'small included file content');
+
+my $t2 = http_gzip_request('/test2.html');
+ok(defined $t2, 'small included file (equal to output_buffers)');
+http_gzip_like($t2, qr/^X{1024}\Z/, 'small included file content');
+
+my $t3 = http_gzip_request('/test3.html');
+ok(defined $t3, 'big included file (more than output_buffers)');
+http_gzip_like($t3, qr/^X{1025}\Z/, 'big included file content');
+
+my $t4 = http_gzip_request('/test4.html');
+ok(defined $t4, 'big ssi main file');
+http_gzip_like($t4, qr/^X{1025}\Z/, 'big ssi main file content');
+
+###############################################################################
diff --git a/tests/ssi_waited.t b/tests/ssi_waited.t
new file mode 100644
index 0000000..8960604
--- /dev/null
+++ b/tests/ssi_waited.t
@@ -0,0 +1,62 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for nginx ssi module, waited subrequests.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http ssi/)->plan(1);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+        location / {
+            ssi on;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('index.html', 'x<!--#include virtual="/first.html" -->' .
+	'x<!--#include virtual="/second.html" -->x');
+$t->write_file('first.html', 'FIRST');
+$t->write_file('second.html',
+	'<!--#include virtual="/waited.html" wait="yes"-->xSECOND');
+$t->write_file('waited.html', 'WAITED');
+
+$t->run();
+
+###############################################################################
+
+like(http_get('/'), qr/^xFIRSTxWAITEDxSECONDx$/m, 'waited non-active');
+
+###############################################################################
diff --git a/tests/ssl.t b/tests/ssl.t
new file mode 100644
index 0000000..ac08c45
--- /dev/null
+++ b/tests/ssl.t
@@ -0,0 +1,371 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+
+# Tests for http ssl module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require IO::Socket::SSL; };
+plan(skip_all => 'IO::Socket::SSL not installed') if $@;
+eval { IO::Socket::SSL::SSL_VERIFY_NONE(); };
+plan(skip_all => 'IO::Socket::SSL too old') if $@;
+
+my $t = Test::Nginx->new()->has(qw/http http_ssl rewrite proxy/)
+	->has_daemon('openssl')->plan(24);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    ssl_certificate_key localhost.key;
+    ssl_certificate localhost.crt;
+    ssl_session_tickets off;
+
+    server {
+        listen       127.0.0.1:8085 ssl;
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        ssl_certificate_key inner.key;
+        ssl_certificate inner.crt;
+        ssl_session_cache shared:SSL:1m;
+        ssl_verify_client optional_no_ca;
+
+        keepalive_requests 1000;
+
+        location / {
+            return 200 "body $ssl_session_reused";
+        }
+        location /id {
+            return 200 "body $ssl_session_id";
+        }
+        location /cipher {
+            return 200 "body $ssl_cipher";
+        }
+        location /ciphers {
+            return 200 "body $ssl_ciphers";
+        }
+        location /client_verify {
+            return 200 "body $ssl_client_verify";
+        }
+        location /protocol {
+            return 200 "body $ssl_protocol";
+        }
+        location /issuer {
+            return 200 "body $ssl_client_i_dn:$ssl_client_i_dn_legacy";
+        }
+        location /subject {
+            return 200 "body $ssl_client_s_dn:$ssl_client_s_dn_legacy";
+        }
+        location /time {
+            return 200 "body $ssl_client_v_start!$ssl_client_v_end!$ssl_client_v_remain";
+        }
+
+        location /body {
+            add_header X-Body $request_body always;
+            proxy_pass http://127.0.0.1:8080/;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        # Special case for enabled "ssl" directive.
+
+        ssl on;
+        ssl_session_cache builtin;
+        ssl_session_timeout 1;
+
+        location / {
+            return 200 "body $ssl_session_reused";
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8082 ssl;
+        server_name  localhost;
+
+        ssl_session_cache builtin:1000;
+
+        location / {
+            return 200 "body $ssl_session_reused";
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8083 ssl;
+        server_name  localhost;
+
+        ssl_session_cache none;
+
+        location / {
+            return 200 "body $ssl_session_reused";
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8084 ssl;
+        server_name  localhost;
+
+        ssl_session_cache off;
+
+        location / {
+            return 200 "body $ssl_session_reused";
+        }
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+$t->write_file('ca.conf', <<EOF);
+[ ca ]
+default_ca = myca
+
+[ myca ]
+new_certs_dir = $d
+database = $d/certindex
+default_md = sha256
+policy = myca_policy
+serial = $d/certserial
+default_days = 3
+
+[ myca_policy ]
+commonName = supplied
+EOF
+
+$t->write_file('certserial', '1000');
+$t->write_file('certindex', '');
+
+system('openssl req -x509 -new '
+	. "-config $d/openssl.conf -subj /CN=issuer/ "
+	. "-out $d/issuer.crt -keyout $d/issuer.key "
+	. ">>$d/openssl.out 2>&1") == 0
+	or die "Can't create certificate for issuer: $!\n";
+
+system("openssl req -new "
+	. "-config $d/openssl.conf -subj /CN=subject/ "
+	. "-out $d/subject.csr -keyout $d/subject.key "
+	. ">>$d/openssl.out 2>&1") == 0
+	or die "Can't create certificate for subject: $!\n";
+
+system("openssl ca -batch -config $d/ca.conf "
+	. "-keyfile $d/issuer.key -cert $d/issuer.crt "
+	. "-subj /CN=subject/ -in $d/subject.csr -out $d/subject.crt "
+	. ">>$d/openssl.out 2>&1") == 0
+	or die "Can't sign certificate for subject: $!\n";
+
+foreach my $name ('localhost', 'inner') {
+	system('openssl req -x509 -new '
+		. "-config $d/openssl.conf -subj /CN=$name/ "
+		. "-out $d/$name.crt -keyout $d/$name.key "
+		. ">>$d/openssl.out 2>&1") == 0
+		or die "Can't create certificate for $name: $!\n";
+}
+
+# suppress deprecation warning
+
+open OLDERR, ">&", \*STDERR; close STDERR;
+$t->run();
+open STDERR, ">&", \*OLDERR;
+
+###############################################################################
+
+my $ctx;
+
+SKIP: {
+skip 'no TLS 1.3 sessions', 6 if get('/protocol', 8085) =~ /TLSv1.3/
+	&& ($Net::SSLeay::VERSION < 1.88 || $IO::Socket::SSL::VERSION < 2.061);
+
+$ctx = get_ssl_context();
+
+like(get('/', 8085, $ctx), qr/^body \.$/m, 'cache shared');
+like(get('/', 8085, $ctx), qr/^body r$/m, 'cache shared reused');
+
+$ctx = get_ssl_context();
+
+like(get('/', 8081, $ctx), qr/^body \.$/m, 'cache builtin');
+like(get('/', 8081, $ctx), qr/^body r$/m, 'cache builtin reused');
+
+$ctx = get_ssl_context();
+
+like(get('/', 8082, $ctx), qr/^body \.$/m, 'cache builtin size');
+like(get('/', 8082, $ctx), qr/^body r$/m, 'cache builtin size reused');
+
+}
+
+$ctx = get_ssl_context();
+
+like(get('/', 8083, $ctx), qr/^body \.$/m, 'cache none');
+like(get('/', 8083, $ctx), qr/^body \.$/m, 'cache none not reused');
+
+$ctx = get_ssl_context();
+
+like(get('/', 8084, $ctx), qr/^body \.$/m, 'cache off');
+like(get('/', 8084, $ctx), qr/^body \.$/m, 'cache off not reused');
+
+# ssl certificate inheritance
+
+my $s = get_ssl_socket(8081);
+like($s->dump_peer_certificate(), qr/CN=localhost/, 'CN');
+
+$s->close();
+
+$s = get_ssl_socket(8085);
+like($s->dump_peer_certificate(), qr/CN=inner/, 'CN inner');
+
+$s->close();
+
+# session timeout
+
+select undef, undef, undef, 2.1;
+
+like(get('/', 8081), qr/^body \.$/m, 'session timeout');
+
+# embedded variables
+
+like(get('/id', 8085), qr/^body \w{64}$/m, 'session id');
+unlike(http_get('/id'), qr/body \w/, 'session id no ssl');
+like(get('/cipher', 8085), qr/^body [\w-]+$/m, 'cipher');
+
+SKIP: {
+skip 'BoringSSL', 1 if $t->has_module('BoringSSL');
+
+like(get('/ciphers', 8085), qr/^body [:\w-]+$/m, 'ciphers');
+
+}
+
+like(get('/client_verify', 8085), qr/^body NONE$/m, 'client verify');
+like(get('/protocol', 8085), qr/^body (TLS|SSL)v(\d|\.)+$/m, 'protocol');
+like(cert('/issuer', 8085), qr!^body CN=issuer:/CN=issuer$!m, 'issuer');
+like(cert('/subject', 8085), qr!^body CN=subject:/CN=subject$!m, 'subject');
+like(cert('/time', 8085), qr/^body [:\s\w]+![:\s\w]+![23]$/m, 'time');
+
+# c->read->ready handling bug in ngx_ssl_recv(), triggered with chunked body
+
+like(get_body('/body', '0123456789', 20, 5), qr/X-Body: (0123456789){100}/,
+	'request body chunked');
+
+# pipelined requests
+
+$s = get_ssl_socket(8085);
+my $req = <<EOF;
+GET / HTTP/1.1
+Host: localhost
+
+EOF
+
+$req x= 1000;
+
+my $r = http($req, socket => $s) || "";
+is(() = $r =~ /(200 OK)/g, 1000, 'pipelined requests');
+
+###############################################################################
+
+sub get {
+	my ($uri, $port, $ctx) = @_;
+	my $s = get_ssl_socket($port, $ctx) or return;
+	my $r = http_get($uri, socket => $s);
+	$s->close();
+	return $r;
+}
+
+sub get_body {
+	my ($uri, $body, $len, $n) = @_;
+	my $s = get_ssl_socket(8085) or return;
+	http("GET /body HTTP/1.1" . CRLF
+		. "Host: localhost" . CRLF
+		. "Connection: close" . CRLF
+		. "Transfer-Encoding: chunked" . CRLF . CRLF,
+		socket => $s, start => 1);
+	my $chs = unpack("H*", pack("C", length($body) * $len));
+	http($chs . CRLF . $body x $len . CRLF, socket => $s, start => 1)
+		for 1 .. $n;
+	my $r = http("0" . CRLF . CRLF, socket => $s);
+	$s->close();
+	return $r;
+}
+
+sub cert {
+	my ($uri, $port) = @_;
+	my $s = get_ssl_socket($port, undef,
+		SSL_cert_file => "$d/subject.crt",
+		SSL_key_file => "$d/subject.key") or return;
+	http_get($uri, socket => $s);
+}
+
+sub get_ssl_context {
+	return IO::Socket::SSL::SSL_Context->new(
+		SSL_verify_mode => IO::Socket::SSL::SSL_VERIFY_NONE(),
+		SSL_session_cache_size => 100
+	);
+}
+
+sub get_ssl_socket {
+	my ($port, $ctx, %extra) = @_;
+	my $s;
+
+	eval {
+		local $SIG{ALRM} = sub { die "timeout\n" };
+		local $SIG{PIPE} = sub { die "sigpipe\n" };
+		alarm(8);
+		$s = IO::Socket::SSL->new(
+			Proto => 'tcp',
+			PeerAddr => '127.0.0.1',
+			PeerPort => port($port),
+			SSL_verify_mode => IO::Socket::SSL::SSL_VERIFY_NONE(),
+			SSL_reuse_ctx => $ctx,
+			SSL_error_trap => sub { die $_[1] },
+			%extra
+		);
+		alarm(0);
+	};
+	alarm(0);
+
+	if ($@) {
+		log_in("died: $@");
+		return undef;
+	}
+
+	return $s;
+}
+
+###############################################################################
diff --git a/tests/ssl_certificate.t b/tests/ssl_certificate.t
new file mode 100644
index 0000000..5d8bde8
--- /dev/null
+++ b/tests/ssl_certificate.t
@@ -0,0 +1,234 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http ssl module with dynamic certificates.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/ :DEFAULT CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval {
+	require Net::SSLeay;
+	Net::SSLeay::load_error_strings();
+	Net::SSLeay::SSLeay_add_ssl_algorithms();
+	Net::SSLeay::randomize();
+};
+plan(skip_all => 'Net::SSLeay not installed') if $@;
+
+eval {
+	my $ctx = Net::SSLeay::CTX_new() or die;
+	my $ssl = Net::SSLeay::new($ctx) or die;
+	Net::SSLeay::set_tlsext_host_name($ssl, 'example.org') == 1 or die;
+};
+plan(skip_all => 'Net::SSLeay with OpenSSL SNI support required') if $@;
+
+my $t = Test::Nginx->new()->has(qw/http http_ssl geo/)
+	->has_daemon('openssl');
+
+$t->{_configure_args} =~ /OpenSSL ([\d\.]+)/;
+plan(skip_all => 'OpenSSL too old') unless defined $1 and $1 ge '1.0.2';
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    geo $one {
+        default one;
+    }
+
+    geo $two {
+        default two;
+    }
+
+    geo $pass {
+        default pass;
+    }
+
+    add_header X-SSL $ssl_server_name:$ssl_session_reused;
+    ssl_session_cache shared:SSL:1m;
+    ssl_session_tickets off;
+
+    server {
+        listen       127.0.0.1:8080 ssl;
+        server_name  default;
+
+        ssl_certificate $one.crt;
+        ssl_certificate_key $one.key;
+    }
+
+    server {
+        listen       127.0.0.1:8080 ssl;
+        server_name  virtual;
+
+        # found in key
+        ssl_certificate $two.crt;
+        ssl_certificate_key $two.key;
+    }
+
+    server {
+        listen       127.0.0.1:8080 ssl;
+        server_name  no_ctx;
+    }
+
+    server {
+        listen       127.0.0.1:8083 ssl;
+        server_name  password;
+
+        # found in key
+        ssl_certificate pass.crt;
+        ssl_certificate_key $pass.key;
+        ssl_password_file password_file;
+    }
+
+    server {
+        listen       127.0.0.1:8081 ssl;
+        server_name  default;
+
+        ssl_certificate $one.crt;
+        ssl_certificate_key $one.key;
+    }
+
+    server {
+        listen       127.0.0.1:8082 ssl;
+        server_name  default;
+
+        ssl_certificate $two.crt;
+        ssl_certificate_key $two.key;
+    }
+
+    server {
+        listen       127.0.0.1:8084 ssl;
+        server_name  localhost;
+
+        ssl_certificate $ssl_server_name.crt;
+        ssl_certificate_key $ssl_server_name.key;
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('one', 'two') {
+	system('openssl req -x509 -new '
+		. "-config $d/openssl.conf -subj /CN=$name/ "
+		. "-out $d/$name.crt -keyout $d/$name.key "
+		. ">>$d/openssl.out 2>&1") == 0
+		or die "Can't create certificate for $name: $!\n";
+}
+
+foreach my $name ('pass') {
+	system("openssl genrsa -out $d/$name.key -passout pass:pass "
+		. "-aes128 2048 >>$d/openssl.out 2>&1") == 0
+		or die "Can't create $name key: $!\n";
+	system("openssl req -x509 -new -config $d/openssl.conf "
+		. "-subj /CN=$name/ -out $d/$name.crt -key $d/$name.key "
+		. "-passin pass:pass >>$d/openssl.out 2>&1") == 0
+		or die "Can't create $name certificate: $!\n";
+}
+
+$t->write_file('password_file', 'pass');
+$t->write_file('index.html', '');
+
+$t->run()->plan(11);
+
+###############################################################################
+
+like(cert('default', 8080), qr/CN=one/, 'default certificate');
+like(get('default', 8080), qr/default/, 'default context');
+
+like(cert('virtual', 8080), qr/CN=two/, 'virtual server certificate');
+like(get('virtual', 8080), qr/virtual/, 'virtual server context');
+
+like(cert('no_ctx', 8080), qr/CN=one/, 'certificate - no context');
+like(get('no_ctx', 8080), qr/no_ctx/, 'virtual server - no context');
+
+like(get('password', 8083), qr/password/, 'ssl_password_file');
+
+# session reuse
+
+my ($s, $ssl) = get('default', 8080);
+my $ses = Net::SSLeay::get_session($ssl);
+
+like(get('default', 8080, $ses), qr/default:r/, 'session reused');
+like(get('default', 8081, $ses), qr/default:r/, 'session id context match');
+like(get('default', 8082, $ses), qr/default:\./, 'session id context distinct');
+
+# errors
+
+Net::SSLeay::ERR_clear_error();
+get_ssl_socket('nx', 8084);
+ok(Net::SSLeay::ERR_peek_error(), 'no certificate');
+
+###############################################################################
+
+sub get {
+	my ($host, $port, $ctx) = @_;
+	my ($s, $ssl) = get_ssl_socket($host, $port, $ctx) or return;
+	Net::SSLeay::write($ssl, 'GET / HTTP/1.0' . CRLF . CRLF);
+	my $r = Net::SSLeay::read($ssl);
+	$s->close();
+	return $r unless wantarray();
+	return ($s, $ssl);
+}
+
+sub cert {
+	my ($host, $port, $ctx) = @_;
+	my ($s, $ssl) = get_ssl_socket($host, $port, $ctx) or return;
+	Net::SSLeay::dump_peer_certificate($ssl);
+}
+
+sub get_ssl_socket {
+	my ($host, $port, $ses) = @_;
+	my $s;
+
+	my $dest_ip = inet_aton('127.0.0.1');
+	$port = port($port);
+	my $dest_serv_params = sockaddr_in($port, $dest_ip);
+
+	socket($s, &AF_INET, &SOCK_STREAM, 0) or die "socket: $!";
+	connect($s, $dest_serv_params) or die "connect: $!";
+
+	my $ctx = Net::SSLeay::CTX_new() or die("Failed to create SSL_CTX $!");
+	my $ssl = Net::SSLeay::new($ctx) or die("Failed to create SSL $!");
+	Net::SSLeay::set_tlsext_host_name($ssl, $host);
+	Net::SSLeay::set_session($ssl, $ses) if defined $ses;
+	Net::SSLeay::set_fd($ssl, fileno($s));
+	Net::SSLeay::connect($ssl) or die("ssl connect");
+	return ($s, $ssl);
+}
+
+###############################################################################
diff --git a/tests/ssl_certificate_chain.t b/tests/ssl_certificate_chain.t
new file mode 100644
index 0000000..d2ab0c2
--- /dev/null
+++ b/tests/ssl_certificate_chain.t
@@ -0,0 +1,179 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http ssl module with certificate chain.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require IO::Socket::SSL; };
+plan(skip_all => 'IO::Socket::SSL not installed') if $@;
+eval { IO::Socket::SSL::SSL_VERIFY_NONE(); };
+plan(skip_all => 'IO::Socket::SSL too old') if $@;
+
+my $t = Test::Nginx->new()->has(qw/http http_ssl/)
+	->has_daemon('openssl')->plan(3);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080 ssl;
+        server_name  localhost;
+
+        ssl_certificate_key end.key;
+        ssl_certificate end.crt;
+    }
+
+    server {
+        listen       127.0.0.1:8081 ssl;
+        server_name  localhost;
+
+        ssl_certificate_key int.key;
+        ssl_certificate int.crt;
+    }
+
+    server {
+        listen       127.0.0.1:8082 ssl;
+        server_name  localhost;
+
+        ssl_certificate_key end.key;
+        ssl_certificate end-int.crt;
+    }
+}
+
+EOF
+
+my $d = $t->testdir();
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+$t->write_file('ca.conf', <<EOF);
+[ ca ]
+default_ca = myca
+
+[ myca ]
+new_certs_dir = $d
+database = $d/certindex
+default_md = sha256
+policy = myca_policy
+serial = $d/certserial
+default_days = 1
+x509_extensions = myca_extensions
+
+[ myca_policy ]
+commonName = supplied
+
+[ myca_extensions ]
+basicConstraints = critical,CA:TRUE
+EOF
+
+foreach my $name ('root') {
+	system('openssl req -x509 -new '
+		. "-config $d/openssl.conf -subj /CN=$name/ "
+		. "-out $d/$name.crt -keyout $d/$name.key "
+		. ">>$d/openssl.out 2>&1") == 0
+		or die "Can't create certificate for $name: $!\n";
+}
+
+foreach my $name ('int', 'end') {
+	system("openssl req -new "
+		. "-config $d/openssl.conf -subj /CN=$name/ "
+		. "-out $d/$name.csr -keyout $d/$name.key "
+		. ">>$d/openssl.out 2>&1") == 0
+		or die "Can't create certificate for $name: $!\n";
+}
+
+$t->write_file('certserial', '1000');
+$t->write_file('certindex', '');
+
+system("openssl ca -batch -config $d/ca.conf "
+	. "-keyfile $d/root.key -cert $d/root.crt "
+	. "-subj /CN=int/ -in $d/int.csr -out $d/int.crt "
+	. ">>$d/openssl.out 2>&1") == 0
+	or die "Can't sign certificate for int: $!\n";
+
+system("openssl ca -batch -config $d/ca.conf "
+	. "-keyfile $d/int.key -cert $d/int.crt "
+	. "-subj /CN=end/ -in $d/end.csr -out $d/end.crt "
+	. ">>$d/openssl.out 2>&1") == 0
+	or die "Can't sign certificate for end: $!\n";
+
+$t->write_file('end-int.crt',
+	$t->read_file('end.crt') . $t->read_file('int.crt'));
+
+$t->run();
+
+###############################################################################
+
+is(get_ssl_socket(port(8080)), undef, 'incomplete chain');
+ok(get_ssl_socket(port(8081)), 'intermediate');
+ok(get_ssl_socket(port(8082)), 'intermediate server');
+
+###############################################################################
+
+sub get_ssl_socket {
+	my ($port) = @_;
+	my ($s, $verify);
+
+	eval {
+		local $SIG{ALRM} = sub { die "timeout\n" };
+		local $SIG{PIPE} = sub { die "sigpipe\n" };
+		alarm(8);
+		$s = IO::Socket::SSL->new(
+			Proto => 'tcp',
+			PeerAddr => '127.0.0.1',
+			PeerPort => $port,
+			SSL_verify_mode => IO::Socket::SSL::SSL_VERIFY_PEER(),
+			SSL_ca_file => "$d/root.crt",
+			SSL_verify_callback => sub {
+				my ($ok) = @_;
+				$verify = $ok;
+				return $ok;
+			},
+			SSL_error_trap => sub { die $_[1] }
+		);
+		alarm(0);
+	};
+	alarm(0);
+
+	if ($@) {
+		log_in("died: $@");
+		return undef;
+	}
+
+	return $verify;
+}
+
+###############################################################################
diff --git a/tests/ssl_certificate_perl.t b/tests/ssl_certificate_perl.t
new file mode 100644
index 0000000..e76ce59
--- /dev/null
+++ b/tests/ssl_certificate_perl.t
@@ -0,0 +1,134 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http ssl module, loading certificates from memory with perl module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval {
+	require Net::SSLeay;
+	Net::SSLeay::load_error_strings();
+	Net::SSLeay::SSLeay_add_ssl_algorithms();
+	Net::SSLeay::randomize();
+};
+plan(skip_all => 'Net::SSLeay not installed') if $@;
+
+eval {
+	my $ctx = Net::SSLeay::CTX_new() or die;
+	my $ssl = Net::SSLeay::new($ctx) or die;
+	Net::SSLeay::set_tlsext_host_name($ssl, 'example.org') == 1 or die;
+};
+plan(skip_all => 'Net::SSLeay with OpenSSL SNI support required') if $@;
+
+my $t = Test::Nginx->new()->has(qw/http http_ssl perl/)->has_daemon('openssl');
+
+$t->{_configure_args} =~ /OpenSSL ([\d\.]+)/;
+plan(skip_all => 'OpenSSL too old') unless defined $1 and $1 ge '1.0.2';
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    perl_set $pem '
+        sub {
+            my $r = shift;
+            local $/;
+            my $sni = $r->variable("ssl_server_name");
+            open my $fh, "<", "%%TESTDIR%%/$sni.crt";
+            my $content = <$fh>;
+            close $fh;
+            return $content;
+        }
+    ';
+
+    server {
+        listen       127.0.0.1:8080 ssl;
+        server_name  localhost;
+
+        ssl_certificate data:$pem;
+        ssl_certificate_key data:$pem;
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('one', 'two') {
+	system('openssl req -x509 -new '
+		. "-config $d/openssl.conf -subj /CN=$name/ "
+		. "-out $d/$name.crt -keyout $d/$name.crt "
+		. ">>$d/openssl.out 2>&1") == 0
+		or die "Can't create certificate for $name: $!\n";
+}
+
+$t->run()->plan(2);
+
+###############################################################################
+
+like(cert('one', 8080), qr/CN=one/, 'certificate');
+like(cert('two', 8080), qr/CN=two/, 'certificate 2');
+
+###############################################################################
+
+sub cert {
+	my ($host, $port) = @_;
+	my ($s, $ssl) = get_ssl_socket($host, $port) or return;
+	Net::SSLeay::dump_peer_certificate($ssl);
+}
+
+sub get_ssl_socket {
+	my ($host, $port) = @_;
+	my $s;
+
+	my $dest_ip = inet_aton('127.0.0.1');
+	$port = port($port);
+	my $dest_serv_params = sockaddr_in($port, $dest_ip);
+
+	socket($s, &AF_INET, &SOCK_STREAM, 0) or die "socket: $!";
+	connect($s, $dest_serv_params) or die "connect: $!";
+
+	my $ctx = Net::SSLeay::CTX_new() or die("Failed to create SSL_CTX $!");
+	my $ssl = Net::SSLeay::new($ctx) or die("Failed to create SSL $!");
+	Net::SSLeay::set_tlsext_host_name($ssl, $host);
+	Net::SSLeay::set_fd($ssl, fileno($s));
+	Net::SSLeay::connect($ssl) or die("ssl connect");
+	return ($s, $ssl);
+}
+
+###############################################################################
diff --git a/tests/ssl_certificates.t b/tests/ssl_certificates.t
new file mode 100644
index 0000000..a6ec6ad
--- /dev/null
+++ b/tests/ssl_certificates.t
@@ -0,0 +1,155 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http ssl module with multiple certificates.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval {
+	require Net::SSLeay;
+	Net::SSLeay::load_error_strings();
+	Net::SSLeay::SSLeay_add_ssl_algorithms();
+	Net::SSLeay::randomize();
+	Net::SSLeay::SSLeay();
+};
+plan(skip_all => 'Net::SSLeay not installed or too old') if $@;
+
+my $t = Test::Nginx->new()->has(qw/http http_ssl/)->has_daemon('openssl');
+
+plan(skip_all => 'no multiple certificates') if $t->has_module('BoringSSL');
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    ssl_certificate_key rsa.key;
+    ssl_certificate rsa.crt;
+    ssl_ciphers DEFAULT:ECCdraft;
+
+    server {
+        listen       127.0.0.1:8080 ssl;
+        server_name  localhost;
+
+        ssl_certificate_key ec.key;
+        ssl_certificate ec.crt;
+
+        ssl_certificate_key rsa.key;
+        ssl_certificate rsa.crt;
+
+        ssl_certificate_key rsa.key;
+        ssl_certificate rsa.crt;
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+system("openssl ecparam -genkey -out $d/ec.key -name prime256v1 "
+	. ">>$d/openssl.out 2>&1") == 0 or die "Can't create EC pem: $!\n";
+system("openssl genrsa -out $d/rsa.key 2048 >>$d/openssl.out 2>&1") == 0
+        or die "Can't create RSA pem: $!\n";
+
+foreach my $name ('ec', 'rsa') {
+	system("openssl req -x509 -new -key $d/$name.key "
+		. "-config $d/openssl.conf -subj /CN=$name/ "
+		. "-out $d/$name.crt -keyout $d/$name.key "
+		. ">>$d/openssl.out 2>&1") == 0
+		or die "Can't create certificate for $name: $!\n";
+}
+
+$t->run()->plan(2);
+
+###############################################################################
+
+like(get_cert('RSA'), qr/CN=rsa/, 'ssl cert RSA');
+like(get_cert('ECDSA'), qr/CN=ec/, 'ssl cert ECDSA');
+
+###############################################################################
+
+sub get_version {
+	my ($s, $ssl) = get_ssl_socket();
+	return Net::SSLeay::version($ssl);
+}
+
+sub get_cert {
+	my ($type) = @_;
+	$type = 'PSS' if $type eq 'RSA' && get_version() > 0x0303;
+	my ($s, $ssl) = get_ssl_socket($type);
+	my $cipher = Net::SSLeay::get_cipher($ssl);
+	Test::Nginx::log_core('||', "cipher: $cipher");
+	return Net::SSLeay::dump_peer_certificate($ssl);
+}
+
+sub get_ssl_socket {
+	my ($type) = @_;
+	my $s;
+
+	eval {
+		local $SIG{ALRM} = sub { die "timeout\n" };
+		local $SIG{PIPE} = sub { die "sigpipe\n" };
+		alarm(8);
+		$s = IO::Socket::INET->new('127.0.0.1:' . port(8080));
+		alarm(0);
+	};
+	alarm(0);
+
+	if ($@) {
+		log_in("died: $@");
+		return undef;
+	}
+
+	my $ctx = Net::SSLeay::CTX_new() or die("Failed to create SSL_CTX $!");
+
+	if (defined $type) {
+		my $ssleay = Net::SSLeay::SSLeay();
+		if ($ssleay < 0x1000200f || $ssleay == 0x20000000) {
+			Net::SSLeay::CTX_set_cipher_list($ctx, $type)
+				or die("Failed to set cipher list");
+		} else {
+			# SSL_CTRL_SET_SIGALGS_LIST
+			Net::SSLeay::CTX_ctrl($ctx, 98, 0, $type . '+SHA256')
+				or die("Failed to set sigalgs");
+		}
+	}
+
+	my $ssl = Net::SSLeay::new($ctx) or die("Failed to create SSL $!");
+	Net::SSLeay::set_fd($ssl, fileno($s));
+	Net::SSLeay::connect($ssl) or die("ssl connect");
+	return ($s, $ssl);
+}
+
+###############################################################################
diff --git a/tests/ssl_client_escaped_cert.t b/tests/ssl_client_escaped_cert.t
new file mode 100644
index 0000000..e7fb5ee
--- /dev/null
+++ b/tests/ssl_client_escaped_cert.t
@@ -0,0 +1,126 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http ssl module, $ssl_client_escaped_cert variable.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require IO::Socket::SSL; };
+plan(skip_all => 'IO::Socket::SSL not installed') if $@;
+eval { IO::Socket::SSL::SSL_VERIFY_NONE(); };
+plan(skip_all => 'IO::Socket::SSL too old') if $@;
+
+my $t = Test::Nginx->new()->has(qw/http http_ssl rewrite/)
+	->has_daemon('openssl')->plan(3);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    ssl_certificate_key localhost.key;
+    ssl_certificate localhost.crt;
+    ssl_verify_client optional_no_ca;
+
+    server {
+        listen       127.0.0.1:8443 ssl;
+        server_name  localhost;
+
+        location /cert {
+            return 200 $ssl_client_raw_cert;
+        }
+        location /escaped {
+            return 200 $ssl_client_escaped_cert;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('localhost') {
+	system('openssl req -x509 -new '
+		. "-config $d/openssl.conf -subj /CN=$name/ "
+		. "-out $d/$name.crt -keyout $d/$name.key "
+		. ">>$d/openssl.out 2>&1") == 0
+		or die "Can't create certificate for $name: $!\n";
+}
+
+$t->run();
+
+###############################################################################
+
+my ($cert) = cert('/cert') =~ /\x0d\x0a?\x0d\x0a?(.*)/ms;
+my ($escaped) = cert('/escaped') =~ /\x0d\x0a?\x0d\x0a?(.*)/ms;
+
+ok($cert, 'ssl_client_raw_cert');
+ok($escaped, 'ssl_client_escaped_cert');
+
+$escaped =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg;
+is($escaped, $cert, 'ssl_client_escaped_cert unescape match');
+
+###############################################################################
+
+sub cert {
+	my ($uri) = @_;
+	my $s;
+
+	eval {
+		local $SIG{ALRM} = sub { die "timeout\n" };
+		local $SIG{PIPE} = sub { die "sigpipe\n" };
+		alarm(8);
+		$s = IO::Socket::SSL->new(
+			Proto => 'tcp',
+			PeerAddr => '127.0.0.1',
+			PeerPort => port(8443),
+			SSL_verify_mode => IO::Socket::SSL::SSL_VERIFY_NONE(),
+			SSL_cert_file => "$d/localhost.crt",
+			SSL_key_file => "$d/localhost.key",
+			SSL_error_trap => sub { die $_[1] },
+		);
+		alarm(0);
+	};
+	alarm(0);
+
+	if ($@) {
+		log_in("died: $@");
+		return undef;
+	}
+
+	http_get($uri, socket => $s);
+}
+
+###############################################################################
diff --git a/tests/ssl_crl.t b/tests/ssl_crl.t
new file mode 100644
index 0000000..c5e32a8
--- /dev/null
+++ b/tests/ssl_crl.t
@@ -0,0 +1,203 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http ssl module, ssl_crl directive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require IO::Socket::SSL; };
+plan(skip_all => 'IO::Socket::SSL not installed') if $@;
+eval { IO::Socket::SSL::SSL_VERIFY_NONE(); };
+plan(skip_all => 'IO::Socket::SSL too old') if $@;
+
+my $t = Test::Nginx->new()->has(qw/http http_ssl/)
+	->has_daemon('openssl')->plan(3);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    ssl_certificate_key  localhost.key;
+    ssl_certificate localhost.crt;
+
+    ssl_verify_client on;
+    ssl_client_certificate int-root.crt;
+
+    add_header X-Verify $ssl_client_verify always;
+
+    server {
+        listen       127.0.0.1:8080 ssl;
+        server_name  localhost;
+
+        ssl_client_certificate root.crt;
+        ssl_crl empty.crl;
+    }
+
+    server {
+        listen       127.0.0.1:8081 ssl;
+        server_name  localhost;
+
+        ssl_client_certificate root.crt;
+        ssl_crl root.crl;
+    }
+
+    server {
+        listen       127.0.0.1:8082 ssl;
+        server_name  localhost;
+
+        ssl_verify_depth 2;
+        ssl_crl root.crl;
+    }
+}
+
+EOF
+
+my $d = $t->testdir();
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+$t->write_file('ca.conf', <<EOF);
+[ ca ]
+default_ca = myca
+
+[ myca ]
+new_certs_dir = $d
+database = $d/certindex
+default_md = sha256
+policy = myca_policy
+serial = $d/certserial
+default_days = 1
+
+[ myca_policy ]
+commonName = supplied
+EOF
+
+foreach my $name ('root', 'localhost') {
+	system('openssl req -x509 -new '
+		. "-config $d/openssl.conf -subj /CN=$name/ "
+		. "-out $d/$name.crt -keyout $d/$name.key "
+		. ">>$d/openssl.out 2>&1") == 0
+		or die "Can't create certificate for $name: $!\n";
+}
+
+foreach my $name ('int', 'end') {
+	system("openssl req -new "
+		. "-config $d/openssl.conf -subj /CN=$name/ "
+		. "-out $d/$name.csr -keyout $d/$name.key "
+		. ">>$d/openssl.out 2>&1") == 0
+		or die "Can't create certificate for $name: $!\n";
+}
+
+$t->write_file('certserial', '1000');
+$t->write_file('certindex', '');
+
+system("openssl ca -batch -config $d/ca.conf "
+	. "-keyfile $d/root.key -cert $d/root.crt "
+	. "-subj /CN=int/ -in $d/int.csr -out $d/int.crt "
+	. ">>$d/openssl.out 2>&1") == 0
+	or die "Can't sign certificate for int: $!\n";
+
+system("openssl ca -batch -config $d/ca.conf "
+	. "-keyfile $d/int.key -cert $d/int.crt "
+	. "-subj /CN=end/ -in $d/end.csr -out $d/end.crt "
+	. ">>$d/openssl.out 2>&1") == 0
+	or die "Can't sign certificate for end: $!\n";
+
+system("openssl ca -gencrl -config $d/ca.conf "
+	. "-keyfile $d/root.key -cert $d/root.crt "
+	. "-out $d/empty.crl -crldays 1 "
+	. ">>$d/openssl.out 2>&1") == 0
+	or die "Can't create empty crl: $!\n";
+
+system("openssl ca -config $d/ca.conf -revoke $d/int.crt "
+	. "-keyfile $d/root.key -cert $d/root.crt "
+	. ">>$d/openssl.out 2>&1") == 0
+	or die "Can't revoke int.crt: $!\n";
+
+system("openssl ca -gencrl -config $d/ca.conf "
+	. "-keyfile $d/root.key -cert $d/root.crt "
+	. "-out $d/root.crl -crldays 1 "
+	. ">>$d/openssl.out 2>&1") == 0
+	or die "Can't update crl: $!\n";
+
+$t->write_file('int-root.crt',
+	$t->read_file('int.crt') . $t->read_file('root.crt'));
+
+$t->write_file('t', '');
+$t->run();
+
+###############################################################################
+
+like(get(8080, 'int'), qr/SUCCESS/, 'crl - no revoked certs');
+like(get(8081, 'int'), qr/FAILED/, 'crl - client cert revoked');
+like(get(8082, 'end'), qr/FAILED/, 'crl - intermediate cert revoked');
+
+###############################################################################
+
+sub get {
+	my ($port, $cert) = @_;
+	my $s = get_ssl_socket($port, $cert) or return;
+	http_get('/t', socket => $s);
+}
+
+sub get_ssl_socket {
+	my ($port, $cert) = @_;
+	my ($s);
+
+	eval {
+		local $SIG{ALRM} = sub { die "timeout\n" };
+		local $SIG{PIPE} = sub { die "sigpipe\n" };
+		alarm(8);
+		$s = IO::Socket::SSL->new(
+			Proto => 'tcp',
+			PeerAddr => '127.0.0.1',
+			PeerPort => port($port),
+			SSL_verify_mode => IO::Socket::SSL::SSL_VERIFY_NONE(),
+			SSL_cert_file => "$d/$cert.crt",
+			SSL_key_file => "$d/$cert.key",
+			SSL_error_trap => sub { die $_[1] }
+		);
+		alarm(0);
+	};
+	alarm(0);
+
+	if ($@) {
+		log_in("died: $@");
+		return undef;
+	}
+
+	return $s;
+}
+
+###############################################################################
diff --git a/tests/ssl_engine_keys.t b/tests/ssl_engine_keys.t
new file mode 100644
index 0000000..cee9e29
--- /dev/null
+++ b/tests/ssl_engine_keys.t
@@ -0,0 +1,149 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http ssl module, loading "engine:..." keys.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+plan(skip_all => 'win32') if $^O eq 'MSWin32';
+
+plan(skip_all => 'may not work, leaves coredump')
+	unless $ENV{TEST_NGINX_UNSAFE};
+
+my $t = Test::Nginx->new()->has(qw/http proxy http_ssl/)->has_daemon('openssl')
+	->has_daemon('softhsm')->has_daemon('pkcs11-tool')->plan(2);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8081 ssl;
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        ssl_certificate localhost.crt;
+        ssl_certificate_key engine:pkcs11:slot_0-id_00;
+
+        location / {
+            # index index.html by default
+        }
+
+        location /proxy {
+            proxy_pass https://127.0.0.1:8081/;
+        }
+
+        location /var {
+            proxy_pass https://127.0.0.1:8082/;
+            proxy_ssl_name localhost;
+            proxy_ssl_server_name on;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8082 ssl;
+        server_name  localhost;
+
+        ssl_certificate $ssl_server_name.crt;
+        ssl_certificate_key engine:pkcs11:slot_0-id_00;
+
+        location / {
+            # index index.html by default
+        }
+    }
+}
+
+EOF
+
+# Create a SoftHSM token with a secret key, and configure OpenSSL
+# to access it using the pkcs11 engine, see detailed example
+# posted by Dmitrii Pichulin here:
+#
+# http://mailman.nginx.org/pipermail/nginx-devel/2014-October/006151.html
+#
+# Note that library paths may differ on different systems,
+# and may need to be adjusted.
+
+$t->write_file('openssl.conf', <<EOF);
+openssl_conf = openssl_def
+
+[openssl_def]
+engines = engine_section
+
+[engine_section]
+pkcs11 = pkcs11_section
+
+[pkcs11_section]
+engine_id = pkcs11
+dynamic_path = /usr/local/lib/engines/pkcs11.so
+MODULE_PATH = /usr/local/lib/softhsm/libsofthsm.so
+init = 1
+PIN = 1234
+
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+$t->write_file('softhsm.conf', <<EOF);
+0:$d/slot0.db
+EOF
+
+$ENV{SOFTHSM_CONF} = "$d/softhsm.conf";
+$ENV{OPENSSL_CONF} = "$d/openssl.conf";
+
+foreach my $name ('localhost') {
+	system('softhsm --init-token --slot 0 --label "NginxZero" '
+		. '--pin 1234 --so-pin 1234 '
+		. ">>$d/openssl.out 2>&1");
+
+	system('pkcs11-tool --module=/usr/local/lib/softhsm/libsofthsm.so '
+		. '-p 1234 -l -k -d 0 -a nx_key_0 --key-type rsa:2048 '
+		. ">>$d/openssl.out 2>&1");
+
+	system('openssl req -x509 -new -engine pkcs11 '
+		. "-config $d/openssl.conf -subj /CN=$name/ "
+		. "-out $d/$name.crt -keyform engine -text -key id_00 "
+		. ">>$d/openssl.out 2>&1") == 0
+		or die "Can't create certificate for $name: $!\n";
+}
+
+$t->run();
+
+$t->write_file('index.html', '');
+
+###############################################################################
+
+like(http_get('/proxy'), qr/200 OK/, 'ssl engine keys');
+like(http_get('/var'), qr/200 OK/, 'ssl_certificate with variable');
+
+###############################################################################
diff --git a/tests/ssl_password_file.t b/tests/ssl_password_file.t
new file mode 100644
index 0000000..6dbfb03
--- /dev/null
+++ b/tests/ssl_password_file.t
@@ -0,0 +1,169 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for ssl_password_file directive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use POSIX qw/ mkfifo /;
+use Socket qw/ $CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require IO::Socket::SSL; };
+plan(skip_all => 'IO::Socket::SSL not installed') if $@;
+eval { IO::Socket::SSL::SSL_VERIFY_NONE(); };
+plan(skip_all => 'IO::Socket::SSL too old') if $@;
+
+plan(skip_all => 'win32') if $^O eq 'MSWin32';
+
+my $t = Test::Nginx->new()->has(qw/http http_ssl rewrite/)
+	->has_daemon('openssl');
+
+$t->plan(3)->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    ssl_certificate_key localhost.key;
+    ssl_certificate localhost.crt;
+
+    # inherited by server "inherits"
+    ssl_password_file password_http;
+
+    server {
+        listen       127.0.0.1:8081 ssl;
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        ssl_password_file password;
+
+        location / {
+            return 200 "$scheme";
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  two_entries;
+
+        ssl_password_file password_many;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  file_is_fifo;
+
+        ssl_password_file password_fifo;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  inherits;
+
+        ssl_certificate_key inherits.key;
+        ssl_certificate inherits.crt;
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+mkfifo("$d/password_fifo", 0700);
+
+foreach my $name ('localhost', 'inherits') {
+	system("openssl genrsa -out $d/$name.key -passout pass:$name "
+		. "-aes128 2048 >>$d/openssl.out 2>&1") == 0
+		or die "Can't create private key: $!\n";
+	system('openssl req -x509 -new '
+		. "-config $d/openssl.conf -subj /CN=$name/ "
+		. "-out $d/$name.crt "
+		. "-key $d/$name.key -passin pass:$name"
+		. ">>$d/openssl.out 2>&1") == 0
+		or die "Can't create certificate for $name: $!\n";
+}
+
+$t->write_file('password', 'localhost');
+$t->write_file('password_many', "wrong$CRLF" . "localhost$CRLF");
+$t->write_file('password_http', 'inherits');
+
+my $p = fork();
+exec("echo localhost > $d/password_fifo") if $p == 0;
+
+# do not mangle with try_run()
+# we need to distinguish ssl_password_file support vs its brokenness
+
+eval {
+	open OLDERR, ">&", \*STDERR; close STDERR;
+	$t->run();
+	open STDERR, ">&", \*OLDERR;
+};
+kill 'INT', $p if $@;
+
+###############################################################################
+
+is($@, '', 'ssl_password_file works');
+
+# simple tests to ensure that nothing broke with ssl_password_file directive
+
+like(http_get('/'), qr/200 OK.*http/ms, 'http');
+like(http_get('/', socket => get_ssl_socket()), qr/200 OK.*https/ms, 'https');
+
+###############################################################################
+
+sub get_ssl_socket {
+	my $s;
+
+	eval {
+		local $SIG{ALRM} = sub { die "timeout\n" };
+		local $SIG{PIPE} = sub { die "sigpipe\n" };
+		alarm(8);
+		$s = IO::Socket::SSL->new(
+			Proto => 'tcp',
+			PeerAddr => '127.0.0.1:' . port(8081),
+			SSL_verify_mode => IO::Socket::SSL::SSL_VERIFY_NONE(),
+			SSL_error_trap => sub { die $_[1] }
+		);
+		alarm(0);
+	};
+	alarm(0);
+
+	if ($@) {
+		log_in("died: $@");
+		return undef;
+	}
+
+	return $s;
+}
+
+###############################################################################
diff --git a/tests/ssl_proxy_protocol.t b/tests/ssl_proxy_protocol.t
new file mode 100644
index 0000000..1e69bf0
--- /dev/null
+++ b/tests/ssl_proxy_protocol.t
@@ -0,0 +1,180 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http ssl module with haproxy protocol.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require IO::Socket::SSL; };
+plan(skip_all => 'IO::Socket::SSL not installed') if $@;
+eval { IO::Socket::SSL::SSL_VERIFY_NONE(); };
+plan(skip_all => 'IO::Socket::SSL too old') if $@;
+
+my $t = Test::Nginx->new()->has(qw/http http_ssl access realip/)
+	->has_daemon('openssl');
+
+$t->write_file_expand('nginx.conf', <<'EOF')->plan(18);
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    log_format pp '$remote_addr $request';
+
+    server {
+        listen       127.0.0.1:8080 proxy_protocol ssl;
+        server_name  localhost;
+
+        ssl_certificate_key localhost.key;
+        ssl_certificate localhost.crt;
+
+        set_real_ip_from  127.0.0.1/32;
+        add_header X-IP $remote_addr;
+        add_header X-PP $proxy_protocol_addr;
+
+        location /pp {
+            real_ip_header proxy_protocol;
+            error_page 404 =200 /t1;
+            access_log %%TESTDIR%%/pp.log pp;
+
+            location /pp_4 {
+                deny 192.0.2.1/32;
+            }
+            location /pp_6 {
+                deny 2001:DB8::1/128;
+            }
+        }
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('localhost') {
+	system('openssl req -x509 -new '
+		. "-config $d/openssl.conf -subj /CN=$name/ "
+		. "-out $d/$name.crt -keyout $d/$name.key "
+		. ">>$d/openssl.out 2>&1") == 0
+	or die "Can't create certificate for $name: $!\n";
+}
+
+$t->write_file('t1', 'SEE-THIS');
+$t->run();
+
+###############################################################################
+
+my $tcp4 = 'PROXY TCP4 192.0.2.1 192.0.2.2 1234 5678' . CRLF;
+my $tcp6 = 'PROXY TCP6 2001:Db8::1 2001:Db8::2 1234 5678' . CRLF;
+my $unk1 = 'PROXY UNKNOWN' . CRLF;
+my $unk2 = 'PROXY UNKNOWN 1 2 3 4 5 6' . CRLF;
+my $r;
+
+# no realip, just PROXY header parsing
+
+$r = pp_get('/t1', $tcp4);
+like($r, qr/SEE-THIS/, 'tcp4 request');
+like($r, qr/X-PP: 192.0.2.1/, 'tcp4 proxy');
+unlike($r, qr/X-IP: 192.0.2.1/, 'tcp4 client');
+
+$r = pp_get('/t1', $tcp6);
+like($r, qr/SEE-THIS/, 'tcp6 request');
+like($r, qr/X-PP: 2001:DB8::1/i, 'tcp6 proxy');
+unlike($r, qr/X-IP: 2001:DB8::1/i, 'tcp6 client');
+
+like(pp_get('/t1', $unk1), qr/SEE-THIS/, 'unknown request 1');
+like(pp_get('/t1', $unk2), qr/SEE-THIS/, 'unknown request 2');
+
+# realip
+
+$r = pp_get('/pp', $tcp4);
+like($r, qr/SEE-THIS/, 'tcp4 request realip');
+like($r, qr/X-PP: 192.0.2.1/, 'tcp4 proxy realip');
+like($r, qr/X-IP: 192.0.2.1/, 'tcp4 client realip');
+
+$r = pp_get('/pp', $tcp6);
+like($r, qr/SEE-THIS/, 'tcp6 request realip');
+like($r, qr/X-PP: 2001:DB8::1/i, 'tcp6 proxy realip');
+like($r, qr/X-IP: 2001:DB8::1/i, 'tcp6 client realip');
+
+# access
+
+$r = pp_get('/pp_4', $tcp4);
+like($r, qr/403 Forbidden/, 'tcp4 access');
+
+$r = pp_get('/pp_6', $tcp6);
+like($r, qr/403 Forbidden/, 'tcp6 access');
+
+# client address in access.log
+
+$t->stop();
+
+my $log = $t->read_file('pp.log');
+like($log, qr!^192\.0\.2\.1 GET /pp_4!m, 'tcp4 access log');
+like($log, qr!^2001:DB8::1 GET /pp_6!mi, 'tcp6 access log');
+
+###############################################################################
+
+sub pp_get {
+	my ($url, $proxy) = @_;
+
+	my $s = http($proxy, start => 1);
+
+	eval {
+		local $SIG{ALRM} = sub { die "timeout\n" };
+		local $SIG{PIPE} = sub { die "sigpipe\n" };
+		alarm(8);
+		IO::Socket::SSL->start_SSL($s,
+			SSL_verify_mode => IO::Socket::SSL::SSL_VERIFY_NONE(),
+			SSL_error_trap => sub { die $_[1] }
+		);
+		alarm(0);
+	};
+	alarm(0);
+
+	if ($@) {
+		log_in("died: $@");
+		return undef;
+	}
+
+	return http(<<EOF, socket => $s);
+GET $url HTTP/1.0
+Host: localhost
+
+EOF
+}
+
+###############################################################################
diff --git a/tests/ssl_proxy_upgrade.t b/tests/ssl_proxy_upgrade.t
new file mode 100644
index 0000000..261234f
--- /dev/null
+++ b/tests/ssl_proxy_upgrade.t
@@ -0,0 +1,367 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http proxy upgrade support with http ssl module.
+# In contrast to proxy_websocket.t, this test doesn't try to use binary
+# WebSocket protocol, but uses simple plain text protocol instead.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use IO::Poll;
+use IO::Select;
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require IO::Socket::SSL; };
+plan(skip_all => 'IO::Socket::SSL not installed') if $@;
+eval { IO::Socket::SSL::SSL_VERIFY_NONE(); };
+plan(skip_all => 'IO::Socket::SSL too old') if $@;
+
+my $t = Test::Nginx->new()->has(qw/http proxy http_ssl/)->has_daemon('openssl')
+	->write_file_expand('nginx.conf', <<'EOF')->plan(30);
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    log_format test "$bytes_sent $body_bytes_sent";
+    access_log %%TESTDIR%%/cc.log test;
+
+    server {
+        listen       127.0.0.1:8080 ssl;
+        server_name  localhost;
+
+        ssl_certificate_key localhost.key;
+        ssl_certificate localhost.crt;
+
+        location / {
+            proxy_pass    http://127.0.0.1:8081;
+            proxy_http_version 1.1;
+            proxy_set_header Upgrade $http_upgrade;
+            proxy_set_header Connection "Upgrade";
+            proxy_read_timeout 2s;
+            send_timeout 2s;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('localhost') {
+	system('openssl req -x509 -new '
+		. "-config $d/openssl.conf -subj /CN=$name/ "
+		. "-out $d/$name.crt -keyout $d/$name.key "
+		. ">>$d/openssl.out 2>&1") == 0
+		or die "Can't create certificate for $name: $!\n";
+}
+
+$t->run_daemon(\&upgrade_fake_daemon);
+$t->run();
+
+$t->waitforsocket('127.0.0.1:' . port(8081))
+	or die "Can't start test backend";
+
+###############################################################################
+
+# establish connection
+
+my @r;
+my $s = upgrade_connect();
+ok($s, "handshake");
+
+SKIP: {
+	skip "handshake failed", 22 unless $s;
+
+	# send a frame
+
+	upgrade_write($s, 'foo');
+	is(upgrade_read($s), 'bar', "upgrade response");
+
+	# send some big frame
+
+	upgrade_write($s, 'foo' x 16384);
+	like(upgrade_read($s), qr/^(bar){16384}$/, "upgrade big response");
+
+	# send multiple frames
+
+	for my $i (1 .. 10) {
+		upgrade_write($s, ('foo' x 16384) . $i, continue => 1);
+		upgrade_write($s, 'bazz' . $i, continue => $i != 10);
+	}
+
+	for my $i (1 .. 10) {
+		like(upgrade_read($s), qr/^(bar){16384}\d+$/, "upgrade $i");
+		is(upgrade_read($s), 'bazz' . $i, "upgrade small $i");
+	}
+}
+
+push @r, $s ? ${*$s}->{_upgrade_private}->{r} : 'failed';
+undef $s;
+
+# establish connection with some pipelined data
+# and make sure they are correctly passed upstream
+
+$s = upgrade_connect(message => "foo");
+ok($s, "handshake pipelined");
+
+SKIP: {
+	skip "handshake failed", 2 unless $s;
+
+	is(upgrade_read($s), "bar", "response pipelined");
+
+	upgrade_write($s, "foo");
+	is(upgrade_read($s), "bar", "next to pipelined");
+}
+
+push @r, $s ? ${*$s}->{_upgrade_private}->{r} : 'failed';
+undef $s;
+
+# connection should not be upgraded unless upgrade was actually
+# requested and allowed by configuration
+
+$s = upgrade_connect(noheader => 1);
+ok(!$s, "handshake noupgrade");
+
+# bytes sent on upgraded connection, fixed in c2f309fb7ad2 (1.7.11)
+# verify with 1) data actually read by client, 2) expected data from backend
+
+$t->stop();
+
+open my $f, '<', "$d/cc.log" or die "Can't open cc.log: $!";
+
+is($f->getline(), shift (@r) . " 540793\n", 'log - bytes');
+is($f->getline(), shift (@r) . " 22\n", 'log - bytes pipelined');
+like($f->getline(), qr/\d+ 0\n/, 'log - bytes noupgrade');
+
+###############################################################################
+
+sub upgrade_connect {
+	my (%opts) = @_;
+
+	my $s = IO::Socket::SSL->new(
+		Proto => 'tcp',
+		PeerAddr => '127.0.0.1:' . port(8080),
+		SSL_verify_mode => IO::Socket::SSL::SSL_VERIFY_NONE(),
+	)
+		or die "Can't connect to nginx: $!\n";
+
+	# send request, $h->to_string
+
+	my $buf = "GET / HTTP/1.1" . CRLF
+		. "Host: localhost" . CRLF
+		. ($opts{noheader} ? '' : "Upgrade: foo" . CRLF)
+		. "Connection: Upgrade" . CRLF . CRLF;
+
+	$buf .= $opts{message} . CRLF . 'FIN' if defined $opts{message};
+
+	local $SIG{PIPE} = 'IGNORE';
+
+	log_out($buf);
+	$s->syswrite($buf);
+
+	# read response
+
+	my $got = '';
+	$buf = '';
+
+	while (1) {
+		$buf = upgrade_getline($s);
+		last unless defined $buf and length $buf;
+		log_in($buf);
+		$got .= $buf;
+		last if $got =~ /\x0d?\x0a\x0d?\x0a$/;
+	}
+
+	# parse server response
+
+	return if $got !~ m!HTTP/1.1 101!;
+
+	# make sure next line is "handshaked"
+
+	$buf = upgrade_read($s);
+
+	return if !defined $buf or $buf ne 'handshaked';
+	return $s;
+}
+
+sub upgrade_getline {
+	my ($s) = @_;
+	my ($h, $buf);
+
+	${*$s}->{_upgrade_private} ||= { b => '', r => 0 };
+	$h = ${*$s}->{_upgrade_private};
+
+	if ($h->{b} =~ /^(.*?\x0a)(.*)/ms) {
+		$h->{b} = $2;
+		return $1;
+	}
+
+	$s->blocking(0);
+	while (IO::Select->new($s)->can_read(3)) {
+		my $n = $s->sysread($buf, 16384);
+		if (!defined $n) {
+			next if $s->errstr() == IO::Socket::SSL->SSL_WANT_READ;
+			last;
+
+		} elsif (!$n) {
+			last;
+		}
+
+		$h->{b} .= $buf;
+		$h->{r} += $n;
+
+		if ($h->{b} =~ /^(.*?\x0a)(.*)/ms) {
+			$h->{b} = $2;
+			return $1;
+		}
+	};
+}
+
+sub upgrade_write {
+	my ($s, $message, %extra) = @_;
+
+	$message = $message . CRLF;
+	$message = $message . 'FIN' unless $extra{continue};
+
+	local $SIG{PIPE} = 'IGNORE';
+
+	$s->blocking(0);
+	while (IO::Select->new($s)->can_write(1.5)) {
+		my $n = $s->syswrite($message);
+		unless ($n) {
+			next if $s->errstr() == IO::Socket::SSL->SSL_WANT_WRITE;
+			last;
+		}
+		$message = substr($message, $n);
+		last unless length $message;
+	}
+
+	if (length $message) {
+		$s->close();
+	}
+}
+
+sub upgrade_read {
+	my ($s) = @_;
+	my $m = upgrade_getline($s);
+	$m =~ s/\x0d?\x0a// if defined $m;
+	log_in($m);
+	return $m;
+}
+
+###############################################################################
+
+sub upgrade_fake_daemon {
+	my $server = IO::Socket::INET->new(
+		Proto => 'tcp',
+		LocalAddr => '127.0.0.1:' . port(8081),
+		Listen => 5,
+		Reuse => 1
+	)
+		or die "Can't create listening socket: $!\n";
+
+	while (my $client = $server->accept()) {
+		upgrade_handle_client($client);
+	}
+}
+
+sub upgrade_handle_client {
+	my ($client) = @_;
+
+	$client->autoflush(1);
+	$client->blocking(0);
+
+	my $poll = IO::Poll->new;
+
+	my $handshake = 1;
+	my $unfinished = '';
+	my $buffer = '';
+	my $n;
+
+	log2c("(new connection $client)");
+
+	while (1) {
+		$poll->mask($client => ($buffer ? POLLIN|POLLOUT : POLLIN));
+		my $p = $poll->poll(0.5);
+		log2c("(poll $p)");
+
+		foreach ($poll->handles(POLLIN)) {
+			$n = $client->sysread(my $chunk, 65536);
+			return unless $n;
+
+			log2i($chunk);
+
+			if ($handshake) {
+				$buffer .= $chunk;
+				next unless $buffer =~ /\x0d?\x0a\x0d?\x0a$/;
+
+				log2c("(handshake done)");
+
+				$handshake = 0;
+				$buffer = 'HTTP/1.1 101 Switching' . CRLF
+					. 'Upgrade: foo' . CRLF
+					. 'Connection: Upgrade' . CRLF . CRLF
+					. 'handshaked' . CRLF;
+
+				log2o($buffer);
+
+				next;
+			}
+
+			$unfinished .= $chunk;
+
+			if ($unfinished =~ m/\x0d?\x0aFIN\z/) {
+				$unfinished =~ s/FIN\z//;
+				$unfinished =~ s/foo/bar/g;
+				log2o($unfinished);
+				$buffer .= $unfinished;
+				$unfinished = '';
+			}
+		}
+
+		foreach my $writer ($poll->handles(POLLOUT)) {
+			next unless length $buffer;
+			$n = $writer->syswrite($buffer);
+			substr $buffer, 0, $n, '';
+		}
+	}
+}
+
+sub log2i { Test::Nginx::log_core('|| <<', @_); }
+sub log2o { Test::Nginx::log_core('|| >>', @_); }
+sub log2c { Test::Nginx::log_core('||', @_); }
+
+###############################################################################
diff --git a/tests/ssl_sni.t b/tests/ssl_sni.t
new file mode 100644
index 0000000..d27d261
--- /dev/null
+++ b/tests/ssl_sni.t
@@ -0,0 +1,216 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+# (C) Valentin Bartenev
+
+# Tests for Server Name Indication (SNI) TLS extension
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http http_ssl sni rewrite/)
+	->has_daemon('openssl')
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080 ssl;
+        server_name  localhost;
+
+        ssl_certificate_key localhost.key;
+        ssl_certificate localhost.crt;
+
+        location / {
+            return 200 $server_name;
+        }
+
+        location /protocol {
+            return 200 $ssl_protocol;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  example.com;
+
+        ssl_certificate_key example.com.key;
+        ssl_certificate example.com.crt;
+
+        location / {
+            return 200 $server_name;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081 ssl;
+        server_name  localhost;
+
+        ssl_certificate_key localhost.key;
+        ssl_certificate localhost.crt;
+
+        location / {
+            return 200 $ssl_session_reused:$ssl_server_name;
+        }
+    }
+}
+
+EOF
+
+eval { require IO::Socket::SSL; die if $IO::Socket::SSL::VERSION < 1.56; };
+plan(skip_all => 'IO::Socket::SSL version >= 1.56 required') if $@;
+
+eval {
+	if (IO::Socket::SSL->can('can_client_sni')) {
+		IO::Socket::SSL->can_client_sni() or die;
+	}
+};
+plan(skip_all => 'IO::Socket::SSL with OpenSSL SNI support required') if $@;
+
+eval {
+	my $ctx = Net::SSLeay::CTX_new() or die;
+	my $ssl = Net::SSLeay::new($ctx) or die;
+	Net::SSLeay::set_tlsext_host_name($ssl, 'example.org') == 1 or die;
+};
+plan(skip_all => 'Net::SSLeay with OpenSSL SNI support required') if $@;
+
+$t->plan(8);
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('localhost', 'example.com') {
+	system('openssl req -x509 -new '
+		. "-config $d/openssl.conf -subj /CN=$name/ "
+		. "-out $d/$name.crt -keyout $d/$name.key "
+		. ">>$d/openssl.out 2>&1") == 0
+		or die "Can't create certificate for $name: $!\n";
+}
+
+$t->run();
+
+###############################################################################
+
+like(get_cert_cn(), qr!/CN=localhost!, 'default cert');
+like(get_cert_cn('example.com'), qr!/CN=example.com!, 'sni cert');
+
+like(https_get_host('example.com'), qr!example.com!,
+	'host exists, sni exists, and host is equal sni');
+
+like(https_get_host('example.com', 'example.org'), qr!example.com!,
+	'host exists, sni not found');
+
+TODO: {
+local $TODO = 'sni restrictions';
+
+like(https_get_host('example.com', 'localhost'), qr!400 Bad Request!,
+	'host exists, sni exists, and host is not equal sni');
+
+like(https_get_host('example.org', 'example.com'), qr!400 Bad Request!,
+	'host not found, sni exists');
+
+}
+
+# $ssl_server_name in sessions
+
+my $ctx = new IO::Socket::SSL::SSL_Context(
+	SSL_verify_mode => IO::Socket::SSL::SSL_VERIFY_NONE(),
+	SSL_session_cache_size => 100);
+
+like(get('/', 'localhost', 8081, $ctx), qr/^\.:localhost$/m, 'ssl server name');
+
+SKIP: {
+skip 'no TLS 1.3 sessions', 1 if get('/protocol', 'localhost') =~ /TLSv1.3/
+	&& ($Net::SSLeay::VERSION < 1.88 || $IO::Socket::SSL::VERSION < 2.061);
+
+like(get('/', 'localhost', 8081, $ctx), qr/^r:localhost$/m,
+	'ssl server name - reused');
+
+}
+
+###############################################################################
+
+sub get_ssl_socket {
+	my ($host, $port, $ctx) = @_;
+	my $s;
+
+	eval {
+		local $SIG{ALRM} = sub { die "timeout\n" };
+		local $SIG{PIPE} = sub { die "sigpipe\n" };
+		alarm(8);
+		$s = IO::Socket::SSL->new(
+			Proto => 'tcp',
+			PeerAddr => '127.0.0.1:' . port($port || 8080),
+			SSL_hostname => $host,
+			SSL_reuse_ctx => $ctx,
+			SSL_verify_mode => IO::Socket::SSL::SSL_VERIFY_NONE(),
+			SSL_error_trap => sub { die $_[1] }
+		);
+		alarm(0);
+	};
+	alarm(0);
+
+	if ($@) {
+		log_in("died: $@");
+		return undef;
+	}
+
+	return $s;
+}
+
+sub get_cert_cn {
+	my ($host) = @_;
+	my $s = get_ssl_socket($host);
+
+	return $s->dump_peer_certificate();
+}
+
+sub https_get_host {
+	my ($host, $sni) = @_;
+	my $s = get_ssl_socket($sni ? $sni : $host);
+
+	return http(<<EOF, socket => $s);
+GET / HTTP/1.0
+Host: $host
+
+EOF
+}
+
+sub get {
+	my ($uri, $host, $port, $ctx) = @_;
+	my $s = get_ssl_socket($host, $port, $ctx) or return;
+	my $r = http_get($uri, socket => $s);
+	$s->close();
+	return $r;
+}
+
+###############################################################################
diff --git a/tests/ssl_sni_reneg.t b/tests/ssl_sni_reneg.t
new file mode 100644
index 0000000..464bbea
--- /dev/null
+++ b/tests/ssl_sni_reneg.t
@@ -0,0 +1,180 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http ssl module with SNI and renegotiation.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/ :DEFAULT CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval {
+	require Net::SSLeay;
+	Net::SSLeay::load_error_strings();
+	Net::SSLeay::SSLeay_add_ssl_algorithms();
+	Net::SSLeay::randomize();
+};
+plan(skip_all => 'Net::SSLeay not installed') if $@;
+
+eval {
+	my $ctx = Net::SSLeay::CTX_new() or die;
+	my $ssl = Net::SSLeay::new($ctx) or die;
+	Net::SSLeay::set_tlsext_host_name($ssl, 'example.org') == 1 or die;
+};
+plan(skip_all => 'Net::SSLeay with OpenSSL SNI support required') if $@;
+
+my $t = Test::Nginx->new()->has(qw/http http_ssl/)->has_daemon('openssl');
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    ssl_certificate_key localhost.key;
+    ssl_certificate localhost.crt;
+
+    server {
+        listen       127.0.0.1:8080 ssl;
+        listen       127.0.0.1:8081 ssl;
+        server_name  localhost;
+
+        location / { }
+    }
+
+    server {
+        listen       127.0.0.1:8081 ssl;
+        server_name  localhost2;
+
+        location / { }
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('localhost') {
+	system('openssl req -x509 -new '
+		. "-config $d/openssl.conf -subj /CN=$name/ "
+		. "-out $d/$name.crt -keyout $d/$name.key "
+		. ">>$d/openssl.out 2>&1") == 0
+		or die "Can't create certificate for $name: $!\n";
+}
+
+$t->run();
+
+{
+	my (undef, $ssl) = get_ssl_socket(8080);
+	plan(skip_all => "TLS 1.3 forbids renegotiation")
+		if Net::SSLeay::version($ssl) > 0x0303;
+}
+
+$t->plan(8);
+
+###############################################################################
+
+my ($s, $ssl) = get_ssl_socket(8080);
+ok($s, 'connection');
+
+SKIP: {
+skip 'connection failed', 3 unless $s;
+
+local $SIG{PIPE} = 'IGNORE';
+
+Net::SSLeay::write($ssl, 'GET / HTTP/1.0' . CRLF);
+
+ok(Net::SSLeay::renegotiate($ssl), 'renegotiation');
+ok(Net::SSLeay::set_tlsext_host_name($ssl, 'localhost'), 'SNI');
+
+Net::SSLeay::write($ssl, 'Host: localhost' . CRLF . CRLF);
+
+ok(!Net::SSLeay::read($ssl), 'response');
+
+}
+
+# virtual servers
+
+($s, $ssl) = get_ssl_socket(8081);
+ok($s, 'connection 2');
+
+SKIP: {
+skip 'connection failed', 3 unless $s;
+
+local $SIG{PIPE} = 'IGNORE';
+
+Net::SSLeay::write($ssl, 'GET / HTTP/1.0' . CRLF);
+
+ok(Net::SSLeay::renegotiate($ssl), 'renegotiation');
+ok(Net::SSLeay::set_tlsext_host_name($ssl, 'localhost'), 'SNI');
+
+Net::SSLeay::write($ssl, 'Host: localhost' . CRLF . CRLF);
+
+ok(!Net::SSLeay::read($ssl), 'virtual servers');
+
+}
+
+###############################################################################
+
+sub get_ssl_socket {
+	my ($port) = @_;
+	my $s;
+
+	my $dest_ip = inet_aton('127.0.0.1');
+	my $dest_serv_params = sockaddr_in(port($port), $dest_ip);
+
+	eval {
+		local $SIG{ALRM} = sub { die "timeout\n" };
+		local $SIG{PIPE} = sub { die "sigpipe\n" };
+		alarm(8);
+		socket($s, &AF_INET, &SOCK_STREAM, 0) or die "socket: $!";
+		connect($s, $dest_serv_params) or die "connect: $!";
+		alarm(0);
+	};
+	alarm(0);
+
+	if ($@) {
+		log_in("died: $@");
+		return undef;
+	}
+
+	my $ctx = Net::SSLeay::CTX_new() or die("Failed to create SSL_CTX $!");
+	my $ssl = Net::SSLeay::new($ctx) or die("Failed to create SSL $!");
+	Net::SSLeay::set_fd($ssl, fileno($s));
+	Net::SSLeay::set_tlsext_host_name($ssl, 'localhost');
+	Net::SSLeay::connect($ssl) or die("ssl connect");
+
+	return ($s, $ssl);
+}
+
+###############################################################################
diff --git a/tests/ssl_sni_sessions.t b/tests/ssl_sni_sessions.t
new file mode 100644
index 0000000..35ef753
--- /dev/null
+++ b/tests/ssl_sni_sessions.t
@@ -0,0 +1,219 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for SSL session resumption with SNI.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http http_ssl sni rewrite/);
+
+$t->has_daemon('openssl')->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    ssl_certificate_key localhost.key;
+    ssl_certificate localhost.crt;
+
+    server {
+        listen       127.0.0.1:8080 ssl;
+        server_name  default;
+
+        ssl_session_tickets off;
+        ssl_session_cache shared:cache1:1m;
+
+        location / {
+            return 200 $ssl_server_name:$ssl_session_reused:$ssl_protocol;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  nocache;
+
+        ssl_session_tickets off;
+        ssl_session_cache shared:cache2:1m;
+
+        location / {
+            return 200 $ssl_server_name:$ssl_session_reused;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081 ssl;
+        server_name  default;
+
+        ssl_session_ticket_key ticket1.key;
+
+        location / {
+            return 200 $ssl_server_name:$ssl_session_reused;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  tickets;
+
+        ssl_session_ticket_key ticket2.key;
+
+        location / {
+            return 200 $ssl_server_name:$ssl_session_reused;
+        }
+    }
+}
+
+EOF
+
+eval { require IO::Socket::SSL; die if $IO::Socket::SSL::VERSION < 1.56; };
+plan(skip_all => 'IO::Socket::SSL version >= 1.56 required') if $@;
+
+eval {
+	if (IO::Socket::SSL->can('can_client_sni')) {
+		IO::Socket::SSL->can_client_sni() or die;
+	}
+};
+plan(skip_all => 'IO::Socket::SSL with OpenSSL SNI support required') if $@;
+
+eval {
+	my $ctx = Net::SSLeay::CTX_new() or die;
+	my $ssl = Net::SSLeay::new($ctx) or die;
+	Net::SSLeay::set_tlsext_host_name($ssl, 'example.org') == 1 or die;
+};
+plan(skip_all => 'Net::SSLeay with OpenSSL SNI support required') if $@;
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('localhost') {
+	system('openssl req -x509 -new '
+		. "-config $d/openssl.conf -subj /CN=$name/ "
+		. "-out $d/$name.crt -keyout $d/$name.key "
+		. ">>$d/openssl.out 2>&1") == 0
+		or die "Can't create certificate for $name: $!\n";
+}
+
+$t->write_file('ticket1.key', '1' x 48);
+$t->write_file('ticket2.key', '2' x 48);
+
+$t->run();
+
+plan(skip_all => 'no TLS 1.3 sessions')
+	if get('default', port(8080), get_ssl_context()) =~ /TLSv1.3/
+	&& ($Net::SSLeay::VERSION < 1.88 || $IO::Socket::SSL::VERSION < 2.061);
+
+$t->plan(6);
+
+###############################################################################
+
+# check that everything works fine with default server
+
+my $ctx = get_ssl_context();
+
+like(get('default', port(8080), $ctx), qr!default:\.!, 'default server');
+like(get('default', port(8080), $ctx), qr!default:r!, 'default server reused');
+
+# check that sessions are still properly saved and restored
+# when using an SNI-based virtual server with different session cache;
+# as session resumption happens before SNI, only default server
+# settings are expected to matter
+
+# this didn't work before nginx 1.9.6 (and caused segfaults if no session
+# cache was configured the SNI-based virtual server), because OpenSSL, when
+# creating new sessions, uses callbacks from the default server context, but
+# provides access to the SNI-selected server context only (ticket #235)
+
+$ctx = get_ssl_context();
+
+like(get('nocache', port(8080), $ctx), qr!nocache:\.!, 'without cache');
+like(get('nocache', port(8080), $ctx), qr!nocache:r!, 'without cache reused');
+
+# make sure tickets can be used if an SNI-based virtual server
+# uses a different set of session ticket keys explicitly set
+
+$ctx = get_ssl_context();
+
+like(get('tickets', port(8081), $ctx), qr!tickets:\.!, 'tickets');
+like(get('tickets', port(8081), $ctx), qr!tickets:r!, 'tickets reused');
+
+###############################################################################
+
+sub get_ssl_context {
+	return IO::Socket::SSL::SSL_Context->new(
+		SSL_verify_mode => IO::Socket::SSL::SSL_VERIFY_NONE(),
+		SSL_session_cache_size => 100
+	);
+}
+
+sub get_ssl_socket {
+	my ($host, $port, $ctx) = @_;
+	my $s;
+
+	eval {
+		local $SIG{ALRM} = sub { die "timeout\n" };
+		local $SIG{PIPE} = sub { die "sigpipe\n" };
+		alarm(8);
+		$s = IO::Socket::SSL->new(
+			Proto => 'tcp',
+			PeerAddr => '127.0.0.1',
+			PeerPort => $port,
+			SSL_hostname => $host,
+			SSL_reuse_ctx => $ctx,
+			SSL_error_trap => sub { die $_[1] }
+		);
+		alarm(0);
+	};
+	alarm(0);
+
+	if ($@) {
+		log_in("died: $@");
+		return undef;
+	}
+
+	return $s;
+}
+
+sub get {
+	my ($host, $port, $ctx) = @_;
+
+	my $s = get_ssl_socket($host, $port, $ctx) or return;
+	my $r = http(<<EOF, socket => $s);
+GET / HTTP/1.0
+Host: $host
+
+EOF
+
+	$s->close();
+	return $r;
+}
+
+###############################################################################
diff --git a/tests/ssl_stapling.t b/tests/ssl_stapling.t
new file mode 100644
index 0000000..d5b8ff3
--- /dev/null
+++ b/tests/ssl_stapling.t
@@ -0,0 +1,406 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for OCSP stapling.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use MIME::Base64 qw/ decode_base64 /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval {
+	require Net::SSLeay;
+	Net::SSLeay::load_error_strings();
+	Net::SSLeay::SSLeay_add_ssl_algorithms();
+	Net::SSLeay::randomize();
+	Net::SSLeay::SSLeay();
+	defined &Net::SSLeay::set_tlsext_status_type or die;
+};
+plan(skip_all => 'Net::SSLeay not installed or too old') if $@;
+
+my $t = Test::Nginx->new()->has(qw/http http_ssl/)->has_daemon('openssl');
+
+plan(skip_all => 'no OCSP stapling') if $t->has_module('BoringSSL');
+
+$t->plan(9)->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    ssl_stapling on;
+    ssl_trusted_certificate trusted.crt;
+
+    ssl_certificate ec-end-int.crt;
+    ssl_certificate_key ec-end.key;
+
+    ssl_certificate end-int.crt;
+    ssl_certificate_key end.key;
+
+    ssl_ciphers DEFAULT:ECCdraft;
+
+    server {
+        listen       127.0.0.1:8443 ssl;
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+    }
+
+    server {
+        listen       127.0.0.1:8444 ssl;
+        server_name  localhost;
+
+        ssl_stapling_responder http://127.0.0.1:8081/;
+    }
+
+    server {
+        listen       127.0.0.1:8445 ssl;
+        server_name  localhost;
+
+        ssl_stapling_verify on;
+    }
+
+    server {
+        listen       127.0.0.1:8446 ssl;
+        server_name  localhost;
+
+        ssl_certificate ec-end.crt;
+        ssl_certificate_key ec-end.key;
+    }
+
+    server {
+        listen       127.0.0.1:8447 ssl;
+        server_name  localhost;
+
+        ssl_certificate end-int.crt;
+        ssl_certificate_key end.key;
+
+        ssl_stapling_file %%TESTDIR%%/resp.der;
+    }
+
+    server {
+        listen       127.0.0.1:8448 ssl;
+        server_name  localhost;
+
+        ssl_certificate ec-end-int.crt;
+        ssl_certificate_key ec-end.key;
+
+        ssl_stapling_file %%TESTDIR%%/ec-resp.der;
+    }
+
+    server {
+        listen       127.0.0.1:8449 ssl;
+        server_name  localhost;
+
+        ssl_stapling_responder http://127.0.0.1:8080/;
+    }
+}
+
+EOF
+
+my $d = $t->testdir();
+my $p = port(8081);
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+$t->write_file('ca.conf', <<EOF);
+[ ca ]
+default_ca = myca
+
+[ myca ]
+new_certs_dir = $d
+database = $d/certindex
+default_md = sha256
+policy = myca_policy
+serial = $d/certserial
+default_days = 1
+x509_extensions = myca_extensions
+
+[ myca_policy ]
+commonName = supplied
+
+[ myca_extensions ]
+basicConstraints = critical,CA:TRUE
+authorityInfoAccess = OCSP;URI:http://127.0.0.1:$p
+EOF
+
+foreach my $name ('root') {
+	system('openssl req -x509 -new '
+		. "-config $d/openssl.conf -subj /CN=$name/ "
+		. "-out $d/$name.crt -keyout $d/$name.key "
+		. ">>$d/openssl.out 2>&1") == 0
+		or die "Can't create certificate for $name: $!\n";
+}
+
+foreach my $name ('int', 'end') {
+	system("openssl req -new "
+		. "-config $d/openssl.conf -subj /CN=$name/ "
+		. "-out $d/$name.csr -keyout $d/$name.key "
+		. ">>$d/openssl.out 2>&1") == 0
+		or die "Can't create certificate for $name: $!\n";
+}
+
+foreach my $name ('ec-end') {
+	system("openssl ecparam -genkey -out $d/$name.key -name prime256v1 "
+		. ">>$d/openssl.out 2>&1") == 0
+		or die "Can't create EC param: $!\n";
+	system("openssl req -new -key $d/$name.key "
+		. "-config $d/openssl.conf -subj /CN=$name/ "
+		. "-out $d/$name.csr "
+		. ">>$d/openssl.out 2>&1") == 0
+		or die "Can't create certificate for $name: $!\n";
+}
+
+$t->write_file('certserial', '1000');
+$t->write_file('certindex', '');
+
+system("openssl ca -batch -config $d/ca.conf "
+	. "-keyfile $d/root.key -cert $d/root.crt "
+	. "-subj /CN=int/ -in $d/int.csr -out $d/int.crt "
+	. ">>$d/openssl.out 2>&1") == 0
+	or die "Can't sign certificate for int: $!\n";
+
+system("openssl ca -batch -config $d/ca.conf "
+	. "-keyfile $d/int.key -cert $d/int.crt "
+	. "-subj /CN=ec-end/ -in $d/ec-end.csr -out $d/ec-end.crt "
+	. ">>$d/openssl.out 2>&1") == 0
+	or die "Can't sign certificate for ec-end: $!\n";
+
+system("openssl ca -batch -config $d/ca.conf "
+	. "-keyfile $d/int.key -cert $d/int.crt "
+	. "-subj /CN=end/ -in $d/end.csr -out $d/end.crt "
+	. ">>$d/openssl.out 2>&1") == 0
+	or die "Can't sign certificate for end: $!\n";
+
+# RFC 6960, serialNumber
+
+system("openssl x509 -in $d/end.crt -serial -noout "
+	. ">>$d/serial 2>>$d/openssl.out") == 0
+	or die "Can't obtain serial for end: $!\n";
+
+my $serial = pack("n2", 0x0202, hex $1) if $t->read_file('serial') =~ /(\d+)/;
+
+system("openssl ca -config $d/ca.conf -revoke $d/end.crt "
+	. "-keyfile $d/root.key -cert $d/root.crt "
+	. ">>$d/openssl.out 2>&1") == 0
+	or die "Can't revoke end.crt: $!\n";
+
+system("openssl ocsp -issuer $d/int.crt -cert $d/end.crt "
+	. "-reqout $d/req.der >>$d/openssl.out 2>&1") == 0
+	or die "Can't create OCSP request: $!\n";
+
+system("openssl ocsp -index $d/certindex -CA $d/int.crt "
+	. "-rsigner $d/root.crt -rkey $d/root.key "
+	. "-reqin $d/req.der -respout $d/resp.der -ndays 1 "
+	. ">>$d/openssl.out 2>&1") == 0
+	or die "Can't create OCSP response: $!\n";
+
+system("openssl ocsp -issuer $d/int.crt -cert $d/ec-end.crt "
+	. "-reqout $d/ec-req.der >>$d/openssl.out 2>&1") == 0
+	or die "Can't create EC OCSP request: $!\n";
+
+system("openssl ocsp -index $d/certindex -CA $d/int.crt "
+	. "-rsigner $d/root.crt -rkey $d/root.key "
+	. "-reqin $d/ec-req.der -respout $d/ec-resp.der -ndays 1 "
+	. ">>$d/openssl.out 2>&1") == 0
+	or die "Can't create EC OCSP response: $!\n";
+
+$t->write_file('trusted.crt',
+	$t->read_file('int.crt') . $t->read_file('root.crt'));
+$t->write_file('end-int.crt',
+	$t->read_file('end.crt') . $t->read_file('int.crt'));
+$t->write_file('ec-end-int.crt',
+	$t->read_file('ec-end.crt') . $t->read_file('int.crt'));
+
+$t->run_daemon(\&http_daemon, $t);
+$t->run();
+
+$t->waitforsocket("127.0.0.1:" . port(8081));
+
+###############################################################################
+
+my $version = get_version();
+
+staple(8443, 'RSA');
+staple(8443, 'ECDSA');
+staple(8444, 'RSA');
+staple(8444, 'ECDSA');
+staple(8445, 'ECDSA');
+staple(8446, 'ECDSA');
+staple(8449, 'ECDSA');
+
+sleep 1;
+
+ok(!staple(8443, 'RSA'), 'staple revoked');
+ok(staple(8443, 'ECDSA'), 'staple success');
+
+ok(!staple(8444, 'RSA'), 'responder revoked');
+ok(staple(8444, 'ECDSA'), 'responder success');
+
+ok(!staple(8445, 'ECDSA'), 'verify - root not trusted');
+
+ok(staple(8446, 'ECDSA', "$d/int.crt"), 'cert store');
+
+is(staple(8447, 'RSA'), '1 1', 'file revoked');
+is(staple(8448, 'ECDSA'), '1 0', 'file success');
+
+ok(!staple(8449, 'ECDSA'), 'ocsp error');
+
+###############################################################################
+
+sub staple {
+	my ($port, $ciphers, $ca) = @_;
+	my (@resp);
+
+	my $staple_cb = sub {
+		my ($ssl, $resp) = @_;
+		push @resp, !!$resp;
+		return 1 unless $resp;
+		my $cert = Net::SSLeay::get_peer_certificate($ssl);
+		my $certid = eval { Net::SSLeay::OCSP_cert2ids($ssl, $cert) }
+			or do { die "no OCSP_CERTID for certificate: $@"; };
+
+		my @res = Net::SSLeay::OCSP_response_results($resp, $certid);
+		push @resp, $res[0][2]->{'statusType'};
+	};
+
+	my $s;
+
+	eval {
+		local $SIG{ALRM} = sub { die "timeout\n" };
+		local $SIG{PIPE} = sub { die "sigpipe\n" };
+		alarm(8);
+		$s = IO::Socket::INET->new('127.0.0.1:' . port($port));
+		alarm(0);
+	};
+	alarm(0);
+
+	if ($@) {
+		log_in("died: $@");
+		return undef;
+	}
+
+	my $ctx = Net::SSLeay::CTX_new() or die("Failed to create SSL_CTX $!");
+
+	my $ssleay = Net::SSLeay::SSLeay();
+	if ($ssleay < 0x1000200f || $ssleay == 0x20000000) {
+		Net::SSLeay::CTX_set_cipher_list($ctx, $ciphers)
+			or die("Failed to set cipher list");
+	} else {
+		# SSL_CTRL_SET_SIGALGS_LIST
+		$ciphers = 'PSS' if $ciphers eq 'RSA' && $version > 0x0303;
+		Net::SSLeay::CTX_ctrl($ctx, 98, 0, $ciphers . '+SHA256')
+			or die("Failed to set sigalgs");
+	}
+
+	Net::SSLeay::CTX_load_verify_locations($ctx, $ca || '', '');
+	Net::SSLeay::CTX_set_tlsext_status_cb($ctx, $staple_cb);
+	my $ssl = Net::SSLeay::new($ctx) or die("Failed to create SSL $!");
+	Net::SSLeay::set_tlsext_status_type($ssl,
+		Net::SSLeay::TLSEXT_STATUSTYPE_ocsp());
+	Net::SSLeay::set_fd($ssl, fileno($s));
+	Net::SSLeay::connect($ssl) or die("ssl connect");
+
+	return join ' ', @resp;
+}
+
+sub get_version {
+	my $s;
+
+	eval {
+		local $SIG{ALRM} = sub { die "timeout\n" };
+		local $SIG{PIPE} = sub { die "sigpipe\n" };
+		alarm(8);
+		$s = IO::Socket::INET->new('127.0.0.1:' . port(8443));
+		alarm(0);
+	};
+	alarm(0);
+
+	if ($@) {
+		log_in("died: $@");
+		return undef;
+	}
+
+	my $ctx = Net::SSLeay::CTX_new() or die("Failed to create SSL_CTX $!");
+	my $ssl = Net::SSLeay::new($ctx) or die("Failed to create SSL $!");
+	Net::SSLeay::set_fd($ssl, fileno($s));
+	Net::SSLeay::connect($ssl) or die("ssl connect");
+
+	Net::SSLeay::version($ssl);
+}
+
+###############################################################################
+
+sub http_daemon {
+	my ($t) = shift;
+	my $server = IO::Socket::INET->new(
+		Proto => 'tcp',
+		LocalHost => "127.0.0.1:" . port(8081),
+		Listen => 5,
+		Reuse => 1
+	)
+		or die "Can't create listening socket: $!\n";
+
+	local $SIG{PIPE} = 'IGNORE';
+
+	while (my $client = $server->accept()) {
+		$client->autoflush(1);
+
+		my $headers = '';
+		my $uri = '';
+
+		while (<$client>) {
+			$headers .= $_;
+			last if (/^\x0d?\x0a?$/);
+		}
+
+		$uri = $1 if $headers =~ /^\S+\s+\/([^ ]+)\s+HTTP/i;
+		next unless $uri;
+
+		$uri =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg;
+		my $req = decode_base64($uri);
+		my $resp = index($req, $serial) > 0 ? 'resp' : 'ec-resp';
+
+		# ocsp dummy handler
+
+		select undef, undef, undef, 0.02;
+
+		$headers = <<"EOF";
+HTTP/1.1 200 OK
+Connection: close
+Content-Type: application/ocsp-response
+
+EOF
+
+		print $client $headers . $t->read_file("$resp.der");
+	}
+}
+
+###############################################################################
diff --git a/tests/ssl_verify_client.t b/tests/ssl_verify_client.t
new file mode 100644
index 0000000..60a8cfd
--- /dev/null
+++ b/tests/ssl_verify_client.t
@@ -0,0 +1,203 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http ssl module, ssl_verify_client.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/ :DEFAULT CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval {
+	require Net::SSLeay;
+	Net::SSLeay::load_error_strings();
+	Net::SSLeay::SSLeay_add_ssl_algorithms();
+	Net::SSLeay::randomize();
+};
+plan(skip_all => 'Net::SSLeay not installed') if $@;
+
+eval {
+	my $ctx = Net::SSLeay::CTX_new() or die;
+	my $ssl = Net::SSLeay::new($ctx) or die;
+	Net::SSLeay::set_tlsext_host_name($ssl, 'example.org') == 1 or die;
+};
+plan(skip_all => 'Net::SSLeay with OpenSSL SNI support required') if $@;
+
+my $t = Test::Nginx->new()->has(qw/http http_ssl sni/)
+	->has_daemon('openssl')->plan(11);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    add_header X-Verify x$ssl_client_verify:${ssl_client_cert}x;
+
+    ssl_session_cache shared:SSL:1m;
+    ssl_session_tickets off;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        ssl_certificate_key 1.example.com.key;
+        ssl_certificate 1.example.com.crt;
+
+        ssl_verify_client on;
+        ssl_client_certificate 2.example.com.crt;
+    }
+
+    server {
+        listen       127.0.0.1:8081 ssl;
+        server_name  on;
+
+        ssl_certificate_key 1.example.com.key;
+        ssl_certificate 1.example.com.crt;
+
+        ssl_verify_client on;
+        ssl_client_certificate 2.example.com.crt;
+    }
+
+    server {
+        listen       127.0.0.1:8081 ssl;
+        server_name  optional;
+
+        ssl_certificate_key 1.example.com.key;
+        ssl_certificate 1.example.com.crt;
+
+        ssl_verify_client optional;
+        ssl_client_certificate 2.example.com.crt;
+        ssl_trusted_certificate 3.example.com.crt;
+    }
+
+    server {
+        listen       127.0.0.1:8081 ssl;
+        server_name  optional_no_ca;
+
+        ssl_certificate_key 1.example.com.key;
+        ssl_certificate 1.example.com.crt;
+
+        ssl_verify_client optional_no_ca;
+        ssl_client_certificate 2.example.com.crt;
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  no_context;
+
+        ssl_verify_client on;
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('1.example.com', '2.example.com', '3.example.com') {
+	system('openssl req -x509 -new '
+		. "-config $d/openssl.conf -subj /CN=$name/ "
+		. "-out $d/$name.crt -keyout $d/$name.key "
+		. ">>$d/openssl.out 2>&1") == 0
+		or die "Can't create certificate for $name: $!\n";
+}
+
+sleep 1 if $^O eq 'MSWin32';
+
+$t->write_file('t', 'SEE-THIS');
+
+$t->run();
+
+###############################################################################
+
+like(http_get('/t'), qr/x:x/, 'plain connection');
+like(get('on'), qr/400 Bad Request/, 'no cert');
+like(get('no_context'), qr/400 Bad Request/, 'no server cert');
+like(get('optional'), qr/NONE:x/, 'no optional cert');
+like(get('optional', '1.example.com'), qr/400 Bad/, 'bad optional cert');
+like(get('optional_no_ca', '1.example.com'), qr/FAILED.*BEGIN/,
+	'bad optional_no_ca cert');
+
+like(get('localhost', '2.example.com'), qr/SUCCESS.*BEGIN/, 'good cert');
+like(get('optional', '2.example.com'), qr/SUCCESS.*BEGI/, 'good cert optional');
+like(get('optional', '3.example.com'), qr/SUCCESS.*BEGIN/, 'good cert trusted');
+
+SKIP: {
+skip 'Net::SSLeay version >= 1.36 required', 1 if $Net::SSLeay::VERSION < 1.36;
+
+my $ca = join ' ', get('optional', '3.example.com');
+is($ca, '/CN=2.example.com', 'no trusted sent');
+
+}
+
+like(get('optional', undef, 'localhost'), qr/421 Misdirected/, 'misdirected');
+
+###############################################################################
+
+sub get {
+	my ($sni, $cert, $host) = @_;
+
+	local $SIG{PIPE} = 'IGNORE';
+
+	$host = $sni if !defined $host;
+
+	my $dest_ip = inet_aton('127.0.0.1');
+	my $dest_serv_params = sockaddr_in(port(8081), $dest_ip);
+
+	socket(my $s, &AF_INET, &SOCK_STREAM, 0) or die "socket: $!";
+	connect($s, $dest_serv_params) or die "connect: $!";
+
+	my $ctx = Net::SSLeay::CTX_new() or die("Failed to create SSL_CTX $!");
+	Net::SSLeay::set_cert_and_key($ctx, "$d/$cert.crt", "$d/$cert.key")
+		or die if $cert;
+	my $ssl = Net::SSLeay::new($ctx) or die("Failed to create SSL $!");
+	Net::SSLeay::set_tlsext_host_name($ssl, $sni) == 1 or die;
+	Net::SSLeay::set_fd($ssl, fileno($s));
+	Net::SSLeay::connect($ssl) or die("ssl connect");
+
+	Net::SSLeay::write($ssl, 'GET /t HTTP/1.0' . CRLF);
+	Net::SSLeay::write($ssl, "Host: $host" . CRLF . CRLF);
+	my $buf = Net::SSLeay::read($ssl);
+	log_in($buf);
+	return $buf unless wantarray();
+
+	my $list = Net::SSLeay::get_client_CA_list($ssl);
+	my @names;
+	for my $i (0 .. Net::SSLeay::sk_X509_NAME_num($list) - 1) {
+		my $name = Net::SSLeay::sk_X509_NAME_value($list, $i);
+		push @names, Net::SSLeay::X509_NAME_oneline($name);
+	}
+	return @names;
+}
+
+###############################################################################
diff --git a/tests/ssl_verify_depth.t b/tests/ssl_verify_depth.t
new file mode 100644
index 0000000..37a8c10
--- /dev/null
+++ b/tests/ssl_verify_depth.t
@@ -0,0 +1,167 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http ssl module, ssl_verify_depth.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require IO::Socket::SSL; };
+plan(skip_all => 'IO::Socket::SSL not installed') if $@;
+eval { IO::Socket::SSL::SSL_VERIFY_NONE(); };
+plan(skip_all => 'IO::Socket::SSL too old') if $@;
+
+my $t = Test::Nginx->new()->has(qw/http http_ssl/)
+	->has_daemon('openssl')->plan(2);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    ssl_certificate_key  localhost.key;
+    ssl_certificate localhost.crt;
+
+    ssl_verify_client on;
+    ssl_client_certificate int-root.crt;
+
+    add_header X-Verify $ssl_client_verify;
+
+    server {
+        listen       127.0.0.1:8080 ssl;
+        server_name  localhost;
+        ssl_verify_depth 0;
+    }
+}
+
+EOF
+
+my $d = $t->testdir();
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+$t->write_file('ca.conf', <<EOF);
+[ ca ]
+default_ca = myca
+
+[ myca ]
+new_certs_dir = $d
+database = $d/certindex
+default_md = sha256
+policy = myca_policy
+serial = $d/certserial
+default_days = 1
+
+[ myca_policy ]
+commonName = supplied
+EOF
+
+foreach my $name ('root', 'localhost') {
+	system('openssl req -x509 -new '
+		. "-config $d/openssl.conf -subj /CN=$name/ "
+		. "-out $d/$name.crt -keyout $d/$name.key "
+		. ">>$d/openssl.out 2>&1") == 0
+		or die "Can't create certificate for $name: $!\n";
+}
+
+foreach my $name ('int', 'end') {
+	system("openssl req -new "
+		. "-config $d/openssl.conf -subj /CN=$name/ "
+		. "-out $d/$name.csr -keyout $d/$name.key "
+		. ">>$d/openssl.out 2>&1") == 0
+		or die "Can't create certificate for $name: $!\n";
+}
+
+$t->write_file('certserial', '1000');
+$t->write_file('certindex', '');
+
+system("openssl ca -batch -config $d/ca.conf "
+	. "-keyfile $d/root.key -cert $d/root.crt "
+	. "-subj /CN=int/ -in $d/int.csr -out $d/int.crt "
+	. ">>$d/openssl.out 2>&1") == 0
+	or die "Can't sign certificate for int: $!\n";
+
+system("openssl ca -batch -config $d/ca.conf "
+	. "-keyfile $d/int.key -cert $d/int.crt "
+	. "-subj /CN=end/ -in $d/end.csr -out $d/end.crt "
+	. ">>$d/openssl.out 2>&1") == 0
+	or die "Can't sign certificate for end: $!\n";
+
+$t->write_file('int-root.crt',
+	$t->read_file('int.crt') . $t->read_file('root.crt'));
+
+$t->write_file('t', '');
+$t->run();
+
+###############################################################################
+
+like(get(8080, 'root'), qr/SUCCESS/, 'verify depth');
+like(get(8080, 'end'), qr/400 Bad Request/, 'verify depth limited');
+
+###############################################################################
+
+sub get {
+	my ($port, $cert) = @_;
+	my $s = get_ssl_socket($port, $cert) or return;
+	http_get('/t', socket => $s);
+}
+
+sub get_ssl_socket {
+	my ($port, $cert) = @_;
+	my ($s);
+
+	eval {
+		local $SIG{ALRM} = sub { die "timeout\n" };
+		local $SIG{PIPE} = sub { die "sigpipe\n" };
+		alarm(8);
+		$s = IO::Socket::SSL->new(
+			Proto => 'tcp',
+			PeerAddr => '127.0.0.1',
+			PeerPort => port($port),
+			SSL_verify_mode => IO::Socket::SSL::SSL_VERIFY_NONE(),
+			SSL_cert_file => "$d/$cert.crt",
+			SSL_key_file => "$d/$cert.key",
+			SSL_error_trap => sub { die $_[1] }
+		);
+		alarm(0);
+	};
+	alarm(0);
+
+	if ($@) {
+		log_in("died: $@");
+		return undef;
+	}
+
+	return $s;
+}
+
+###############################################################################
diff --git a/tests/stream_access.t b/tests/stream_access.t
new file mode 100644
index 0000000..2ffba82
--- /dev/null
+++ b/tests/stream_access.t
@@ -0,0 +1,227 @@
+#!/usr/bin/perl
+
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+
+# Tests for stream access module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_access unix/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    server {
+        listen       127.0.0.1:8082;
+        proxy_pass   [::1]:%%PORT_8080%%;
+    }
+
+    server {
+        listen       127.0.0.1:8083;
+        proxy_pass   unix:%%TESTDIR%%/unix.sock.0;
+    }
+
+    server {
+        listen       127.0.0.1:8085;
+        proxy_pass   [::1]:%%PORT_8081%%;
+    }
+
+    server {
+        listen       127.0.0.1:8086;
+        proxy_pass   unix:%%TESTDIR%%/unix.sock.1;
+    }
+
+    server {
+        listen       127.0.0.1:8088;
+        proxy_pass   [::1]:%%PORT_8082%%;
+    }
+
+    server {
+        listen       127.0.0.1:8089;
+        proxy_pass   unix:%%TESTDIR%%/unix.sock.2;
+    }
+
+    server {
+        listen       127.0.0.1:8091;
+        proxy_pass   [::1]:%%PORT_8083%%;
+    }
+
+    server {
+        listen       127.0.0.1:8092;
+        proxy_pass   unix:%%TESTDIR%%/unix.sock.3;
+    }
+
+    server {
+        listen       127.0.0.1:8094;
+        proxy_pass   [::1]:%%PORT_8084%%;
+    }
+
+    server {
+        listen       127.0.0.1:8095;
+        proxy_pass   unix:%%TESTDIR%%/unix.sock.4;
+    }
+
+    server {
+        listen       127.0.0.1:8097;
+        proxy_pass   [::1]:%%PORT_8085%%;
+    }
+
+    server {
+        listen       127.0.0.1:8098;
+        proxy_pass   unix:%%TESTDIR%%/unix.sock.5;
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        listen       [::1]:%%PORT_8080%%;
+        listen       unix:%%TESTDIR%%/unix.sock.0;
+        proxy_pass   127.0.0.1:8080;
+        allow        all;
+    }
+
+    server {
+        listen       127.0.0.1:8084;
+        listen       [::1]:%%PORT_8081%%;
+        listen       unix:%%TESTDIR%%/unix.sock.1;
+        proxy_pass   127.0.0.1:8080;
+        deny         all;
+    }
+
+    server {
+        listen       127.0.0.1:8087;
+        listen       [::1]:%%PORT_8082%%;
+        listen       unix:%%TESTDIR%%/unix.sock.2;
+        proxy_pass   127.0.0.1:8080;
+        allow        unix:;
+    }
+
+    server {
+        listen       127.0.0.1:8090;
+        listen       [::1]:%%PORT_8083%%;
+        listen       unix:%%TESTDIR%%/unix.sock.3;
+        proxy_pass   127.0.0.1:8080;
+        deny         127.0.0.1;
+    }
+
+    server {
+        listen       127.0.0.1:8093;
+        listen       [::1]:%%PORT_8084%%;
+        listen       unix:%%TESTDIR%%/unix.sock.4;
+        proxy_pass   127.0.0.1:8080;
+        deny         ::1;
+    }
+
+    server {
+        listen       127.0.0.1:8096;
+        listen       [::1]:%%PORT_8085%%;
+        listen       unix:%%TESTDIR%%/unix.sock.5;
+        proxy_pass   127.0.0.1:8080;
+        deny         unix:;
+    }
+}
+
+EOF
+
+$t->try_run('no inet6 support')->plan(18);
+$t->run_daemon(\&stream_daemon);
+$t->waitforsocket('127.0.0.1:' . port(8080));
+
+###############################################################################
+
+my $str = 'SEE-THIS';
+
+# allow all
+
+is(stream('127.0.0.1:' . port(8081))->io($str), $str, 'inet allow all');
+is(stream('127.0.0.1:' . port(8082))->io($str), $str, 'inet6 allow all');
+is(stream('127.0.0.1:' . port(8083))->io($str), $str, 'unix allow all');
+
+# deny all
+
+is(stream('127.0.0.1:' . port(8084))->io($str), '', 'inet deny all');
+is(stream('127.0.0.1:' . port(8085))->io($str), '', 'inet6 deny all');
+is(stream('127.0.0.1:' . port(8086))->io($str), '', 'unix deny all');
+
+# allow unix
+
+is(stream('127.0.0.1:' . port(8087))->io($str), $str, 'inet allow unix');
+is(stream('127.0.0.1:' . port(8088))->io($str), $str, 'inet6 allow unix');
+is(stream('127.0.0.1:' . port(8089))->io($str), $str, 'unix allow unix');
+
+# deny inet
+
+is(stream('127.0.0.1:' . port(8090))->io($str), '', 'inet deny inet');
+is(stream('127.0.0.1:' . port(8091))->io($str), $str, 'inet6 deny inet');
+is(stream('127.0.0.1:' . port(8092))->io($str), $str, 'unix deny inet');
+
+# deny inet6
+
+is(stream('127.0.0.1:' . port(8093))->io($str), $str, 'inet deny inet6');
+is(stream('127.0.0.1:' . port(8094))->io($str), '', 'inet6 deny inet6');
+is(stream('127.0.0.1:' . port(8095))->io($str), $str, 'unix deny inet6');
+
+# deny unix
+
+is(stream('127.0.0.1:' . port(8096))->io($str), $str, 'inet deny unix');
+is(stream('127.0.0.1:' . port(8097))->io($str), $str, 'inet6 deny unix');
+is(stream('127.0.0.1:' . port(8098))->io($str), '', 'unix deny unix');
+
+###############################################################################
+
+sub stream_daemon {
+	my $server = IO::Socket::INET->new(
+		Proto => 'tcp',
+		LocalAddr => '127.0.0.1:' . port(8080),
+		Listen => 5,
+		Reuse => 1
+	)
+		or die "Can't create listening socket: $!\n";
+
+	local $SIG{PIPE} = 'IGNORE';
+
+	while (my $client = $server->accept()) {
+		$client->autoflush(1);
+
+		log2c("(new connection $client)");
+
+		$client->sysread(my $buffer, 65536) or next;
+
+		log2i("$client $buffer");
+
+		log2o("$client $buffer");
+
+		$client->syswrite($buffer);
+
+		close $client;
+	}
+}
+
+sub log2i { Test::Nginx::log_core('|| <<', @_); }
+sub log2o { Test::Nginx::log_core('|| >>', @_); }
+sub log2c { Test::Nginx::log_core('||', @_); }
+
+###############################################################################
diff --git a/tests/stream_access_log.t b/tests/stream_access_log.t
new file mode 100644
index 0000000..a354da6
--- /dev/null
+++ b/tests/stream_access_log.t
@@ -0,0 +1,207 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for stream access_log module and variables.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_map gzip/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    log_format  test  $server_addr;
+    log_format  vars  $connection:$nginx_version:$hostname:$pid;
+    log_format  addr  $binary_remote_addr:$remote_addr:$remote_port:
+                      $server_addr:$server_port:$upstream_addr;
+    log_format  date  $msec!$time_local!$time_iso8601;
+    log_format  byte  $bytes_received:$bytes_sent:
+                      $upstream_bytes_sent:$upstream_bytes_received;
+    log_format  time  $upstream_connect_time:$upstream_first_byte_time:
+                      $upstream_session_time:$session_time;
+
+    access_log  %%TESTDIR%%/off.log test;
+
+    map $server_port $logme {
+        %%PORT_8083%%  1;
+        default        0;
+    }
+
+    server {
+        listen      127.0.0.1:8081;
+        proxy_pass  127.0.0.1:8080;
+        access_log  off;
+    }
+
+    server {
+        listen      127.0.0.1:8082;
+        proxy_pass  127.0.0.1:8080;
+        proxy_download_rate 2;
+        access_log  %%TESTDIR%%/time.log time;
+    }
+
+    server {
+        listen      127.0.0.1:8083;
+        listen      127.0.0.1:8084;
+        proxy_pass  127.0.0.1:8080;
+        access_log  %%TESTDIR%%/filtered.log test if=$logme;
+    }
+
+    server {
+        listen      127.0.0.1:8085;
+        proxy_pass  127.0.0.1:8080;
+        access_log  %%TESTDIR%%/complex.log test if=$logme$logme;
+    }
+
+    server {
+        listen      127.0.0.1:8086;
+        proxy_pass  127.0.0.1:8080;
+        access_log  %%TESTDIR%%/compressed.log test
+                    gzip buffer=1m flush=100ms;
+    }
+
+    server {
+        listen      127.0.0.1:8087;
+        proxy_pass  127.0.0.1:8080;
+        access_log  %%TESTDIR%%/varlog_$bytes_sent.log test;
+    }
+
+    server {
+        listen      127.0.0.1:8088;
+        proxy_pass  127.0.0.1:8080;
+        access_log  %%TESTDIR%%/vars.log vars;
+        access_log  %%TESTDIR%%/addr.log addr;
+        access_log  %%TESTDIR%%/date.log date;
+        access_log  %%TESTDIR%%/byte.log byte;
+    }
+}
+
+EOF
+
+$t->run_daemon(\&stream_daemon);
+$t->run()->plan(10);
+
+$t->waitforsocket('127.0.0.1:' . port(8080));
+
+###############################################################################
+
+my $str = 'SEE-THIS';
+
+stream('127.0.0.1:' . port(8081))->io($str);
+stream('127.0.0.1:' . port(8082))->io($str);
+stream('127.0.0.1:' . port(8083))->io($str);
+stream('127.0.0.1:' . port(8084))->io($str);
+stream('127.0.0.1:' . port(8085))->io($str);
+stream('127.0.0.1:' . port(8086))->io($str);
+stream('127.0.0.1:' . port(8087))->io($str);
+
+my $dport = port(8088);
+my $s = stream("127.0.0.1:$dport");
+my $lhost = $s->sockhost();
+my $escaped = $s->sockaddr();
+$escaped =~ s/([^\x20-\x7e])/sprintf('\\x%02X', ord($1))/gmxe;
+my $lport = $s->sockport();
+my $uport = port(8080);
+
+$s->io($str);
+
+# wait for file to appear with nonzero size thanks to the flush parameter
+
+for (1 .. 10) {
+	last if -s $t->testdir() . '/compressed.log';
+	select undef, undef, undef, 0.1;
+}
+
+# verify that "gzip" parameter turns on compression
+
+SKIP: {
+	eval { require IO::Uncompress::Gunzip; };
+	skip("IO::Uncompress::Gunzip not installed", 1) if $@;
+
+	my $gzipped = $t->read_file('compressed.log');
+	my $log;
+	IO::Uncompress::Gunzip::gunzip(\$gzipped => \$log);
+	like($log, qr/^127.0.0.1/, 'compressed log - flush time');
+}
+
+# now verify all other logs
+
+$t->stop();
+
+is($t->read_file('off.log'), '', 'log off');
+is($t->read_file('filtered.log'), "127.0.0.1\n", 'log filtering');
+ok($t->read_file('complex.log'), 'if with complex value');
+ok($t->read_file('varlog_3.log'), 'variable in file');
+
+chomp(my $hostname = lc `hostname`);
+like($t->read_file('vars.log'), qr/^\d+:[\d.]+:$hostname:\d+$/, 'log vars');
+is($t->read_file('addr.log'),
+	"$escaped:$lhost:$lport:127.0.0.1:$dport:127.0.0.1:$uport\n",
+	'log addr');
+like($t->read_file('date.log'), qr#^\d+.\d+![-+\w/: ]+![-+\dT:]+$#, 'log date');
+is($t->read_file('byte.log'), "8:3:8:3\n", 'log bytes');
+like($t->read_file('time.log'), qr/0\.\d+:0\.\d+:1\.\d+:1\.\d+/, 'log time');
+
+###############################################################################
+
+sub stream_daemon {
+	my $server = IO::Socket::INET->new(
+		Proto => 'tcp',
+		LocalAddr => '127.0.0.1',
+		LocalPort => port(8080),
+		Listen => 5,
+		Reuse => 1
+	)
+		or die "Can't create listening socket: $!\n";
+
+	local $SIG{PIPE} = 'IGNORE';
+
+	while (my $client = $server->accept()) {
+		$client->autoflush(1);
+
+		log2c("(new connection $client)");
+
+		$client->sysread(my $buffer, 65536) or next;
+
+		log2i("$client $buffer");
+
+		$buffer = "ack";
+
+		log2o("$client $buffer");
+
+		$client->syswrite($buffer);
+
+		close $client;
+	}
+}
+
+sub log2i { Test::Nginx::log_core('|| <<', @_); }
+sub log2o { Test::Nginx::log_core('|| >>', @_); }
+sub log2c { Test::Nginx::log_core('||', @_); }
+
+###############################################################################
diff --git a/tests/stream_access_log_escape.t b/tests/stream_access_log_escape.t
new file mode 100644
index 0000000..40d63e4
--- /dev/null
+++ b/tests/stream_access_log_escape.t
@@ -0,0 +1,68 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Stream tests for access_log with escape parameter.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_map stream_return/)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    map $pid $a {
+        default '" \ "';
+    }
+    map $pid $b {
+        default "foo";
+    }
+
+    log_format json     escape=json     $a$b$upstream_addr;
+    log_format default  escape=default  $a$b$upstream_addr;
+
+    server {
+        listen       127.0.0.1:8080;
+        return       ok;
+
+        access_log %%TESTDIR%%/json.log json;
+        access_log %%TESTDIR%%/test.log default;
+    }
+}
+
+EOF
+
+$t->run()->plan(2);
+
+###############################################################################
+
+http_get('/');
+
+$t->stop();
+
+is($t->read_file('json.log'), '\" \\\\ \"foo' . "\n", 'json');
+is($t->read_file('test.log'), '\x22 \x5C \x22foo-' . "\n", 'default');
+
+###############################################################################
diff --git a/tests/stream_access_log_none.t b/tests/stream_access_log_none.t
new file mode 100644
index 0000000..5cd4ca0
--- /dev/null
+++ b/tests/stream_access_log_none.t
@@ -0,0 +1,65 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Stream tests for access_log with escape parameter.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_map stream_return/)->plan(1)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    map $pid $a {
+        default '" \ "';
+    }
+    map $pid $b {
+        default "foo";
+    }
+
+    log_format none     escape=none     $a$b$upstream_addr;
+
+    server {
+        listen       127.0.0.1:8080;
+        return       ok;
+
+        access_log %%TESTDIR%%/none.log none;
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+http_get('/');
+
+$t->stop();
+
+is($t->read_file('none.log'), '" \\ "foo' . "\n", 'none');
+
+###############################################################################
diff --git a/tests/stream_error_log.t b/tests/stream_error_log.t
new file mode 100644
index 0000000..d5df787
--- /dev/null
+++ b/tests/stream_error_log.t
@@ -0,0 +1,310 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Stream tests for error_log.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use IO::Select;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+plan(skip_all => 'win32') if $^O eq 'MSWin32';
+
+my $t = Test::Nginx->new()->has(qw/stream/)->plan(34);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+error_log %%TESTDIR%%/e_glob.log info;
+error_log %%TESTDIR%%/e_glob2.log info;
+error_log syslog:server=127.0.0.1:%%PORT_8983_UDP%% info;
+
+daemon off;
+
+events {
+}
+
+stream {
+    upstream u {
+        server 127.0.0.1:%%PORT_8983_UDP%% down;
+    }
+
+    server {
+        listen      127.0.0.1:8080;
+        proxy_pass  u;
+
+        error_log %%TESTDIR%%/e_debug.log debug;
+        error_log %%TESTDIR%%/e_info.log info;
+        error_log %%TESTDIR%%/e_emerg.log emerg;
+        error_log stderr info;
+    }
+
+    server {
+        listen      127.0.0.1:8082;
+        proxy_pass  127.0.0.1:8081;
+
+        error_log %%TESTDIR%%/e_stream.log info;
+        error_log syslog:server=127.0.0.1:%%PORT_8985_UDP%% info;
+        error_log syslog:server=127.0.0.1:%%PORT_8984_UDP%% info;
+    }
+}
+
+EOF
+
+open OLDERR, ">&", \*STDERR;
+open STDERR, '>', $t->testdir() . '/stderr' or die "Can't reopen STDERR: $!";
+open my $stderr, '<', $t->testdir() . '/stderr'
+	or die "Can't open stderr file: $!";
+
+$t->run_daemon(\&stream_daemon);
+$t->run_daemon(\&syslog_daemon, port(8983), $t, 's_glob.log');
+$t->run_daemon(\&syslog_daemon, port(8984), $t, 's_stream.log');
+
+$t->waitforsocket('127.0.0.1:' . port(8081));
+$t->waitforfile($t->testdir . '/s_glob.log');
+$t->waitforfile($t->testdir . '/s_stream.log');
+
+$t->run();
+
+open STDERR, ">&", \*OLDERR;
+
+###############################################################################
+
+stream('127.0.0.1:' . port(8080))->io('data');
+
+# error_log levels
+
+SKIP: {
+skip "no --with-debug", 1 unless $t->has_module('--with-debug');
+
+isnt(lines($t, 'e_debug.log', '[debug]'), 0, 'file debug in debug');
+
+}
+
+isnt(lines($t, 'e_info.log', '[info]'), 0, 'file info in info');
+is(lines($t, 'e_info.log', '[debug]'), 0, 'file debug in info');
+isnt(lines($t, 'stderr', '[info]'), 0, 'stderr info in info');
+is(lines($t, 'stderr', '[debug]'), 0, 'stderr debug in info');
+
+# multiple error_log
+
+like($t->read_file('e_glob.log'), qr!nginx/[.0-9]+!, 'error global');
+like($t->read_file('e_glob2.log'), qr!nginx/[.0-9]+!, 'error global 2');
+is_deeply(levels($t, 'e_glob.log'), levels($t, 'e_glob2.log'),
+	'multiple error global');
+
+# syslog
+
+parse_syslog_message('syslog', get_syslog('data2', '127.0.0.1:' . port(8082),
+	port(8985)));
+
+is_deeply(levels($t, 's_glob.log'), levels($t, 'e_glob.log'),
+	'global syslog messages');
+is_deeply(levels($t, 's_stream.log'), levels($t, 'e_stream.log'),
+	'stream syslog messages');
+
+# error_log context
+
+SKIP: {
+skip "relies on error log contents", 5 unless $ENV{TEST_NGINX_UNSAFE};
+
+my $msg = 'no live upstreams while connecting to upstream, '
+	. 'client: 127.0.0.1, server: 127.0.0.1:' . port(8080)
+	. ', upstream: "u"';
+
+unlike($t->read_file('e_glob.log'), qr/$msg/ms, 'stream error in global');
+like($t->read_file('e_info.log'), qr/$msg/ms, 'stream error in info');
+like($t->read_file('stderr'), qr/$msg/ms, 'stream error in info stderr');
+unlike($t->read_file('e_emerg.log'), qr/$msg/ms, 'stream error in emerg');
+
+$msg = "bytes from/to client:5/4, bytes from/to upstream:4/5";
+
+like($t->read_file('e_stream.log'), qr/$msg/ms, 'stream byte counters');
+
+}
+
+###############################################################################
+
+sub lines {
+	my ($t, $file, $pattern) = @_;
+
+	if ($file eq 'stderr') {
+		return map { $_ =~ /\Q$pattern\E/ } (<$stderr>);
+	}
+
+	my $path = $t->testdir() . '/' . $file;
+	open my $fh, '<', $path or return "$!";
+	my $value = map { $_ =~ /\Q$pattern\E/ } (<$fh>);
+	close $fh;
+	return $value;
+}
+
+sub levels {
+	my ($t, $file) = @_;
+	my %levels_hash;
+
+	map { $levels_hash{$_}++; } ($t->read_file($file) =~ /(\[\w+\])/g);
+
+	return \%levels_hash;
+}
+
+sub get_syslog {
+	my ($data, $peer, $port) = @_;
+	my ($s);
+
+	eval {
+		local $SIG{ALRM} = sub { die "timeout\n" };
+		local $SIG{PIPE} = sub { die "sigpipe\n" };
+		alarm(1);
+		$s = IO::Socket::INET->new(
+			Proto => 'udp',
+			LocalAddr => "127.0.0.1:$port"
+		);
+		alarm(0);
+	};
+	alarm(0);
+	if ($@) {
+		log_in("died: $@");
+		return undef;
+	}
+
+	stream($peer)->io($data);
+	$data = '';
+
+	IO::Select->new($s)->can_read(1.5);
+	while (IO::Select->new($s)->can_read(0.1)) {
+		my $buffer;
+		sysread($s, $buffer, 4096);
+		$data .= $buffer;
+	}
+	$s->close();
+	return $data;
+}
+
+sub parse_syslog_message {
+	my ($desc, $line) = @_;
+
+	ok($line, $desc);
+
+SKIP: {
+	skip "$desc timeout", 18 unless $line;
+
+	my @months = ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug',
+		'Sep', 'Oct', 'Nov', 'Dec');
+
+	my ($pri, $mon, $mday, $hour, $minute, $sec, $host, $tag, $msg) =
+		$line =~ /^<(\d{1,3})>				# PRI
+			([A-Z][a-z]{2})\s			# mon
+			([ \d]\d)\s(\d{2}):(\d{2}):(\d{2})\s	# date
+			([\S]*)\s				# host
+			(\w{1,32}):\s				# tag
+			(.*)/x;					# MSG
+
+	my $sev = $pri & 0x07;
+	my $fac = ($pri & 0x03f8) >> 3;
+
+	ok(defined($pri), "$desc has PRI");
+	ok($sev >= 0 && $sev <= 7, "$desc valid severity");
+	ok($fac >= 0 && $fac < 24, "$desc valid facility");
+
+	ok(defined($mon), "$desc has month");
+	ok((grep $mon, @months), "$desc valid month");
+
+	ok(defined($mday), "$desc has day");
+	ok($mday <= 31, "$desc valid day");
+
+	ok(defined($hour), "$desc has hour");
+	ok($hour < 24, "$desc valid hour");
+
+	ok(defined($minute), "$desc has minutes");
+	ok($minute < 60, "$desc valid minutes");
+
+	ok(defined($sec), "$desc has seconds");
+	ok($sec < 60, "$desc valid seconds");
+
+	ok(defined($host), "$desc has host");
+	chomp(my $hostname = lc `hostname`);
+	is($host , $hostname, "$desc valid host");
+
+	ok(defined($tag), "$desc has tag");
+	like($tag, qr'\w+', "$desc valid tag");
+
+	ok(length($msg) > 0, "$desc valid CONTENT");
+}
+
+}
+
+###############################################################################
+
+sub syslog_daemon {
+	my ($port, $t, $file) = @_;
+
+	my $s = IO::Socket::INET->new(
+		Proto => 'udp',
+		LocalAddr => "127.0.0.1:$port"
+	);
+
+	open my $fh, '>', $t->testdir() . '/' . $file;
+	select $fh; $| = 1;
+
+	while (1) {
+		my $buffer;
+		$s->recv($buffer, 4096);
+		print $fh $buffer . "\n";
+	}
+}
+
+sub stream_daemon {
+	my $server = IO::Socket::INET->new(
+		Proto => 'tcp',
+		LocalHost => '127.0.0.1',
+		LocalPort => port(8081),
+		Listen => 5,
+		Reuse => 1
+	)
+		or die "Can't create listening socket: $!\n";
+
+	local $SIG{PIPE} = 'IGNORE';
+
+	while (my $client = $server->accept()) {
+		$client->autoflush(1);
+
+		log2c("(new connection $client)");
+
+		$client->sysread(my $buffer, 65536) or next;
+
+		log2i("$client $buffer");
+
+		$buffer = $client->sockport();
+
+		log2o("$client $buffer");
+
+		$client->syswrite($buffer);
+
+		close $client;
+	}
+}
+
+sub log2i { Test::Nginx::log_core('|| <<', @_); }
+sub log2o { Test::Nginx::log_core('|| >>', @_); }
+sub log2c { Test::Nginx::log_core('||', @_); }
+
+###############################################################################
diff --git a/tests/stream_geo.t b/tests/stream_geo.t
new file mode 100644
index 0000000..d263ec9
--- /dev/null
+++ b/tests/stream_geo.t
@@ -0,0 +1,253 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+# (C) Sergey Kandaurov
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+
+# Tests for stream geo module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_return stream_map stream_geo/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    geo $geo {
+        127.0.0.0/8   loopback;
+        192.0.2.0/24  test;
+        0.0.0.0/0     world;
+    }
+
+    geo $geo_include {
+        include       geo.conf;
+        192.0.2.0/24  test;
+        0.0.0.0/0     world;
+    }
+
+    geo $geo_delete {
+        127.0.0.0/8   loopback;
+        192.0.2.0/24  test;
+        0.0.0.0/0     world;
+        delete        127.0.0.0/8;
+    }
+
+    geo $remote_addr $geo_from_addr {
+        127.0.0.0/8   loopback;
+        192.0.2.0/24  test;
+    }
+
+    map $server_port $var {
+        %%PORT_8080%%  "192.0.2.1";
+        %%PORT_8081%%  "10.0.0.1";
+        %%PORT_8085%%  "10.11.2.1";
+        %%PORT_8086%%  "loopback";
+        %%PORT_8087%%  "10.13.2.1";
+    }
+
+    geo $var $geo_from_var {
+        default       default;
+        127.0.0.0/8   loopback;
+        192.0.2.0/24  test;
+    }
+
+    geo $var $geo_var_ranges {
+        ranges;
+        default                default;
+        127.0.0.0-127.0.0.1    loopback;
+
+        # ranges with two /16 networks
+        # the latter network has greater two least octets
+        # (see 1301a58b5dac for details)
+        10.10.3.0-10.11.2.255  foo;
+        10.12.3.0-10.13.2.255  foo2;
+        delete                 10.10.3.0-10.11.2.255;
+    }
+
+    geo $var $geo_world {
+        127.0.0.0/8   loopback;
+        192.0.2.0/24  test;
+        0.0.0.0/0     world;
+    }
+
+    geo $geo_ranges {
+        ranges;
+        default                    default;
+        127.0.0.0-127.255.255.255  loopback;
+        192.0.2.0-192.0.2.255      test;
+    }
+
+    geo $geo_ranges_include {
+        ranges;
+        default                default;
+        include                geo-ranges.conf;
+        192.0.2.0-192.0.2.255  test;
+    }
+
+    geo $geo_ranges_delete {
+        ranges;
+        default                default;
+        127.0.0.0-127.0.0.255  test;
+        127.0.0.1-127.0.0.1    loopback;
+        delete                 127.0.0.0-127.0.0.0;
+        delete                 127.0.0.2-127.0.0.255;
+        delete                 127.0.0.1-127.0.0.1;
+    }
+
+    # delete range with two /16
+    geo $geo_ranges_delete_2 {
+        ranges;
+        default              default;
+        127.0.0.0-127.1.0.0  loopback;
+        delete               127.0.0.0-127.1.0.0;
+    }
+
+    geo $geo_before {
+        ranges;
+        default                default;
+        127.0.0.1-127.0.0.255  loopback;
+        127.0.0.0-127.0.0.0    test;
+    }
+
+    geo $geo_after {
+        ranges;
+        default                default;
+        127.0.0.0-127.0.0.1    loopback;
+        127.0.0.2-127.0.0.255  test;
+    }
+
+    geo $geo_insert {
+        ranges;
+        default                default;
+        127.0.0.0-127.0.0.255  test;
+        127.0.0.1-127.0.0.2    test2;
+        127.0.0.1-127.0.0.1    loopback;
+    }
+
+    geo $geo_insert_before {
+        ranges;
+        default                default;
+        127.0.0.0-127.0.0.255  test;
+        127.0.0.0-127.0.0.1    loopback;
+    }
+
+    geo $geo_insert_after {
+        ranges;
+        default                default;
+        127.0.0.0-127.0.0.255  test;
+        127.0.0.1-127.0.0.255  loopback;
+     }
+
+    server {
+        listen  127.0.0.1:8080;
+        return  "geo:$geo
+                 geo_include:$geo_include
+                 geo_delete:$geo_delete
+                 geo_ranges:$geo_ranges
+                 geo_ranges_include:$geo_ranges_include
+                 geo_before:$geo_before
+                 geo_after:$geo_after
+                 geo_insert:$geo_insert
+                 geo_insert_before:$geo_insert_before
+                 geo_insert_after:$geo_insert_after
+                 geo_from_addr:$geo_from_addr
+                 geo_from_var:$geo_from_var";
+    }
+
+    server {
+        listen  127.0.0.1:8081;
+        return  $geo_from_var;
+    }
+
+    server {
+        listen  127.0.0.1:8082;
+        return  $geo_world;
+    }
+
+    server {
+        listen  127.0.0.1:8083;
+        return  $geo_ranges_delete;
+    }
+
+    server {
+        listen  127.0.0.1:8084;
+        return  $geo_ranges_delete_2;
+    }
+
+    server {
+        listen  127.0.0.1:8085;
+        return  $geo_var_ranges;
+    }
+
+    server {
+        listen  127.0.0.1:8086;
+        return  $geo_var_ranges;
+    }
+
+    server {
+        listen  127.0.0.1:8087;
+        return  $geo_var_ranges;
+    }
+}
+
+EOF
+
+$t->write_file('geo.conf', '127.0.0.0/8  loopback;');
+$t->write_file('geo-ranges.conf', '127.0.0.0-127.255.255.255  loopback;');
+
+$t->run()->plan(19);
+
+###############################################################################
+
+my %data = stream('127.0.0.1:' . port(8080))->read() =~ /(\w+):(\w+)/g;
+is($data{geo}, 'loopback', 'geo');
+is($data{geo_include}, 'loopback', 'geo include');
+is($data{geo_delete}, 'world', 'geo delete');
+is($data{geo_ranges}, 'loopback', 'geo ranges');
+is($data{geo_ranges_include}, 'loopback', 'geo ranges include');
+
+is(stream('127.0.0.1:' . port(8083))->read(), 'default', 'geo ranges delete');
+is(stream('127.0.0.1:' . port(8084))->read(), 'default', 'geo ranges delete 2');
+
+is($data{geo_before}, 'loopback', 'geo ranges add before');
+is($data{geo_after}, 'loopback', 'geo ranges add after');
+is($data{geo_insert}, 'loopback', 'geo ranges insert');
+is($data{geo_insert_before}, 'loopback', 'geo ranges insert before');
+is($data{geo_insert_after}, 'loopback', 'geo ranges insert after');
+
+is($data{geo_from_addr}, 'loopback', 'geo from addr');
+is($data{geo_from_var}, 'test', 'geo from var');
+
+is(stream('127.0.0.1:' . port(8085))->read(), 'default',
+	'geo delete range from variable');
+
+is(stream('127.0.0.1:' . port(8081))->read(), 'default', 'geo default');
+is(stream('127.0.0.1:' . port(8082))->read(), 'world', 'geo world');
+is(stream('127.0.0.1:' . port(8086))->read(), 'default', 'geo ranges default');
+is(stream('127.0.0.1:' . port(8087))->read(), 'foo2', 'geo ranges add');
+
+###############################################################################
diff --git a/tests/stream_geo_binary.t b/tests/stream_geo_binary.t
new file mode 100644
index 0000000..4dfc532
--- /dev/null
+++ b/tests/stream_geo_binary.t
@@ -0,0 +1,72 @@
+#!/usr/bin/perl
+
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+
+# Tests for stream geo module with binary base.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+plan(skip_all => 'long configuration parsing') unless $ENV{TEST_NGINX_UNSAFE};
+
+my $t = Test::Nginx->new()->has(qw/stream stream_return stream_geo/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    geo $geo_base_create {
+        ranges;
+        include  base.conf;
+    }
+
+    geo $geo_base_include {
+        ranges;
+        include  base.conf;
+    }
+
+    server {
+        listen  127.0.0.1:8080;
+        return  "geo_base_create:$geo_base_create
+                 geo_base_include:$geo_base_include";
+    }
+}
+
+EOF
+
+$t->write_file('base.conf', join('', map {
+	"127." . $_/256/256 % 256 . "." . $_/256 % 256 . "." . $_ % 256 .
+	"-127." . $_/256/256 % 256 . "." . $_/256 % 256 . "." .$_ % 256 . " " .
+	($_ == 1 ? "loopback" : "range$_") . ";" } (0 .. 100000)));
+
+$t->run()->plan(2);
+
+###############################################################################
+
+my %data = stream('127.0.0.1:' . port(8080))->read() =~ /(\w+):(\w+)/g;
+is($data{geo_base_create}, 'loopback', 'geo binary base create');
+is($data{geo_base_include}, 'loopback', 'geo binary base include');
+
+###############################################################################
diff --git a/tests/stream_geo_ipv6.t b/tests/stream_geo_ipv6.t
new file mode 100644
index 0000000..2b150a4
--- /dev/null
+++ b/tests/stream_geo_ipv6.t
@@ -0,0 +1,103 @@
+#!/usr/bin/perl
+
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+
+# Stream tests for geo module with IPv6.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_return stream_map stream_geo/)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    geo $geo {
+        ::1/128         loopback;
+        2001:0db8::/32  test;
+        ::/0            world;
+    }
+
+    geo $geo_delete {
+        ::1/128         loopback;
+        2001:0db8::/32  test;
+        ::/0            world;
+        delete          ::1/128;
+    }
+
+    map $server_port $var {
+        %%PORT_8080%%  "::1";
+        %%PORT_8081%%  "::ffff:192.0.2.1";
+    }
+
+    geo $var $geo_var {
+        default    default;
+        192.0.2.1  test;
+    }
+
+    geo $var $geo_var_ranges {
+        ranges;
+        default              default;
+        127.0.0.1-127.0.0.2  loopback;
+        192.0.2.0-192.0.2.1  test;
+    }
+
+    server {
+        listen      127.0.0.1:8080;
+        proxy_pass  [::1]:%%PORT_8080%%;
+    }
+
+    server {
+        listen  [::1]:%%PORT_8080%%;
+        return  "geo:$geo
+                 geo_delete:$geo_delete
+                 geo_var:$geo_var
+                 geo_var_ranges:$geo_var_ranges";
+    }
+
+    server {
+        listen  127.0.0.1:8081;
+        return  "geo_var:$geo_var
+                 geo_var_ranges:$geo_var_ranges";
+    }
+}
+
+EOF
+
+$t->try_run('no inet6 support')->plan(6);
+
+###############################################################################
+
+my %data = stream('127.0.0.1:' . port(8080))->read() =~ /(\w+):(\w+)/g;
+is($data{geo}, 'loopback', 'geo ipv6');
+is($data{geo_delete}, 'world', 'geo ipv6 delete');
+is($data{geo_var}, 'default', 'geo ipv6 from variable');
+is($data{geo_var_ranges}, 'default', 'geo ipv6 from variable range');
+
+%data = stream('127.0.0.1:' . port(8081))->read() =~ /(\w+):(\w+)/g;
+is($data{geo_var}, 'test', 'geo ipv6 ipv4-mapped from variable');
+is($data{geo_var_ranges}, 'test', 'geo ipv6 ipv4-mapped from variable range');
+
+###############################################################################
diff --git a/tests/stream_geo_unix.t b/tests/stream_geo_unix.t
new file mode 100644
index 0000000..139eff4
--- /dev/null
+++ b/tests/stream_geo_unix.t
@@ -0,0 +1,85 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for stream geo module with unix socket.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_geo stream_return unix/)
+	->plan(4);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    geo $geo {
+        default                  default;
+        255.255.255.255          none;
+    }
+
+    geo $remote_addr $geora {
+        default                  default;
+        255.255.255.255          none;
+    }
+
+    geo $geor {
+        ranges;
+        0.0.0.0-255.255.255.254  test;
+        default                  none;
+    }
+
+    geo $remote_addr $georra {
+        ranges;
+        0.0.0.0-255.255.255.254  test;
+        default                  none;
+    }
+
+    server {
+        listen      unix:%%TESTDIR%%/unix.sock;
+        return      "geo:$geo geora:$geora geor:$geor georra:$georra";
+    }
+
+    server {
+        listen      127.0.0.1:8080;
+        proxy_pass  unix:%%TESTDIR%%/unix.sock;
+    }
+}
+
+EOF
+
+$t->write_file('index.html', '');
+$t->run();
+
+###############################################################################
+
+my %data = stream('127.0.0.1:' . port(8080))->read() =~ /(\w+):(\w+)/g;
+is($data{geo}, 'none', 'geo unix');
+is($data{geor}, 'none', 'geo unix ranges');
+is($data{geora}, 'none', 'geo unix remote addr');
+is($data{georra}, 'none', 'geo unix ranges remote addr');
+
+###############################################################################
diff --git a/tests/stream_geoip.t b/tests/stream_geoip.t
new file mode 100644
index 0000000..bef3840
--- /dev/null
+++ b/tests/stream_geoip.t
@@ -0,0 +1,193 @@
+#!/usr/bin/perl
+
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+
+# Tests for stream geoip module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/ $CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_geoip stream_return/)
+	->has('stream_realip');
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    set_real_ip_from  127.0.0.1/32;
+
+    geoip_country  %%TESTDIR%%/country.dat;
+    geoip_city     %%TESTDIR%%/city.dat;
+    geoip_org      %%TESTDIR%%/org.dat;
+
+    server {
+        listen  127.0.0.1:8080 proxy_protocol;
+        return  "country_code:$geoip_country_code
+                 country_code3:$geoip_country_code3
+                 country_name:$geoip_country_name
+
+                 area_code:$geoip_area_code
+                 city_continent_code:$geoip_city_continent_code
+                 city_country_code:$geoip_city_country_code
+                 city_country_code3:$geoip_city_country_code3
+                 city_country_name:$geoip_city_country_name
+                 dma_code:$geoip_dma_code
+                 latitude:$geoip_latitude
+                 longitude:$geoip_longitude
+                 region:$geoip_region
+                 region_name:$geoip_region_name
+                 city:$geoip_city
+                 postal_code:$geoip_postal_code
+
+                 org:$geoip_org";
+    }
+}
+
+EOF
+
+my $d = $t->testdir();
+
+# country database:
+#
+# "10.0.0.1","10.0.0.1","RU","Russian Federation"
+# "2001:db8::","2001:db8::","US","United States"
+
+my $data = '';
+
+for my $i (0 .. 156) {
+	# skip to offset 32 if 1st bit set in ipv6 address wins
+	$data .= pack_node($i + 1) . pack_node(32), next if $i == 2;
+	# otherwise default to RU
+	$data .= pack_node(0xffffb9) . pack_node(0xffff00), next if $i == 31;
+	# continue checking bits set in ipv6 address
+	$data .= pack_node(0xffff00) . pack_node($i + 1), next
+		if grep $_ == $i, (44, 49, 50, 52, 53, 55, 56, 57);
+	# last bit set in ipv6 address
+	$data .= pack_node(0xffffe1) . pack_node(0xffff00), next if $i == 156;
+	$data .= pack_node($i + 1) . pack_node(0xffff00);
+}
+
+$data .= chr(0x00) x 3;
+$data .= chr(0xFF) x 3;
+$data .= chr(12);
+
+$t->write_file('country.dat', $data);
+
+# city database:
+#
+# "167772161","167772161","RU","48","Moscow","119034","55.7543",37.6202",,
+
+$data = '';
+
+for my $i (0 .. 31) {
+	$data .= pack_node(32) . pack_node($i + 1), next if $i == 4 or $i == 6;
+	$data .= pack_node(32) . pack_node($i + 2), next if $i == 31;
+	$data .= pack_node($i + 1) . pack_node(32);
+}
+
+$data .= chr(42);
+$data .= chr(185);
+$data .= pack('Z*', 48);
+$data .= pack('Z*', 'Moscow');
+$data .= pack('Z*', 119034);
+$data .= pack_node(int((55.7543 + 180) * 10000));
+$data .= pack_node(int((37.6202 + 180) * 10000));
+$data .= chr(0) x 3;
+$data .= chr(0xFF) x 3;
+$data .= chr(2);
+$data .= pack_node(32);
+
+$t->write_file('city.dat', $data);
+
+# organization database:
+#
+# "167772161","167772161","Nginx"
+
+$data = '';
+
+for my $i (0 .. 31) {
+	$data .= pack_org(32) . pack_org($i + 1), next if $i == 4 or $i == 6;
+	$data .= pack_org(32) . pack_org($i + 2), next if $i == 31;
+	$data .= pack_org($i + 1) . pack_org(32);
+}
+
+$data .= chr(42);
+$data .= pack('Z*', 'Nginx');
+$data .= chr(0xFF) x 3;
+$data .= chr(5);
+$data .= pack_node(32);
+
+$t->write_file('org.dat', $data);
+$t->try_run('no inet6 support')->plan(20);
+
+###############################################################################
+
+my %data = stream_pp('10.0.0.1') =~ /(\w+):(.*)/g;
+is($data{country_code}, 'RU', 'geoip country code');
+is($data{country_code3}, 'RUS', 'geoip country code 3');
+is($data{country_name}, 'Russian Federation', 'geoip country name');
+
+is($data{area_code}, 0, 'geoip area code');
+is($data{city_continent_code}, 'EU', 'geoip city continent code');
+is($data{city_country_code}, 'RU', 'geoip city country code');
+is($data{city_country_code3}, 'RUS', 'geoip city country code 3');
+is($data{city_country_name}, 'Russian Federation', 'geoip city country name');
+is($data{dma_code}, 0, 'geoip dma code');
+is($data{latitude}, 55.7543, 'geoip latitude');
+is($data{longitude}, 37.6202, 'geoip longitude');
+is($data{region}, 48, 'geoip region');
+is($data{region_name}, 'Moscow City', 'geoip region name');
+is($data{city}, 'Moscow', 'geoip city');
+is($data{postal_code}, 119034, 'geoip postal code');
+
+is($data{org}, 'Nginx', 'geoip org');
+
+like(stream_pp('::ffff:10.0.0.1'), qr/org:Nginx/, 'geoip ipv6 ipv4-mapped');
+
+%data = stream_pp('2001:db8::') =~ /(\w+):(.*)/g;
+is($data{country_code}, 'US', 'geoip ipv6 country code');
+is($data{country_code3}, 'USA', 'geoip ipv6 country code 3');
+is($data{country_name}, 'United States', 'geoip ipv6 country name');
+
+###############################################################################
+
+sub stream_pp {
+	my ($ip) = @_;
+	my $type = ($ip =~ ':' ? 'TCP6' : 'TCP4');
+	return stream('127.0.0.1:' . port(8080))
+		->io("PROXY $type $ip 127.0.0.1 8080 8080${CRLF}");
+}
+
+sub pack_node {
+	substr pack('V', shift), 0, 3;
+}
+
+sub pack_org {
+	pack('V', shift);
+}
+
+###############################################################################
diff --git a/tests/stream_js.t b/tests/stream_js.t
new file mode 100644
index 0000000..0fa3715
--- /dev/null
+++ b/tests/stream_js.t
@@ -0,0 +1,441 @@
+#!/usr/bin/perl
+
+# (C) Andrey Zelenkov
+# (C) Dmitry Volyntsev
+# (C) Nginx, Inc.
+
+# Tests for stream njs module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ dgram stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy rewrite stream stream_return udp/)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    js_include test.js;
+
+    server {
+        listen       127.0.0.1:8079;
+        server_name  localhost;
+
+        location /njs {
+            js_content test_njs;
+        }
+
+        location /p/ {
+            proxy_pass http://127.0.0.1:8095/;
+
+        }
+
+        location /return {
+            return 200 $http_foo;
+        }
+    }
+}
+
+stream {
+    js_set $js_addr      js_addr;
+    js_set $js_var       js_var;
+    js_set $js_log       js_log;
+    js_set $js_unk       js_unk;
+    js_set $js_req_line  js_req_line;
+    js_set $js_sess_unk  js_sess_unk;
+
+    js_include test.js;
+
+    server {
+        listen  127.0.0.1:8080;
+        return  $js_addr;
+    }
+
+    server {
+        listen  127.0.0.1:8081;
+        return  $js_log;
+    }
+
+    server {
+        listen  127.0.0.1:8082;
+        return  $js_var;
+    }
+
+    server {
+        listen  127.0.0.1:8083;
+        return  $js_unk;
+    }
+
+    server {
+        listen  127.0.0.1:8084;
+        return  $js_sess_unk;
+    }
+
+    server {
+        listen  127.0.0.1:%%PORT_8985_UDP%% udp;
+        return  $js_addr;
+    }
+
+    server {
+        listen      127.0.0.1:8086;
+        js_access   js_access_step;
+        js_preread  js_preread_step;
+        js_filter   js_filter_step;
+        proxy_pass  127.0.0.1:8090;
+    }
+
+    server {
+        listen      127.0.0.1:8087;
+        js_access   js_access_undecided;
+        return      OK;
+    }
+
+    server {
+        listen      127.0.0.1:8088;
+        js_access   js_access_allow;
+        return      OK;
+    }
+
+    server {
+        listen      127.0.0.1:8089;
+        js_access   js_access_deny;
+        return      OK;
+    }
+
+    server {
+        listen      127.0.0.1:8091;
+        js_preread  js_preread_async;
+        proxy_pass  127.0.0.1:8090;
+    }
+
+    server {
+        listen      127.0.0.1:8092;
+        js_preread  js_preread_data;
+        proxy_pass  127.0.0.1:8090;
+    }
+
+    server {
+        listen      127.0.0.1:8093;
+        js_preread  js_preread_req_line;
+        return      $js_req_line;
+    }
+
+    server {
+        listen      127.0.0.1:8094;
+        js_filter   js_filter_empty;
+        proxy_pass  127.0.0.1:8090;
+    }
+
+    server {
+        listen      127.0.0.1:8095;
+        js_filter   js_filter_header_inject;
+        proxy_pass  127.0.0.1:8079;
+    }
+
+    server {
+        listen      127.0.0.1:8096;
+        js_filter   js_filter_search;
+        proxy_pass  127.0.0.1:8090;
+    }
+
+    server {
+        listen      127.0.0.1:8097;
+        js_access   js_access_except;
+        proxy_pass  127.0.0.1:8090;
+    }
+
+    server {
+        listen      127.0.0.1:8098;
+        js_preread  js_preread_except;
+        proxy_pass  127.0.0.1:8090;
+    }
+
+    server {
+        listen      127.0.0.1:8099;
+        js_filter   js_filter_except;
+        proxy_pass  127.0.0.1:8090;
+    }
+}
+
+EOF
+
+$t->write_file('test.js', <<EOF);
+    function test_njs(r) {
+        r.return(200, njs.version);
+    }
+
+    function js_addr(s) {
+        return 'addr=' + s.remoteAddress;
+    }
+
+    function js_var(s) {
+        return 'variable=' + s.variables.remote_addr;
+    }
+
+    function js_sess_unk(s) {
+        return 'sess_unk=' + s.unk;
+    }
+
+    function js_log(s) {
+        s.log("SEE-THIS");
+    }
+
+    var res = '';
+
+    function js_access_step(s) {
+        res += '1';
+
+        setTimeout(function() {
+            if (s.remoteAddress.match('127.0.0.1')) {
+                s.allow();
+            }
+        }, 1);
+    }
+
+    function js_preread_step(s) {
+        s.on('upload', function (data) {
+            res += '2';
+            if (res.length >= 3) {
+                s.done();
+            }
+        });
+    }
+
+    function js_filter_step(s) {
+        s.on('upload', function(data, flags) {
+            s.send(data);
+            res += '3';
+        });
+
+        s.on('download', function(data, flags) {
+
+            if (!flags.last) {
+                res += '4';
+                s.send(data);
+
+            } else {
+                res += '5';
+                s.send(res, {last:1});
+                s.off('download');
+            }
+        });
+    }
+
+    function js_access_undecided(s) {
+        s.decline();
+    }
+
+    function js_access_allow(s) {
+        if (s.remoteAddress.match('127.0.0.1')) {
+            s.done();
+            return;
+        }
+
+        s.abort();
+    }
+
+    function js_access_deny(s) {
+        if (s.remoteAddress.match('127.0.0.1')) {
+            s.abort();
+            return;
+        }
+
+        s.allow();
+    }
+
+
+    function js_preread_async(s) {
+        setTimeout(function() {
+            s.done();
+        }, 1);
+    }
+
+    function js_preread_data(s) {
+        s.on('upload', function (data, flags) {
+            if (data.indexOf('z') != -1) {
+                s.done();
+            }
+        });
+    }
+
+    var line = '';
+
+    function js_preread_req_line(s) {
+        s.on('upload', function (data, flags) {
+            var n = data.indexOf('\\n');
+            if (n != -1) {
+                line = data.substr(0, n);
+                s.done();
+            }
+        });
+    }
+
+    function js_req_line(s) {
+        return line;
+    }
+
+    function js_filter_empty(s) {
+    }
+
+    function js_filter_header_inject(s) {
+        var req = '';
+
+        s.on('upload', function(data, flags) {
+            req += data;
+
+            var n = req.search('\\n');
+            if (n != -1) {
+                var rest = req.substr(n + 1);
+                req = req.substr(0, n + 1);
+
+                s.send(req + 'Foo: foo' + '\\r\\n' + rest, flags);
+
+                s.off('upload');
+            }
+        });
+    }
+
+    function js_filter_search(s) {
+        s.on('download', function(data, flags) {
+            var n = data.search('y');
+            if (n != -1) {
+                s.send('z');
+            }
+        });
+
+        s.on('upload', function(data, flags) {
+            var n = data.search('x');
+            if (n != -1) {
+                s.send('y');
+            }
+        });
+    }
+
+    function js_access_except(s) {
+        function done() {return s.a.a};
+
+        setTimeout(done, 1);
+        setTimeout(done, 2);
+    }
+
+    function js_preread_except(s) {
+        var fs = require('fs');
+        fs.readFileSync();
+    }
+
+    function js_filter_except(s) {
+        s.on('unknown', function() {});
+    }
+
+EOF
+
+$t->run_daemon(\&stream_daemon, port(8090));
+$t->try_run('no stream njs available')->plan(19);
+$t->waitforsocket('127.0.0.1:' . port(8090));
+
+###############################################################################
+
+is(stream('127.0.0.1:' . port(8080))->read(), 'addr=127.0.0.1',
+	's.remoteAddress');
+is(dgram('127.0.0.1:' . port(8985))->io('.'), 'addr=127.0.0.1',
+	's.remoteAddress udp');
+is(stream('127.0.0.1:' . port(8081))->read(), 'undefined', 's.log');
+is(stream('127.0.0.1:' . port(8082))->read(), 'variable=127.0.0.1',
+	's.variables');
+is(stream('127.0.0.1:' . port(8083))->read(), '', 'stream js unknown function');
+is(stream('127.0.0.1:' . port(8084))->read(), 'sess_unk=undefined', 's.unk');
+
+is(stream('127.0.0.1:' . port(8086))->io('0'), '0122345',
+	'async handlers order');
+is(stream('127.0.0.1:' . port(8087))->io('#'), 'OK', 'js_access_undecided');
+is(stream('127.0.0.1:' . port(8088))->io('#'), 'OK', 'js_access_allow');
+is(stream('127.0.0.1:' . port(8089))->io('#'), '', 'js_access_deny');
+
+is(stream('127.0.0.1:' . port(8091))->io('#'), '#', 'js_preread_async');
+is(stream('127.0.0.1:' . port(8092))->io('#z'), '#z', 'js_preread_async_data');
+is(stream('127.0.0.1:' . port(8093))->io("xy\na"), 'xy', 'js_preread_req_line');
+
+is(stream('127.0.0.1:' . port(8094))->io('x'), 'x', 'js_filter_empty');
+like(get('/p/return'), qr/foo/, 'js_filter_injected_header');
+is(stream('127.0.0.1:' . port(8096))->io('x'), 'z', 'js_filter_search');
+
+stream('127.0.0.1:' . port(8097))->io('x');
+stream('127.0.0.1:' . port(8098))->io('x');
+stream('127.0.0.1:' . port(8099))->io('x');
+
+$t->stop();
+
+ok(index($t->read_file('error.log'), 'SEE-THIS') > 0, 'stream js log');
+ok(index($t->read_file('error.log'), 'at fs.readFileSync') > 0,
+	'stream js_preread backtrace');
+ok(index($t->read_file('error.log'), 'at js_filter_except') > 0,
+	'stream js_filter backtrace');
+
+###############################################################################
+
+sub stream_daemon {
+	my $server = IO::Socket::INET->new(
+		Proto => 'tcp',
+		LocalAddr => '127.0.0.1:' . port(8090),
+		Listen => 5,
+		Reuse => 1
+	)
+		or die "Can't create listening socket: $!\n";
+
+	local $SIG{PIPE} = 'IGNORE';
+
+	while (my $client = $server->accept()) {
+		$client->autoflush(1);
+
+		log2c("(new connection $client)");
+
+		$client->sysread(my $buffer, 65536) or next;
+
+		log2i("$client $buffer");
+
+		log2o("$client $buffer");
+
+		$client->syswrite($buffer);
+
+		close $client;
+	}
+}
+
+sub log2i { Test::Nginx::log_core('|| <<', @_); }
+sub log2o { Test::Nginx::log_core('|| >>', @_); }
+sub log2c { Test::Nginx::log_core('||', @_); }
+
+sub get {
+	my ($url, %extra) = @_;
+
+	my $s = IO::Socket::INET->new(
+		Proto => 'tcp',
+		PeerAddr => '127.0.0.1:' . port(8079)
+	) or die "Can't connect to nginx: $!\n";
+
+	return http_get($url, socket => $s);
+}
+
+###############################################################################
diff --git a/tests/stream_js_import.t b/tests/stream_js_import.t
new file mode 100644
index 0000000..509aa88
--- /dev/null
+++ b/tests/stream_js_import.t
@@ -0,0 +1,115 @@
+#!/usr/bin/perl
+
+# (C) Dmitry Volyntsev
+# (C) Nginx, Inc.
+
+# Tests for stream njs module, js_import directive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http stream stream_return/)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    js_set $test foo.bar.p;
+
+    js_import lib.js;
+    js_import foo from ./main.js;
+
+    server {
+        listen  127.0.0.1:8081;
+        return  $test;
+    }
+
+    server {
+        listen      127.0.0.1:8082;
+        js_access   lib.access;
+        js_preread  lib.preread;
+        js_filter   lib.filter;
+        proxy_pass  127.0.0.1:8083;
+    }
+
+    server {
+        listen  127.0.0.1:8083;
+        return  "x";
+    }
+}
+
+EOF
+
+$t->write_file('lib.js', <<EOF);
+    var res = '';
+
+    function access(s) {
+        res += '1';
+        s.allow();
+    }
+
+    function preread(s) {
+        s.on('upload', function (data) {
+            res += '2';
+            if (res.length >= 3) {
+                s.done();
+            }
+        });
+    }
+
+    function filter(s) {
+        s.on('upload', function(data, flags) {
+            s.send(data);
+            res += '3';
+        });
+
+        s.on('download', function(data, flags) {
+            if (!flags.last) {
+                res += '4';
+                s.send(data);
+
+            } else {
+                res += '5';
+                s.send(res, {last:1});
+                s.off('download');
+            }
+        });
+    }
+
+    export default {access, preread, filter};
+
+EOF
+
+$t->write_file('main.js', <<EOF);
+    export default {bar: {p(s) {return "P-TEST"}}};
+
+EOF
+
+$t->try_run('no njs available')->plan(2);
+
+###############################################################################
+
+is(stream('127.0.0.1:' . port(8081))->read(), 'P-TEST', 'foo.bar.p');
+is(stream('127.0.0.1:' . port(8082))->io('0'), 'x122345', 'lib.access');
+
+###############################################################################
diff --git a/tests/stream_js_object.t b/tests/stream_js_object.t
new file mode 100644
index 0000000..b3cb129
--- /dev/null
+++ b/tests/stream_js_object.t
@@ -0,0 +1,119 @@
+#!/usr/bin/perl
+
+# (C) Dmitry Volyntsev
+# (C) Nginx, Inc.
+
+# Tests for stream njs module, stream session object.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http stream stream_return/)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    js_include test.js;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /njs {
+            js_content test_njs;
+        }
+    }
+}
+
+stream {
+    js_set $test     test;
+
+    js_include test.js;
+
+    server {
+        listen  127.0.0.1:8081;
+        return  $test$status;
+    }
+}
+
+EOF
+
+$t->write_file('test.js', <<EOF);
+    function test_njs(r) {
+        r.return(200, njs.version);
+    }
+
+    function to_string(s) {
+        return s.toString() === '[object Stream Session]';
+    }
+
+    function define_prop(s) {
+        Object.defineProperty(s.variables, 'status', {value:400});
+        return s.variables.status == 400;
+    }
+
+    function in_operator(s) {
+        return ['status', 'unknown']
+               .map(v=>v in s.variables)
+               .toString() === 'true,false';
+    }
+
+    function redefine_proto(s) {
+        s[0] = 'a';
+        s[1] = 'b';
+        s.length = 2;
+        Object.setPrototypeOf(s, Array.prototype);
+        return s.join('|') === 'a|b';
+    }
+
+    function get_own_prop_descs(s) {
+        return Object.getOwnPropertyDescriptors(s)['on'].value === s.on;
+    }
+
+    function test(s) {
+        return [ to_string,
+                 define_prop,
+                 in_operator,
+                 redefine_proto,
+                 get_own_prop_descs,
+               ].every(v=>v(s));
+    }
+
+EOF
+
+$t->try_run('no njs stream session object')->plan(1);
+
+###############################################################################
+
+TODO: {
+local $TODO = 'not yet'
+              unless http_get('/njs') =~ /^([.0-9]+)$/m && $1 ge '0.4.0';
+
+is(stream('127.0.0.1:' . port(8081))->read(), 'true400', 'var set');
+
+}
+
+###############################################################################
diff --git a/tests/stream_js_variables.t b/tests/stream_js_variables.t
new file mode 100644
index 0000000..1697948
--- /dev/null
+++ b/tests/stream_js_variables.t
@@ -0,0 +1,99 @@
+#!/usr/bin/perl
+
+# (C) Dmitry Volyntsev
+# (C) Nginx, Inc.
+
+# Tests for stream njs module, setting nginx variables.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http stream stream_return/)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    js_include test.js;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /njs {
+            js_content test_njs;
+        }
+    }
+}
+
+stream {
+    js_set $test_var       test_var;
+    js_set $test_not_found test_not_found;
+
+    js_include test.js;
+
+    server {
+        listen  127.0.0.1:8081;
+        return  $test_var$status;
+    }
+
+    server {
+        listen  127.0.0.1:8082;
+        return  $test_not_found;
+    }
+}
+
+EOF
+
+$t->write_file('test.js', <<EOF);
+    function test_njs(r) {
+        r.return(200, njs.version);
+    }
+
+    function test_var(s) {
+        s.variables.status = 400;
+        return 'test_var';
+    }
+
+    function test_not_found(s) {
+        try {
+            s.variables.unknown = 1;
+        } catch (e) {
+            return 'not_found';
+        }
+    }
+
+EOF
+
+$t->try_run('no stream njs available')->plan(2);
+
+###############################################################################
+
+is(stream('127.0.0.1:' . port(8081))->read(), 'test_var400', 'var set');
+is(stream('127.0.0.1:' . port(8082))->read(), 'not_found', 'not found set');
+
+$t->stop();
+
+###############################################################################
diff --git a/tests/stream_limit_conn.t b/tests/stream_limit_conn.t
new file mode 100644
index 0000000..68edda2
--- /dev/null
+++ b/tests/stream_limit_conn.t
@@ -0,0 +1,136 @@
+#!/usr/bin/perl
+
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+
+# Tests for stream limit_conn module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http stream stream_limit_conn/)
+	->plan(8)->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    limit_conn_zone  $binary_remote_addr  zone=zone:1m;
+    limit_conn_zone  $binary_remote_addr  zone=zone2:1m;
+
+    server {
+        listen           127.0.0.1:8080;
+        proxy_pass       127.0.0.1:8084;
+        limit_conn       zone 1;
+    }
+
+    server {
+        listen           127.0.0.1:8085;
+        proxy_pass       127.0.0.1:8084;
+        limit_conn       zone 5;
+    }
+
+    server {
+        listen           127.0.0.1:8081;
+        proxy_pass       127.0.0.1:8084;
+        limit_conn       zone2 1;
+    }
+
+    server {
+        listen           127.0.0.1:8082;
+        proxy_pass       127.0.0.1:8080;
+        limit_conn       zone2 1;
+    }
+
+    server {
+        listen           127.0.0.1:8083;
+        proxy_pass       127.0.0.1:8080;
+        limit_conn       zone 1;
+    }
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8084;
+        server_name  localhost;
+
+        location / { }
+    }
+}
+
+EOF
+
+$t->write_file('index.html', '');
+$t->run();
+
+###############################################################################
+
+like(get(), qr/200 OK/, 'passed');
+
+# same and other zones
+
+my $s = http(<<EOF, start => 1, sleep => 0.2);
+GET / HTTP/1.0
+EOF
+
+ok($s, 'long connection');
+
+is(get(), undef, 'rejected same zone');
+like(get('127.0.0.1:' . port(8081)), qr/200 OK/, 'passed different zone');
+like(get('127.0.0.1:' . port(8085)), qr/200 OK/, 'passed same zone unlimited');
+
+ok(http(<<EOF, socket => $s), 'long connection closed');
+Host: localhost
+
+EOF
+
+# zones proxy chain
+
+like(get('127.0.0.1:' . port(8082)), qr/200 OK/, 'passed proxy');
+is(get('127.0.0.1:' . port(8083)), undef, 'rejected proxy');
+
+###############################################################################
+
+sub get {
+	my $peer = shift;
+
+	my $r = http_get('/', socket => getconn($peer));
+	if (!$r) {
+		$r = undef;
+	}
+
+	return $r;
+}
+
+sub getconn {
+	my $peer = shift;
+	my $s = IO::Socket::INET->new(
+		Proto => 'tcp',
+		PeerAddr => $peer || '127.0.0.1:' . port(8080)
+	)
+		or die "Can't connect to nginx: $!\n";
+
+	return $s;
+}
+
+###############################################################################
diff --git a/tests/stream_limit_conn_complex.t b/tests/stream_limit_conn_complex.t
new file mode 100644
index 0000000..1147ce1
--- /dev/null
+++ b/tests/stream_limit_conn_complex.t
@@ -0,0 +1,99 @@
+#!/usr/bin/perl
+
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+
+# Tests for stream limit_conn module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http stream stream_limit_conn/)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    limit_conn_zone  $binary_remote_addr$server_port  zone=zone:1m;
+
+    server {
+        listen      127.0.0.1:8080;
+        proxy_pass  127.0.0.1:8084;
+        limit_conn  zone 1;
+    }
+
+    server {
+        listen      127.0.0.1:8081;
+        proxy_pass  127.0.0.1:8084;
+        limit_conn  zone 1;
+    }
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8084;
+        server_name  localhost;
+
+        location / { }
+    }
+}
+
+EOF
+
+$t->write_file('index.html', '');
+$t->run()->plan(4);
+
+###############################################################################
+
+like(get(port(8080)), qr/200 OK/, 'passed');
+
+my $s = http(<<EOF, start => 1, sleep => 0.2);
+GET / HTTP/1.0
+EOF
+
+ok($s, 'long connection');
+
+is(get(port(8080)), undef, 'rejected same key');
+like(get(port(8081)), qr/200 OK/, 'passed different key');
+
+###############################################################################
+
+sub get {
+	my $port = shift;
+
+	my $s = IO::Socket::INET->new(
+		Proto => 'tcp',
+		PeerAddr => "127.0.0.1:$port"
+	)
+		or die "Can't connect to nginx: $!\n";
+
+	my $r = http_get('/', socket => $s);
+	if (!$r) {
+		$r = undef;
+	}
+
+	return $r;
+}
+
+###############################################################################
diff --git a/tests/stream_limit_conn_dry_run.t b/tests/stream_limit_conn_dry_run.t
new file mode 100644
index 0000000..2a2d691
--- /dev/null
+++ b/tests/stream_limit_conn_dry_run.t
@@ -0,0 +1,110 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for limit_conn_dry_run directive, limit_conn_status variable.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_limit_conn http/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    limit_conn_zone  $binary_remote_addr  zone=zone:1m;
+
+    log_format test $server_port:$limit_conn_status;
+    access_log %%TESTDIR%%/test.log test;
+
+    server {
+        listen      127.0.0.1:8080;
+        proxy_pass  127.0.0.1:8084;
+        limit_conn  zone 1;
+
+        proxy_timeout 5s;
+    }
+
+    server {
+        listen      127.0.0.1:8081;
+        proxy_pass  127.0.0.1:8084;
+        limit_conn  zone 1;
+    }
+
+    server {
+        listen      127.0.0.1:8082;
+        proxy_pass  127.0.0.1:8084;
+        limit_conn  zone 1;
+
+        limit_conn_dry_run on;
+    }
+
+    server {
+        listen      127.0.0.1:8083;
+        proxy_pass  127.0.0.1:8084;
+    }
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8084;
+        server_name  localhost;
+
+        location / { }
+    }
+}
+
+EOF
+
+$t->write_file('index.html', 'OK');
+$t->try_run('no limit_conn_dry_run/limit_conn_status')->plan(9);
+
+###############################################################################
+
+my ($p, $p1, $p2, $p3) = (port(8080), port(8081), port(8082), port(8083));
+
+is(stream("127.0.0.1:$p")->io("GET /\n"), 'OK', 'passed');
+
+my $s = stream('127.0.0.1:' . port(8080));
+$s->write("GET");
+
+is(stream("127.0.0.1:$p1")->io("GET /\n"), '', 'rejected');
+is(stream("127.0.0.1:$p2")->io("GET /\n"), 'OK', 'rejected dry run');
+is(stream("127.0.0.1:$p3")->io("GET /\n"), 'OK', 'no limit');
+
+undef $s;
+
+$t->stop();
+
+like($t->read_file('error.log'), qr/limiting connections, dry/, 'log dry run');
+like($t->read_file('test.log'), qr|$p:PASSED|, 'log passed');
+like($t->read_file('test.log'), qr|$p1:REJECTED$|m, 'log rejected');
+like($t->read_file('test.log'), qr|$p2:REJECTED_DRY_RUN|, 'log rejected dry');
+like($t->read_file('test.log'), qr|$p3:-|, 'log not found');
+
+###############################################################################
diff --git a/tests/stream_limit_rate.t b/tests/stream_limit_rate.t
new file mode 100644
index 0000000..ccb5bd0
--- /dev/null
+++ b/tests/stream_limit_rate.t
@@ -0,0 +1,213 @@
+#!/usr/bin/perl
+
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+
+# Tests for stream proxy module, limit rate directives.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use IO::Select;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream/)->plan(9)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    # download and upload rates are set equal to the maximum
+    # number of bytes transmitted
+
+    # proxy_download_rate value comes from following calculations:
+    # test string length (1000) + whitespace (1) + time string length (10)
+
+    proxy_download_rate      1011;
+    proxy_upload_rate        1000;
+
+    server {
+        listen               127.0.0.1:8081;
+        proxy_pass           127.0.0.1:8080;
+    }
+
+    server {
+        listen               127.0.0.1:8082;
+        proxy_pass           127.0.0.1:8080;
+        proxy_download_rate  0;
+        proxy_upload_rate    0;
+    }
+
+    server {
+        listen               127.0.0.1:8083;
+        proxy_pass           127.0.0.1:8080;
+        proxy_download_rate  1;
+    }
+
+    server {
+        listen               127.0.0.1:8084;
+        proxy_pass           127.0.0.1:8080;
+        proxy_upload_rate    1;
+    }
+
+    server {
+        listen               127.0.0.1:8085;
+        proxy_pass           127.0.0.1:8080;
+        proxy_download_rate  250;
+    }
+
+    server {
+        listen               127.0.0.1:8086;
+        proxy_pass           127.0.0.1:8087;
+        proxy_upload_rate    250;
+    }
+}
+
+EOF
+
+$t->run_daemon(\&stream_daemon, port(8080));
+$t->run_daemon(\&stream_daemon, port(8087));
+$t->run();
+
+$t->waitforsocket('127.0.0.1:' . port(8080));
+$t->waitforsocket('127.0.0.1:' . port(8087));
+
+###############################################################################
+
+my $str = '1234567890' x 100;
+
+my %r = response($str, peer => '127.0.0.1:' . port(8081));
+is($r{'data'}, $str, 'exact limit');
+
+%r = response($str . 'extra', peer => '127.0.0.1:' . port(8082));
+is($r{'data'}, $str . 'extra', 'unlimited');
+
+SKIP: {
+skip 'unsafe on VM', 3 unless $ENV{TEST_NGINX_UNSAFE};
+
+# if interaction between backend and client is slow then proxy can add extra
+# bytes to upload/download data
+
+%r = response($str . 'extra', peer => '127.0.0.1:' . port(8081));
+is($r{'data'}, $str, 'limited');
+
+%r = response($str, peer => '127.0.0.1:' . port(8083), readonce => 1);
+is($r{'data'}, '1', 'download - one byte');
+
+%r = response($str, peer =>  '127.0.0.1:' . port(8084));
+is($r{'data'}, '1', 'upload - one byte');
+
+}
+
+# Five chunks are split with four 1s delays:
+# the first four chunks are quarters of test string
+# and the fifth one is some extra data from backend.
+
+%r = response($str, peer =>  '127.0.0.1:' . port(8085));
+my $diff = time() - $r{'time'};
+cmp_ok($diff, '>=', 4, 'download - time');
+is($r{'data'}, $str, 'download - data');
+
+my $time = time();
+%r = response($str . 'close', peer => '127.0.0.1:' . port(8086));
+$diff = time() - $time;
+cmp_ok($diff, '>=', 4, 'upload - time');
+is($r{'data'}, $str . 'close', 'upload - data');
+
+###############################################################################
+
+sub response {
+	my ($data, %extra) = @_;
+
+	my $s = stream($extra{peer});
+	$s->write($data);
+
+	$data = '';
+	while (1) {
+		my $buf = $s->read();
+		last unless length($buf);
+
+		$data .= $buf;
+
+		last if $extra{'readonce'};
+	}
+	$data =~ /([\S]*)\s?(\d+)?/;
+
+	return ('data' => $1, 'time' => $2)
+}
+
+###############################################################################
+
+sub stream_daemon {
+	my $port = shift;
+
+	my $server = IO::Socket::INET->new(
+		Proto => 'tcp',
+		LocalAddr => '127.0.0.1',
+		LocalPort => $port,
+		Listen => 5,
+		Reuse => 1
+	)
+		or die "Can't create listening socket: $!\n";
+
+	my $sel = IO::Select->new($server);
+
+	local $SIG{PIPE} = 'IGNORE';
+
+	while (my @ready = $sel->can_read) {
+		foreach my $fh (@ready) {
+			if ($server == $fh) {
+				my $new = $fh->accept;
+				$new->autoflush(1);
+				$sel->add($new);
+
+			} elsif (stream_handle_client($fh)) {
+				$sel->remove($fh);
+				$fh->close;
+			}
+		}
+	}
+}
+
+sub stream_handle_client {
+	my ($client) = @_;
+
+	log2c("(new connection $client)");
+
+	$client->sysread(my $buffer, 65536) or return 1;
+
+	log2i("$client $buffer");
+
+	$buffer .= " " . time() if $client->sockport() eq port(8080);
+
+	log2o("$client $buffer");
+
+	$client->syswrite($buffer);
+
+	return $client->sockport() eq port(8080) ? 1 : $buffer =~ /close/;
+}
+
+sub log2i { Test::Nginx::log_core('|| <<', @_); }
+sub log2o { Test::Nginx::log_core('|| >>', @_); }
+sub log2c { Test::Nginx::log_core('||', @_); }
+
+###############################################################################
diff --git a/tests/stream_limit_rate2.t b/tests/stream_limit_rate2.t
new file mode 100644
index 0000000..cfc4455
--- /dev/null
+++ b/tests/stream_limit_rate2.t
@@ -0,0 +1,227 @@
+#!/usr/bin/perl
+
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+
+# Tests for stream proxy module, limit rate directives, variables support.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use IO::Select;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_map/)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    # download and upload rates are set equal to the maximum
+    # number of bytes transmitted
+
+    # proxy_download_rate value comes from following calculations:
+    # test string length (1000) + whitespace (1) + time string length (10)
+
+    map $server_port $down {
+        default        1011;
+        %%PORT_8082%%  0;
+        %%PORT_8083%%  1;
+        %%PORT_8085%%  250;
+    }
+
+    map $server_port $up {
+        default        1000;
+        %%PORT_8082%%  0;
+        %%PORT_8084%%  1;
+        %%PORT_8086%%  250;
+    }
+
+    proxy_download_rate      $down;
+    proxy_upload_rate        $up;
+
+    server {
+        listen               127.0.0.1:8081;
+        proxy_pass           127.0.0.1:8080;
+    }
+
+    server {
+        listen               127.0.0.1:8082;
+        proxy_pass           127.0.0.1:8080;
+        proxy_download_rate  $down;
+        proxy_upload_rate    $up;
+    }
+
+    server {
+        listen               127.0.0.1:8083;
+        proxy_pass           127.0.0.1:8080;
+        proxy_download_rate  $down;
+    }
+
+    server {
+        listen               127.0.0.1:8084;
+        proxy_pass           127.0.0.1:8080;
+        proxy_upload_rate    $up;
+    }
+
+    server {
+        listen               127.0.0.1:8085;
+        proxy_pass           127.0.0.1:8080;
+        proxy_download_rate  $down;
+    }
+
+    server {
+        listen               127.0.0.1:8086;
+        proxy_pass           127.0.0.1:8087;
+        proxy_upload_rate    $up;
+    }
+}
+
+EOF
+
+$t->run_daemon(\&stream_daemon, port(8080));
+$t->run_daemon(\&stream_daemon, port(8087));
+$t->try_run('no proxy_download_rate variables')->plan(9);
+
+$t->waitforsocket('127.0.0.1:' . port(8080));
+$t->waitforsocket('127.0.0.1:' . port(8087));
+
+###############################################################################
+
+my $str = '1234567890' x 100;
+
+my %r = response($str, peer => '127.0.0.1:' . port(8081));
+is($r{'data'}, $str, 'exact limit');
+
+%r = response($str . 'extra', peer => '127.0.0.1:' . port(8082));
+is($r{'data'}, $str . 'extra', 'unlimited');
+
+SKIP: {
+skip 'unsafe on VM', 3 unless $ENV{TEST_NGINX_UNSAFE};
+
+# if interaction between backend and client is slow then proxy can add extra
+# bytes to upload/download data
+
+%r = response($str . 'extra', peer => '127.0.0.1:' . port(8081));
+is($r{'data'}, $str, 'limited');
+
+%r = response($str, peer => '127.0.0.1:' . port(8083), readonce => 1);
+is($r{'data'}, '1', 'download - one byte');
+
+%r = response($str, peer =>  '127.0.0.1:' . port(8084));
+is($r{'data'}, '1', 'upload - one byte');
+
+}
+
+# Five chunks are split with four 1s delays:
+# the first four chunks are quarters of test string
+# and the fifth one is some extra data from backend.
+
+%r = response($str, peer =>  '127.0.0.1:' . port(8085));
+my $diff = time() - $r{'time'};
+cmp_ok($diff, '>=', 4, 'download - time');
+is($r{'data'}, $str, 'download - data');
+
+my $time = time();
+%r = response($str . 'close', peer => '127.0.0.1:' . port(8086));
+$diff = time() - $time;
+cmp_ok($diff, '>=', 4, 'upload - time');
+is($r{'data'}, $str . 'close', 'upload - data');
+
+###############################################################################
+
+sub response {
+	my ($data, %extra) = @_;
+
+	my $s = stream($extra{peer});
+	$s->write($data);
+
+	$data = '';
+	while (1) {
+		my $buf = $s->read();
+		last unless length($buf);
+
+		$data .= $buf;
+
+		last if $extra{'readonce'};
+	}
+	$data =~ /([\S]*)\s?(\d+)?/;
+
+	return ('data' => $1, 'time' => $2)
+}
+
+###############################################################################
+
+sub stream_daemon {
+	my $port = shift;
+
+	my $server = IO::Socket::INET->new(
+		Proto => 'tcp',
+		LocalAddr => '127.0.0.1',
+		LocalPort => $port,
+		Listen => 5,
+		Reuse => 1
+	)
+		or die "Can't create listening socket: $!\n";
+
+	my $sel = IO::Select->new($server);
+
+	local $SIG{PIPE} = 'IGNORE';
+
+	while (my @ready = $sel->can_read) {
+		foreach my $fh (@ready) {
+			if ($server == $fh) {
+				my $new = $fh->accept;
+				$new->autoflush(1);
+				$sel->add($new);
+
+			} elsif (stream_handle_client($fh)) {
+				$sel->remove($fh);
+				$fh->close;
+			}
+		}
+	}
+}
+
+sub stream_handle_client {
+	my ($client) = @_;
+
+	log2c("(new connection $client)");
+
+	$client->sysread(my $buffer, 65536) or return 1;
+
+	log2i("$client $buffer");
+
+	$buffer .= " " . time() if $client->sockport() eq port(8080);
+
+	log2o("$client $buffer");
+
+	$client->syswrite($buffer);
+
+	return $client->sockport() eq port(8080) ? 1 : $buffer =~ /close/;
+}
+
+sub log2i { Test::Nginx::log_core('|| <<', @_); }
+sub log2o { Test::Nginx::log_core('|| >>', @_); }
+sub log2c { Test::Nginx::log_core('||', @_); }
+
+###############################################################################
diff --git a/tests/stream_map.t b/tests/stream_map.t
new file mode 100644
index 0000000..35a46c9
--- /dev/null
+++ b/tests/stream_map.t
@@ -0,0 +1,72 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for stream map module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_return stream_map/)
+	->has(qw/http rewrite/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    map $server_port $x {
+        %%PORT_8080%%             literal;
+        default                   default;
+        ~(%%PORT_8082%%)          $1;
+        ~(?P<ncap>%%PORT_8083%%)  $ncap;
+    }
+
+    server {
+        listen  127.0.0.1:8080;
+        listen  127.0.0.1:8081;
+        listen  127.0.0.1:8082;
+        listen  127.0.0.1:8083;
+        return  $x;
+    }
+
+    server {
+        listen  127.0.0.1:8084;
+        return  $x:${x};
+    }
+}
+
+EOF
+
+$t->run()->plan(5);
+
+###############################################################################
+
+is(stream('127.0.0.1:' . port(8080))->read(), 'literal', 'literal');
+is(stream('127.0.0.1:' . port(8081))->read(), 'default', 'default');
+is(stream('127.0.0.1:' . port(8082))->read(), port(8082), 'capture');
+is(stream('127.0.0.1:' . port(8083))->read(), port(8083), 'named capture');
+is(stream('127.0.0.1:' . port(8084))->read(), 'default:default', 'braces');
+
+###############################################################################
diff --git a/tests/stream_proxy.t b/tests/stream_proxy.t
new file mode 100644
index 0000000..ebf1237
--- /dev/null
+++ b/tests/stream_proxy.t
@@ -0,0 +1,118 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for stream proxy module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use IO::Select;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream/)->plan(5)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    server {
+        listen      127.0.0.1:8080;
+        proxy_pass  127.0.0.1:8081;
+        proxy_connect_timeout 2s;
+    }
+}
+
+EOF
+
+$t->run_daemon(\&stream_daemon);
+$t->run()->waitforsocket('127.0.0.1:' . port(8081));
+
+###############################################################################
+
+my $s = stream('127.0.0.1:' . port(8080));
+
+is($s->io('foo1', length => 4), 'bar1', 'proxy connection');
+is($s->io('foo3', length => 4), 'bar3', 'proxy connection again');
+is($s->io('close'), 'close', 'proxy connection close');
+is($s->io('test'), '', 'proxy connection closed');
+
+$s = stream('127.0.0.1:' . port(8080));
+
+sleep 3;
+
+is($s->io('foo', length => 3), 'bar', 'proxy connect timeout');
+
+###############################################################################
+
+sub stream_daemon {
+	my $server = IO::Socket::INET->new(
+		Proto => 'tcp',
+		LocalAddr => '127.0.0.1:' . port(8081),
+		Listen => 5,
+		Reuse => 1
+	)
+		or die "Can't create listening socket: $!\n";
+
+	my $sel = IO::Select->new($server);
+
+	local $SIG{PIPE} = 'IGNORE';
+
+	while (my @ready = $sel->can_read) {
+		foreach my $fh (@ready) {
+			if ($server == $fh) {
+				my $new = $fh->accept;
+				$new->autoflush(1);
+				$sel->add($new);
+
+			} elsif (stream_handle_client($fh)) {
+				$sel->remove($fh);
+				$fh->close;
+			}
+		}
+	}
+}
+
+sub stream_handle_client {
+	my ($client) = @_;
+
+	log2c("(new connection $client)");
+
+	$client->sysread(my $buffer, 65536) or return 1;
+
+	log2i("$client $buffer");
+
+	$buffer =~ s/foo/bar/g;
+
+	log2o("$client $buffer");
+
+	$client->syswrite($buffer);
+
+	return $buffer =~ /close/;
+}
+
+sub log2i { Test::Nginx::log_core('|| <<', @_); }
+sub log2o { Test::Nginx::log_core('|| >>', @_); }
+sub log2c { Test::Nginx::log_core('||', @_); }
+
+###############################################################################
diff --git a/tests/stream_proxy_bind.t b/tests/stream_proxy_bind.t
new file mode 100644
index 0000000..0a71123
--- /dev/null
+++ b/tests/stream_proxy_bind.t
@@ -0,0 +1,77 @@
+#!/usr/bin/perl
+
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+
+# Test for stream proxy_bind directive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+plan(skip_all => 'win32') if $^O eq 'MSWin32';
+plan(skip_all => '127.0.0.2 local address required')
+	unless defined IO::Socket::INET->new( LocalAddr => '127.0.0.2' );
+
+my $t = Test::Nginx->new()->has(qw/http proxy stream/)->plan(1)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    server {
+        listen            127.0.0.1:8081;
+        proxy_bind        127.0.0.2;
+        proxy_pass        127.0.0.1:8082;
+    }
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen          127.0.0.1:8080;
+        server_name     localhost;
+
+        location / {
+            proxy_pass  http://127.0.0.1:8081;
+        }
+    }
+
+    server {
+        listen          127.0.0.1:8082;
+
+        location / {
+            add_header   X-IP $remote_addr;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('index.html', '');
+$t->run();
+
+###############################################################################
+
+like(http_get('/'), qr/X-IP: 127.0.0.2/, 'bind');
+
+###############################################################################
diff --git a/tests/stream_proxy_complex.t b/tests/stream_proxy_complex.t
new file mode 100644
index 0000000..9bc1f1a
--- /dev/null
+++ b/tests/stream_proxy_complex.t
@@ -0,0 +1,79 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for stream proxy module with complex value.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_return/)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    upstream %%PORT_8081%% {
+        server 127.0.0.1:8091;
+    }
+
+    upstream %%PORT_8082%% {
+        server 127.0.0.1:8092;
+        server 127.0.0.1:8093;
+    }
+
+    server {
+        listen      127.0.0.1:8081;
+        listen      127.0.0.1:8082;
+        proxy_pass  $server_port;
+    }
+
+    server {
+        listen      127.0.0.1:8083;
+        proxy_pass  $server_addr:%%PORT_8093%%;
+    }
+
+    server {
+        listen      127.0.0.1:8091;
+        listen      127.0.0.1:8092;
+        listen      127.0.0.1:8093;
+        return      $server_port;
+    }
+}
+
+EOF
+
+$t->run()->plan(5);
+
+###############################################################################
+
+is(stream('127.0.0.1:' . port(8081))->read(), port(8091), 'upstream');
+is(stream('127.0.0.1:' . port(8081))->read(), port(8091), 'upstream again');
+
+is(stream('127.0.0.1:' . port(8082))->read(), port(8092), 'upstream 2');
+is(stream('127.0.0.1:' . port(8082))->read(), port(8093), 'upstream second');
+
+is(stream('127.0.0.1:' . port(8083))->read(), port(8093), 'implicit');
+
+###############################################################################
diff --git a/tests/stream_proxy_next_upstream.t b/tests/stream_proxy_next_upstream.t
new file mode 100644
index 0000000..beca885
--- /dev/null
+++ b/tests/stream_proxy_next_upstream.t
@@ -0,0 +1,122 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for stream proxy module, proxy_next_upstream directive and friends.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream/)->plan(3);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    upstream u {
+        server 127.0.0.1:8083 max_fails=0;
+        server 127.0.0.1:8084 max_fails=0;
+        server 127.0.0.1:8085 backup;
+    }
+
+    upstream u2 {
+        server 127.0.0.1:8083;
+        server 127.0.0.1:8085 backup;
+    }
+
+    proxy_connect_timeout 2;
+
+    server {
+        listen      127.0.0.1:8080;
+        proxy_pass  u;
+        proxy_next_upstream off;
+    }
+
+    server {
+        listen      127.0.0.1:8081;
+        proxy_pass  u2;
+        proxy_next_upstream on;
+    }
+
+    server {
+        listen      127.0.0.1:8082;
+        proxy_pass  u;
+        proxy_next_upstream on;
+        proxy_next_upstream_tries 2;
+    }
+}
+
+EOF
+
+$t->run_daemon(\&stream_daemon);
+$t->run()->waitforsocket('127.0.0.1:' . port(8085));
+
+###############################################################################
+
+is(stream('127.0.0.1:' . port(8080))->io('.'), '', 'next off');
+is(stream('127.0.0.1:' . port(8081))->io('.'), 'SEE-THIS', 'next on');
+
+# make sure backup is not tried
+
+is(stream('127.0.0.1:' . port(8082))->io('.'), '', 'next tries');
+
+###############################################################################
+
+sub stream_daemon {
+	my $server = IO::Socket::INET->new(
+		Proto => 'tcp',
+		LocalHost => '127.0.0.1:' . port(8085),
+		Listen => 5,
+		Reuse => 1
+	)
+		or die "Can't create listening socket: $!\n";
+
+	local $SIG{PIPE} = 'IGNORE';
+
+	while (my $client = $server->accept()) {
+		$client->autoflush(1);
+
+		log2c("(new connection $client)");
+
+		$client->sysread(my $buffer, 65536) or next;
+
+		log2i("$client $buffer");
+
+		$buffer = 'SEE-THIS';
+
+		log2o("$client $buffer");
+
+		$client->syswrite($buffer);
+
+	} continue {
+		close $client;
+	}
+}
+
+sub log2i { Test::Nginx::log_core('|| <<', @_); }
+sub log2o { Test::Nginx::log_core('|| >>', @_); }
+sub log2c { Test::Nginx::log_core('||', @_); }
+
+###############################################################################
diff --git a/tests/stream_proxy_protocol.t b/tests/stream_proxy_protocol.t
new file mode 100644
index 0000000..2045ddc
--- /dev/null
+++ b/tests/stream_proxy_protocol.t
@@ -0,0 +1,120 @@
+#!/usr/bin/perl
+
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+
+# Tests for stream proxy module with haproxy protocol.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use IO::Select;
+use Socket qw/ $CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream/)->plan(2)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    proxy_protocol on;
+
+    server {
+        listen          127.0.0.1:8080;
+        proxy_pass      127.0.0.1:8081;
+    }
+
+    server {
+        listen          127.0.0.1:8082;
+        proxy_pass      127.0.0.1:8081;
+        proxy_protocol  off;
+    }
+}
+
+EOF
+
+$t->run_daemon(\&stream_daemon);
+$t->run();
+$t->waitforsocket('127.0.0.1:' . port(8081));
+
+###############################################################################
+
+my $dp = port(8080);
+my $s = stream('127.0.0.1:' . $dp);
+my $data = $s->io('close');
+my $sp = $s->sockport();
+is($data, "PROXY TCP4 127.0.0.1 127.0.0.1 $sp $dp${CRLF}close", 'protocol on');
+
+is(stream('127.0.0.1:' . port(8082))->io('close'), 'close', 'protocol off');
+
+###############################################################################
+
+sub stream_daemon {
+	my $server = IO::Socket::INET->new(
+		Proto => 'tcp',
+		LocalAddr => '127.0.0.1:' . port(8081),
+		Listen => 5,
+		Reuse => 1
+	)
+		or die "Can't create listening socket: $!\n";
+
+	my $sel = IO::Select->new($server);
+
+	local $SIG{PIPE} = 'IGNORE';
+
+	while (my @ready = $sel->can_read) {
+		foreach my $fh (@ready) {
+			if ($server == $fh) {
+				my $new = $fh->accept;
+				$new->autoflush(1);
+				$sel->add($new);
+
+			} elsif (stream_handle_client($fh)) {
+				$sel->remove($fh);
+				$fh->close;
+			}
+		}
+	}
+}
+
+sub stream_handle_client {
+	my ($client) = @_;
+
+	log2c("(new connection $client)");
+
+	$client->sysread(my $buffer, 65536) or return 1;
+
+	log2i("$client $buffer");
+
+	log2o("$client $buffer");
+
+	$client->syswrite($buffer);
+
+	return $buffer =~ /close/;
+}
+
+sub log2i { Test::Nginx::log_core('|| <<', @_); }
+sub log2o { Test::Nginx::log_core('|| >>', @_); }
+sub log2c { Test::Nginx::log_core('||', @_); }
+
+###############################################################################
diff --git a/tests/stream_proxy_protocol_ipv6.t b/tests/stream_proxy_protocol_ipv6.t
new file mode 100644
index 0000000..1c83cd6
--- /dev/null
+++ b/tests/stream_proxy_protocol_ipv6.t
@@ -0,0 +1,127 @@
+#!/usr/bin/perl
+
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+
+# Tests for stream proxy module with IPv6 haproxy protocol.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use IO::Select;
+use Socket qw/ $CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream/)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    server {
+        listen          127.0.0.1:8080;
+        proxy_pass      [::1]:%%PORT_8080%%;
+    }
+
+    server {
+        listen          127.0.0.1:8081;
+        proxy_pass      [::1]:%%PORT_8081%%;
+    }
+
+    server {
+        listen          [::1]:%%PORT_8080%%;
+        proxy_pass      127.0.0.1:8082;
+        proxy_protocol  on;
+    }
+
+    server {
+        listen          [::1]:%%PORT_8081%%;
+        proxy_pass      127.0.0.1:8082;
+    }
+}
+
+EOF
+
+$t->run_daemon(\&stream_daemon);
+$t->try_run('no inet6 support')->plan(2);
+$t->waitforsocket('127.0.0.1:' . port(8082));
+
+###############################################################################
+
+my $dp = port(8080);
+
+like(stream('127.0.0.1:' . $dp)->io('close'),
+	qr/PROXY TCP6 ::1 ::1 \d+ $dp$CRLF/, 'protocol on');
+unlike(stream('127.0.0.1:' . port(8081))->io('close'), qr/PROXY/,
+	'protocol off');
+
+###############################################################################
+
+sub stream_daemon {
+	my $server = IO::Socket::INET->new(
+		Proto => 'tcp',
+		LocalHost => '127.0.0.1:' . port(8082),
+		Listen => 5,
+		Reuse => 1
+	)
+		or die "Can't create listening socket: $!\n";
+
+	my $sel = IO::Select->new($server);
+
+	local $SIG{PIPE} = 'IGNORE';
+
+	while (my @ready = $sel->can_read) {
+		foreach my $fh (@ready) {
+			if ($server == $fh) {
+				my $new = $fh->accept;
+				$new->autoflush(1);
+				$sel->add($new);
+
+			} elsif (stream_handle_client($fh)) {
+				$sel->remove($fh);
+				$fh->close;
+			}
+		}
+	}
+}
+
+sub stream_handle_client {
+	my ($client) = @_;
+
+	log2c("(new connection $client)");
+
+	$client->sysread(my $buffer, 65536) or return 1;
+
+	log2i("$client $buffer");
+
+	log2o("$client $buffer");
+
+	$client->syswrite($buffer);
+
+	return $buffer =~ /close/;
+}
+
+sub log2i { Test::Nginx::log_core('|| <<', @_); }
+sub log2o { Test::Nginx::log_core('|| >>', @_); }
+sub log2c { Test::Nginx::log_core('||', @_); }
+
+###############################################################################
diff --git a/tests/stream_proxy_protocol_ssl.t b/tests/stream_proxy_protocol_ssl.t
new file mode 100644
index 0000000..141f181
--- /dev/null
+++ b/tests/stream_proxy_protocol_ssl.t
@@ -0,0 +1,181 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for stream proxy module with haproxy protocol to ssl backend.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/ CR LF CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx qw/ :DEFAULT http_end /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require IO::Socket::SSL; };
+plan(skip_all => 'IO::Socket::SSL not installed') if $@;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_ssl/)->has_daemon('openssl')
+	->plan(2);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    proxy_ssl       on;
+    proxy_protocol  on;
+
+    server {
+        listen          127.0.0.1:8080;
+        proxy_pass      127.0.0.1:8081;
+    }
+
+    server {
+        listen          127.0.0.1:8082;
+        proxy_pass      127.0.0.1:8083;
+        proxy_protocol  off;
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('localhost') {
+	system('openssl req -x509 -new '
+		. "-config $d/openssl.conf -subj /CN=$name/ "
+		. "-out $d/$name.crt -keyout $d/$name.key "
+		. ">>$d/openssl.out 2>&1") == 0
+		or die "Can't create certificate for $name: $!\n";
+}
+
+$t->run_daemon(\&stream_daemon_ssl, port(8081), path => $d, pp => 1);
+$t->run_daemon(\&stream_daemon_ssl, port(8083), path => $d, pp => 0);
+$t->run();
+
+$t->waitforsocket('127.0.0.1:' . port(8081));
+$t->waitforsocket('127.0.0.1:' . port(8083));
+
+###############################################################################
+
+my $dp = port(8080);
+
+my %r = pp_get('test', '127.0.0.1:' . $dp);
+is($r{'data'}, "PROXY TCP4 127.0.0.1 127.0.0.1 $r{'sp'} $dp" . CRLF . 'test',
+	'protocol on');
+
+%r = pp_get('test', '127.0.0.1:' . port(8082));
+is($r{'data'}, 'test', 'protocol off');
+
+###############################################################################
+
+sub pp_get {
+	my ($data, $peer) = @_;
+
+	my $s = http($data, socket => getconn($peer), start => 1);
+	my $sockport = $s->sockport();
+	$data = http_end($s);
+	return ('data' => $data, 'sp' => $sockport);
+}
+
+sub getconn {
+	my $peer = shift;
+	my $s = IO::Socket::INET->new(
+		Proto => 'tcp',
+		PeerAddr => $peer
+	)
+		or die "Can't connect to nginx: $!\n";
+
+	return $s;
+}
+
+###############################################################################
+
+sub stream_daemon_ssl {
+	my ($port, %extra) = @_;
+	my $d = $extra{path};
+	my $pp = $extra{pp};
+	my $server = IO::Socket::INET->new(
+		Proto => 'tcp',
+		LocalHost => "127.0.0.1:$port",
+		Listen => 5,
+		Reuse => 1
+	)
+		or die "Can't create listening socket: $!\n";
+
+	local $SIG{PIPE} = 'IGNORE';
+
+	while (my $client = $server->accept()) {
+		my ($buffer, $data) = ('', '');
+		$client->autoflush(1);
+
+		log2c("(new connection $client on $port)");
+
+		# read no more than haproxy header of variable length
+
+		while ($pp) {
+			my $prev = $buffer;
+			$client->sysread($buffer, 1) or last;
+			$data .= $buffer;
+			last if $prev eq CR && $buffer eq LF;
+		}
+
+		log2i("$client $data");
+
+		# would fail on waitforsocket
+
+		eval {
+			IO::Socket::SSL->start_SSL($client,
+				SSL_server => 1,
+				SSL_cert_file => "$d/localhost.crt",
+				SSL_key_file => "$d/localhost.key",
+				SSL_error_trap => sub { die $_[1] }
+			);
+		};
+		next if $@;
+
+		$client->sysread($buffer, 65536) or next;
+
+		log2i("$client $buffer");
+
+		$data .= $buffer;
+
+		log2o("$client $data");
+
+		$client->syswrite($data);
+
+		close $client;
+	}
+}
+
+sub log2i { Test::Nginx::log_core('|| <<', @_); }
+sub log2o { Test::Nginx::log_core('|| >>', @_); }
+sub log2c { Test::Nginx::log_core('||', @_); }
+
+###############################################################################
diff --git a/tests/stream_proxy_ssl.t b/tests/stream_proxy_ssl.t
new file mode 100644
index 0000000..cc6b6c7
--- /dev/null
+++ b/tests/stream_proxy_ssl.t
@@ -0,0 +1,121 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Stream tests for proxy to ssl backend.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_ssl http http_ssl/)
+	->has(qw/stream_return/)
+	->has_daemon('openssl')->plan(6);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    proxy_ssl on;
+    proxy_ssl_session_reuse on;
+    proxy_connect_timeout 2s;
+
+    server {
+        listen      127.0.0.1:8081;
+        proxy_pass  127.0.0.1:8083;
+        proxy_ssl_session_reuse off;
+    }
+
+    server {
+        listen      127.0.0.1:8082;
+        proxy_pass  127.0.0.1:8083;
+    }
+
+    server {
+        listen      127.0.0.1:8083 ssl;
+        return      $ssl_session_reused;
+
+        ssl_certificate_key localhost.key;
+        ssl_certificate localhost.crt;
+        ssl_session_cache builtin;
+    }
+
+    server {
+        listen      127.0.0.1:8080;
+        proxy_pass  127.0.0.1:8084;
+    }
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8084 ssl;
+        server_name  localhost;
+
+        ssl_certificate_key localhost.key;
+        ssl_certificate localhost.crt;
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+$t->write_file('index.html', '');
+
+my $d = $t->testdir();
+
+foreach my $name ('localhost') {
+	system('openssl req -x509 -new '
+		. "-config $d/openssl.conf -subj /CN=$name/ "
+		. "-out $d/$name.crt -keyout $d/$name.key "
+		. ">>$d/openssl.out 2>&1") == 0
+		or die "Can't create certificate for $name: $!\n";
+}
+
+$t->run();
+
+###############################################################################
+
+is(stream('127.0.0.1:' . port(8081))->read(), '.', 'ssl');
+is(stream('127.0.0.1:' . port(8081))->read(), '.', 'ssl 2');
+
+is(stream('127.0.0.1:' . port(8082))->read(), '.', 'ssl session new');
+is(stream('127.0.0.1:' . port(8082))->read(), 'r', 'ssl session reused');
+is(stream('127.0.0.1:' . port(8082))->read(), 'r', 'ssl session reused 2');
+
+my $s = http('', start => 1);
+
+sleep 3;
+
+like(http_get('/', socket => $s), qr/200 OK/, 'proxy connect timeout');
+
+###############################################################################
diff --git a/tests/stream_proxy_ssl_certificate.t b/tests/stream_proxy_ssl_certificate.t
new file mode 100644
index 0000000..ee2e0d5
--- /dev/null
+++ b/tests/stream_proxy_ssl_certificate.t
@@ -0,0 +1,169 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for stream proxy module with proxy certificate to ssl backend.
+# The proxy_ssl_certificate and proxy_ssl_password_file directives.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_ssl http http_ssl/)
+	->has_daemon('openssl')->plan(5);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    proxy_ssl on;
+    proxy_ssl_session_reuse off;
+
+    server {
+        listen      127.0.0.1:8082;
+        proxy_pass  127.0.0.1:8080;
+
+        proxy_ssl_certificate 1.example.com.crt;
+        proxy_ssl_certificate_key 1.example.com.key;
+    }
+
+    server {
+        listen      127.0.0.1:8083;
+        proxy_pass  127.0.0.1:8080;
+
+        proxy_ssl_certificate 2.example.com.crt;
+        proxy_ssl_certificate_key 2.example.com.key;
+    }
+
+    server {
+        listen      127.0.0.1:8084;
+        proxy_pass  127.0.0.1:8081;
+
+        proxy_ssl_certificate 3.example.com.crt;
+        proxy_ssl_certificate_key 3.example.com.key;
+        proxy_ssl_password_file password;
+    }
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080 ssl;
+        server_name  localhost;
+
+        ssl_certificate 2.example.com.crt;
+        ssl_certificate_key 2.example.com.key;
+
+        ssl_verify_client optional_no_ca;
+        ssl_trusted_certificate 1.example.com.crt;
+
+        location / {
+            add_header X-Verify $ssl_client_verify;
+            add_header X-Name   $ssl_client_s_dn;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081 ssl;
+        server_name  localhost;
+
+        ssl_certificate 1.example.com.crt;
+        ssl_certificate_key 1.example.com.key;
+
+        ssl_verify_client optional_no_ca;
+        ssl_trusted_certificate 3.example.com.crt;
+
+        location / {
+            add_header X-Verify $ssl_client_verify;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('1.example.com', '2.example.com') {
+	system('openssl req -x509 -new '
+		. "-config $d/openssl.conf -subj /CN=$name/ "
+		. "-out $d/$name.crt -keyout $d/$name.key "
+		. ">>$d/openssl.out 2>&1") == 0
+		or die "Can't create certificate for $name: $!\n";
+}
+
+foreach my $name ('3.example.com') {
+	system("openssl genrsa -out $d/$name.key -passout pass:$name "
+		. "-aes128 2048 >>$d/openssl.out 2>&1") == 0
+		or die "Can't create private key: $!\n";
+	system('openssl req -x509 -new '
+		. "-config $d/openssl.conf -subj /CN=$name/ "
+		. "-out $d/$name.crt "
+		. "-key $d/$name.key -passin pass:$name"
+		. ">>$d/openssl.out 2>&1") == 0
+		or die "Can't create certificate for $name: $!\n";
+}
+
+sleep 1 if $^O eq 'MSWin32';
+
+$t->write_file('password', '3.example.com');
+$t->write_file('index.html', '');
+
+$t->run();
+
+###############################################################################
+
+like(http_get('/', socket => getconn('127.0.0.1:' . port(8082))),
+	qr/X-Verify: SUCCESS/ms, 'verify certificate');
+like(http_get('/', socket => getconn('127.0.0.1:' . port(8083))),
+	qr/X-Verify: FAILED/ms, 'fail certificate');
+like(http_get('/', socket => getconn('127.0.0.1:' . port(8084))),
+	qr/X-Verify: SUCCESS/ms, 'with encrypted key');
+
+like(http_get('/', socket => getconn('127.0.0.1:' . port(8082))),
+	qr!X-Name: /?CN=1.example!, 'valid certificate');
+unlike(http_get('/', socket => getconn('127.0.0.1:' . port(8083))),
+	qr!X-Name: /?CN=1.example!, 'invalid certificate');
+
+###############################################################################
+
+sub getconn {
+	my $peer = shift;
+	my $s = IO::Socket::INET->new(
+		Proto => 'tcp',
+		PeerAddr => $peer
+	)
+		or die "Can't connect to nginx: $!\n";
+
+	return $s;
+}
+
+###############################################################################
diff --git a/tests/stream_proxy_ssl_name.t b/tests/stream_proxy_ssl_name.t
new file mode 100644
index 0000000..304a578
--- /dev/null
+++ b/tests/stream_proxy_ssl_name.t
@@ -0,0 +1,149 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Stream tests for proxy to ssl backend, use of Server Name Indication
+# (proxy_ssl_name, proxy_ssl_server_name directives).
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_ssl http http_ssl sni/)
+	->has_daemon('openssl')->plan(5);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    proxy_ssl on;
+    proxy_ssl_session_reuse off;
+
+    upstream u {
+        server 127.0.0.1:8085;
+    }
+
+    server {
+        listen      127.0.0.1:8080;
+        proxy_pass  u;
+
+        proxy_ssl_server_name off;
+    }
+
+    server {
+        listen      127.0.0.1:8081;
+        proxy_pass  u;
+
+        proxy_ssl_server_name on;
+    }
+
+    server {
+        listen      127.0.0.1:8082;
+        proxy_pass  127.0.0.1:8085;
+
+        proxy_ssl_server_name on;
+        proxy_ssl_name example.com;
+    }
+
+    server {
+        listen      127.0.0.1:8083;
+        proxy_pass  127.0.0.1:8085;
+
+        proxy_ssl_server_name on;
+    }
+
+    server {
+        listen      127.0.0.1:8084;
+        proxy_pass  127.0.0.1:8085;
+
+        proxy_ssl_server_name on;
+        proxy_ssl_name example.com:123;
+    }
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8085 ssl;
+        server_name  localhost;
+
+        ssl_certificate_key localhost.key;
+        ssl_certificate localhost.crt;
+
+        location / {
+            add_header X-Name $ssl_server_name,;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('localhost') {
+	system('openssl req -x509 -new '
+		. "-config $d/openssl.conf -subj /CN=$name/ "
+		. "-out $d/$name.crt -keyout $d/$name.key "
+		. ">>$d/openssl.out 2>&1") == 0
+		or die "Can't create certificate for $name: $!\n";
+}
+
+$t->write_file('index.html', '');
+
+$t->run();
+
+###############################################################################
+
+like(http_get('/'), qr/200 OK.*X-Name: ,/s, 'no name');
+like(http_get('/', socket => getconn('127.0.0.1:' . port(8081))),
+	qr/200 OK.*X-Name: u,/s, 'name default');
+like(http_get('/', socket => getconn('127.0.0.1:' . port(8082))),
+	qr/200 OK.*X-Name: example.com,/s, 'name override');
+like(http_get('/', socket => getconn('127.0.0.1:' . port(8083))),
+	qr/200 OK.*X-Name: ,/s, 'no ip');
+like(http_get('/', socket => getconn('127.0.0.1:' . port(8084))),
+	qr/200 OK.*X-Name: example.com,/s, 'no port in name');
+
+###############################################################################
+
+sub getconn {
+	my $peer = shift;
+	my $s = IO::Socket::INET->new(
+		Proto => 'tcp',
+		PeerAddr => $peer
+	)
+		or die "Can't connect to nginx: $!\n";
+
+	return $s;
+}
+
+###############################################################################
diff --git a/tests/stream_proxy_ssl_name_complex.t b/tests/stream_proxy_ssl_name_complex.t
new file mode 100644
index 0000000..47b317f
--- /dev/null
+++ b/tests/stream_proxy_ssl_name_complex.t
@@ -0,0 +1,90 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Stream tests for proxy to ssl backend, use of Server Name Indication
+# (proxy_ssl_name, proxy_ssl_server_name directives) with complex value.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_ssl stream_return sni/)
+	->has_daemon('openssl');
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    proxy_ssl on;
+    proxy_ssl_session_reuse off;
+
+    server {
+        listen      127.0.0.1:8081;
+        listen      127.0.0.1:8082;
+        proxy_pass  127.0.0.1:8085;
+
+        proxy_ssl_server_name on;
+        proxy_ssl_name x${server_port}x;
+    }
+
+    server {
+        ssl_certificate_key localhost.key;
+        ssl_certificate localhost.crt;
+
+        listen  127.0.0.1:8085 ssl;
+        return  $ssl_server_name;
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('localhost') {
+	system('openssl req -x509 -new '
+		. "-config $d/openssl.conf -subj /CN=$name/ "
+		. "-out $d/$name.crt -keyout $d/$name.key "
+		. ">>$d/openssl.out 2>&1") == 0
+		or die "Can't create certificate for $name: $!\n";
+}
+
+$t->run()->plan(2);
+
+###############################################################################
+
+my ($p1, $p2) = (port(8081), port(8082));
+
+is(stream("127.0.0.1:$p1")->read(), "x${p1}x", 'name 1');
+is(stream("127.0.0.1:$p2")->read(), "x${p2}x", 'name 2');
+
+###############################################################################
diff --git a/tests/stream_proxy_ssl_verify.t b/tests/stream_proxy_ssl_verify.t
new file mode 100644
index 0000000..e9d5f28
--- /dev/null
+++ b/tests/stream_proxy_ssl_verify.t
@@ -0,0 +1,174 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Stream tests for proxy to ssl backend, backend certificate verification.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_ssl stream_return/)
+	->has_daemon('openssl')->plan(6);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    proxy_ssl on;
+    proxy_ssl_verify on;
+
+    server {
+        listen      127.0.0.1:8080;
+        proxy_pass  127.0.0.1:8086;
+
+        proxy_ssl_name example.com;
+        proxy_ssl_trusted_certificate 1.example.com.crt;
+    }
+
+    server {
+        listen      127.0.0.1:8081;
+        proxy_pass  127.0.0.1:8086;
+
+        proxy_ssl_name foo.example.com;
+        proxy_ssl_trusted_certificate 1.example.com.crt;
+    }
+
+    server {
+        listen      127.0.0.1:8082;
+        proxy_pass  127.0.0.1:8086;
+
+        proxy_ssl_name no.match.example.com;
+        proxy_ssl_trusted_certificate 1.example.com.crt;
+    }
+
+    server {
+        listen      127.0.0.1:8083;
+        proxy_pass  127.0.0.1:8087;
+
+        proxy_ssl_name 2.example.com;
+        proxy_ssl_trusted_certificate 2.example.com.crt;
+    }
+
+    server {
+        listen      127.0.0.1:8084;
+        proxy_pass  127.0.0.1:8087;
+
+        proxy_ssl_name bad.example.com;
+        proxy_ssl_trusted_certificate 2.example.com.crt;
+    }
+
+    server {
+        listen      127.0.0.1:8085;
+        proxy_pass  127.0.0.1:8087;
+
+        proxy_ssl_trusted_certificate 1.example.com.crt;
+        proxy_ssl_session_reuse off;
+    }
+
+    server {
+        listen      127.0.0.1:8086 ssl;
+        proxy_ssl   off;
+        return      OK;
+
+        ssl_certificate 1.example.com.crt;
+        ssl_certificate_key 1.example.com.key;
+    }
+
+    server {
+        listen      127.0.0.1:8087 ssl;
+        proxy_ssl   off;
+        return      OK;
+
+        ssl_certificate 2.example.com.crt;
+        ssl_certificate_key 2.example.com.key;
+    }
+}
+
+EOF
+
+$t->write_file('openssl.1.example.com.conf', <<EOF);
+[ req ]
+prompt = no
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+x509_extensions = v3_req
+
+[ req_distinguished_name ]
+commonName=no.match.example.com
+
+[ v3_req ]
+subjectAltName = DNS:example.com,DNS:*.example.com
+EOF
+
+$t->write_file('openssl.2.example.com.conf', <<EOF);
+[ req ]
+prompt = no
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+
+[ req_distinguished_name ]
+commonName=2.example.com
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('1.example.com', '2.example.com') {
+	system('openssl req -x509 -new '
+		. "-config $d/openssl.$name.conf "
+		. "-out $d/$name.crt -keyout $d/$name.key "
+		. ">>$d/openssl.out 2>&1") == 0
+		or die "Can't create certificate for $name: $!\n";
+}
+
+sleep 1 if $^O eq 'MSWin32';
+
+$t->run();
+
+###############################################################################
+
+# subjectAltName
+
+is(get(8080), 'OK', 'verify');
+is(get(8081), 'OK', 'verify wildcard');
+isnt(get(8082), 'OK', 'verify fail');
+
+# commonName
+
+is(get(8083), 'OK', 'verify cn');
+isnt(get(8084), 'OK', 'verify cn fail');
+
+# untrusted
+
+isnt(get(8085), 'OK', 'untrusted');
+
+###############################################################################
+
+sub get {
+	stream('127.0.0.1:' . port(shift))->read();
+}
+
+###############################################################################
diff --git a/tests/stream_realip.t b/tests/stream_realip.t
new file mode 100644
index 0000000..759a8a7
--- /dev/null
+++ b/tests/stream_realip.t
@@ -0,0 +1,170 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for stream realip module, server side proxy protocol.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use IO::Select;
+use Socket qw/ $CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_return stream_realip/)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    server {
+        listen      127.0.0.1:8083 proxy_protocol;
+        listen      127.0.0.1:8084;
+        return      $proxy_protocol_addr:$proxy_protocol_port;
+    }
+
+    server {
+        listen      127.0.0.1:8085 proxy_protocol;
+        proxy_pass  127.0.0.1:8081;
+    }
+
+    server {
+        listen      127.0.0.1:8086 proxy_protocol;
+        listen      [::1]:%%PORT_8086%% proxy_protocol;
+        return      "$remote_addr:$remote_port:
+                     $realip_remote_addr:$realip_remote_port";
+
+        set_real_ip_from ::1;
+        set_real_ip_from 127.0.0.2;
+    }
+
+    server {
+        listen      127.0.0.1:8087;
+        proxy_pass  [::1]:%%PORT_8086%%;
+    }
+
+    server {
+        listen      127.0.0.1:8088 proxy_protocol;
+        listen      [::1]:%%PORT_8088%% proxy_protocol;
+        return      "$remote_addr:$remote_port:
+                     $realip_remote_addr:$realip_remote_port";
+
+        set_real_ip_from 127.0.0.1;
+        set_real_ip_from ::2;
+    }
+
+    server {
+        listen      127.0.0.1:8089;
+        proxy_pass  [::1]:%%PORT_8088%%;
+    }
+}
+
+EOF
+
+$t->run_daemon(\&stream_daemon);
+$t->try_run('no inet6 support')->plan(8);
+$t->waitforsocket('127.0.0.1:' . port(8081));
+
+###############################################################################
+
+is(pp_get(8083, "PROXY TCP4 192.0.2.1 192.0.2.2 1234 5678${CRLF}"),
+	'192.0.2.1:1234', 'server');
+
+is(stream('127.0.0.1:' . port(8084))->read(), ':', 'server off');
+
+is(pp_get(8085, "PROXY TCP4 192.0.2.1 192.0.2.2 1234 5678${CRLF}close"),
+	'close', 'server payload');
+
+like(pp_get(8086, "PROXY TCP4 192.0.2.1 192.0.2.2 1234 5678${CRLF}"),
+	qr/^(\Q127.0.0.1:\E\d+):\s+\1$/, 'server ipv6 realip - no match');
+
+like(pp_get(8087, "PROXY TCP4 192.0.2.1 192.0.2.2 1234 5678${CRLF}"),
+	qr/\Q192.0.2.1:1234:\E\s+\Q::1:\E\d+/, 'server ipv6 realip');
+
+like(pp_get(8088, "PROXY TCP4 192.0.2.1 192.0.2.2 1234 5678${CRLF}"),
+	qr/\Q192.0.2.1:1234:\E\s+\Q127.0.0.1:\E\d+/, 'server ipv4 realip');
+
+like(pp_get(8089, "PROXY TCP4 192.0.2.1 192.0.2.2 1234 5678${CRLF}"),
+	qr/^(::1:\d+):\s+\1$/, 'server ipv4 realip - no match');
+
+like(pp_get(8088, "PROXY UNKNOWN TCP4 192.0.2.1 192.0.2.2 1234 5678${CRLF}"),
+	qr/^(\Q127.0.0.1:\E\d+):\s+\1$/, 'server unknown');
+
+###############################################################################
+
+sub pp_get {
+	my ($port, $proxy) = @_;
+	stream(PeerPort => port($port))->io($proxy);
+}
+
+###############################################################################
+
+sub stream_daemon {
+	my $server = IO::Socket::INET->new(
+		Proto => 'tcp',
+		LocalAddr => '127.0.0.1:' . port(8081),
+		Listen => 5,
+		Reuse => 1
+	)
+		or die "Can't create listening socket: $!\n";
+
+	my $sel = IO::Select->new($server);
+
+	local $SIG{PIPE} = 'IGNORE';
+
+	while (my @ready = $sel->can_read) {
+		foreach my $fh (@ready) {
+			if ($server == $fh) {
+				my $new = $fh->accept;
+				$new->autoflush(1);
+				$sel->add($new);
+
+			} elsif (stream_handle_client($fh)) {
+				$sel->remove($fh);
+				$fh->close;
+			}
+		}
+	}
+}
+
+sub stream_handle_client {
+	my ($client) = @_;
+
+	log2c("(new connection $client)");
+
+	$client->sysread(my $buffer, 65536) or return 1;
+
+	log2i("$client $buffer");
+
+	log2o("$client $buffer");
+
+	$client->syswrite($buffer);
+
+	return $buffer =~ /close/;
+}
+
+sub log2i { Test::Nginx::log_core('|| <<', @_); }
+sub log2o { Test::Nginx::log_core('|| >>', @_); }
+sub log2c { Test::Nginx::log_core('||', @_); }
+
+###############################################################################
diff --git a/tests/stream_realip_hostname.t b/tests/stream_realip_hostname.t
new file mode 100644
index 0000000..a867ba3
--- /dev/null
+++ b/tests/stream_realip_hostname.t
@@ -0,0 +1,100 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for stream realip module, 'unix:' and hostname in set_real_ip_from.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/ $CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_return stream_realip unix/)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    server {
+        listen      unix:%%TESTDIR%%/unix.sock proxy_protocol;
+        listen      127.0.0.1:8080;
+        listen      127.0.0.1:8082 proxy_protocol;
+        return      $remote_addr;
+
+        set_real_ip_from unix:;
+    }
+
+    server {
+        listen      127.0.0.1:8081;
+        proxy_pass  unix:%%TESTDIR%%/unix.sock;
+    }
+
+    server {
+        listen      127.0.0.1:8085 proxy_protocol;
+        listen      unix:%%TESTDIR%%/unix2.sock proxy_protocol;
+        return      $remote_addr;
+
+        set_real_ip_from localhost;
+    }
+
+    server {
+        listen      127.0.0.1:8083;
+        proxy_pass  127.0.0.1:8085;
+    }
+
+    server {
+        listen      127.0.0.1:8084;
+        proxy_pass  unix:%%TESTDIR%%/unix2.sock;
+    }
+}
+
+EOF
+
+$t->run();
+
+plan(skip_all => 'no 127.0.0.1 on host')
+	if http_get('/') ne '127.0.0.1';
+
+$t->plan(4);
+
+###############################################################################
+
+is(pp_get(8081, "PROXY TCP4 192.0.2.1 192.0.2.2 1234 5678${CRLF}"),
+	'192.0.2.1', 'realip unix');
+isnt(pp_get(8082, "PROXY TCP4 192.0.2.1 192.0.2.2 1234 5678${CRLF}"),
+	'192.0.2.1', 'realip unix - no match');
+
+is(pp_get(8083, "PROXY TCP4 192.0.2.1 192.0.2.2 1234 5678${CRLF}"),
+	'192.0.2.1', 'realip hostname');
+isnt(pp_get(8084, "PROXY TCP4 192.0.2.1 192.0.2.2 1234 5678${CRLF}"),
+	'192.0.2.1', 'realip hostname - no match');
+
+###############################################################################
+
+sub pp_get {
+	my ($port, $proxy) = @_;
+	stream(PeerPort => port($port))->io($proxy);
+}
+
+###############################################################################
diff --git a/tests/stream_resolver.t b/tests/stream_resolver.t
new file mode 100644
index 0000000..3613521
--- /dev/null
+++ b/tests/stream_resolver.t
@@ -0,0 +1,193 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for stream upstream name resolved, proxy_next_upstream_tries.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_map stream_return/)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    map $server_port $upstream {
+        %%PORT_8081%%  a.example.com:%%PORT_8090%%;
+        %%PORT_8082%%  a.example.com;
+        %%PORT_8083%%  nx.example.com:%%PORT_8082%%;
+    }
+
+    map $server_port $many {
+        default  $server_port.many.example.com;
+    }
+
+    resolver  127.0.0.1:%%PORT_8980_UDP%%;
+
+    server {
+        listen      127.0.0.1:8081;
+        listen      127.0.0.1:8082;
+        listen      127.0.0.1:8083;
+        proxy_pass  $upstream;
+    }
+
+    server {
+        listen      127.0.0.1:8084;
+        proxy_pass  $many:%%PORT_8090%%;
+
+        proxy_next_upstream_tries 3;
+        proxy_connect_timeout 1s;
+    }
+
+    server {
+        listen      127.0.0.1:8085;
+        proxy_pass  $many:%%PORT_8090%%;
+
+        proxy_next_upstream_tries 2;
+        proxy_connect_timeout 1s;
+    }
+
+    server {
+        listen      127.0.0.1:8086;
+        proxy_pass  $many:%%PORT_8090%%;
+
+        proxy_next_upstream_tries 0;
+        proxy_connect_timeout 1s;
+    }
+
+    server {
+        listen      127.0.0.1:8090;
+        return      SEE-THIS;
+    }
+}
+
+EOF
+
+$t->run_daemon(\&dns_daemon, port(8980), $t);
+$t->run()->plan(8);
+
+$t->waitforfile($t->testdir . '/' . port(8980));
+
+###############################################################################
+
+ok(stream('127.0.0.1:' . port(8081))->read(), 'resolver');
+ok(!stream('127.0.0.1:' . port(8082))->read(), 'upstream no port');
+ok(!stream('127.0.0.1:' . port(8083))->read(), 'name not found');
+
+ok(stream('127.0.0.1:' . port(8084))->read(), 'resolved tries');
+ok(!stream('127.0.0.1:' . port(8085))->read(), 'resolved tries limited');
+ok(stream('127.0.0.1:' . port(8086))->read(), 'resolved tries zero');
+
+$t->stop();
+
+SKIP: {
+skip "relies on error log contents", 2 unless $ENV{TEST_NGINX_UNSAFE};
+
+my $log = `grep -F '[error]' ${\($t->testdir())}/error.log`;
+like($log, qr/no port in upstream "a.example.com"/, 'log - no port');
+like($log, qr/nx.example.com could not be resolved/, 'log - not found');
+
+}
+
+###############################################################################
+
+sub reply_handler {
+	my ($recv_data, $port) = @_;
+
+	my (@name, @rdata);
+
+	use constant NOERROR	=> 0;
+	use constant A		=> 1;
+	use constant IN 	=> 1;
+
+	# default values
+
+	my ($hdr, $rcode, $ttl) = (0x8180, NOERROR, 3600);
+
+	# decode name
+
+	my ($len, $offset) = (undef, 12);
+	while (1) {
+		$len = unpack("\@$offset C", $recv_data);
+		last if $len == 0;
+		$offset++;
+		push @name, unpack("\@$offset A$len", $recv_data);
+		$offset += $len;
+	}
+
+	$offset -= 1;
+	my ($id, $type, $class) = unpack("n x$offset n2", $recv_data);
+
+	my $name = join('.', @name);
+	if ($name eq 'a.example.com' && $type == A) {
+		push @rdata, rd_addr($ttl, '127.0.0.1');
+
+	} elsif ($name =~ qr/many.example.com/ && $type == A) {
+		push @rdata, rd_addr($ttl, '127.0.0.2');
+		push @rdata, rd_addr($ttl, '127.0.0.2');
+		push @rdata, rd_addr($ttl, '127.0.0.1');
+	}
+
+	$len = @name;
+	pack("n6 (C/a*)$len x n2", $id, $hdr | $rcode, 1, scalar @rdata,
+		0, 0, @name, $type, $class) . join('', @rdata);
+}
+
+sub rd_addr {
+	my ($ttl, $addr) = @_;
+
+	my $code = 'split(/\./, $addr)';
+
+	return pack 'n3N', 0xc00c, A, IN, $ttl if $addr eq '';
+
+	pack 'n3N nC4', 0xc00c, A, IN, $ttl, eval "scalar $code", eval($code);
+}
+
+sub dns_daemon {
+	my ($port, $t) = @_;
+
+	my ($data, $recv_data);
+	my $socket = IO::Socket::INET->new(
+		LocalAddr    => '127.0.0.1',
+		LocalPort    => $port,
+		Proto        => 'udp',
+	)
+		or die "Can't create listening socket: $!\n";
+
+	local $SIG{PIPE} = 'IGNORE';
+
+	# signal we are ready
+
+	open my $fh, '>', $t->testdir() . '/' . $port;
+	close $fh;
+
+	while (1) {
+		$socket->recv($recv_data, 65536);
+		$data = reply_handler($recv_data, $port);
+		$socket->send($data);
+	}
+}
+
+###############################################################################
diff --git a/tests/stream_split_clients.t b/tests/stream_split_clients.t
new file mode 100644
index 0000000..862863d
--- /dev/null
+++ b/tests/stream_split_clients.t
@@ -0,0 +1,77 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for stream split_client module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_split_clients stream_return/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    split_clients $connection $variant {
+        51.2%  "first";
+        10%    "second";
+        *      "third";
+    }
+
+    server {
+        listen  127.0.0.1:8080;
+        return  $variant;
+    }
+}
+
+EOF
+
+$t->run();
+$t->plan(1);
+
+###############################################################################
+
+# NB: split_clients distribution is a subject to implementation details
+
+like(many('/', 20), qr/first: 12, second: 2, third: 6/, 'split');
+
+###############################################################################
+
+sub many {
+	my ($uri, $count) = @_;
+	my %dist;
+
+	for (1 .. $count) {
+		if (my $data = stream('127.0.0.1:' . port(8080))->read()) {
+			$dist{$data} = 0 unless defined $data;
+			$dist{$data}++;
+		}
+	}
+
+	return join ', ', map { $_ . ": " . $dist{$_} } sort keys %dist;
+}
+
+###############################################################################
diff --git a/tests/stream_ssl.t b/tests/stream_ssl.t
new file mode 100644
index 0000000..641d123
--- /dev/null
+++ b/tests/stream_ssl.t
@@ -0,0 +1,228 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for stream ssl module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use POSIX qw/ mkfifo /;
+use Socket qw/ :DEFAULT $CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval {
+	require Net::SSLeay;
+	Net::SSLeay::load_error_strings();
+	Net::SSLeay::SSLeay_add_ssl_algorithms();
+	Net::SSLeay::randomize();
+};
+plan(skip_all => 'Net::SSLeay not installed') if $@;
+
+plan(skip_all => 'win32') if $^O eq 'MSWin32';
+
+my $t = Test::Nginx->new()->has(qw/stream stream_ssl/)->has_daemon('openssl');
+
+$t->plan(7)->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    ssl_certificate_key localhost.key;
+    ssl_certificate localhost.crt;
+    ssl_session_tickets off;
+
+    # inherited by server "inherits"
+    ssl_password_file password_stream;
+
+    server {
+        listen      127.0.0.1:8080 ssl;
+        proxy_pass  127.0.0.1:8081;
+
+        ssl_session_cache builtin;
+        ssl_password_file password;
+    }
+
+    server {
+        listen      127.0.0.1:8082 ssl;
+        proxy_pass  127.0.0.1:8081;
+
+        ssl_session_cache off;
+        ssl_password_file password_many;
+    }
+
+    server {
+        listen      127.0.0.1:8083 ssl;
+        proxy_pass  127.0.0.1:8081;
+
+        ssl_session_cache builtin:1000;
+        ssl_password_file password_fifo;
+    }
+
+    server {
+        listen      127.0.0.1:8084 ssl;
+        proxy_pass  127.0.0.1:8081;
+
+        ssl_session_cache shared:SSL:1m;
+        ssl_certificate_key inherits.key;
+        ssl_certificate inherits.crt;
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+mkfifo("$d/password_fifo", 0700);
+
+foreach my $name ('localhost', 'inherits') {
+	system("openssl genrsa -out $d/$name.key -passout pass:$name "
+		. "-aes128 2048 >>$d/openssl.out 2>&1") == 0
+		or die "Can't create private key: $!\n";
+	system('openssl req -x509 -new '
+		. "-config $d/openssl.conf -subj /CN=$name/ "
+		. "-out $d/$name.crt "
+		. "-key $d/$name.key -passin pass:$name"
+		. ">>$d/openssl.out 2>&1") == 0
+		or die "Can't create certificate for $name: $!\n";
+}
+
+
+my $ctx = Net::SSLeay::CTX_new() or die("Failed to create SSL_CTX $!");
+
+$t->write_file('password', 'localhost');
+$t->write_file('password_many', "wrong$CRLF" . "localhost$CRLF");
+$t->write_file('password_stream', 'inherits');
+
+my $p = fork();
+exec("echo localhost > $d/password_fifo") if $p == 0;
+
+$t->run_daemon(\&http_daemon);
+
+eval {
+	open OLDERR, ">&", \*STDERR; close STDERR;
+	$t->run();
+	open STDERR, ">&", \*OLDERR;
+};
+kill 'INT', $p if $@;
+
+$t->waitforsocket('127.0.0.1:' . port(8081));
+
+###############################################################################
+
+my ($s, $ssl, $ses);
+
+($s, $ssl) = get_ssl_socket(port(8080));
+Net::SSLeay::write($ssl, "GET / HTTP/1.0$CRLF$CRLF");
+like(Net::SSLeay::read($ssl), qr/200 OK/, 'ssl');
+
+# ssl_session_cache
+
+($s, $ssl) = get_ssl_socket(port(8080));
+$ses = Net::SSLeay::get_session($ssl);
+
+($s, $ssl) = get_ssl_socket(port(8080), $ses);
+is(Net::SSLeay::session_reused($ssl), 1, 'builtin session reused');
+
+($s, $ssl) = get_ssl_socket(port(8082));
+$ses = Net::SSLeay::get_session($ssl);
+
+($s, $ssl) = get_ssl_socket(port(8082), $ses);
+isnt(Net::SSLeay::session_reused($ssl), 1, 'session not reused');
+
+($s, $ssl) = get_ssl_socket(port(8083));
+$ses = Net::SSLeay::get_session($ssl);
+
+($s, $ssl) = get_ssl_socket(port(8083), $ses);
+is(Net::SSLeay::session_reused($ssl), 1, 'builtin size session reused');
+
+($s, $ssl) = get_ssl_socket(port(8084));
+$ses = Net::SSLeay::get_session($ssl);
+
+($s, $ssl) = get_ssl_socket(port(8084), $ses);
+is(Net::SSLeay::session_reused($ssl), 1, 'shared session reused');
+
+# ssl_certificate inheritance
+
+($s, $ssl) = get_ssl_socket(port(8080));
+like(Net::SSLeay::dump_peer_certificate($ssl), qr/CN=localhost/, 'CN');
+
+($s, $ssl) = get_ssl_socket(port(8084));
+like(Net::SSLeay::dump_peer_certificate($ssl), qr/CN=inherits/, 'CN inner');
+
+###############################################################################
+
+sub get_ssl_socket {
+	my ($port, $ses) = @_;
+	my $s;
+
+	my $dest_ip = inet_aton('127.0.0.1');
+	my $dest_serv_params = sockaddr_in($port, $dest_ip);
+
+	socket($s, &AF_INET, &SOCK_STREAM, 0) or die "socket: $!";
+	connect($s, $dest_serv_params) or die "connect: $!";
+
+	my $ssl = Net::SSLeay::new($ctx) or die("Failed to create SSL $!");
+	Net::SSLeay::set_session($ssl, $ses) if defined $ses;
+	Net::SSLeay::set_fd($ssl, fileno($s));
+	Net::SSLeay::connect($ssl) or die("ssl connect");
+	return ($s, $ssl);
+}
+
+###############################################################################
+
+sub http_daemon {
+	my $server = IO::Socket::INET->new(
+		Proto => 'tcp',
+		LocalHost => '127.0.0.1:' . port(8081),
+		Listen => 5,
+		Reuse => 1
+	)
+		or die "Can't create listening socket: $!\n";
+
+	local $SIG{PIPE} = 'IGNORE';
+
+	while (my $client = $server->accept()) {
+		$client->autoflush(1);
+
+		while (<$client>) {
+			last if (/^\x0d?\x0a?$/);
+		}
+
+		print $client <<EOF;
+HTTP/1.1 200 OK
+Connection: close
+
+EOF
+
+		close $client;
+	}
+}
+
+###############################################################################
diff --git a/tests/stream_ssl_certificate.t b/tests/stream_ssl_certificate.t
new file mode 100644
index 0000000..099db33
--- /dev/null
+++ b/tests/stream_ssl_certificate.t
@@ -0,0 +1,213 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for stream ssl module with dynamic certificates.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/ :DEFAULT CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval {
+	require Net::SSLeay;
+	Net::SSLeay::load_error_strings();
+	Net::SSLeay::SSLeay_add_ssl_algorithms();
+	Net::SSLeay::randomize();
+};
+plan(skip_all => 'Net::SSLeay not installed') if $@;
+
+eval {
+	my $ctx = Net::SSLeay::CTX_new() or die;
+	my $ssl = Net::SSLeay::new($ctx) or die;
+	Net::SSLeay::set_tlsext_host_name($ssl, 'example.org') == 1 or die;
+};
+plan(skip_all => 'Net::SSLeay with OpenSSL SNI support required') if $@;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_ssl stream_geo stream_return/)
+	->has_daemon('openssl');
+
+$t->{_configure_args} =~ /OpenSSL ([\d\.]+)/;
+plan(skip_all => 'OpenSSL too old') unless defined $1 and $1 ge '1.0.2';
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    geo $one {
+        default one;
+    }
+
+    geo $two {
+        default two;
+    }
+
+    geo $pass {
+        default pass;
+    }
+
+    ssl_session_cache shared:SSL:1m;
+    ssl_session_tickets off;
+
+    server {
+        listen       127.0.0.1:8080 ssl;
+        return       $ssl_server_name:$ssl_session_reused;
+
+        ssl_certificate $one.crt;
+        ssl_certificate_key $one.key;
+    }
+
+    server {
+        listen       127.0.0.1:8083 ssl;
+        return       $ssl_server_name:$ssl_session_reused;
+
+        # found in key
+        ssl_certificate pass.crt;
+        ssl_certificate_key $pass.key;
+        ssl_password_file password_file;
+    }
+
+    server {
+        listen       127.0.0.1:8081 ssl;
+        return       $ssl_server_name:$ssl_session_reused;
+
+        ssl_certificate $one.crt;
+        ssl_certificate_key $one.key;
+    }
+
+    server {
+        listen       127.0.0.1:8082 ssl;
+        return       $ssl_server_name:$ssl_session_reused;
+
+        ssl_certificate $two.crt;
+        ssl_certificate_key $two.key;
+    }
+
+    server {
+        listen       127.0.0.1:8084 ssl;
+        return       $ssl_server_name:$ssl_session_reused;
+
+        ssl_certificate $ssl_server_name.crt;
+        ssl_certificate_key $ssl_server_name.key;
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('one', 'two') {
+	system('openssl req -x509 -new '
+		. "-config $d/openssl.conf -subj /CN=$name/ "
+		. "-out $d/$name.crt -keyout $d/$name.key "
+		. ">>$d/openssl.out 2>&1") == 0
+		or die "Can't create certificate for $name: $!\n";
+}
+
+foreach my $name ('pass') {
+	system("openssl genrsa -out $d/$name.key -passout pass:pass "
+		. "-aes128 2048 >>$d/openssl.out 2>&1") == 0
+		or die "Can't create $name key: $!\n";
+	system("openssl req -x509 -new -config $d/openssl.conf "
+		. "-subj /CN=$name/ -out $d/$name.crt -key $d/$name.key "
+		. "-passin pass:pass >>$d/openssl.out 2>&1") == 0
+		or die "Can't create $name certificate: $!\n";
+}
+
+$t->write_file('password_file', 'pass');
+$t->write_file('index.html', '');
+
+$t->run()->plan(7);
+
+###############################################################################
+
+like(cert('default', 8080), qr/CN=one/, 'default certificate');
+like(get('default', 8080), qr/default/, 'default context');
+
+like(get('password', 8083), qr/password/, 'ssl_password_file');
+
+# session reuse
+
+my ($s, $ssl) = get_ssl_socket('default', 8080);
+my $ses = Net::SSLeay::get_session($ssl);
+
+like(get('default', 8080, $ses), qr/:r/, 'session reused');
+
+# do not check $ssl_server_name, since stream doesn't install SNI callback
+# see for more details: https://github.com/openssl/openssl/issues/7014
+
+like(get('default', 8081, $ses), qr/:r/, 'session id context match');
+like(get('default', 8082, $ses), qr/:\./, 'session id context distinct');
+
+# errors
+
+Net::SSLeay::ERR_clear_error();
+get_ssl_socket('nx', 8084);
+ok(Net::SSLeay::ERR_peek_error(), 'no certificate');
+
+###############################################################################
+
+sub get {
+	my ($host, $port, $ctx) = @_;
+	my ($s, $ssl) = get_ssl_socket($host, $port, $ctx) or return;
+	my $r = Net::SSLeay::read($ssl);
+	$s->close();
+	return $r;
+}
+
+sub cert {
+	my ($host, $port, $ctx) = @_;
+	my ($s, $ssl) = get_ssl_socket($host, $port, $ctx) or return;
+	Net::SSLeay::dump_peer_certificate($ssl);
+}
+
+sub get_ssl_socket {
+	my ($host, $port, $ses) = @_;
+	my $s;
+
+	my $dest_ip = inet_aton('127.0.0.1');
+	$port = port($port);
+	my $dest_serv_params = sockaddr_in($port, $dest_ip);
+
+	socket($s, &AF_INET, &SOCK_STREAM, 0) or die "socket: $!";
+	connect($s, $dest_serv_params) or die "connect: $!";
+
+	my $ctx = Net::SSLeay::CTX_new() or die("Failed to create SSL_CTX $!");
+	my $ssl = Net::SSLeay::new($ctx) or die("Failed to create SSL $!");
+	Net::SSLeay::set_tlsext_host_name($ssl, $host);
+	Net::SSLeay::set_session($ssl, $ses) if defined $ses;
+	Net::SSLeay::set_fd($ssl, fileno($s));
+	Net::SSLeay::connect($ssl) or die("ssl connect");
+	return ($s, $ssl);
+}
+
+###############################################################################
diff --git a/tests/stream_ssl_preread.t b/tests/stream_ssl_preread.t
new file mode 100644
index 0000000..6991902
--- /dev/null
+++ b/tests/stream_ssl_preread.t
@@ -0,0 +1,244 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for stream_ssl_preread module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_map stream_ssl_preread/)
+	->has(qw/stream_ssl stream_return/)->has_daemon('openssl')
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    log_format status $status;
+
+    map $ssl_preread_server_name $name {
+        ""       127.0.0.1:8093;
+        default  $ssl_preread_server_name;
+    }
+
+    upstream foo {
+        server 127.0.0.1:8091;
+    }
+
+    upstream bar {
+        server 127.0.0.1:8092;
+    }
+
+    upstream next {
+        server 127.0.0.1:8094;
+        server 127.0.0.1:8080;
+    }
+
+    ssl_preread  on;
+
+    server {
+        listen       127.0.0.1:8080;
+        return       $name;
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        proxy_pass   $name;
+    }
+
+    server {
+        listen       127.0.0.1:8082;
+        proxy_pass   $name;
+        ssl_preread  off;
+    }
+
+    server {
+        listen       127.0.0.1:8083;
+        proxy_pass   $name;
+
+        preread_timeout      2s;
+        preread_buffer_size  42;
+
+        access_log %%TESTDIR%%/status.log status;
+    }
+
+    server {
+        listen       127.0.0.1:8084;
+        proxy_pass   next;
+
+        proxy_connect_timeout  2s;
+        preread_buffer_size    8;
+    }
+
+    ssl_certificate_key localhost.key;
+    ssl_certificate localhost.crt;
+
+    server {
+        listen       127.0.0.1:8091 ssl;
+        listen       127.0.0.1:8092 ssl;
+        listen       127.0.0.1:8093 ssl;
+        ssl_preread  off;
+        return       $server_port;
+    }
+}
+
+EOF
+
+eval { require IO::Socket::SSL; die if $IO::Socket::SSL::VERSION < 1.56; };
+plan(skip_all => 'IO::Socket::SSL version >= 1.56 required') if $@;
+
+eval {
+	if (IO::Socket::SSL->can('can_client_sni')) {
+		IO::Socket::SSL->can_client_sni() or die;
+	}
+};
+plan(skip_all => 'IO::Socket::SSL with OpenSSL SNI support required') if $@;
+
+eval {
+	my $ctx = Net::SSLeay::CTX_new() or die;
+	my $ssl = Net::SSLeay::new($ctx) or die;
+	Net::SSLeay::set_tlsext_host_name($ssl, 'example.org') == 1 or die;
+};
+plan(skip_all => 'Net::SSLeay with OpenSSL SNI support required') if $@;
+
+$t->plan(13);
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('localhost') {
+	system('openssl req -x509 -new '
+		. "-config $d/openssl.conf -subj /CN=$name/ "
+		. "-out $d/$name.crt -keyout $d/$name.key "
+		. ">>$d/openssl.out 2>&1") == 0
+		or die "Can't create certificate for $name: $!\n";
+}
+
+$t->run();
+
+###############################################################################
+
+my ($p1, $p2, $p3, $p4) = (port(8091), port(8092), port(8093), port(8084));
+
+is(get_ssl('foo', 8081), $p1, 'sni');
+is(get_ssl('foo', 8081), $p1, 'sni again');
+
+is(get_ssl('bar', 8081), $p2, 'sni 2');
+is(get_ssl('bar', 8081), $p2, 'sni 2 again');
+
+# fallback to an empty value for some reason
+
+is(get_ssl('', 8081), $p3, 'no sni');
+is(get_ssl('foo', 8082), $p3, 'preread off');
+is(get_ssl('foo', 8083), undef, 'preread buffer full');
+is(stream('127.0.0.1:' . port(8080))->io('x' x 1000), "127.0.0.1:$p3",
+	'not a handshake');
+
+# ticket #1317
+
+is(stream("127.0.0.1:$p4")->io('x' x 16), "127.0.0.1:$p3",
+	'pending buffers on next upstream');
+
+# no junk in variable due to short ClientHello length value
+
+is(get_short(), "127.0.0.1:$p3", 'short client hello');
+
+# allow record with older SSL version, such as 3.0
+
+is(get_oldver(), 'foo', 'older version in ssl record');
+
+# SNI "foo|f" fragmented across TLS records
+
+is(get_frag(), 'foof', 'handshake fragment split on SNI');
+
+$t->stop();
+
+is($t->read_file('status.log'), "400\n", 'preread buffer full - log');
+
+###############################################################################
+
+sub get_frag {
+	my $r = pack("N*", 0x16030100, 0x3b010000, 0x380303ac,
+		0x8c8678a0, 0xaa1e7eed, 0x3644eed6, 0xc3bd2c69,
+		0x7bc7deda, 0x249db0e3, 0x0c339eba, 0xa80b7600,
+		0x00020000, 0x0100000d, 0x00000009, 0x00070000,
+		0x04666f6f, 0x16030100);
+	$r .= pack("n", 0x0166);
+
+	http($r);
+}
+
+sub get_short {
+	my $r = pack("N*", 0x16030100, 0x38010000, 0x330303eb);
+	$r .= pack("N*", 0x6357cdba, 0xa6b8d853, 0xf1f6ac0f);
+	$r .= pack("N*", 0xdf03178c, 0x0ae41824, 0xe7643682);
+	$r .= pack("N*", 0x3c1b273f, 0xbfde4b00, 0x00000000);
+	$r .= pack("CN3", 0x0c, 0x00000008, 0x00060000, 0x03666f6f);
+
+	http($r);
+}
+
+sub get_oldver {
+	my $r = pack("N*", 0x16030000, 0x38010000, 0x340303eb);
+	$r .= pack("N*", 0x6357cdba, 0xa6b8d853, 0xf1f6ac0f);
+	$r .= pack("N*", 0xdf03178c, 0x0ae41824, 0xe7643682);
+	$r .= pack("N*", 0x3c1b273f, 0xbfde4b00, 0x00000000);
+	$r .= pack("CN3", 0x0c, 0x00000008, 0x00060000, 0x03666f6f);
+
+	http($r);
+}
+
+sub get_ssl {
+	my ($host, $port) = @_;
+	my $s = stream('127.0.0.1:' . port($port));
+
+	eval {
+		local $SIG{ALRM} = sub { die "timeout\n" };
+		local $SIG{PIPE} = sub { die "sigpipe\n" };
+		alarm(8);
+		IO::Socket::SSL->start_SSL($s->{_socket},
+			SSL_hostname => $host,
+			SSL_verify_mode => IO::Socket::SSL::SSL_VERIFY_NONE(),
+			SSL_error_trap => sub { die $_[1] }
+		);
+		alarm(0);
+	};
+	alarm(0);
+
+	if ($@) {
+		log_in("died: $@");
+		return undef;
+	}
+
+	return $s->read();
+}
+
+###############################################################################
diff --git a/tests/stream_ssl_preread_alpn.t b/tests/stream_ssl_preread_alpn.t
new file mode 100644
index 0000000..eb61e34
--- /dev/null
+++ b/tests/stream_ssl_preread_alpn.t
@@ -0,0 +1,148 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for stream_ssl_preread module, ALPN preread.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_map stream_ssl_preread/)
+	->has(qw/stream_ssl stream_return/)->has_daemon('openssl')
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    map $ssl_preread_alpn_protocols $name {
+        ""       127.0.0.1:8093;
+        default  $ssl_preread_alpn_protocols;
+    }
+
+    upstream foo {
+        server 127.0.0.1:8091;
+    }
+
+    upstream bar {
+        server 127.0.0.1:8092;
+    }
+
+    upstream foo,bar {
+        server 127.0.0.1:8093;
+    }
+
+    ssl_preread  on;
+
+    server {
+        listen       127.0.0.1:8081;
+        proxy_pass   $name;
+    }
+
+    ssl_certificate_key localhost.key;
+    ssl_certificate localhost.crt;
+
+    server {
+        listen       127.0.0.1:8091 ssl;
+        listen       127.0.0.1:8092 ssl;
+        listen       127.0.0.1:8093 ssl;
+        ssl_preread  off;
+        return       $server_port;
+    }
+}
+
+EOF
+
+eval { require IO::Socket::SSL; die if $IO::Socket::SSL::VERSION < 1.56; };
+plan(skip_all => 'IO::Socket::SSL version >= 1.56 required') if $@;
+
+eval { IO::Socket::SSL->can_alpn() or die; };
+plan(skip_all => 'IO::Socket::SSL with OpenSSL ALPN support required') if $@;
+
+eval { exists &Net::SSLeay::P_alpn_selected or die; };
+plan(skip_all => 'Net::SSLeay with OpenSSL ALPN support required') if $@;
+
+$t->plan(5);
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('localhost') {
+	system('openssl req -x509 -new '
+		. "-config $d/openssl.conf -subj /CN=$name/ "
+		. "-out $d/$name.crt -keyout $d/$name.key "
+		. ">>$d/openssl.out 2>&1") == 0
+		or die "Can't create certificate for $name: $!\n";
+}
+
+$t->run();
+
+###############################################################################
+
+my ($p1, $p2, $p3) = (port(8091), port(8092), port(8093));
+
+is(get_ssl(8081, 'foo'), $p1, 'alpn');
+is(get_ssl(8081, 'foo'), $p1, 'alpn again');
+
+is(get_ssl(8081, 'bar'), $p2, 'alpn 2');
+is(get_ssl(8081, 'bar'), $p2, 'alpn 2 again');
+
+is(get_ssl(8081, 'foo', 'bar'), $p3, 'alpn many');
+
+get_ssl(8081, '');
+
+###############################################################################
+
+sub get_ssl {
+	my ($port, @alpn) = @_;
+	my $s = stream('127.0.0.1:' . port($port));
+
+	eval {
+		local $SIG{ALRM} = sub { die "timeout\n" };
+		local $SIG{PIPE} = sub { die "sigpipe\n" };
+		alarm(8);
+		IO::Socket::SSL->start_SSL($s->{_socket},
+			SSL_alpn_protocols => [ @alpn ],
+			SSL_verify_mode => IO::Socket::SSL::SSL_VERIFY_NONE(),
+			SSL_error_trap => sub { die $_[1] }
+		);
+		alarm(0);
+	};
+	alarm(0);
+
+	if ($@) {
+		log_in("died: $@");
+		return undef;
+	}
+
+	return $s->read();
+}
+
+###############################################################################
diff --git a/tests/stream_ssl_preread_protocol.t b/tests/stream_ssl_preread_protocol.t
new file mode 100644
index 0000000..1faf38d
--- /dev/null
+++ b/tests/stream_ssl_preread_protocol.t
@@ -0,0 +1,101 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for stream_ssl_preread module, protocol preread.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_ssl_preread stream_return/)
+	->write_file_expand('nginx.conf', <<'EOF')->plan(7)->run();
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    server {
+        listen       127.0.0.1:8080;
+        ssl_preread  on;
+        return       $ssl_preread_protocol;
+    }
+}
+
+EOF
+
+###############################################################################
+
+is(get('SSLv3'), 'SSLv3', 'client hello SSLv3');
+is(get('TLSv1'), 'TLSv1', 'client hello TLSv1');
+is(get('TLSv1.1'), 'TLSv1.1', 'client hello TLSv1.1');
+is(get('TLSv1.2'), 'TLSv1.2', 'client hello TLSv1.2');
+
+is(get_tls13(), 'TLSv1.3', 'client hello supported_versions');
+
+is(get_ssl2('SSLv2'), 'SSLv2', 'client hello version 2');
+is(get_ssl2('TLSv1'), 'TLSv1', 'client hello version 2 - TLSv1');
+
+###############################################################################
+
+sub get {
+	my $v = shift;
+	my ($re, $ch);
+
+	$re = 0x0300, $ch = 0x0300 if $v eq 'SSLv3';
+	$re = 0x0301, $ch = 0x0301 if $v eq 'TLSv1';
+	$re = 0x0301, $ch = 0x0302 if $v eq 'TLSv1.1';
+	$re = 0x0301, $ch = 0x0303 if $v eq 'TLSv1.2';
+
+	my $r = pack("CnNn2C", 0x16, $re, 0x00380100, 0x0034, $ch, 0xeb);
+	$r .= pack("N*", 0x6357cdba, 0xa6b8d853, 0xf1f6ac0f);
+	$r .= pack("N*", 0xdf03178c, 0x0ae41824, 0xe7643682);
+	$r .= pack("N*", 0x3c1b273f, 0xbfde4b00, 0x00000000);
+	$r .= pack("CN3", 0x0c, 0x00000008, 0x00060000, 0x03666f6f);
+
+	http($r);
+}
+
+sub get_tls13 {
+	my $r = pack("N*", 0x16030100, 0x33010000, 0x2f0303eb);
+	$r .= pack("N*", 0x6357cdba, 0xa6b8d853, 0xf1f6ac0f);
+	$r .= pack("N*", 0xdf03178c, 0x0ae41824, 0xe7643682);
+	$r .= pack("N*", 0x3c1b273f, 0xbfde4b00, 0x00000000);
+	$r .= pack("CNCn", 0x07, 0x002b0007, 0x02, 0x7f1c);
+
+	http($r);
+}
+
+sub get_ssl2 {
+	my $v = shift;
+	my $ch;
+
+	$ch = 0x0002 if $v eq 'SSLv2';
+	$ch = 0x0301 if $v eq 'TLSv1';
+
+	my $r = pack("nCn4", 0x801c, 0x01, $ch, 0x0003, 0x0000, 0x0010);
+	$r .= pack("C3", 0x01, 0x00, 0x80);
+	$r .= pack("N4", 0x322dd95c, 0x4749ef17, 0x3d5f0916, 0xf0b730f8);
+
+	http($r);
+}
+
+###############################################################################
diff --git a/tests/stream_ssl_realip.t b/tests/stream_ssl_realip.t
new file mode 100644
index 0000000..7de6625
--- /dev/null
+++ b/tests/stream_ssl_realip.t
@@ -0,0 +1,153 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for stream realip module, server side proxy protocol with ssl.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/ $CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx qw/ :DEFAULT http_end /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require IO::Socket::SSL; };
+plan(skip_all => 'IO::Socket::SSL not installed') if $@;
+eval { IO::Socket::SSL::SSL_VERIFY_NONE(); };
+plan(skip_all => 'IO::Socket::SSL too old') if $@;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_return stream_realip/)
+	->has(qw/stream_ssl/)->has_daemon('openssl')
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    ssl_certificate_key localhost.key;
+    ssl_certificate localhost.crt;
+
+    server {
+        listen      127.0.0.1:8083 proxy_protocol ssl;
+        return      $proxy_protocol_addr:$proxy_protocol_port;
+    }
+
+    server {
+        listen      127.0.0.1:8086 proxy_protocol ssl;
+        listen      [::1]:%%PORT_8086%% proxy_protocol ssl;
+        return      "$remote_addr:$remote_port:
+                     $realip_remote_addr:$realip_remote_port";
+
+        set_real_ip_from ::1;
+        set_real_ip_from 127.0.0.2;
+    }
+
+    server {
+        listen      127.0.0.1:8087;
+        proxy_pass  [::1]:%%PORT_8086%%;
+    }
+
+    server {
+        listen      127.0.0.1:8088 proxy_protocol ssl;
+        listen      [::1]:%%PORT_8088%% proxy_protocol ssl;
+        return      "$remote_addr:$remote_port:
+                     $realip_remote_addr:$realip_remote_port";
+
+        set_real_ip_from 127.0.0.1;
+        set_real_ip_from ::2;
+    }
+
+    server {
+        listen      127.0.0.1:8089;
+        proxy_pass  [::1]:%%PORT_8088%%;
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('localhost') {
+	system('openssl req -x509 -new '
+		. "-config $d/openssl.conf -subj /CN=$name/ "
+		. "-out $d/$name.crt -keyout $d/$name.key "
+		. ">>$d/openssl.out 2>&1") == 0
+		or die "Can't create certificate for $name: $!\n";
+}
+
+$t->try_run('no inet6 support')->plan(6);
+
+###############################################################################
+
+is(pp_get(8083, "PROXY TCP4 192.0.2.1 192.0.2.2 1234 5678${CRLF}"),
+	'192.0.2.1:1234', 'server');
+
+like(pp_get(8086, "PROXY TCP4 192.0.2.1 192.0.2.2 1234 5678${CRLF}"),
+	qr/^(\Q127.0.0.1:\E\d+):\s+\1$/, 'server ipv6 realip - no match');
+
+like(pp_get(8087, "PROXY TCP4 192.0.2.1 192.0.2.2 1234 5678${CRLF}"),
+	qr/\Q192.0.2.1:1234:\E\s+\Q::1:\E\d+/, 'server ipv6 realip');
+
+like(pp_get(8088, "PROXY TCP4 192.0.2.1 192.0.2.2 1234 5678${CRLF}"),
+	qr/\Q192.0.2.1:1234:\E\s+\Q127.0.0.1:\E\d+/, 'server ipv4 realip');
+
+like(pp_get(8089, "PROXY TCP4 192.0.2.1 192.0.2.2 1234 5678${CRLF}"),
+	qr/^(::1:\d+):\s+\1$/, 'server ipv4 realip - no match');
+
+like(pp_get(8088, "PROXY UNKNOWN TCP4 192.0.2.1 192.0.2.2 1234 5678${CRLF}"),
+	qr/^(\Q127.0.0.1:\E\d+):\s+\1$/, 'server unknown');
+
+###############################################################################
+
+sub pp_get {
+	my ($port, $proxy) = @_;
+
+	my $s = IO::Socket::INET->new('127.0.0.1:' . port($port)) or return;
+	http($proxy, start => 1, socket => $s);
+
+	eval {
+		local $SIG{ALRM} = sub { die "timeout\n" };
+		local $SIG{PIPE} = sub { die "sigpipe\n" };
+		alarm(8);
+		IO::Socket::SSL->start_SSL($s,
+			SSL_verify_mode => IO::Socket::SSL::SSL_VERIFY_NONE(),
+			SSL_error_trap => sub { die $_[1] }
+		);
+		alarm(0);
+	};
+	alarm(0);
+
+	if ($@) {
+		log_in("died: $@");
+		return undef;
+	}
+
+	http_end($s);
+}
+
+###############################################################################
diff --git a/tests/stream_ssl_variables.t b/tests/stream_ssl_variables.t
new file mode 100644
index 0000000..c86f78b
--- /dev/null
+++ b/tests/stream_ssl_variables.t
@@ -0,0 +1,145 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for stream ssl module with variables.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval {
+	require Net::SSLeay;
+	Net::SSLeay::load_error_strings();
+	Net::SSLeay::SSLeay_add_ssl_algorithms();
+	Net::SSLeay::randomize();
+};
+plan(skip_all => 'Net::SSLeay not installed') if $@;
+
+eval {
+	my $ctx = Net::SSLeay::CTX_new() or die;
+	my $ssl = Net::SSLeay::new($ctx) or die;
+	Net::SSLeay::set_tlsext_host_name($ssl, 'example.org') == 1 or die;
+};
+plan(skip_all => 'Net::SSLeay with OpenSSL SNI support required') if $@;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_ssl stream_return/)
+	->has_daemon('openssl');
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    ssl_certificate_key localhost.key;
+    ssl_certificate localhost.crt;
+    ssl_session_cache builtin;
+
+    server {
+        listen  127.0.0.1:8080;
+        listen  127.0.0.1:8081 ssl;
+        return  $ssl_session_reused:$ssl_session_id:$ssl_cipher:$ssl_protocol;
+    }
+
+    server {
+        listen  127.0.0.1:8082 ssl;
+        return  $ssl_server_name;
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('localhost') {
+	system('openssl req -x509 -new '
+		. "-config $d/openssl.conf -subj /CN=$name/ "
+		. "-out $d/$name.crt -keyout $d/$name.key "
+		. ">>$d/openssl.out 2>&1") == 0
+		or die "Can't create certificate for $name: $!\n";
+}
+
+$t->run()->plan(6);
+
+###############################################################################
+
+my ($s, $ssl);
+
+is(stream('127.0.0.1:' . port(8080))->read(), ':::', 'no ssl');
+
+($s, $ssl) = get_ssl_socket(port(8081));
+like(Net::SSLeay::read($ssl), qr/^\.:(\w{64})?:[\w-]+:(TLS|SSL)v(\d|\.)+$/,
+	'ssl variables');
+
+my $ses = Net::SSLeay::get_session($ssl);
+($s, $ssl) = get_ssl_socket(port(8081), $ses);
+like(Net::SSLeay::read($ssl), qr/^r:\w{64}:[\w-]+:(TLS|SSL)v(\d|\.)+$/,
+	'ssl variables - session reused');
+
+SKIP: {
+skip 'no sni', 3 unless $t->has_module('sni');
+
+($s, $ssl) = get_ssl_socket(port(8082), undef, 'example.com');
+is(Net::SSLeay::ssl_read_all($ssl), 'example.com', 'ssl server name');
+
+my $ses = Net::SSLeay::get_session($ssl);
+($s, $ssl) = get_ssl_socket(port(8082), $ses, 'example.com');
+is(Net::SSLeay::ssl_read_all($ssl), 'example.com', 'ssl server name - reused');
+
+($s, $ssl) = get_ssl_socket(port(8082));
+is(Net::SSLeay::ssl_read_all($ssl), '', 'ssl server name empty');
+
+}
+
+###############################################################################
+
+sub get_ssl_socket {
+	my ($port, $ses, $name) = @_;
+	my $s;
+
+	my $dest_ip = inet_aton('127.0.0.1');
+	my $dest_serv_params = sockaddr_in($port, $dest_ip);
+
+	socket($s, &AF_INET, &SOCK_STREAM, 0) or die "socket: $!";
+	connect($s, $dest_serv_params) or die "connect: $!";
+
+	my $ctx = Net::SSLeay::CTX_new() or die("Failed to create SSL_CTX $!");
+	my $ssl = Net::SSLeay::new($ctx) or die("Failed to create SSL $!");
+	Net::SSLeay::set_tlsext_host_name($ssl, $name) if defined $name;
+	Net::SSLeay::set_session($ssl, $ses) if defined $ses;
+	Net::SSLeay::set_fd($ssl, fileno($s));
+	Net::SSLeay::connect($ssl) or die("ssl connect");
+	return ($s, $ssl);
+}
+
+###############################################################################
diff --git a/tests/stream_ssl_verify_client.t b/tests/stream_ssl_verify_client.t
new file mode 100644
index 0000000..988fdc3
--- /dev/null
+++ b/tests/stream_ssl_verify_client.t
@@ -0,0 +1,169 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+
+# Tests for stream ssl module, ssl_verify_client.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval {
+	require Net::SSLeay;
+	Net::SSLeay::load_error_strings();
+	Net::SSLeay::SSLeay_add_ssl_algorithms();
+	Net::SSLeay::randomize();
+};
+plan(skip_all => 'Net::SSLeay not installed') if $@;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_ssl stream_return/)
+	->has_daemon('openssl');
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    log_format  status  $status;
+
+    ssl_certificate_key 1.example.com.key;
+    ssl_certificate 1.example.com.crt;
+
+    server {
+        listen  127.0.0.1:8080;
+        return  $ssl_client_verify:$ssl_client_cert;
+
+        ssl_verify_client on;
+        ssl_client_certificate 2.example.com.crt;
+    }
+
+    server {
+        listen  127.0.0.1:8081 ssl;
+        return  $ssl_client_verify:$ssl_client_cert;
+
+        ssl_verify_client on;
+        ssl_client_certificate 2.example.com.crt;
+
+        access_log %%TESTDIR%%/status.log status;
+    }
+
+    server {
+        listen  127.0.0.1:8082 ssl;
+        return  $ssl_client_verify:$ssl_client_cert;
+
+        ssl_verify_client optional;
+        ssl_client_certificate 2.example.com.crt;
+        ssl_trusted_certificate 3.example.com.crt;
+    }
+
+    server {
+        listen  127.0.0.1:8083 ssl;
+        return  $ssl_client_verify:$ssl_client_cert;
+
+        ssl_verify_client optional_no_ca;
+        ssl_client_certificate 2.example.com.crt;
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('1.example.com', '2.example.com', '3.example.com') {
+	system('openssl req -x509 -new '
+		. "-config $d/openssl.conf -subj /CN=$name/ "
+		. "-out $d/$name.crt -keyout $d/$name.key "
+		. ">>$d/openssl.out 2>&1") == 0
+		or die "Can't create certificate for $name: $!\n";
+}
+
+$t->run()->plan(10);
+
+###############################################################################
+
+is(stream('127.0.0.1:' . port(8080))->read(), ':', 'plain connection');
+
+is(get(8081), '', 'no cert');
+is(get(8082, '1.example.com'), '', 'bad optional cert');
+is(get(8082), 'NONE:', 'no optional cert');
+like(get(8083, '1.example.com'), qr/FAILED.*BEGIN/, 'bad optional_no_ca cert');
+
+like(get(8081, '2.example.com'), qr/SUCCESS.*BEGIN/, 'good cert');
+like(get(8082, '2.example.com'), qr/SUCCESS.*BEGIN/, 'good cert optional');
+like(get(8082, '3.example.com'), qr/SUCCESS.*BEGIN/, 'good cert trusted');
+
+SKIP: {
+skip 'Net::SSLeay version >= 1.36 required', 1 if $Net::SSLeay::VERSION < 1.36;
+
+my $ca = join ' ', get(8082, '3.example.com');
+is($ca, '/CN=2.example.com', 'no trusted sent');
+
+}
+
+$t->stop();
+
+is($t->read_file('status.log'), "500\n200\n", 'log');
+
+###############################################################################
+
+sub get {
+	my ($port, $cert) = @_;
+
+	my $dest_ip = inet_aton('127.0.0.1');
+	my $dest_serv_params = sockaddr_in(port($port), $dest_ip);
+
+	socket(my $s, &AF_INET, &SOCK_STREAM, 0) or die "socket: $!";
+	connect($s, $dest_serv_params) or die "connect: $!";
+
+	my $ctx = Net::SSLeay::CTX_new() or die("Failed to create SSL_CTX $!");
+	Net::SSLeay::set_cert_and_key($ctx, "$d/$cert.crt", "$d/$cert.key")
+		or die if $cert;
+	my $ssl = Net::SSLeay::new($ctx) or die("Failed to create SSL $!");
+	Net::SSLeay::set_fd($ssl, fileno($s));
+	Net::SSLeay::connect($ssl) or die("ssl connect");
+
+	my $buf = Net::SSLeay::read($ssl);
+	log_in($buf);
+	return $buf unless wantarray();
+
+	my $list = Net::SSLeay::get_client_CA_list($ssl);
+	my @names;
+	for my $i (0 .. Net::SSLeay::sk_X509_NAME_num($list) - 1) {
+		my $name = Net::SSLeay::sk_X509_NAME_value($list, $i);
+		push @names, Net::SSLeay::X509_NAME_oneline($name);
+	}
+	return @names;
+}
+
+###############################################################################
diff --git a/tests/stream_status_variable.t b/tests/stream_status_variable.t
new file mode 100644
index 0000000..10e3648
--- /dev/null
+++ b/tests/stream_status_variable.t
@@ -0,0 +1,108 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for stream status variable.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_return stream_access/)
+	->has(qw/stream_limit_conn/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    log_format  status  $status;
+
+    limit_conn_zone  $binary_remote_addr  zone=zone:1m;
+
+    server {
+        listen      127.0.0.1:8080;
+        return      SEE-THIS;
+        access_log  %%TESTDIR%%/200.log status;
+    }
+
+    server {
+        listen      127.0.0.1:8081;
+        return      SEE-THIS;
+        deny        all;
+        access_log  %%TESTDIR%%/403.log status;
+    }
+
+    server {
+        listen      127.0.0.1:8082;
+        proxy_pass  127.0.0.1:8083;
+        access_log  %%TESTDIR%%/502.log status;
+
+        proxy_connect_timeout 0;
+    }
+
+    server {
+        listen      127.0.0.1:8084;
+        proxy_pass  example.com:$remote_port;
+        access_log  %%TESTDIR%%/500.log status;
+    }
+
+    server {
+        listen      127.0.0.1:8085;
+        limit_conn  zone 1;
+        proxy_pass  127.0.0.1:8086;
+        access_log  %%TESTDIR%%/503.log status;
+    }
+
+    server {
+        listen      127.0.0.1:8086 proxy_protocol;
+        return      SEE-THIS;
+        access_log  %%TESTDIR%%/400.log status;
+    }
+}
+
+EOF
+
+$t->run()->plan(6);
+
+###############################################################################
+
+stream('127.0.0.1:' . port(8080))->read();
+stream('127.0.0.1:' . port(8081))->read();
+stream('127.0.0.1:' . port(8082))->read();
+stream('127.0.0.1:' . port(8084))->read();
+
+my $s = stream('127.0.0.1:' . port(8085));
+stream('127.0.0.1:' . port(8085))->read();
+$s->io('PROXY INVALID');
+
+$t->stop();
+
+is($t->read_file('200.log'), "200\n", 'stream status 200');
+is($t->read_file('400.log'), "400\n", 'stream status 400');
+is($t->read_file('403.log'), "403\n", 'stream status 403');
+is($t->read_file('500.log'), "500\n", 'stream status 500');
+is($t->read_file('502.log'), "502\n", 'stream status 502');
+is($t->read_file('503.log'), "503\n200\n", 'stream status 503');
+
+###############################################################################
diff --git a/tests/stream_tcp_nodelay.t b/tests/stream_tcp_nodelay.t
new file mode 100644
index 0000000..3b1dc23
--- /dev/null
+++ b/tests/stream_tcp_nodelay.t
@@ -0,0 +1,123 @@
+#!/usr/bin/perl
+
+# (C) Andrey Zelenkov
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Stream tests for tcp_nodelay.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use IO::Select;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream/);
+
+$t->plan(2)->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    proxy_buffer_size 1;
+    tcp_nodelay off;
+
+    server {
+        listen      127.0.0.1:8081;
+        proxy_pass  127.0.0.1:8080;
+    }
+
+    server {
+        tcp_nodelay on;
+        listen      127.0.0.1:8082;
+        proxy_pass  127.0.0.1:8080;
+    }
+}
+
+EOF
+
+$t->run_daemon(\&stream_daemon);
+$t->run()->waitforsocket('127.0.0.1:' . port(8080));
+
+###############################################################################
+
+my $str = '1234567890' x 10 . 'F';
+my $length = length($str);
+
+is(stream('127.0.0.1:' . port(8081))->io($str, length => $length), $str,
+	'tcp_nodelay off');
+is(stream('127.0.0.1:' . port(8082))->io($str, length => $length), $str,
+	'tcp_nodelay on');
+
+###############################################################################
+
+sub stream_daemon {
+	my $server = IO::Socket::INET->new(
+		Proto => 'tcp',
+		LocalAddr => '127.0.0.1:' . port(8080),
+		Listen => 5,
+		Reuse => 1
+	)
+		or die "Can't create listening socket: $!\n";
+
+	my $sel = IO::Select->new($server);
+
+	local $SIG{PIPE} = 'IGNORE';
+
+	while (my @ready = $sel->can_read) {
+		foreach my $fh (@ready) {
+			if ($server == $fh) {
+				my $new = $fh->accept;
+				$new->autoflush(1);
+				$sel->add($new);
+
+			} elsif (stream_handle_client($fh)) {
+				$sel->remove($fh);
+				$fh->close;
+			}
+		}
+	}
+}
+
+sub stream_handle_client {
+	my ($client) = @_;
+
+	log2c("(new connection $client)");
+
+	$client->sysread(my $buffer, 65536) or return 1;
+
+	log2i("$client $buffer");
+
+	my $close = $buffer =~ /F/;
+
+	log2o("$client $buffer");
+
+	$client->syswrite($buffer);
+
+	return $close;
+}
+
+sub log2i { Test::Nginx::log_core('|| <<', @_); }
+sub log2o { Test::Nginx::log_core('|| >>', @_); }
+sub log2c { Test::Nginx::log_core('||', @_); }
+
+###############################################################################
diff --git a/tests/stream_udp_limit_conn.t b/tests/stream_udp_limit_conn.t
new file mode 100644
index 0000000..977fb4e
--- /dev/null
+++ b/tests/stream_udp_limit_conn.t
@@ -0,0 +1,135 @@
+#!/usr/bin/perl
+
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+
+# Tests for stream limit_conn module with datagrams.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ dgram /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_limit_conn udp/)->plan(9)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    limit_conn_zone  $binary_remote_addr  zone=zone:1m;
+    limit_conn_zone  $binary_remote_addr  zone=zone2:1m;
+
+    proxy_responses  1;
+    proxy_timeout    1s;
+
+    server {
+        listen           127.0.0.1:%%PORT_8981_UDP%% udp;
+        proxy_pass       127.0.0.1:%%PORT_8980_UDP%%;
+
+        limit_conn       zone 1;
+        proxy_responses  2;
+    }
+
+    server {
+        listen           127.0.0.1:%%PORT_8982_UDP%% udp;
+        proxy_pass       127.0.0.1:%%PORT_8980_UDP%%;
+        limit_conn       zone2 1;
+    }
+
+    server {
+        listen           127.0.0.1:%%PORT_8983_UDP%% udp;
+        proxy_pass       127.0.0.1:%%PORT_8980_UDP%%;
+        limit_conn       zone 5;
+    }
+
+    server {
+        listen           127.0.0.1:%%PORT_8984_UDP%% udp;
+        proxy_pass       127.0.0.1:%%PORT_8981_UDP%%;
+        limit_conn       zone2 1;
+    }
+
+    server {
+        listen           127.0.0.1:%%PORT_8985_UDP%% udp;
+        proxy_pass       127.0.0.1:%%PORT_8981_UDP%%;
+        limit_conn       zone 1;
+    }
+}
+
+EOF
+
+$t->run();
+$t->run_daemon(\&udp_daemon, $t);
+$t->waitforfile($t->testdir . '/' . port(8980));
+
+###############################################################################
+
+# same and other zones
+
+my $s = dgram('127.0.0.1:' . port(8981));
+
+is($s->io('1'), '1', 'passed');
+
+# regardless of incomplete responses, new requests in the same
+# socket will be treated as requests in existing session
+
+is($s->io('1', read_timeout => 0.4), '1', 'passed new request');
+
+is(dgram('127.0.0.1:' . port(8981))->io('1', read_timeout => 0.1), '',
+	'rejected new session');
+is(dgram('127.0.0.1:' . port(8982))->io('1'), '1', 'passed different zone');
+is(dgram('127.0.0.1:' . port(8983))->io('1'), '1', 'passed same zone unlimited');
+
+sleep 1;	# waiting for proxy_timeout to expire
+
+is($s->io('2', read => 2), '12', 'new session after proxy_timeout');
+
+is(dgram('127.0.0.1:' . port(8981))->io('2', read => 2), '12', 'passed 2');
+
+# zones proxy chain
+
+is(dgram('127.0.0.1:' . port(8984))->io('1'), '1', 'passed proxy');
+is(dgram('127.0.0.1:' . port(8985))->io('1', read_timeout => 0.1), '',
+	'rejected proxy');
+
+###############################################################################
+
+sub udp_daemon {
+	my $t = shift;
+
+	my $server = IO::Socket::INET->new(
+		Proto => 'udp',
+		LocalAddr => '127.0.0.1:' . port(8980),
+		Reuse => 1,
+	)
+		or die "Can't create listening socket: $!\n";
+
+	# signal we are ready
+
+	open my $fh, '>', $t->testdir() . '/' . port(8980);
+	close $fh;
+
+	while (1) {
+		$server->recv(my $buffer, 65536);
+		$server->send($_) for (1 .. $buffer);
+	}
+}
+
+###############################################################################
diff --git a/tests/stream_udp_limit_rate.t b/tests/stream_udp_limit_rate.t
new file mode 100644
index 0000000..fc848c5
--- /dev/null
+++ b/tests/stream_udp_limit_rate.t
@@ -0,0 +1,123 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for stream proxy module with datagrams, limit rate directives.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ dgram /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream udp/)->plan(8)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    proxy_requests           2;
+    proxy_responses          1;
+    proxy_timeout            3s;
+
+    server {
+        listen               127.0.0.1:%%PORT_8982_UDP%% udp;
+        proxy_pass           127.0.0.1:%%PORT_8980_UDP%%;
+    }
+
+    server {
+        listen               127.0.0.1:%%PORT_8983_UDP%% udp;
+        proxy_pass           127.0.0.1:%%PORT_8980_UDP%%;
+        proxy_download_rate  500;
+    }
+
+    server {
+        listen               127.0.0.1:%%PORT_8984_UDP%% udp;
+        proxy_pass           127.0.0.1:%%PORT_8980_UDP%%;
+        proxy_upload_rate    500;
+    }
+}
+
+EOF
+
+$t->run_daemon(\&udp_daemon, port(8980), $t);
+$t->run();
+
+$t->waitforfile($t->testdir . '/' . port(8980));
+
+###############################################################################
+
+my $str = '1234567890' x 100;
+
+# unlimited
+
+my $s = dgram('127.0.0.1:' . port(8982));
+is($s->io($str), $str, 'unlimited');
+is($s->io($str), $str, 'unlimited 2');
+
+# datagram doesn't get split
+
+$s = dgram('127.0.0.1:' . port(8983));
+is($s->io($str), $str, 'download');
+my $t1 = time();
+is($s->io($str), $str, 'download 2');
+my $t2 = time();
+cmp_ok($t1, '<', $t2, 'download 2 delayed');
+
+# infinite event report before 1.15.9
+
+$s = dgram('127.0.0.1:' . port(8984));
+is($s->io($str), $str, 'upload');
+is($s->io($str, read_timeout => 0.5), '', 'upload limited');
+
+select undef, undef, undef, 1.6;
+is($s->io($str), $str, 'upload passed');
+
+###############################################################################
+
+sub udp_daemon {
+	my ($port, $t) = @_;
+
+	my $server = IO::Socket::INET->new(
+		Proto => 'udp',
+		LocalAddr => "127.0.0.1:$port",
+	)
+		or die "Can't create listening socket: $!\n";
+
+	# signal we are ready
+
+	open my $fh, '>', $t->testdir() . "/$port";
+	close $fh;
+
+	while (1) {
+		$server->recv(my $buffer, 65536);
+		log2i("$server $buffer");
+
+		log2o("$server $buffer");
+		$server->send($buffer);
+	}
+}
+
+sub log2i { Test::Nginx::log_core('|| <<', @_); }
+sub log2o { Test::Nginx::log_core('|| >>', @_); }
+sub log2c { Test::Nginx::log_core('||', @_); }
+
+###############################################################################
diff --git a/tests/stream_udp_proxy.t b/tests/stream_udp_proxy.t
new file mode 100644
index 0000000..fb0ac79
--- /dev/null
+++ b/tests/stream_udp_proxy.t
@@ -0,0 +1,101 @@
+#!/usr/bin/perl
+
+# (C) Nginx, Inc.
+
+# Tests for stream proxy module with datagrams.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ dgram /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream udp/)->plan(4)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    proxy_timeout        1s;
+
+    server {
+        listen           127.0.0.1:%%PORT_8980_UDP%% udp;
+        proxy_pass       127.0.0.1:%%PORT_8981_UDP%%;
+
+        proxy_responses  0;
+    }
+
+    server {
+        listen           127.0.0.1:%%PORT_8982_UDP%% udp;
+        proxy_pass       127.0.0.1:%%PORT_8981_UDP%%;
+
+        proxy_responses  2;
+    }
+
+    server {
+        listen           127.0.0.1:%%PORT_8983_UDP%% udp;
+        proxy_pass       127.0.0.1:%%PORT_8981_UDP%%;
+    }
+}
+
+EOF
+
+
+$t->run_daemon(\&udp_daemon, port(8981), $t);
+$t->run();
+$t->waitforfile($t->testdir . '/' . port(8981));
+
+###############################################################################
+
+my $s = dgram('127.0.0.1:' . port(8980));
+is($s->io('1', read => 1, read_timeout => 0.5), '', 'proxy responses 0');
+
+$s = dgram('127.0.0.1:' . port(8982));
+is($s->io('1'), '1', 'proxy responses 1');
+$s = dgram('127.0.0.1:' . port(8982));
+is($s->io('2', read => 2), '12', 'proxy responses 2');
+
+$s = dgram('127.0.0.1:' . port(8983));
+is($s->io('3', read => 3), '123', 'proxy responses default');
+
+###############################################################################
+
+sub udp_daemon {
+	my ($port, $t) = @_;
+
+	my $server = IO::Socket::INET->new(
+		Proto => 'udp',
+		LocalAddr => '127.0.0.1:' . port(8981),
+		Reuse => 1,
+	)
+		or die "Can't create listening socket: $!\n";
+
+	# signal we are ready
+
+	open my $fh, '>', $t->testdir() . '/' . port(8981);
+	close $fh;
+
+	while (1) {
+		$server->recv(my $buffer, 65536);
+		$server->send($_) for (1 .. $buffer);
+	}
+}
+
+###############################################################################
diff --git a/tests/stream_udp_proxy_requests.t b/tests/stream_udp_proxy_requests.t
new file mode 100644
index 0000000..315ae5b
--- /dev/null
+++ b/tests/stream_udp_proxy_requests.t
@@ -0,0 +1,212 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for stream proxy module, the proxy_requests directive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ dgram /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream udp/)->plan(26)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    proxy_timeout  2100ms;
+
+    log_format status $status;
+
+    server {
+        listen           127.0.0.1:%%PORT_8980_UDP%% udp;
+        proxy_pass       127.0.0.1:%%PORT_8990_UDP%%;
+
+        proxy_requests   0;
+    }
+
+    server {
+        listen           127.0.0.1:%%PORT_8981_UDP%% udp;
+        proxy_pass       127.0.0.1:%%PORT_8990_UDP%%;
+
+        proxy_requests   1;
+    }
+
+    server {
+        listen           127.0.0.1:%%PORT_8982_UDP%% udp;
+        proxy_pass       127.0.0.1:%%PORT_8990_UDP%%;
+
+        proxy_requests   2;
+    }
+
+    server {
+        listen           127.0.0.1:%%PORT_8983_UDP%% udp;
+        proxy_pass       127.0.0.1:%%PORT_8990_UDP%%;
+    }
+
+    server {
+        listen           127.0.0.1:%%PORT_8984_UDP%% udp;
+        proxy_pass       127.0.0.1:%%PORT_8991_UDP%%;
+
+        proxy_requests   2;
+        access_log       %%TESTDIR%%/s.log status;
+    }
+
+    server {
+        listen           127.0.0.1:%%PORT_8985_UDP%% udp;
+        proxy_pass       127.0.0.1:%%PORT_8990_UDP%%;
+
+        proxy_requests   2;
+        proxy_responses  2;
+        access_log       %%TESTDIR%%/s2.log status;
+    }
+}
+
+EOF
+
+
+$t->run_daemon(\&udp_daemon, $t, port(8990));
+$t->run_daemon(\&udp_daemon, $t, port(8991));
+$t->run();
+
+$t->waitforfile($t->testdir . '/' . port(8990));
+$t->waitforfile($t->testdir . '/' . port(8991));
+
+###############################################################################
+
+# proxy_requests 0, binding is not dropped across streams
+
+my $s = dgram('127.0.0.1:' . port(8980));
+my $n = $s->io('1', read => 1);
+ok($n, 'requests 0 create');
+is($s->read(), '1', 'requests 0 create - response');
+
+is($s->io('1', read => 1), $n, 'requests 0 second - binding saved');
+is($s->read(), '1', 'requests 0 second - response');
+
+is($s->io('1', read => 1), $n, 'requests 0 follow - binding saved');
+is($s->read(), '1', 'requests 0 follow - response');
+
+# proxy_requests 1, binding is dropped on every next stream
+
+$s = dgram('127.0.0.1:' . port(8981));
+$n = $s->io('1', read => 1);
+ok($n, 'requests 1 create');
+is($s->read(), '1', 'requests 1 create - response');
+
+isnt($s->io('1', read => 1), $n, 'requests 1 second - binding lost');
+is($s->read(), '1', 'requests 1 second - response');
+
+# proxy_requests 2, binding is dropped on every second stream
+
+$s = dgram('127.0.0.1:' . port(8982));
+$n = $s->io('1', read => 1);
+ok($n, 'requests 2 create');
+is($s->read(), '1', 'requests 2 create - response');
+
+is($s->io('1', read => 1), $n, 'requests 2 second - binding saved');
+is($s->read(), '1', 'requests 2 second - response');
+
+isnt($s->io('1', read => 1), $n, 'requests 2 follow - binding lost');
+is($s->read(), '1', 'requests 2 follow - response');
+
+# proxy_requests unset, binding is not dropped across streams
+
+$s = dgram('127.0.0.1:' . port(8983));
+$n = $s->io('1', read => 1);
+ok($n, 'requests unset create');
+is($s->read(), '1', 'requests unset create - response');
+
+is($s->io('1', read => 1), $n, 'requests unset second - binding saved');
+is($s->read(), '1', 'requests unset second - response');
+
+is($s->io('1', read => 1), $n, 'requests unset follow - binding saved');
+is($s->read(), '1', 'requests unset follow - response');
+
+# proxy_requests 2, with slow backend
+# client sends 5 packets, each responded with 3 packets
+# expects all packets proxied from backend, the last (uneven) session succeed
+
+$s = dgram('127.0.0.1:' . port(8984));
+$s->write('2') for 1 .. 5;
+my $b = join ' ', map { $s->read() } (1 .. 15);
+like($b, qr/^(\d+ 1 2) \1 (?!\1)(\d+ 1 2) \2 (?!\2)\d+ 1 2$/, 'slow backend');
+
+# proxy_requests 2, proxy_responses 2
+# client sends 5 packets, each responded with 2 packets
+# expects all packets proxied from backend, the last (uneven) session succeed
+
+$s = dgram('127.0.0.1:' . port(8985));
+$s->write('1') for 1 .. 5;
+$b = join ' ', map { $s->read() } (1 .. 10);
+
+SKIP: {
+skip 'session could early terminate', 1 unless $ENV{TEST_NGINX_UNSAFE};
+
+like($b, qr/^(\d+ 1) \1 (?!\1)(\d+ 1) \2 (?!\2)\d+ 1$/, 'requests - responses');
+
+}
+
+$t->stop();
+
+is($t->read_file('s.log'), <<EOF, 'uneven session status - slow backend');
+200
+200
+200
+EOF
+
+is($t->read_file('s2.log'), <<EOF, 'uneven session status - responses');
+200
+200
+200
+EOF
+
+###############################################################################
+
+sub udp_daemon {
+	my ($t, $port) = @_;
+
+	my $server = IO::Socket::INET->new(
+		Proto => 'udp',
+		LocalAddr => "127.0.0.1:$port",
+		Reuse => 1
+	)
+		or die "Can't create listening socket: $!\n";
+
+	# signal we are ready
+
+	open my $fh, '>', $t->testdir() . "/$port";
+	close $fh;
+
+	my $slp = 1 if $port == port(8991);
+
+	while (1) {
+		$server->recv(my $buffer, 65536);
+		sleep 1, $slp = 0 if $slp;
+
+		$server->send($server->peerport());
+		$server->send($_) for (1 .. $buffer);
+	}
+}
+
+###############################################################################
diff --git a/tests/stream_udp_stream.t b/tests/stream_udp_stream.t
new file mode 100644
index 0000000..5721081
--- /dev/null
+++ b/tests/stream_udp_stream.t
@@ -0,0 +1,75 @@
+#!/usr/bin/perl
+
+# (C) Nginx, Inc.
+
+# Tests for UDP stream.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ dgram /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_return udp/)->plan(8)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    proxy_timeout   1s;
+
+    server {
+        listen      127.0.0.1:%%PORT_8980_UDP%% udp;
+        proxy_pass  127.0.0.1:%%PORT_8981_UDP%%;
+    }
+
+    server {
+        listen      127.0.0.1:%%PORT_8981_UDP%% udp;
+        return      $remote_port;
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+my $s = dgram('127.0.0.1:' . port(8980));
+my $data = $s->io('1', read_timeout => 0.5);
+isnt($data, '', 'udp_stream response 1');
+
+my $s2 = dgram('127.0.0.1:' . port(8980));
+my $data2 = $s2->io('1', read_timeout => 0.5);
+isnt($data2, '', 'udp_stream response 2');
+
+isnt($data, $data2, 'udp_stream two sessions');
+
+is($s->io('1'), $data, 'udp_stream session 1');
+is($s->io('1'), $data, 'udp_stream session 2');
+
+is($s2->io('1'), $data2, 'udp_stream another session 1');
+is($s2->io('1'), $data2, 'udp_stream another session 2');
+
+select undef, undef, undef, 1.1;
+
+isnt($s->io('1'), $data, 'udp_stream new session');
+
+###############################################################################
diff --git a/tests/stream_udp_upstream.t b/tests/stream_udp_upstream.t
new file mode 100644
index 0000000..6fe81b4
--- /dev/null
+++ b/tests/stream_udp_upstream.t
@@ -0,0 +1,147 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Stream tests for upstream module and balancers with datagrams.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ dgram /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream udp/)->plan(5)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    proxy_responses      1;
+    proxy_timeout        1s;
+
+    upstream u {
+        server 127.0.0.1:%%PORT_8984_UDP%%;
+        server 127.0.0.1:%%PORT_8985_UDP%%;
+    }
+
+    upstream u2 {
+        server 127.0.0.1:%%PORT_8986_UDP%% down;
+        server 127.0.0.1:%%PORT_8986_UDP%%;
+        server 127.0.0.1:%%PORT_8984_UDP%%;
+        server 127.0.0.1:%%PORT_8985_UDP%%;
+    }
+
+    upstream u3 {
+        server 127.0.0.1:%%PORT_8984_UDP%%;
+        server 127.0.0.1:%%PORT_8985_UDP%% weight=2;
+    }
+
+    upstream u4 {
+        server 127.0.0.1:%%PORT_8986_UDP%% down;
+        server 127.0.0.1:%%PORT_8984_UDP%% backup;
+    }
+
+    server {
+        listen      127.0.0.1:%%PORT_8980_UDP%% udp;
+        proxy_pass  u;
+    }
+
+    server {
+        listen      127.0.0.1:%%PORT_8981_UDP%% udp;
+        proxy_pass  u2;
+    }
+
+    server {
+        listen      127.0.0.1:%%PORT_8982_UDP%% udp;
+        proxy_pass  u3;
+    }
+
+    server {
+        listen      127.0.0.1:%%PORT_8983_UDP%% udp;
+        proxy_pass  u4;
+    }
+}
+
+EOF
+
+$t->run_daemon(\&udp_daemon, port(8984), $t);
+$t->run_daemon(\&udp_daemon, port(8985), $t);
+$t->run();
+
+$t->waitforfile($t->testdir . '/' . port(8984));
+$t->waitforfile($t->testdir . '/' . port(8985));
+
+###############################################################################
+
+my @ports = my ($port4, $port5) = (port(8984), port(8985));
+
+is(many(10, port(8980)), "$port4: 5, $port5: 5", 'balanced');
+
+is(dgram('127.0.0.1:' . port(8981))->io('.', read_timeout => 0.5), '',
+	'no next upstream for dgram');
+
+is(many(10, port(8981)), "$port4: 5, $port5: 5", 'failures');
+
+is(many(9, port(8982)), "$port4: 3, $port5: 6", 'weight');
+is(many(10, port(8983)), "$port4: 10", 'backup');
+
+###############################################################################
+
+sub many {
+	my ($count, $port) = @_;
+	my (%ports);
+
+	for (1 .. $count) {
+		if (dgram("127.0.0.1:$port")->io('.') =~ /(\d+)/) {
+			$ports{$1} = 0 unless defined $ports{$1};
+			$ports{$1}++;
+		}
+	}
+
+	my @keys = map { my $p = $_; grep { $p == $_ } keys %ports } @ports;
+	return join ', ', map { $_ . ": " . $ports{$_} } @keys;
+}
+
+###############################################################################
+
+sub udp_daemon {
+	my ($port, $t) = @_;
+
+	my $server = IO::Socket::INET->new(
+		Proto => 'udp',
+		LocalAddr => '127.0.0.1:' . $port,
+		Reuse => 1,
+	)
+		or die "Can't create listening socket: $!\n";
+
+	# signal we are ready
+
+	open my $fh, '>', $t->testdir() . '/' . $port;
+	close $fh;
+
+	while (1) {
+		$server->recv(my $buffer, 65536);
+		$buffer = $server->sockport();
+		$server->send($buffer);
+	}
+}
+
+###############################################################################
diff --git a/tests/stream_udp_upstream_hash.t b/tests/stream_udp_upstream_hash.t
new file mode 100644
index 0000000..9b47021
--- /dev/null
+++ b/tests/stream_udp_upstream_hash.t
@@ -0,0 +1,121 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Stream tests for upstream hash balancer module with datagrams.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ dgram /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_upstream_hash udp/)->plan(2);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    proxy_responses      1;
+    proxy_timeout        1s;
+
+    upstream hash {
+        hash $remote_addr;
+        server 127.0.0.1:%%PORT_8982_UDP%%;
+        server 127.0.0.1:%%PORT_8983_UDP%%;
+    }
+
+    upstream cons {
+        hash $remote_addr consistent;
+        server 127.0.0.1:%%PORT_8982_UDP%%;
+        server 127.0.0.1:%%PORT_8983_UDP%%;
+    }
+
+    server {
+        listen      127.0.0.1:%%PORT_8980_UDP%% udp;
+        proxy_pass  hash;
+    }
+
+    server {
+        listen      127.0.0.1:%%PORT_8981_UDP%% udp;
+        proxy_pass  cons;
+    }
+}
+
+EOF
+
+$t->run_daemon(\&udp_daemon, port(8982), $t);
+$t->run_daemon(\&udp_daemon, port(8983), $t);
+$t->run();
+
+$t->waitforfile($t->testdir . '/' . port(8982));
+$t->waitforfile($t->testdir . '/' . port(8983));
+
+###############################################################################
+
+my @ports = my ($port2, $port3) = (port(8982), port(8983));
+
+is(many(10, port(8980)), "$port3: 10", 'hash');
+like(many(10, port(8981)), qr/($port2|$port3): 10/, 'hash consistent');
+
+###############################################################################
+
+sub many {
+	my ($count, $port) = @_;
+	my (%ports);
+
+	for (1 .. $count) {
+		if (dgram("127.0.0.1:$port")->io('.') =~ /(\d+)/) {
+			$ports{$1} = 0 unless defined $ports{$1};
+			$ports{$1}++;
+		}
+	}
+
+	my @keys = map { my $p = $_; grep { $p == $_ } keys %ports } @ports;
+	return join ', ', map { $_ . ": " . $ports{$_} } @keys;
+}
+
+###############################################################################
+
+sub udp_daemon {
+	my ($port, $t) = @_;
+
+	my $server = IO::Socket::INET->new(
+		Proto => 'udp',
+		LocalAddr => '127.0.0.1:' . $port,
+		Reuse => 1,
+	)
+		or die "Can't create listening socket: $!\n";
+
+	# signal we are ready
+
+	open my $fh, '>', $t->testdir() . '/' . $port;
+	close $fh;
+
+	while (1) {
+		$server->recv(my $buffer, 65536);
+		$buffer = $server->sockport();
+		$server->send($buffer);
+	}
+}
+
+###############################################################################
diff --git a/tests/stream_udp_upstream_least_conn.t b/tests/stream_udp_upstream_least_conn.t
new file mode 100644
index 0000000..87acabe
--- /dev/null
+++ b/tests/stream_udp_upstream_least_conn.t
@@ -0,0 +1,127 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Stream tests for upstream least_conn balancer module with datagrams.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ dgram /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_upstream_least_conn udp/)
+	->plan(2)->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    proxy_responses      1;
+    proxy_timeout        1s;
+
+    upstream u {
+        least_conn;
+        server 127.0.0.1:%%PORT_8981_UDP%%;
+        server 127.0.0.1:%%PORT_8982_UDP%%;
+    }
+
+    server {
+        listen      127.0.0.1:%%PORT_8980_UDP%% udp;
+        proxy_pass  u;
+    }
+}
+
+EOF
+
+$t->run_daemon(\&udp_daemon, port(8981), $t);
+$t->run_daemon(\&udp_daemon, port(8982), $t);
+$t->run();
+
+$t->waitforfile($t->testdir . '/' . port(8981));
+$t->waitforfile($t->testdir . '/' . port(8982));
+
+###############################################################################
+
+my @ports = my ($port1, $port2) = (port(8981), port(8982));
+
+is(many(10), "$port1: 5, $port2: 5", 'balanced');
+
+my @sockets;
+for (1 .. 2) {
+	my $s = dgram('127.0.0.1:' . port(8980));
+	$s->write('w');
+	push @sockets, $s;
+}
+
+select undef, undef, undef, 0.2;
+
+is(many(10), "$port2: 10", 'least_conn');
+
+###############################################################################
+
+sub many {
+	my ($count) = @_;
+	my (%ports);
+
+	for (1 .. $count) {
+		if (dgram('127.0.0.1:' . port(8980))->io('.') =~ /(\d+)/) {
+			$ports{$1} = 0 unless defined $ports{$1};
+			$ports{$1}++;
+		}
+	}
+
+	my @keys = map { my $p = $_; grep { $p == $_ } keys %ports } @ports;
+	return join ', ', map { $_ . ": " . $ports{$_} } @keys;
+}
+
+###############################################################################
+
+sub udp_daemon {
+	my ($port, $t) = @_;
+
+	my $server = IO::Socket::INET->new(
+		Proto => 'udp',
+		LocalAddr => '127.0.0.1:' . $port,
+		Reuse => 1,
+	)
+		or die "Can't create listening socket: $!\n";
+
+	# signal we are ready
+
+	open my $fh, '>', $t->testdir() . '/' . $port;
+	close $fh;
+
+	while (1) {
+		$server->recv(my $buffer, 65536);
+
+		my $port = $server->sockport();
+
+		if ($buffer =~ /w/ && $port == port(8981)) {
+			select undef, undef, undef, 2.5;
+		}
+
+		$buffer = $port;
+
+		$server->send($buffer);
+	}
+}
+
+###############################################################################
diff --git a/tests/stream_udp_wildcard.t b/tests/stream_udp_wildcard.t
new file mode 100644
index 0000000..202d9d8
--- /dev/null
+++ b/tests/stream_udp_wildcard.t
@@ -0,0 +1,62 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for stream proxy module with datagrams, source address selection.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ dgram /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+plan(skip_all => '127.0.0.2 local address required')
+	unless defined IO::Socket::INET->new( LocalAddr => '127.0.0.2' );
+
+plan(skip_all => 'listen on wildcard address')
+	unless $ENV{TEST_NGINX_UNSAFE};
+
+my $t = Test::Nginx->new()->has(qw/stream stream_return udp/)->plan(1)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    server {
+        listen  %%PORT_8999_UDP%% udp;
+        return  $server_addr;
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+my $s = dgram(
+	LocalAddr => '127.0.0.1',
+	PeerAddr  => '127.0.0.2:' . port(8999)
+);
+
+is($s->io('test'), '127.0.0.2', 'stream udp wildcard');
+
+###############################################################################
diff --git a/tests/stream_unix.t b/tests/stream_unix.t
new file mode 100644
index 0000000..500e039
--- /dev/null
+++ b/tests/stream_unix.t
@@ -0,0 +1,111 @@
+#!/usr/bin/perl
+
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+
+# Simple tests for stream with unix socket.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require IO::Socket::UNIX; };
+plan(skip_all => 'IO::Socket::UNIX not installed') if $@;
+
+my $t = Test::Nginx->new()->has(qw/stream unix/)->plan(2);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    upstream u {
+        server unix:%%TESTDIR%%/unix.sock;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        proxy_pass   unix:%%TESTDIR%%/unix.sock;
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        proxy_pass   u;
+    }
+}
+
+EOF
+
+my $path = $t->testdir() . '/unix.sock';
+
+$t->run_daemon(\&stream_daemon, $path);
+$t->run();
+
+# wait for unix socket to appear
+
+for (1 .. 50) {
+	last if -S $path;
+	select undef, undef, undef, 0.1;
+}
+
+###############################################################################
+
+my $str = 'SEE-THIS';
+
+is(stream('127.0.0.1:' . port(8080))->io($str), $str, 'proxy');
+is(stream('127.0.0.1:' . port(8081))->io($str), $str, 'upstream');
+
+###############################################################################
+
+sub stream_daemon {
+	my $server = IO::Socket::UNIX->new(
+		Proto => 'tcp',
+		Local => shift,
+		Listen => 5,
+		Reuse => 1
+	)
+		or die "Can't create listening socket: $!\n";
+
+	local $SIG{PIPE} = 'IGNORE';
+
+	while (my $client = $server->accept()) {
+		$client->autoflush(1);
+
+		log2c("(new connection $client)");
+
+		$client->sysread(my $buffer, 65536) or next;
+
+		log2i("$client $buffer");
+
+		log2o("$client $buffer");
+
+		$client->syswrite($buffer);
+
+		close $client;
+	}
+}
+
+sub log2i { Test::Nginx::log_core('|| <<', @_); }
+sub log2o { Test::Nginx::log_core('|| >>', @_); }
+sub log2c { Test::Nginx::log_core('||', @_); }
+
+###############################################################################
diff --git a/tests/stream_upstream.t b/tests/stream_upstream.t
new file mode 100644
index 0000000..37c95b0
--- /dev/null
+++ b/tests/stream_upstream.t
@@ -0,0 +1,212 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Stream tests for upstream module and balancers.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use IO::Select;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream/)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    log_format bytes $upstream_addr!
+                     $upstream_bytes_sent!$upstream_bytes_received;
+
+    upstream u {
+        server 127.0.0.1:8084;
+        server 127.0.0.1:8085;
+    }
+
+    upstream u2 {
+        server 127.0.0.1:8086 down;
+        server 127.0.0.1:8086;
+        server 127.0.0.1:8084;
+        server 127.0.0.1:8085;
+    }
+
+    upstream u3 {
+        server 127.0.0.1:8084;
+        server 127.0.0.1:8085 weight=2;
+    }
+
+    upstream u4 {
+        server 127.0.0.1:8086 fail_timeout=1s;
+        server 127.0.0.1:8084 backup;
+    }
+
+    proxy_connect_timeout 2;
+
+    server {
+        listen      127.0.0.1:8080;
+        proxy_pass  u;
+    }
+
+    server {
+        listen      127.0.0.1:8081;
+        proxy_pass  u2;
+    }
+
+    server {
+        listen      127.0.0.1:8082;
+        proxy_pass  u3;
+    }
+
+    server {
+        listen      127.0.0.1:8083;
+        proxy_pass  u4;
+        access_log  %%TESTDIR%%/u.log bytes;
+    }
+}
+
+EOF
+
+$t->run_daemon(\&stream_daemon, port(8084));
+$t->run_daemon(\&stream_daemon, port(8085));
+$t->run()->plan(6);
+
+$t->waitforsocket('127.0.0.1:' . port(8084));
+$t->waitforsocket('127.0.0.1:' . port(8085));
+
+###############################################################################
+
+my @ports = my ($port4, $port5, $port6) = (port(8084), port(8085), port(8086));
+
+is(many(30, port(8080)), "$port4: 15, $port5: 15", 'balanced');
+is(many(30, port(8081)), "$port4: 15, $port5: 15", 'failures');
+is(many(30, port(8082)), "$port4: 10, $port5: 20", 'weight');
+is(many(30, port(8083)), "$port4: 30", 'backup');
+
+$t->run_daemon(\&stream_daemon, port(8086));
+$t->waitforsocket('127.0.0.1:' . port(8086));
+
+sleep 2;	# wait till fail_timeout passes
+is(parallel(30, port(8083)), "$port6: 30", 'recovery');
+
+$t->stop();
+
+like($t->read_file('u.log'), qr/127.0.0.1:$port6, 127.0.0.1:$port4!0, 1!0, 4/,
+	'per-upstream variables');
+
+###############################################################################
+
+sub many {
+	my ($count, $port) = @_;
+	my (%ports);
+
+	for (1 .. $count) {
+		if (stream("127.0.0.1:$port")->io('.') =~ /(\d+)/) {
+			$ports{$1} = 0 unless defined $ports{$1};
+			$ports{$1}++;
+		}
+	}
+
+	my @keys = map { my $p = $_; grep { $p == $_ } keys %ports } @ports;
+	return join ', ', map { $_ . ": " . $ports{$_} } @keys;
+}
+
+sub parallel {
+	my ($count, $port) = @_;
+	my (%ports, @s);
+
+	for (1 .. $count) {
+		my $s = stream("127.0.0.1:$port");
+		$s->write('keep');
+		$s->read();
+		push @s, $s;
+	}
+
+	for (1 .. $count) {
+		if ((pop @s)->io('.') =~ /(\d+)/) {
+			$ports{$1} = 0 unless defined $ports{$1};
+			$ports{$1}++;
+		}
+	}
+
+	my @keys = map { my $p = $_; grep { $p == $_ } keys %ports } @ports;
+	return join ', ', map { $_ . ": " . $ports{$_} } @keys;
+}
+
+###############################################################################
+
+sub stream_daemon {
+	my ($port) = @_;
+
+	my $server = IO::Socket::INET->new(
+		Proto => 'tcp',
+		LocalAddr => '127.0.0.1',
+		LocalPort => $port,
+		Listen => 5,
+		Reuse => 1
+	)
+		or die "Can't create listening socket: $!\n";
+
+	my $sel = IO::Select->new($server);
+
+	local $SIG{PIPE} = 'IGNORE';
+
+	while (my @ready = $sel->can_read) {
+		foreach my $fh (@ready) {
+			if ($server == $fh) {
+				my $new = $fh->accept;
+				$new->autoflush(1);
+				$sel->add($new);
+
+			} elsif (stream_handle_client($fh)) {
+				$sel->remove($fh);
+				$fh->close;
+			}
+		}
+	}
+}
+
+sub stream_handle_client {
+	my ($client) = @_;
+
+	log2c("(new connection $client)");
+
+	$client->sysread(my $buffer, 65536) or return 1;
+
+	log2i("$client $buffer");
+
+	my $close = $buffer ne 'keep';
+	$buffer = $client->sockport();
+
+	log2o("$client $buffer");
+
+	$client->syswrite($buffer);
+
+	return $close;
+}
+
+sub log2i { Test::Nginx::log_core('|| <<', @_); }
+sub log2o { Test::Nginx::log_core('|| >>', @_); }
+sub log2c { Test::Nginx::log_core('||', @_); }
+
+###############################################################################
diff --git a/tests/stream_upstream_hash.t b/tests/stream_upstream_hash.t
new file mode 100644
index 0000000..e28925e
--- /dev/null
+++ b/tests/stream_upstream_hash.t
@@ -0,0 +1,183 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Stream tests for upstream hash balancer module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use IO::Select;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_upstream_hash/)->plan(4);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    upstream hash {
+        hash $remote_addr;
+        server 127.0.0.1:8082;
+        server 127.0.0.1:8083;
+    }
+
+    upstream cons {
+        hash $remote_addr consistent;
+        server 127.0.0.1:8082;
+        server 127.0.0.1:8083;
+    }
+
+    upstream empty {
+        hash $proxy_protocol_addr;
+        server 127.0.0.1:8082;
+        server 127.0.0.1:8083;
+    }
+
+    upstream cempty {
+        hash $proxy_protocol_addr consistent;
+        server 127.0.0.1:8082;
+        server 127.0.0.1:8083;
+    }
+
+    server {
+        listen      127.0.0.1:8080;
+        proxy_pass  hash;
+    }
+
+    server {
+        listen      127.0.0.1:8081;
+        proxy_pass  cons;
+    }
+
+    server {
+        listen      127.0.0.1:8084;
+        proxy_pass  empty;
+    }
+
+    server {
+        listen      127.0.0.1:8085;
+        proxy_pass  cempty;
+    }
+}
+
+EOF
+
+$t->run_daemon(\&stream_daemon, port(8082));
+$t->run_daemon(\&stream_daemon, port(8083));
+$t->run();
+
+$t->waitforsocket('127.0.0.1:' . port(8082));
+$t->waitforsocket('127.0.0.1:' . port(8083));
+
+###############################################################################
+
+my @ports = my ($port2, $port3) = (port(8082), port(8083));
+
+is(many(10, port(8080)), "$port3: 10", 'hash');
+like(many(10, port(8081)), qr/($port2|$port3): 10/, 'hash consistent');
+
+# fallback to round-robin
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.17.1');
+
+like(many(4, port(8084)), qr/$port2: 2, $port3: 2/, 'empty key');
+like(many(4, port(8085)), qr/$port2: 2, $port3: 2/, 'empty key - consistent');
+
+}
+
+###############################################################################
+
+sub many {
+	my ($count, $port) = @_;
+	my (%ports);
+
+	for (1 .. $count) {
+		if (stream("127.0.0.1:$port")->io('.') =~ /(\d+)/) {
+			$ports{$1} = 0 unless defined $ports{$1};
+			$ports{$1}++;
+		}
+	}
+
+	my @keys = map { my $p = $_; grep { $p == $_ } keys %ports } @ports;
+	return join ', ', map { $_ . ": " . $ports{$_} } @keys;
+}
+
+###############################################################################
+
+sub stream_daemon {
+	my ($port) = @_;
+
+	my $server = IO::Socket::INET->new(
+		Proto => 'tcp',
+		LocalAddr => '127.0.0.1',
+		LocalPort => $port,
+		Listen => 5,
+		Reuse => 1
+	)
+		or die "Can't create listening socket: $!\n";
+
+	my $sel = IO::Select->new($server);
+
+	local $SIG{PIPE} = 'IGNORE';
+
+	while (my @ready = $sel->can_read) {
+		foreach my $fh (@ready) {
+			if ($server == $fh) {
+				my $new = $fh->accept;
+				$new->autoflush(1);
+				$sel->add($new);
+
+			} elsif (stream_handle_client($fh)) {
+				$sel->remove($fh);
+				$fh->close;
+			}
+		}
+	}
+}
+
+sub stream_handle_client {
+	my ($client) = @_;
+
+	log2c("(new connection $client)");
+
+	$client->sysread(my $buffer, 65536) or return 1;
+
+	log2i("$client $buffer");
+
+	$buffer = $client->sockport();
+
+	log2o("$client $buffer");
+
+	$client->syswrite($buffer);
+
+	return 1;
+}
+
+sub log2i { Test::Nginx::log_core('|| <<', @_); }
+sub log2o { Test::Nginx::log_core('|| >>', @_); }
+sub log2c { Test::Nginx::log_core('||', @_); }
+
+###############################################################################
diff --git a/tests/stream_upstream_least_conn.t b/tests/stream_upstream_least_conn.t
new file mode 100644
index 0000000..929dfd1
--- /dev/null
+++ b/tests/stream_upstream_least_conn.t
@@ -0,0 +1,156 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Stream tests for upstream least_conn balancer module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use IO::Select;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_upstream_least_conn/)->plan(2)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    upstream u {
+        least_conn;
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8082;
+    }
+
+    server {
+        listen      127.0.0.1:8080;
+        proxy_pass  u;
+    }
+}
+
+EOF
+
+$t->run_daemon(\&stream_daemon, port(8081));
+$t->run_daemon(\&stream_daemon, port(8082));
+$t->run();
+
+$t->waitforsocket('127.0.0.1:' . port(8081));
+$t->waitforsocket('127.0.0.1:' . port(8082));
+
+###############################################################################
+
+my @ports = my ($port1, $port2) = (port(8081), port(8082));
+
+is(many(10), "$port1: 5, $port2: 5", 'balanced');
+
+my @sockets;
+for (1 .. 2) {
+	my $s = stream('127.0.0.1:' . port(8080));
+	$s->write('w');
+	push @sockets, $s;
+}
+
+select undef, undef, undef, 0.2;
+
+is(many(10), "$port2: 10", 'least_conn');
+
+###############################################################################
+
+sub many {
+	my ($count) = @_;
+	my (%ports);
+
+	for (1 .. $count) {
+		if (stream('127.0.0.1:' . port(8080))->io('.') =~ /(\d+)/) {
+			$ports{$1} = 0 unless defined $ports{$1};
+			$ports{$1}++;
+		}
+	}
+
+	my @keys = map { my $p = $_; grep { $p == $_ } keys %ports } @ports;
+	return join ', ', map { $_ . ": " . $ports{$_} } @keys;
+}
+
+###############################################################################
+
+sub stream_daemon {
+	my ($port) = @_;
+
+	my $server = IO::Socket::INET->new(
+		Proto => 'tcp',
+		LocalAddr => '127.0.0.1',
+		LocalPort => $port,
+		Listen => 5,
+		Reuse => 1
+	)
+		or die "Can't create listening socket: $!\n";
+
+	my $sel = IO::Select->new($server);
+
+	local $SIG{PIPE} = 'IGNORE';
+
+	while (my @ready = $sel->can_read) {
+		foreach my $fh (@ready) {
+			if ($server == $fh) {
+				my $new = $fh->accept;
+				$new->autoflush(1);
+				$sel->add($new);
+
+			} elsif (stream_handle_client($fh)) {
+				$sel->remove($fh);
+				$fh->close;
+			}
+		}
+	}
+}
+
+sub stream_handle_client {
+	my ($client) = @_;
+
+	log2c("(new connection $client)");
+
+	$client->sysread(my $buffer, 65536) or return 1;
+
+	log2i("$client $buffer");
+
+	my $port = $client->sockport();
+
+	if ($buffer =~ /w/ && $port == port(8081)) {
+		Test::Nginx::log_core('||', "$port: sleep(2.5)");
+		select undef, undef, undef, 2.5;
+	}
+
+	$buffer = $port;
+
+	log2o("$client $buffer");
+
+	$client->syswrite($buffer);
+
+	return 1;
+}
+
+sub log2i { Test::Nginx::log_core('|| <<', @_); }
+sub log2o { Test::Nginx::log_core('|| >>', @_); }
+sub log2c { Test::Nginx::log_core('||', @_); }
+
+###############################################################################
diff --git a/tests/stream_upstream_max_conns.t b/tests/stream_upstream_max_conns.t
new file mode 100644
index 0000000..173dfec
--- /dev/null
+++ b/tests/stream_upstream_max_conns.t
@@ -0,0 +1,405 @@
+#!/usr/bin/perl
+
+# (C) Nginx, Inc.
+# (C) Sergey Kandaurov
+
+# Tests for stream upstream module with max_conns feature.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use IO::Select;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx qw/ :DEFAULT http_end /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_upstream_least_conn/)
+	->has(qw/stream_upstream_hash/)->plan(14);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    upstream u_unlim {
+        server 127.0.0.1:8081 max_conns=0;
+        server 127.0.0.1:8082;
+    }
+    upstream u_lim {
+        server 127.0.0.1:8081 max_conns=3;
+    }
+
+    upstream u_backup {
+        server 127.0.0.1:8081 max_conns=2;
+        server 127.0.0.1:8082 backup;
+    }
+    upstream u_backup_lim {
+        server 127.0.0.1:8081 max_conns=2;
+        server 127.0.0.1:8082 backup max_conns=3;
+    }
+
+    upstream u_two {
+        server 127.0.0.1:8081 max_conns=1;
+        server 127.0.0.1:8082 max_conns=1;
+    }
+    upstream u_some {
+        server 127.0.0.1:8081 max_conns=1;
+        server 127.0.0.1:8082;
+    }
+    upstream u_many {
+        server 127.0.0.1:8081 max_conns=1;
+        server 127.0.0.1:8081 max_conns=1;
+        server 127.0.0.1:8082;
+    }
+
+    upstream u_weight {
+        server 127.0.0.1:8081 weight=2 max_conns=1;
+        server 127.0.0.1:8082;
+    }
+
+    upstream u_lc {
+        least_conn;
+        server 127.0.0.1:8081 max_conns=1;
+        server 127.0.0.1:8082;
+    }
+    upstream u_lc_backup {
+        least_conn;
+        server 127.0.0.1:8081 max_conns=2;
+        server 127.0.0.1:8082 backup;
+    }
+    upstream u_lc_backup_lim {
+        least_conn;
+        server 127.0.0.1:8081 max_conns=2;
+        server 127.0.0.1:8082 backup max_conns=3;
+    }
+
+    upstream u_hash {
+        hash $remote_addr;
+        server 127.0.0.1:8081 max_conns=1;
+        server 127.0.0.1:8082 max_conns=2;
+    }
+    upstream u_chash {
+        hash $remote_addr consistent;
+        server 127.0.0.1:8081 max_conns=1;
+        server 127.0.0.1:8082 max_conns=2;
+    }
+
+    server {
+        listen      127.0.0.1:8086;
+        proxy_pass  u_unlim;
+    }
+
+    server {
+        listen      127.0.0.1:8087;
+        proxy_pass  u_lim;
+    }
+
+    server {
+        listen      127.0.0.1:8088;
+        proxy_pass  u_backup;
+    }
+
+    server {
+        listen      127.0.0.1:8089;
+        proxy_pass  u_backup_lim;
+    }
+
+    server {
+        listen      127.0.0.1:8090;
+        proxy_pass  u_two;
+    }
+
+    server {
+        listen      127.0.0.1:8091;
+        proxy_pass  u_some;
+    }
+
+    server {
+        listen      127.0.0.1:8092;
+        proxy_pass  u_many;
+    }
+
+    server {
+        listen      127.0.0.1:8093;
+        proxy_pass  u_weight;
+    }
+
+    server {
+        listen      127.0.0.1:8094;
+        proxy_pass  u_lc;
+    }
+
+    server {
+        listen      127.0.0.1:8095;
+        proxy_pass  u_lc_backup;
+    }
+
+    server {
+        listen      127.0.0.1:8096;
+        proxy_pass  u_lc_backup_lim;
+    }
+
+    server {
+        listen      127.0.0.1:8097;
+        proxy_pass  u_hash;
+    }
+
+    server {
+        listen      127.0.0.1:8098;
+        proxy_pass  u_chash;
+    }
+}
+
+EOF
+
+$t->run_daemon(\&http_daemon, port(8081), port(8082), port(8085));
+$t->run();
+
+$t->waitforsocket('127.0.0.1:' . port(8081));
+$t->waitforsocket('127.0.0.1:' . port(8082));
+$t->waitforsocket('127.0.0.1:' . port(8085));
+
+###############################################################################
+
+my @ports = my ($p1, $p2) = (port(8081), port(8082));
+
+# two peers without max_conns
+
+is(parallel(8086, '/u_unlim?delay=0', 4), "$p1: 2, $p2: 2", 'unlimited');
+
+# reopen connection to test connection subtraction
+
+my @s = http_get_multi(8087, '/u_lim', 2, 1.1);
+get(8087, '/close');
+push @s, http_get_multi(8087, '/u_lim', 1, 1.1);
+get(8085, '/closeall');
+
+is(http_end_multi(\@s), "$p1: 3", 'conn subtraction');
+
+# simple test with limited peer
+
+is(parallel(8087, '/u_lim', 4), "$p1: 3", 'single');
+
+# limited peer with backup peer
+
+is(peers(8088, '/u_backup', 6), "$p1 $p1 $p2 $p2 $p2 $p2", 'backup');
+
+# peer and backup peer, both limited
+
+is(peers(8089, '/u_backup_lim', 6), "$p1 $p1 $p2 $p2 $p2 ", 'backup limited');
+
+# all peers limited
+
+is(parallel(8090, '/u_two', 4), "$p1: 1, $p2: 1", 'all peers');
+
+# subset of peers limited
+
+is(parallel(8091, '/u_some', 4), "$p1: 1, $p2: 3", 'some peers');
+
+# ensure that peer "weight" does not affect its max_conns limit
+
+is(parallel(8093, '/u_weight', 4), "$p1: 1, $p2: 3", 'weight');
+
+# peers with equal server value aggregate max_conns limit
+
+is(parallel(8092, '/u_many', 6), "$p1: 2, $p2: 4", 'equal peer');
+
+# least_conn balancer tests
+
+is(parallel(8094, '/u_lc', 4), "$p1: 1, $p2: 3", 'least_conn');
+is(peers(8095, '/u_lc_backup', 6), "$p1 $p1 $p2 $p2 $p2 $p2",
+	'least_conn backup');
+is(peers(8096, '/u_lc_backup_lim', 6), "$p1 $p1 $p2 $p2 $p2 ",
+	'least_conn backup limited');
+
+# hash balancer tests
+
+is(parallel(8097, '/u_hash', 4), "$p1: 1, $p2: 2", 'hash');
+is(parallel(8098, '/u_chash', 4), "$p1: 1, $p2: 2", 'hash consistent');
+
+###############################################################################
+
+sub peers {
+	my ($port, $uri, $count) = @_;
+
+	my @sockets = http_get_multi($port, $uri, $count, 1.1);
+	get(8085, '/closeall');
+
+	join ' ', map { defined $_ && /X-Port: (\d+)/ && $1 }
+		map { http_end $_ } (@sockets);
+}
+
+sub parallel {
+	my ($port, $uri, $count) = @_;
+
+	my @sockets = http_get_multi($port, $uri, $count);
+	for (1 .. 20) {
+		last if IO::Select->new(@sockets)->can_read(3) == $count;
+		select undef, undef, undef, 0.01;
+	}
+	get(8085, '/closeall');
+	return http_end_multi(\@sockets);
+}
+
+sub get {
+	my ($port, $uri, %opts) = @_;
+	my $s = IO::Socket::INET->new(
+		Proto => 'tcp',
+		PeerAddr => '127.0.0.1',
+		PeerPort => port($port),
+	)
+		or die "Can't connect to nginx: $!\n";
+
+	http_get($uri, socket => $s, %opts);
+}
+
+sub http_get_multi {
+	my ($port, $uri, $count, $wait) = @_;
+	my @sockets;
+
+	for (0 .. $count - 1) {
+		$sockets[$_] = get($port, $uri, start => 1);
+		IO::Select->new($sockets[$_])->can_read($wait) if $wait;
+	}
+
+	return @sockets;
+}
+
+sub http_end_multi {
+	my ($sockets) = @_;
+	my %ports;
+
+	for my $sock (@$sockets) {
+		my $r = http_end($sock);
+		if ($r && $r =~ /X-Port: (\d+)/) {
+			$ports{$1} = 0 unless defined $ports{$1};
+			$ports{$1}++;
+		}
+		close $sock;
+	}
+
+	my @keys = map { my $p = $_; grep { $p == $_ } keys %ports } @ports;
+	return join ', ', map { $_ . ": " . $ports{$_} } @keys;
+}
+
+###############################################################################
+
+sub http_daemon {
+	my (@ports) = @_;
+	my (@socks, @clients);
+
+	for my $port (@ports) {
+		my $server = IO::Socket::INET->new(
+			Proto => 'tcp',
+			LocalHost => "127.0.0.1:$port",
+			Listen => 42,
+			Reuse => 1
+		)
+			or die "Can't create listening socket: $!\n";
+		push @socks, $server;
+	}
+
+	my $sel = IO::Select->new(@socks);
+	my $skip = 4;
+	my $count = 0;
+
+	local $SIG{PIPE} = 'IGNORE';
+
+OUTER:
+	while (my @ready = $sel->can_read) {
+		foreach my $fh (@ready) {
+			if (grep $_ == $fh, @socks) {
+				my $new = $fh->accept;
+				$new->autoflush(1);
+				$sel->add($new);
+				$count++;
+
+			} else {
+				my @busy = grep { $_->sockport() } @ready;
+
+				# finish other handles
+				if ($fh->sockport() == port(8085) && @busy > 1
+					&& grep $_->sockport() != port(8085),
+					@busy)
+				{
+					next;
+				}
+
+				# late events in other handles
+				if ($fh->sockport() == port(8085) && @busy == 1
+					&& $count > 1 && $skip-- > 0)
+				{
+					select undef, undef, undef, 0.1;
+					next OUTER;
+				}
+
+				my $rv = process_socket($fh, \@clients);
+				if ($rv == 1) {
+					$sel->remove($fh);
+					$fh->close;
+				}
+				if ($rv == 2) {
+					for (@clients) {
+						$sel->remove($_);
+						$_->close;
+					}
+					$sel->remove($fh);
+					$fh->close;
+					$skip = 4;
+				}
+				$count--;
+			}
+		}
+	}
+}
+
+# Returns true to close connection
+
+sub process_socket {
+	my ($client, $saved) = @_;
+	my $port = $client->sockport();
+
+	my $headers = '';
+	my $uri = '';
+
+	while (<$client>) {
+		$headers .= $_;
+		last if (/^\x0d?\x0a?$/);
+	}
+	return 1 if $headers eq '';
+
+	$uri = $1 if $headers =~ /^\S+\s+([^ ]+)\s+HTTP/i;
+	return 1 if $uri eq '';
+
+	Test::Nginx::log_core('||', "$port: response, 200");
+	print $client <<EOF;
+HTTP/1.1 200 OK
+X-Port: $port
+
+OK
+EOF
+
+	return 2 if $uri =~ /closeall/;
+	return 1 if $uri =~ /close/;
+
+	push @$saved, $client;
+	return 0;
+}
+
+###############################################################################
diff --git a/tests/stream_upstream_random.t b/tests/stream_upstream_random.t
new file mode 100644
index 0000000..ea87e4e
--- /dev/null
+++ b/tests/stream_upstream_random.t
@@ -0,0 +1,310 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for upstream random balancer module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx qw/ :DEFAULT http_end /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()
+	->has(qw/stream stream_upstream_zone stream_upstream_random/)->plan(12)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+worker_processes 2;
+
+events {
+}
+
+stream {
+    upstream u {
+        zone z 1m;
+        random;
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8082;
+    }
+
+    upstream lc {
+        zone lc 1m;
+        random two;
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8082;
+    }
+
+    upstream w {
+        zone w 1m;
+        random two least_conn;
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8082 weight=2;
+    }
+
+    upstream mc {
+        zone mc 1m;
+        random;
+        server 127.0.0.1:8081 max_conns=2;
+        server 127.0.0.1:8082 max_conns=1;
+    }
+
+    upstream mc2 {
+        zone mc 1m;
+        random two;
+        server 127.0.0.1:8081 max_conns=2;
+        server 127.0.0.1:8082 max_conns=1;
+    }
+
+    upstream one {
+        random;
+        server 127.0.0.1:8081;
+    }
+
+    upstream two {
+        random two;
+        server 127.0.0.1:8081;
+    }
+
+    upstream zone {
+        zone z 1m;
+        random;
+        server 127.0.0.1:8081;
+    }
+
+    upstream ztwo {
+        zone z 1m;
+        random two;
+        server 127.0.0.1:8081;
+    }
+
+    upstream fail {
+        zone fail 1m;
+        random;
+        server 127.0.0.1:8096;
+        server 127.0.0.1:8083 down;
+        server 127.0.0.1:8082;
+    }
+
+    upstream fail2 {
+        zone fail2 1m;
+        random two;
+        server 127.0.0.1:8096;
+        server 127.0.0.1:8083 down;
+        server 127.0.0.1:8082;
+    }
+
+    proxy_connect_timeout 2;
+
+    server {
+        listen      127.0.0.1:8080;
+        proxy_pass  u;
+    }
+
+    server {
+        listen      127.0.0.1:8083;
+        proxy_pass  lc;
+    }
+
+    server {
+        listen      127.0.0.1:8084;
+        proxy_pass  w;
+    }
+
+    server {
+        listen      127.0.0.1:8085;
+        proxy_pass  mc;
+    }
+
+    server {
+        listen      127.0.0.1:8086;
+        proxy_pass  mc2;
+    }
+
+    server {
+        listen      127.0.0.1:8087;
+        proxy_pass  one;
+    }
+
+    server {
+        listen      127.0.0.1:8088;
+        proxy_pass  two;
+    }
+
+    server {
+        listen      127.0.0.1:8089;
+        proxy_pass  zone;
+    }
+
+    server {
+        listen      127.0.0.1:8090;
+        proxy_pass  ztwo;
+    }
+
+    server {
+        listen      127.0.0.1:8091;
+        proxy_pass  fail;
+    }
+
+    server {
+        listen      127.0.0.1:8092;
+        proxy_pass  fail2;
+    }
+}
+
+EOF
+
+$t->run_daemon(\&http_daemon, port(8081));
+$t->run_daemon(\&http_daemon, port(8082));
+$t->run();
+
+$t->waitforsocket('127.0.0.1:' . port(8081));
+$t->waitforsocket('127.0.0.1:' . port(8082));
+
+###############################################################################
+
+my @ports = my ($port1, $port2) = (port(8081), port(8082));
+
+like(get(8080, '/'), qr/X-Port: ($port1|$port2)/, 'random');
+like(get(8083, '/'), qr/X-Port: ($port1|$port2)/, 'random two');
+
+my $s = get(8083, '/w', start => 1, sleep => 0.5);
+my $r = get(8083, '/');
+my ($p) = http_end($s) =~ /X-Port: (\d+)/;
+like($r, qr/X-Port: (?!$p)/, 'random wait');
+
+SKIP: {
+skip 'long test', 3 unless $ENV{TEST_NGINX_UNSAFE};
+
+is(parallel(8084, '/w', 3), "$port1: 1, $port2: 2", 'random weight');
+
+is(parallel(8085, '/w', 4), "$port1: 2, $port2: 1", 'max_conns');
+is(parallel(8086, '/w', 4), "$port1: 2, $port2: 1", 'max_conns two');
+
+}
+
+# single variants
+
+like(get(8087, '/'), qr/X-Port: $port1/, 'single one');
+like(get(8088, '/'), qr/X-Port: $port1/, 'single two');
+like(get(8089, '/'), qr/X-Port: $port1/, 'zone one');
+like(get(8090, '/'), qr/X-Port: $port1/, 'zone two');
+
+like(many(8091, '/', 10), qr/$port2: 10/, 'failures');
+like(many(8092, '/', 10), qr/$port2: 10/, 'failures two');
+
+###############################################################################
+
+sub get {
+	my ($port, $uri, %opts) = @_;
+	my $s = IO::Socket::INET->new(
+		Proto => 'tcp',
+		PeerAddr => '127.0.0.1',
+		PeerPort => port($port),
+	)
+		or die "Can't connect to nginx: $!\n";
+
+	http_get($uri, socket => $s, %opts);
+}
+
+sub many {
+	my ($port, $uri, $count, %opts) = @_;
+	my %ports;
+
+	for (1 .. $count) {
+		if (get($port, $uri) =~ /X-Port: (\d+)/) {
+			$ports{$1} = 0 unless defined $ports{$1};
+			$ports{$1}++;
+		}
+
+		select undef, undef, undef, $opts{delay} if $opts{delay};
+	}
+
+	my @keys = map { my $p = $_; grep { $p == $_ } keys %ports } @ports;
+	return join ', ', map { $_ . ": " . $ports{$_} } @keys;
+}
+
+sub parallel {
+	my ($port, $uri, $n) = @_;
+	my %ports;
+
+	my @s = map { get($port, $uri, start => 1, sleep => 0.1) } (1 .. $n);
+
+	for (@s) {
+		my $r = http_end($_);
+		if ($r && $r =~ /X-Port: (\d+)/) {
+			$ports{$1} = 0 unless defined $ports{$1};
+			$ports{$1}++;
+		}
+	}
+
+	my @keys = map { my $p = $_; grep { $p == $_ } keys %ports } @ports;
+	return join ', ', map { $_ . ": " . $ports{$_} } @keys;
+}
+
+###############################################################################
+
+sub http_daemon {
+	my ($port) = @_;
+
+	my $server = IO::Socket::INET->new(
+		Proto => 'tcp',
+		LocalHost => '127.0.0.1',
+		LocalPort => $port,
+		Listen => 5,
+		Reuse => 1
+	)
+		or die "Can't create listening socket: $!\n";
+
+	local $SIG{PIPE} = 'IGNORE';
+
+	while (my $client = $server->accept()) {
+		$client->autoflush(1);
+
+		my $headers = '';
+		my $uri = '';
+
+		while (<$client>) {
+			$headers .= $_;
+			last if (/^\x0d?\x0a?$/);
+		}
+
+		$uri = $1 if $headers =~ /^\S+\s+([^ ]+)\s+HTTP/i;
+
+		if ($uri eq '/w') {
+			Test::Nginx::log_core('||', "$port: sleep(2.5)");
+			select undef, undef, undef, 2.5;
+		}
+
+		if ($uri eq '/close' && $port == port(8081)) {
+			next;
+		}
+
+		Test::Nginx::log_core('||', "$port: response, 200");
+		print $client <<EOF;
+HTTP/1.1 200 OK
+Connection: close
+X-Port: $port
+
+OK
+EOF
+
+		close $client;
+	}
+}
+
+###############################################################################
diff --git a/tests/stream_upstream_zone.t b/tests/stream_upstream_zone.t
new file mode 100644
index 0000000..edb4096
--- /dev/null
+++ b/tests/stream_upstream_zone.t
@@ -0,0 +1,87 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Stream tests for upstream zone.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_return stream_upstream_zone/)
+	->plan(2)->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    log_format test $upstream_addr;
+
+    upstream u {
+        zone u 1m;
+        server 127.0.0.1:8081;
+    }
+
+    upstream u2 {
+        zone u;
+        server 127.0.0.1:8081 down;
+        server 127.0.0.1:8081 backup down;
+    }
+
+    server {
+        listen      127.0.0.1:8081;
+        return      OK;
+    }
+
+    server {
+        listen      127.0.0.1:8091;
+        proxy_pass  u;
+
+        access_log %%TESTDIR%%/access1.log test;
+    }
+
+    server {
+        listen      127.0.0.1:8092;
+        proxy_pass  u2;
+
+        access_log %%TESTDIR%%/access2.log test;
+    }
+}
+
+EOF
+
+$t->write_file('index.html', '');
+$t->run();
+
+###############################################################################
+
+my $p = port(8081);
+
+stream('127.0.0.1:' . port(8091))->read();
+stream("127.0.0.1:" . port(8092))->read();
+
+$t->stop();
+
+is($t->read_file('access1.log'), "127.0.0.1:$p\n", 'upstream name');
+is($t->read_file('access2.log'), "u2\n", 'no live upstreams');
+
+###############################################################################
diff --git a/tests/stream_upstream_zone_ssl.t b/tests/stream_upstream_zone_ssl.t
new file mode 100644
index 0000000..f17d5ef
--- /dev/null
+++ b/tests/stream_upstream_zone_ssl.t
@@ -0,0 +1,122 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Stream tests for upstream zone with ssl backend.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_ssl stream_return/)
+	->has(qw/stream_upstream_zone/)->has_daemon('openssl')->plan(9);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    proxy_ssl on;
+    proxy_ssl_session_reuse on;
+
+    upstream u {
+        zone u 1m;
+        server 127.0.0.1:8084;
+    }
+
+    upstream u2 {
+        zone u2 1m;
+        server 127.0.0.1:8084 backup;
+        server 127.0.0.1:8085 down;
+    }
+
+    server {
+        listen      127.0.0.1:8080;
+        proxy_pass  u;
+        proxy_ssl_session_reuse off;
+    }
+
+    server {
+        listen      127.0.0.1:8081;
+        proxy_pass  u;
+    }
+
+    server {
+        listen      127.0.0.1:8082;
+        proxy_pass  u2;
+        proxy_ssl_session_reuse off;
+    }
+
+    server {
+        listen      127.0.0.1:8083;
+        proxy_pass  u2;
+    }
+
+    server {
+        listen      127.0.0.1:8084 ssl;
+        return      $ssl_session_reused;
+
+        ssl_certificate_key localhost.key;
+        ssl_certificate localhost.crt;
+        ssl_session_cache builtin;
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('localhost') {
+	system('openssl req -x509 -new '
+		. "-config $d/openssl.conf -subj /CN=$name/ "
+		. "-out $d/$name.crt -keyout $d/$name.key "
+		. ">>$d/openssl.out 2>&1") == 0
+		or die "Can't create certificate for $name: $!\n";
+}
+
+$t->run();
+
+###############################################################################
+
+is(stream('127.0.0.1:' . port(8080))->read(), '.', 'ssl');
+is(stream('127.0.0.1:' . port(8080))->read(), '.', 'ssl 2');
+
+is(stream('127.0.0.1:' . port(8081))->read(), '.', 'ssl session new');
+is(stream('127.0.0.1:' . port(8081))->read(), 'r', 'ssl session reused');
+is(stream('127.0.0.1:' . port(8081))->read(), 'r', 'ssl session reused 2');
+
+is(stream('127.0.0.1:' . port(8082))->read(), '.', 'backup ssl');
+is(stream('127.0.0.1:' . port(8082))->read(), '.', 'backup ssl 2');
+
+is(stream('127.0.0.1:' . port(8083))->read(), '.', 'backup ssl session new');
+is(stream('127.0.0.1:' . port(8083))->read(), 'r', 'backup ssl session reused');
+
+###############################################################################
diff --git a/tests/stream_variables.t b/tests/stream_variables.t
new file mode 100644
index 0000000..2696c35
--- /dev/null
+++ b/tests/stream_variables.t
@@ -0,0 +1,107 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for stream variables.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream dgram /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_return udp/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    server {
+        listen  127.0.0.1:8080;
+        return  $connection:$nginx_version:$hostname:$pid:$bytes_sent;
+    }
+
+    server {
+        listen  127.0.0.1:8081;
+        listen  [::1]:%%PORT_8081%%;
+        return  $remote_addr:$remote_port:$server_addr:$server_port;
+    }
+
+    server {
+        listen  127.0.0.1:8082;
+        proxy_pass  [::1]:%%PORT_8081%%;
+    }
+
+    server {
+        listen  127.0.0.1:8083;
+        listen  [::1]:%%PORT_8083%%;
+        return  $binary_remote_addr;
+    }
+
+    server {
+        listen  127.0.0.1:8084;
+        proxy_pass  [::1]:%%PORT_8083%%;
+    }
+
+    server {
+        listen  127.0.0.1:8085;
+        return  $msec!$time_local!$time_iso8601;
+    }
+
+    server {
+        listen  127.0.0.1:8086;
+        listen  127.0.0.1:%%PORT_8987_UDP%% udp;
+        return  $protocol;
+    }
+}
+
+EOF
+
+$t->try_run('no inet6 support')->plan(8);
+
+###############################################################################
+
+chomp(my $hostname = lc `hostname`);
+like(stream('127.0.0.1:' . port(8080))->read(),
+	qr/^\d+:[\d.]+:$hostname:\d+:0$/, 'vars');
+
+my $dport = port(8081);
+my $s = stream("127.0.0.1:$dport");
+my $lport = $s->sockport();
+is($s->read(), "127.0.0.1:$lport:127.0.0.1:$dport", 'addr');
+
+my $data = stream('127.0.0.1:' . port(8082))->read();
+like($data, qr/^::1:\d+:::1:\d+$/, 'addr ipv6');
+
+$data = stream('127.0.0.1:' . port(8083))->read();
+is(unpack("H*", $data), '7f000001', 'binary addr');
+
+$data = stream('127.0.0.1:' . port(8084))->read();
+is(unpack("H*", $data), '0' x 31 . '1', 'binary addr ipv6');
+
+$data = stream('127.0.0.1:' . port(8085))->read();
+like($data, qr#^\d+.\d+![-+\w/: ]+![-+\dT:]+$#, 'time');
+
+is(stream('127.0.0.1:' . port(8086))->read(), 'TCP', 'protocol TCP');
+is(dgram('127.0.0.1:' . port(8987))->io('.'), 'UDP', 'protocol UDP');
+
+###############################################################################
diff --git a/tests/stub_status.t b/tests/stub_status.t
new file mode 100644
index 0000000..b1fa7dd
--- /dev/null
+++ b/tests/stub_status.t
@@ -0,0 +1,187 @@
+#!/usr/bin/perl
+
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+
+# Tests for stub status module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http stub_status/)->plan(34);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        add_header X-Active $connections_active;
+        add_header X-Reading $connections_reading;
+        add_header X-Writing $connections_writing;
+        add_header X-Waiting $connections_waiting;
+
+        location / { }
+        location /rate {
+            limit_rate 15;
+        }
+        location /stub {
+            stub_status;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('index.html', '');
+$t->run();
+
+###############################################################################
+
+my %status = status('/stub');
+like(http_get('/stub'), qr/200 OK/, 'get request');
+is($status{'active'}, 1, 'open connection');
+is($status{'requests'}, 1, 'first request');
+is($status{'accepts'}, 1, 'first request accepted');
+is($status{'handled'}, 1, 'first request handled');
+is($status{'writing'}, 1, 'first response');
+is($status{'reading'}, 0, 'not reading');
+
+# pipelined requests
+
+http(<<EOF);
+GET / HTTP/1.1
+Host: localhost
+
+GET / HTTP/1.1
+Host: localhost
+Connection: close
+
+EOF
+
+%status = status('/stub');
+is($status{'requests'}, 5, 'requests increased by 2');
+is($status{'accepts'}, 4, 'accepts increased by 1');
+
+# states
+
+my $s = http('', start => 1);
+
+%status = status('/stub');
+is($status{'active'}, 2, 'active');
+is($status{'waiting'}, 1, 'waiting state');
+is($status{'reading'}, 0, 'waiting state - not reading');
+is($status{'writing'}, 1, 'waiting state - not writing');
+
+http(<<EOF, start => 1, socket => $s, sleep => 0.2);
+GET /rate HTTP/1.0
+EOF
+
+%status = status('/stub');
+is($status{'waiting'}, 0, 'reading state - not waiting');
+is($status{'reading'}, 1, 'reading state');
+is($status{'writing'}, 1, 'reading state - not writing');
+
+http(<<EOF, start => 1, socket => $s, sleep => 0.2);
+Host: localhost
+
+EOF
+
+%status = status('/stub');
+is($status{'waiting'}, 0, 'writing state - not waiting');
+is($status{'reading'}, 0, 'writing state - not reading');
+is($status{'writing'}, 2, 'writing state');
+
+$s->close();
+
+# head and post requests
+
+like(http_head('/stub'), qr/200 OK/, 'head request');
+like(http_post('/stub'), qr/405 Not Allowed/, 'post request');
+
+# embedded variables in headers
+
+my $r = http_get('/stub');
+like($r, qr/X-Active: 1/, 'get - var active');
+like($r, qr/X-Reading: 0/, 'get - var reading');
+like($r, qr/X-Writing: 1/, 'get - var writing');
+like($r, qr/X-Waiting: 0/, 'get - var waiting');
+
+$r = http_head('/stub');
+like($r, qr/X-Active: 1/, 'head - var active');
+like($r, qr/X-Reading: 0/, 'head - var reading');
+like($r, qr/X-Writing: 1/, 'head - var writing');
+like($r, qr/X-Waiting: 0/, 'head - var waiting');
+is(get_body($r), '', 'head - empty body');
+
+$r = http_get('/');
+like($r, qr/X-Active: 1/, 'no stub - var active');
+like($r, qr/X-Reading: 0/, 'no stub - var reading');
+like($r, qr/X-Writing: 1/, 'no stub - var writing');
+like($r, qr/X-Waiting: 0/, 'no stub - var waiting');
+
+###############################################################################
+
+sub get_body {
+	my ($r) = @_;
+	$r =~ /.*?\x0d\x0a?\x0d\x0a?(.*)/ms;
+	return $1;
+}
+
+sub http_post {
+	my ($url) = @_;
+	return http(<<EOF);
+POST $url HTTP/1.0
+Host: localhost
+
+EOF
+}
+
+sub status {
+	my ($url) = @_;
+	my $r = http_get($url);
+
+	$r =~ /
+		Active\ connections:\ +(\d+)
+		\s+server\ accepts\ handled\ requests
+		\s+(\d+)\ +(\d+)\ +(\d+)
+		\s+Reading:\ +(\d+)
+		\s+Writing:\ +(\d+)
+		\s+Waiting:\ +(\d+)
+	/sx;
+
+	return ('active' => $1,
+		'accepts' => $2,
+		'handled' => $3,
+		'requests' => $4,
+		'reading' => $5,
+		'writing' => $6,
+		'waiting' => $7,
+	);
+}
+
+###############################################################################
diff --git a/tests/sub_filter.t b/tests/sub_filter.t
new file mode 100644
index 0000000..aef631e
--- /dev/null
+++ b/tests/sub_filter.t
@@ -0,0 +1,154 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for sub filter.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http rewrite sub proxy/)->plan(30)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        sub_filter_types *;
+        sub_filter foo bar;
+
+        location / {
+        }
+
+        location /once {
+            return 200 $arg_b;
+        }
+
+        location /many {
+            sub_filter_once off;
+            return 200 $arg_b;
+        }
+
+        location /complex {
+            sub_filter abac _replaced;
+            return 200 $arg_b;
+        }
+
+        location /complex2 {
+            sub_filter ababX _replaced;
+            return 200 $arg_b;
+        }
+
+        location /complex3 {
+            sub_filter aab _replaced;
+            return 200 $arg_b;
+        }
+
+        location /single {
+            sub_filter A B;
+            return 200 $arg_b;
+        }
+
+        location /single/many {
+            sub_filter A B;
+            sub_filter_once off;
+            return 200 $arg_b;
+        }
+
+        location /var/string {
+            sub_filter X$arg_a _replaced;
+            return 200 $arg_b;
+        }
+
+        location /var/replacement {
+            sub_filter aab '${arg_a}_replaced';
+            return 200 $arg_b;
+        }
+
+        location /lm {
+            sub_filter_last_modified on;
+            proxy_pass http://127.0.0.1:8081/;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+    }
+}
+
+EOF
+
+$t->write_file('foo.html', 'foo');
+$t->write_file('foo_uc.html', 'FOO');
+$t->write_file('foofoo.html', 'foofoo');
+$t->run();
+
+###############################################################################
+
+like(http_get('/foo.html'), qr/bar/, 'sub_filter');
+like(http_get('/foo_uc.html'), qr/bar/, 'sub_filter caseless');
+like(http_get('/foofoo.html'), qr/barfoo/, 'once default');
+
+like(http_get('/once?b=foofoo'), qr/barfoo/, 'once');
+like(http_get('/many?b=foofoo'), qr/barbar/, 'many');
+like(http_get('/many?b=fo'), qr/fo/, 'incomplete');
+like(http_get('/many?b=foofo'), qr/barfo/, 'incomplete long');
+
+like(http_get('/complex?b=abac'), qr/_replaced/, 'complex');
+like(http_get('/complex?b=abaabac'), qr/aba_replaced/, 'complex 1st char');
+like(http_get('/complex?b=ababac'), qr/replaced/, 'complex 2nd char');
+like(http_get('/complex2?b=ababX'), qr/_replaced/, 'complex2');
+like(http_get('/complex2?b=abababX'), qr/ab_replaced/, 'complex2 long');
+like(http_get('/complex3?b=aab'), qr/_replaced/, 'complex3 aab in aab');
+like(http_get('/complex3?b=aaab'), qr/a_replaced/, 'complex3 aab in aaab');
+like(http_get('/complex3?b=aaaab'), qr/aa_replaced/, 'complex3 aab in aaaab');
+
+like(http_get('/single?b=A'), qr/B/, 'single only');
+like(http_get('/single?b=AA'), qr/BA/, 'single begin');
+like(http_get('/single?b=CAAC'), qr/CBAC/, 'single middle');
+like(http_get('/single?b=CA'), qr/CB/, 'single end');
+
+like(http_get('/single/many?b=A'), qr/B/, 'single many only');
+like(http_get('/single/many?b=AA'), qr/BB/, 'single many begin');
+like(http_get('/single/many?b=CAAC'), qr/CBBC/, 'single many middle');
+like(http_get('/single/many?b=CA'), qr/CB/, 'single many end');
+
+like(http_get('/var/string?a=foo&b=Xfoo'), qr/_replaced/, 'complex string');
+like(http_get('/var/string?a=foo&b=XFOO'), qr/_replaced/,
+	'complex string caseless');
+like(http_get('/var/string?a=abcdefghijklmnopq&b=Xabcdefghijklmnopq'),
+	qr/_replaced/, 'complex string long');
+
+like(http_get('/var/replacement?a=ee&b=aaab'), qr/aee_replaced/,
+	'complex replacement');
+
+unlike(http_get('/foo.html'), qr/(Last-Modified|ETag)/, 'no last modified');
+like(http_get('/lm/foo.html'), qr/Last-Modified/, 'last modified');
+like(http_get('/lm/foo.html'), qr!ETag: W/"[^"]+"!, 'last modified weak');
+
+###############################################################################
diff --git a/tests/sub_filter_buffering.t b/tests/sub_filter_buffering.t
new file mode 100644
index 0000000..f3631a3
--- /dev/null
+++ b/tests/sub_filter_buffering.t
@@ -0,0 +1,103 @@
+#!/usr/bin/perl
+
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+
+# Tests for sub_filter buffering.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http sub proxy/)->plan(2)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        proxy_buffering off;
+        proxy_http_version 1.1;
+
+        sub_filter_types *;
+
+        location /partial {
+            proxy_pass http://127.0.0.1:8081;
+            sub_filter za ZA;
+        }
+
+        location /negative {
+            proxy_pass http://127.0.0.1:8081;
+            sub_filter ab AB;
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&http_daemon);
+$t->run()->waitforsocket('127.0.0.1:' . port(8081));
+
+###############################################################################
+
+# partial match: the last byte matching pattern is buffered
+
+like(http_get('/partial'), qr/xy$/, 'partial match');
+
+# no partial match: an entire buffer is sent as is without buffering
+
+like(http_get('/negative'), qr/xyz/, 'negative match');
+
+###############################################################################
+
+sub http_daemon {
+	my $server = IO::Socket::INET->new(
+		Proto => 'tcp',
+		LocalHost => '127.0.0.1:' . port(8081),
+		Listen => 5,
+		Reuse => 1
+	)
+		or die "Can't create listening socket: $!\n";
+
+	local $SIG{PIPE} = 'IGNORE';
+
+	while (my $client = $server->accept()) {
+		$client->autoflush(1);
+
+		while (<$client>) {
+			last if /^\x0d?\x0a?$/;
+		}
+
+		print $client
+			"HTTP/1.1 200 OK" . CRLF .
+			"Content-Length: 10" . CRLF . CRLF .
+			"xyz";
+	}
+}
+
+###############################################################################
diff --git a/tests/sub_filter_merge.t b/tests/sub_filter_merge.t
new file mode 100644
index 0000000..1b483f5
--- /dev/null
+++ b/tests/sub_filter_merge.t
@@ -0,0 +1,58 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Test for sub_filter inheritance from http context.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http sub/);
+
+$t->plan(1)->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    sub_filter foo bar;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / { }
+    }
+}
+
+EOF
+
+$t->write_file('foo.html', 'foo');
+$t->run();
+
+###############################################################################
+
+like(http_get('/foo.html'), qr/bar/, 'sub_filter inheritance');
+
+###############################################################################
diff --git a/tests/sub_filter_multi.t b/tests/sub_filter_multi.t
new file mode 100644
index 0000000..14e3c1a
--- /dev/null
+++ b/tests/sub_filter_multi.t
@@ -0,0 +1,380 @@
+#!/usr/bin/perl
+
+# (C) Dmitry Volyntsev
+# (C) Nginx, Inc.
+
+# Tests for multiple patterns in sub filter.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http rewrite sub proxy/)->plan(42);
+
+my $long_pattern = '0123456789abcdef' x 17;
+
+(my $conf = <<'EOF') =~ s/%%LONG_PATTERN%%/$long_pattern/g;
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        sub_filter_types *;
+        sub_filter foo bar;
+
+        location /multi {
+            sub_filter_once off;
+            sub_filter aab +;
+            sub_filter yyz -;
+            return 200 $arg_a;
+        }
+
+        location /multi2 {
+            sub_filter_once off;
+            sub_filter aabb  +;
+            sub_filter aaabb -;
+            return 200 $arg_a;
+        }
+
+        location /multi3 {
+            sub_filter_once off;
+            sub_filter aacbb +;
+            sub_filter aadbb -;
+            return 200 $arg_a;
+        }
+
+        location /case {
+            sub_filter_once off;
+            sub_filter AAB +;
+            sub_filter YYZ -;
+            return 200 $arg_a;
+        }
+
+        location /case2 {
+            sub_filter_once off;
+            sub_filter ABCDEFGHIJKLMNOPQRSTUVWXYZ +;
+            return 200 $arg_a;
+        }
+
+        location /case3 {
+            sub_filter_once off;
+            sub_filter abcdefghijklmnopqrstuvwxyz +;
+            return 200 $arg_a;
+        }
+
+        location /minimal {
+            sub_filter_once off;
+            sub_filter ab +;
+            sub_filter cd -;
+            sub_filter ef *;
+            sub_filter gh !;
+            sub_filter x  _;
+            return 200 $arg_a;
+        }
+
+        location /once {
+            sub_filter aab +;
+            sub_filter yyz -;
+            return 200 $arg_a;
+        }
+
+        location /table/inheritance {
+            sub_filter_once off;
+            return 200 $arg_a;
+        }
+
+        location /utf8 {
+            sub_filter_once off;
+            sub_filter 模様 замена1;
+            sub_filter पैटर्न замена2;
+            sub_filter паттерн replaced;
+            return 200 $arg_a;
+        }
+
+        location /var/replacement/multi {
+            sub_filter_once off;
+            sub_filter aab '${arg_a}_replaced';
+            sub_filter yyz '${arg_b}_replaced';
+            return 200 $arg_c;
+        }
+
+        location /crossbuf/match1 {
+            sub_filter_once off;
+            sub_filter abpattyz +;
+            alias %%TESTDIR%%/;
+        }
+
+        location /crossbuf/match2 {
+            sub_filter_once off;
+            sub_filter abpattrnyz +;
+            alias %%TESTDIR%%/;
+        }
+
+        location /crossbuf/match3 {
+            sub_filter_once off;
+            sub_filter abpatternyz +;
+            alias %%TESTDIR%%/;
+        }
+
+        location /crossbuf/match4 {
+            sub_filter_once off;
+            sub_filter abpattternyz +;
+            alias %%TESTDIR%%/;
+        }
+
+        location /crossbuf/match5-01 {
+            sub_filter_once off;
+            sub_filter abyz +;
+            sub_filter abpattternyz -;
+            alias %%TESTDIR%%/;
+        }
+
+        location /crossbuf/match5-02 {
+            sub_filter_once off;
+            sub_filter abpayz +;
+            sub_filter abpattternyz -;
+            alias %%TESTDIR%%/;
+        }
+
+        location /crossbuf/match6 {
+            sub_filter_once off;
+            sub_filter abpattxernyz +;
+            sub_filter abpattternyz -;
+            alias %%TESTDIR%%/;
+        }
+
+        location /crossbuf/superlong/match1 {
+            sub_filter_once off;
+            sub_filter %%LONG_PATTERN%% +;
+            alias %%TESTDIR%%/;
+        }
+
+        location /crossbuf/superlong/match2 {
+            sub_filter_once off;
+            sub_filter %%LONG_PATTERN%% +;
+            sub_filter yz -;
+            alias %%TESTDIR%%/;
+        }
+
+        location /crossbuf/superlong/match3 {
+            sub_filter_once off;
+            sub_filter %%LONG_PATTERN%% +;
+            sub_filter 01ef -;
+            alias %%TESTDIR%%/;
+        }
+
+        location /crossbuf/superlong/match4 {
+            sub_filter_once off;
+            sub_filter %%LONG_PATTERN%% +;
+            sub_filter 01ef -;
+            sub_filter _ *;
+            alias %%TESTDIR%%/;
+        }
+
+        location /shortbuf/match1 {
+            sub_filter_once off;
+            sub_filter abpatternyz +;
+
+            proxy_pass http://127.0.0.1:8081/;
+            proxy_buffering off;
+        }
+
+        location /shortbuf/match2 {
+            sub_filter_once off;
+            sub_filter abpatternyz +;
+            sub_filter abpaernyz -;
+
+            proxy_pass http://127.0.0.1:8081/;
+            proxy_buffering off;
+        }
+
+        location /shortbuf/match3 {
+            sub_filter_once off;
+            sub_filter abpatternyz +;
+            sub_filter abpaernyz -;
+            sub_filter _ *;
+
+            proxy_pass http://127.0.0.1:8081/;
+            proxy_buffering off;
+        }
+
+        location /shortbuf/match4 {
+            sub_filter_once off;
+            sub_filter patt +;
+
+            proxy_pass http://127.0.0.1:8081/;
+            proxy_buffering off;
+        }
+
+        location /shortbuf/match5 {
+            sub_filter_once off;
+            sub_filter abpatternyz +;
+            sub_filter abpa -;
+            sub_filter tter *;
+
+            proxy_pass http://127.0.0.1:8081/;
+            proxy_buffering off;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+
+        limit_rate 4;
+        limit_rate_after 160;
+
+        location / {
+            return 200 $arg_a;
+        }
+    }
+}
+
+EOF
+
+$t->write_file_expand('nginx.conf', $conf);
+
+$t->write_file('huge1.html', 'abpattyz' x 6000);
+$t->write_file('huge2.html', 'abpattrnyz' x 5000);
+$t->write_file('huge3.html', 'abpatternyz' x 4000);
+$t->write_file('huge4.html', 'abpattternyz' x 4000);
+
+$t->write_file('huge5-01.html', 'abpatternyzA' x 4000);
+$t->write_file('huge5-02.html', 'abpatternyzABCDEFGHIJ' x 4000);
+$t->write_file('huge5-03.html', 'abpatternyzABCDEFGHIJK' x 4000);
+$t->write_file('huge5-04.html', 'abpatternyzABCDEFGHIJKL' x 4000);
+
+$t->write_file('huge6-01.html', 'abyzAabpattternyz' x 3000);
+$t->write_file('huge6-02.html', 'abpayzAabpattternyz' x 3000);
+
+$t->write_file('huge7-01.html', 'abpattxernyzabpattternyz' x 3000);
+$t->write_file('huge7-02.html', 'abpattxernyzAabpattternyz' x 3000);
+$t->write_file('huge7-03.html', 'abpattxernyzABCDEFGHIJabpattternyz' x 3000);
+$t->write_file('huge7-04.html', 'abpattxernyzABCDEFGHIJKabpattternyz' x 3000);
+$t->write_file('huge7-05.html', 'abpattxernyzABCDEFGHIJKLabpattternyz' x 3000);
+
+$t->write_file('huge8.html', scalar ('ABC' . $long_pattern . 'XYZ') x 1000);
+$t->write_file('huge9.html', scalar ('ABC' . $long_pattern . 'yz') x 1000);
+$t->write_file('huge10-01.html', scalar ($long_pattern . 'ABC01ef') x 1000);
+$t->write_file('huge10-02.html', scalar ('01efABC' . $long_pattern) x 1000);
+$t->write_file('huge11.html', scalar ('01efA_Z' . $long_pattern) x 1000);
+
+$t->run();
+
+###############################################################################
+
+like(http_get('/multi?a=aabAyyzBaab'), qr/\+A-B\+/, 'simple match');
+like(http_get('/multi2?a=aabbaaabbaabb'), qr/\+-\+/, 'partial match');
+like(http_get('/multi3?a=aadbbaacbb'), qr/-\+/, 'exact match');
+
+like(http_get('/multi?a=AABYYZAAB'), qr/\+-\+/, 'case insensivity 1');
+like(http_get('/case?a=aabyyzaab'), qr/\+-\+/, 'case insensivity 2');
+like(http_get('/case2?a=abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'),
+	qr/\+\+/, 'case insensivity 3');
+like(http_get('/case3?a=abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'),
+	qr/\+\+/, 'case insensivity 4');
+
+like(http_get('/minimal?a=AAabcdefghBxBabCxCcdDDefEEghFF'),
+	qr/AA\+-\*!B_B\+C_C-DD\*EE!FF/, 'minimal match');
+
+like(http_get('/utf8?a=ТЕКСТ模様ТЕКСТ2पैटर्नТЕКСТ3паттерн'),
+	qr/ТЕКСТзамена1ТЕКСТ2замена2ТЕКСТ3replaced/, 'utf8 match');
+
+like(http_get('/once?a=aabyyzaab'), qr/\+-aab/, 'once 1');
+like(http_get('/once?a=yyzaabyyz'), qr/-\+yyz/, 'once 2');
+like(http_get('/once?a=yyzyyzaabaabyyz'), qr/-yyz\+aabyyz/, 'once 3');
+
+like(http_get('/table/inheritance?a=foofoo'), qr/barbar/, 'table inheritance');
+
+like(http_get('/var/replacement/multi?a=A&b=B&c=aabyyzaab'),
+	qr/A_replacedB_replacedA_replaced/, 'complex multiple replace');
+
+like(http_get('/crossbuf/match1/huge1.html'), qr/\+{6000}/,
+	'crossbuf match 1 (simple match len 8)');
+like(http_get('/crossbuf/match2/huge2.html'), qr/\+{5000}/,
+	'crossbuf match 2 (simple match len 9)');
+like(http_get('/crossbuf/match3/huge3.html'), qr/\+{4000}/,
+	'crossbuf match 3 (simple match len 10)');
+like(http_get('/crossbuf/match4/huge4.html'), qr/\+{4000}/,
+	'crossbuf match 4 (simple match len 11)');
+
+like(http_get('/crossbuf/match3/huge5-01.html'), qr/(\+A){4000}/,
+	'crossbuf match 5.1');
+like(http_get('/crossbuf/match3/huge5-02.html'), qr/(\+ABCDEFGHIJ){4000}/,
+	'crossbuf match 5.2');
+like(http_get('/crossbuf/match3/huge5-03.html'), qr/(\+ABCDEFGHIJK){4000}/,
+	'crossbuf match 5.3');
+like(http_get('/crossbuf/match3/huge5-04.html'), qr/(\+ABCDEFGHIJKL){4000}/,
+	'crossbuf match 5.4');
+
+like(http_get('/crossbuf/match5-01/huge6-01.html'), qr/(\+A-){3000}/,
+	'crossbuf match 6.1 (multiple replace)');
+like(http_get('/crossbuf/match5-02/huge6-02.html'), qr/(\+A-){3000}/,
+	'crossbuf match 6.2 (multiple replace)');
+
+like(http_get('/crossbuf/match6/huge7-01.html'), qr/(\+-){3000}/,
+	'crossbuf match 7.1 (multiple replace)');
+like(http_get('/crossbuf/match6/huge7-02.html'), qr/(\+A-){3000}/,
+	'crossbuf match 7.2 (multiple replace)');
+like(http_get('/crossbuf/match6/huge7-03.html'), qr/(\+ABCDEFGHIJ-){3000}/,
+	'crossbuf match 7.3 (multiple replace)');
+like(http_get('/crossbuf/match6/huge7-04.html'), qr/(\+ABCDEFGHIJK-){3000}/,
+	'crossbuf match 7.4 (multiple replace)');
+like(http_get('/crossbuf/match6/huge7-05.html'), qr/(\+ABCDEFGHIJKL-){3000}/,
+	'crossbuf match 7.5 (multiple replace)');
+
+like(http_get('/crossbuf/superlong/match1/huge8.html'), qr/(ABC\+XYZ){1000}/,
+	'crossbuf superlong match 1');
+like(http_get('/crossbuf/superlong/match2/huge9.html'), qr/(ABC\+-){1000}/,
+	'crossbuf superlong match 2 (multiple replace)');
+like(http_get('/crossbuf/superlong/match3/huge10-01.html'), qr/(\+ABC-){1000}/,
+	'crossbuf superlong match 3.1 (multiple replace)');
+like(http_get('/crossbuf/superlong/match3/huge10-02.html'), qr/(-ABC\+){1000}/,
+	'crossbuf superlong match 3.2 (multiple replace)');
+like(http_get('/crossbuf/superlong/match4/huge11.html'), qr/(-A\*Z\+){1000}/,
+	'crossbuf superlong match 4 (1 byte search pattern)');
+
+SKIP: {
+skip 'long tests', 8 unless $ENV{TEST_NGINX_UNSAFE};
+
+like(http_get('/shortbuf/match1?a=' . 'abpatternyzA' x 3),
+	qr/(\+A){3}/, 'shortbuf match 1.1');
+like(http_get('/shortbuf/match1?a=' . 'abpatternyzABCD' x 3),
+	qr/(\+ABCD){3}/, 'shortbuf match 1.2');
+like(http_get('/shortbuf/match1?a=' . 'abpatternyzABCDE' x 3),
+	qr/(\+ABCDE){3}/, 'shortbuf match 1.3');
+like(http_get('/shortbuf/match2?a=' . 'abpatternyzAabpaernyzB' x 2),
+	qr/(\+A-B){2}/, 'shortbuf match 2.1 (multiple replace)');
+like(http_get('/shortbuf/match2?a=' . 'abpatternyzAabpaernyz' x 2),
+	qr/(\+A-){2}/, 'shortbuf match 2.2 (multiple replace)');
+like(http_get('/shortbuf/match3?a=' . 'abpatternyzA_' x 3),
+	qr/(\+A\*){3}/, 'shortbuf match 3 (1 byte search pattern)');
+like(http_get('/shortbuf/match4?a=' . 'pattABCDEFGHI' x 3),
+	qr/(\+ABCDEFGHI){3}/, 'shortbuf match 4');
+like(http_get('/shortbuf/match5?a=abpatternyzABCDE' . 'abpatternyABCDE' x 2),
+	qr/\+ABCDE(-\*nyABCDE){2}/, 'shortbuf match 5');
+}
+
+###############################################################################
diff --git a/tests/sub_filter_multi2.t b/tests/sub_filter_multi2.t
new file mode 100644
index 0000000..45e053c
--- /dev/null
+++ b/tests/sub_filter_multi2.t
@@ -0,0 +1,82 @@
+#!/usr/bin/perl
+
+# (C) Dmitry Volyntsev
+# (C) Nginx, Inc.
+
+# Tests for sub filter with variables in search patterns.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http rewrite sub/)->plan(7)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        sub_filter_types *;
+
+        location /var/replacement {
+            sub_filter_once off;
+            sub_filter '${arg_a}' '${arg_a}+';
+            sub_filter '${arg_b}' '${arg_b}-';
+            return 200 $arg_c;
+        }
+
+        location /var/replacement2 {
+            sub_filter_once off;
+            sub_filter '${arg_a}A${arg_b}'  +;
+            sub_filter '${arg_c}AA${arg_d}' -;
+            return 200 $arg_e;
+        }
+    }
+
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+like(http_get('/var/replacement?a=a&b=b&c=abXYaXbZ'),
+	qr/a\+b-XYa\+Xb-Z/, 'complex');
+like(http_get('/var/replacement?a=patt&b=abyz&c=pattabyzXYpattXabyzZpatt'),
+	qr/patt\+abyz-XYpatt\+Xabyz-Zpatt\+/, 'complex 2');
+like(http_get('/var/replacement?a=a&b=b&c=ABXYAXBZ'),
+	qr/a\+b-XYa\+Xb-Z/, 'case insensivity');
+like(http_get('/var/replacement?b=b&c=abXYaXbZ'),
+	qr/ab-XYaXb-Z/, 'one search string is empty');
+like(http_get('/var/replacement?c=abXYaXbZ'),
+	qr/abXYaXbZ/, 'all search strings are empty');
+like(http_get('/var/replacement2?a=aaa&b=bbb&c=yy&d=zz&e=AaaaAbbbZyyAAzzY'),
+	qr/A\+Z-Y/, 'multiple variables');
+like(http_get('/var/replacement2?b=bbb&c=yy&e=AAbbbZyyAAY'),
+	qr/A\+Z-Y/, 'multiple variables 2');
+
+###############################################################################
diff --git a/tests/sub_filter_perl.t b/tests/sub_filter_perl.t
new file mode 100644
index 0000000..74d9bbb
--- /dev/null
+++ b/tests/sub_filter_perl.t
@@ -0,0 +1,123 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for sub filter, extended tests using embedded perl.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http sub perl/)->plan(22)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        sub_filter_types *;
+        sub_filter foobarbaz replaced;
+
+        location / {
+            perl 'sub {
+                my $r = shift;
+                $r->send_http_header("text/html");
+                return OK if $r->header_only;
+                $r->print("foo");
+                $r->flush();
+                $r->print("bar");
+                $r->flush();
+                $r->print("baz");
+                return OK;
+            }';
+        }
+
+        location /multi {
+            sub_filter aab _replaced;
+            perl 'sub {
+                my $r = shift;
+                $r->send_http_header("text/html");
+                return OK if $r->header_only;
+                $r->print($r->variable("arg_a"));
+                $r->print($r->variable("arg_b"));
+                return OK;
+            }';
+        }
+
+        location /short {
+            sub_filter ab _replaced;
+            perl 'sub {
+                my $r = shift;
+                $r->send_http_header("text/html");
+                return OK if $r->header_only;
+                $r->print($r->variable("arg_a"));
+                $r->print($r->variable("arg_b"));
+                return OK;
+            }';
+        }
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+like(http_get('/flush'), qr/^replaced$/m, 'flush');
+
+like(http_get('/multi?a=a&b=ab'), qr/^_replaced$/m, 'aab in a + ab');
+like(http_get('/multi?a=a&b=aaab'), qr/^aa_replaced$/m, 'aab in a + aaab');
+like(http_get('/multi?a=a&b=aab'), qr/^a_replaced$/m, 'aab in a + aab');
+like(http_get('/multi?a=a&b=aaaab'), qr/^aaa_replaced$/m, 'aab in a + aaaab');
+like(http_get('/multi?a=aa&b=ab'), qr/^a_replaced$/m, 'aab in aa + ab');
+like(http_get('/multi?a=aa&b=aab'), qr/^aa_replaced$/m, 'aab in aa + aab');
+like(http_get('/multi?a=aa&b=aaab'), qr/^aaa_replaced$/m, 'aab in aa + aaab');
+like(http_get('/multi?a=aa&b=aaaab'), qr/^aaaa_replaced$/m, 'aab in aa + aaaab');
+
+# full backtracking
+
+like(http_get('/multi?a=aa&b=xaaab'), qr/^aaxa_replaced$/m, 'aab in aa + xaaab');
+like(http_get('/multi?a=aa&b=axaaab'), qr/^aaaxa_replaced$/m,
+	'aab in aa + axaaab');
+like(http_get('/multi?a=aa&b=aaxaaab'), qr/^aaaaxa_replaced$/m,
+	'aab in aa + aaxaaab');
+
+# short pattern
+
+like(http_get('/short?a=a&b=b'), qr/^_replaced$/m, 'ab in a + b');
+like(http_get('/short?a=a&b=ab'), qr/^a_replaced$/m, 'ab in a + ab');
+like(http_get('/short?a=a&b=aab'), qr/^aa_replaced$/m, 'ab in a + aab');
+like(http_get('/short?a=a&b=aaab'), qr/^aaa_replaced$/m, 'ab in a + aaab');
+like(http_get('/short?a=a&b=aaaab'), qr/^aaaa_replaced$/m, 'ab in a + aaaab');
+
+like(http_get('/short?a=aa&b=b'), qr/^a_replaced$/m, 'ab in aa + b');
+like(http_get('/short?a=aa&b=ab'), qr/^aa_replaced$/m, 'ab in aa + ab');
+like(http_get('/short?a=aa&b=aab'), qr/^aaa_replaced$/m, 'ab in aa + aab');
+like(http_get('/short?a=aa&b=aaab'), qr/^aaaa_replaced$/m, 'ab in aa + aaab');
+like(http_get('/short?a=aa&b=aaaab'), qr/^aaaaa_replaced$/m, 'ab in aa + aaaab');
+
+###############################################################################
diff --git a/tests/sub_filter_slice.t b/tests/sub_filter_slice.t
new file mode 100644
index 0000000..5277e63
--- /dev/null
+++ b/tests/sub_filter_slice.t
@@ -0,0 +1,103 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for slice filter with sub filter.
+
+# A response is sent using chunked encoding.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy slice sub/)->plan(3);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            sub_filter foo bar;
+            sub_filter_types *;
+
+            slice 2;
+
+            proxy_pass    http://127.0.0.1:8081/;
+
+            proxy_set_header   Range  $slice_range;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location / { }
+    }
+}
+
+EOF
+
+$t->write_file('t', '0123456789');
+$t->run();
+
+###############################################################################
+
+my $r;
+
+# range filter in subrequests (subrequest_ranges)
+
+$r = get('/t', 'Range: bytes=2-4');
+unlike($r, qr/\x0d\x0a?0\x0d\x0a?\x0d\x0a?\w/, 'only final chunk');
+
+TODO: {
+local $TODO = 'not yet';
+
+# server is assumed to return the requested range
+
+$r = get('/t', 'Range: bytes=3-4');
+like($r, qr/ 206 /, 'range request - 206 partial reply');
+is(Test::Nginx::http_content($r), '34', 'range request - correct content');
+
+}
+
+###############################################################################
+
+sub get {
+	my ($url, $extra) = @_;
+	return http(<<EOF);
+GET $url HTTP/1.1
+Host: localhost
+Connection: close
+$extra
+
+EOF
+}
+
+###############################################################################
diff --git a/tests/sub_filter_ssi.t b/tests/sub_filter_ssi.t
new file mode 100644
index 0000000..e263fdb
--- /dev/null
+++ b/tests/sub_filter_ssi.t
@@ -0,0 +1,85 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for sub filter and subrequests.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http sub ssi xslt/)->plan(2)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    types {
+        text/html html;
+        text/xml  xml;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            ssi on;
+            sub_filter notfoo bar;
+        }
+
+        location /xslt {
+            ssi on;
+            sub_filter_types *;
+            sub_filter root>foo bar;
+            xslt_stylesheet test.xslt;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('index.html', '<!--#include virtual="/not.html" --> truncated');
+$t->write_file('not.html', 'response is not');
+
+$t->write_file('xslt.html', '<!--#include virtual="/xslt.xml" --> truncated');
+$t->write_file('xslt.xml', '<root>test</root>');
+$t->write_file('test.xslt', <<'EOF');
+
+<xsl:stylesheet version="1.0"
+                xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
+<xsl:output method="html"/>
+<xsl:strip-space elements="*"/>
+<xsl:template match="/">response is not</xsl:template>
+</xsl:stylesheet>
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+like(http_get('/index.html'), qr/not truncated/, 'subrequest partial match');
+like(http_get('/xslt.html'), qr/not.*truncated/ms, 'partial match and xslt');
+
+###############################################################################
diff --git a/tests/subrequest_output_buffer_size.t b/tests/subrequest_output_buffer_size.t
new file mode 100644
index 0000000..2446750
--- /dev/null
+++ b/tests/subrequest_output_buffer_size.t
@@ -0,0 +1,85 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for subrequest_output_buffer_size directive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy ssi/)->plan(4)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            proxy_pass http://127.0.0.1:8081;
+            subrequest_output_buffer_size 42;
+        }
+
+        location /longok {
+            proxy_pass http://127.0.0.1:8081/long;
+        }
+
+        location /ssi {
+            ssi on;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location / { }
+    }
+}
+
+EOF
+
+$t->write_file('ssi.html',
+	'<!--#include virtual="/$arg_c" set="x" -->' .
+	'set: <!--#echo var="x" -->');
+
+$t->write_file('length', 'TEST-OK-IF-YOU-SEE-THIS');
+$t->write_file('long', 'x' x 400);
+$t->write_file('empty', '');
+
+$t->run();
+
+###############################################################################
+
+my ($r, $n);
+
+like(http_get('/ssi.html?c=length'), qr/SEE-THIS/, 'request');
+like(http_get('/ssi.html?c=empty'), qr/set: $/, 'empty');
+unlike(http_get('/ssi.html?c=long'), qr/200 OK/, 'long');
+like(http_get('/ssi.html?c=longok'), qr/x{400}/, 'long ok');
+
+###############################################################################
diff --git a/tests/syslog.t b/tests/syslog.t
new file mode 100644
index 0000000..8f07b74
--- /dev/null
+++ b/tests/syslog.t
@@ -0,0 +1,352 @@
+#!/usr/bin/perl
+
+# (C) Nginx, Inc.
+
+# Tests for syslog.
+# Various log levels emitted with limit_req_log_level.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use IO::Select;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+plan(skip_all => 'win32') if $^O eq 'MSWin32';
+
+my $t = Test::Nginx->new()->has(qw/http limit_req/)->plan(61);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+error_log syslog:server=127.0.0.1:%%PORT_8981_UDP%% info;
+error_log %%TESTDIR%%/f_glob.log info;
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    limit_req_zone $binary_remote_addr zone=one:1m rate=1r/m;
+
+    log_format empty "";
+    log_format logf "$uri:$status";
+
+    error_log syslog:server=127.0.0.1:%%PORT_8982_UDP%% info;
+    error_log %%TESTDIR%%/f_http.log info;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /e {
+            error_log syslog:server=127.0.0.1:%%PORT_8984_UDP%%;
+        }
+        location /a {
+            access_log syslog:server=127.0.0.1:%%PORT_8984_UDP%%;
+        }
+        location /ef {
+            error_log syslog:server=127.0.0.1:%%PORT_8984_UDP%%,facility=user;
+        }
+        location /es {
+            error_log syslog:server=127.0.0.1:%%PORT_8984_UDP%%,severity=alert;
+        }
+        location /et {
+            error_log syslog:server=127.0.0.1:%%PORT_8984_UDP%%,tag=SEETHIS;
+        }
+        location /af {
+            access_log syslog:server=127.0.0.1:%%PORT_8984_UDP%%,facility=user;
+        }
+        location /as {
+            # put severity inside to catch possible parsing programming errors
+            access_log syslog:severity=alert,server=127.0.0.1:%%PORT_8984_UDP%%;
+        }
+        location /at {
+            access_log syslog:server=127.0.0.1:%%PORT_8984_UDP%%,tag=SEETHIS;
+        }
+        location /e2 {
+            error_log syslog:server=127.0.0.1:%%PORT_8984_UDP%%;
+            error_log syslog:server=127.0.0.1:%%PORT_8984_UDP%%;
+        }
+        location /a2 {
+            access_log syslog:server=127.0.0.1:%%PORT_8984_UDP%%;
+            access_log syslog:server=127.0.0.1:%%PORT_8984_UDP%%;
+        }
+        location /a_logf {
+            access_log syslog:server=127.0.0.1:%%PORT_8984_UDP%% logf;
+        }
+        location /if {
+            access_log syslog:server=127.0.0.1:%%PORT_8983_UDP%% logf
+                if=$arg_logme;
+        }
+
+        location /nohostname {
+            access_log syslog:server=127.0.0.1:%%PORT_8984_UDP%%,nohostname;
+        }
+
+        location /debug {
+            limit_req zone=one;
+            error_log syslog:server=127.0.0.1:%%PORT_8984_UDP%% debug;
+        }
+        location /info {
+            limit_req zone=one;
+            limit_req_log_level info;
+            error_log syslog:server=127.0.0.1:%%PORT_8984_UDP%% info;
+        }
+        location /notice {
+            limit_req zone=one;
+            limit_req_log_level notice;
+            error_log syslog:server=127.0.0.1:%%PORT_8984_UDP%% notice;
+        }
+        location /warn {
+            limit_req zone=one;
+            limit_req_log_level warn;
+            error_log syslog:server=127.0.0.1:%%PORT_8984_UDP%% warn;
+        }
+        location /error {
+            limit_req zone=one;
+            limit_req_log_level error;
+            error_log syslog:server=127.0.0.1:%%PORT_8984_UDP%%;
+        }
+        location /low {
+            error_log syslog:server=127.0.0.1:%%PORT_8984_UDP%% warn;
+            error_log syslog:server=127.0.0.1:%%PORT_8984_UDP%%;
+        }
+        location /dup {
+            error_log syslog:server=127.0.0.1:%%PORT_8984_UDP%%;
+            error_log syslog:server=127.0.0.1:%%PORT_8984_UDP%%;
+        }
+        location /high {
+            error_log syslog:server=127.0.0.1:%%PORT_8984_UDP%% emerg;
+            error_log syslog:server=127.0.0.1:%%PORT_8984_UDP%%;
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&syslog_daemon, port(8981), $t, 's_glob.log');
+$t->run_daemon(\&syslog_daemon, port(8982), $t, 's_http.log');
+$t->run_daemon(\&syslog_daemon, port(8983), $t, 's_if.log');
+
+$t->waitforfile($t->testdir . '/s_glob.log');
+$t->waitforfile($t->testdir . '/s_http.log');
+$t->waitforfile($t->testdir . '/s_if.log');
+
+$t->run();
+
+###############################################################################
+
+my $s = IO::Socket::INET->new(
+	Proto => 'udp',
+	LocalAddr => '127.0.0.1:' . port(8984)
+)
+	or die "Can't open syslog socket: $!";
+
+parse_syslog_message('error_log', get_syslog('/e'));
+parse_syslog_message('access_log', get_syslog('/a'));
+
+like(get_syslog('/ef'), qr/^<11>/, 'error_log facility');
+like(get_syslog('/es'), qr/^<187>/, 'error_log severity');
+like(get_syslog('/et'), qr/SEETHIS:/, 'error_log tag');
+
+like(get_syslog('/af'), qr/^<14>/, 'access_log facility');
+like(get_syslog('/as'), qr/^<185>/, 'access_log severity');
+like(get_syslog('/at'), qr/SEETHIS:/, 'access_log tag');
+
+
+like(get_syslog('/e'),
+	qr/nginx: \d{4}\/\d{2}\/\d{2} \d{2}:\d{2}:\d{2} \[error\]/,
+	'error_log format');
+like(get_syslog('/a_logf'), qr/nginx: \/a_logf:404$/, 'access_log log_format');
+
+my @lines = split /<\d+>/, get_syslog('/a2');
+is($lines[1], $lines[2], 'access_log many');
+
+@lines = split /<\d+>/, get_syslog('/e2');
+is($lines[1], $lines[2], 'error_log many');
+
+# error_log log levels
+
+SKIP: {
+
+skip "no --with-debug", 1 unless $t->has_module('--with-debug');
+
+isnt(syslog_lines('/debug', '[debug]'), 0, 'debug');
+
+}
+
+# charge limit_req
+
+get_syslog('/info');
+
+is(syslog_lines('/info', '[info]'), 1, 'info');
+is(syslog_lines('/notice', '[notice]'), 1, 'notice');
+is(syslog_lines('/warn', '[warn]'), 1, 'warn');
+is(syslog_lines('/error', '[error]'), 1, 'error');
+
+# count log messages emitted with various error_log levels
+
+is(syslog_lines('/low', '[error]'), 2, 'low');
+is(syslog_lines('/dup', '[error]'), 2, 'dup');
+is(syslog_lines('/high', '[error]'), 1, 'high');
+
+# check for the presence of the syslog messages in the global and http contexts
+
+is_deeply(levels($t, 's_glob.log'), levels($t, 'f_glob.log'), 'master syslog');
+is_deeply(levels($t, 's_http.log'), levels($t, 'f_http.log'), 'http syslog');
+
+http_get('/if');
+http_get('/if/empty?logme=');
+http_get('/if/zero?logme=0');
+http_get('/if/good?logme=1');
+http_get('/if/work?logme=yes');
+
+get_syslog('/a');
+
+like($t->read_file('s_if.log'), qr/good:404.*work:404/s, 'syslog if success');
+unlike($t->read_file('s_if.log'), qr/(if:|empty:|zero:)404/, 'syslog if fail');
+
+like(get_syslog('/nohostname'),
+	qr/^<(\d{1,3})>				# PRI
+	([A-Z][a-z]{2})\s			# mon
+	([ \d]\d)\s(\d{2}):(\d{2}):(\d{2})\s	# date
+	(\w{1,32}):\s				# tag
+	(.*)/x,					# MSG
+	'nohostname');
+
+# send error handling
+
+ok(get_syslog('/a'), 'send success');
+
+close $s;
+
+get_syslog('/a');
+get_syslog('/a');
+
+$s = IO::Socket::INET->new(
+	Proto => 'udp',
+	LocalAddr => '127.0.0.1:' . port(8984)
+)
+	or die "Can't open syslog socket: $!";
+
+ok(get_syslog('/a'), 'send error - recover');
+
+###############################################################################
+
+sub syslog_lines {
+	my ($uri, $pattern, $port) = @_;
+	return map { $_ =~ /\Q$pattern\E/g } (get_syslog($uri));
+}
+
+sub levels {
+	my ($t, $file) = @_;
+	my %levels_hash;
+
+	map { $levels_hash{$_}++; } ($t->read_file($file) =~ /(\[\w+\])/g);
+
+	return \%levels_hash;
+}
+
+sub get_syslog {
+	my ($uri) = @_;
+	my $data = '';
+
+	http_get($uri);
+
+	IO::Select->new($s)->can_read(1);
+	while (IO::Select->new($s)->can_read(0.1)) {
+		my $buffer;
+		sysread($s, $buffer, 4096);
+		$data .= $buffer;
+	}
+	return $data;
+}
+
+sub parse_syslog_message {
+	my ($desc, $line) = @_;
+
+	unless ($line) {
+		fail("$desc timeout in receiving syslog");
+	}
+
+	my @months = ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug',
+		'Sep', 'Oct', 'Nov', 'Dec');
+
+	my ($pri, $mon, $mday, $hour, $minute, $sec, $host, $tag, $msg) =
+		$line =~ /^<(\d{1,3})>				# PRI
+			([A-Z][a-z]{2})\s			# mon
+			([ \d]\d)\s(\d{2}):(\d{2}):(\d{2})\s	# date
+			([\S]*)\s				# host
+			(\w{1,32}):\s				# tag
+			(.*)/x;					# MSG
+
+	my $sev = $pri & 0x07;
+	my $fac = ($pri & 0x03f8) >> 3;
+
+	ok(defined($pri), "$desc has PRI");
+	ok($sev >= 0 && $sev <= 7, "$desc valid severity");
+	ok($fac >= 0 && $fac < 24, "$desc valid facility");
+
+	ok(defined($mon), "$desc has month");
+	ok((grep $mon, @months), "$desc valid month");
+
+	ok(defined($mday), "$desc has day");
+	ok($mday <= 31, "$desc valid day");
+
+	ok(defined($hour), "$desc has hour");
+	ok($hour < 24, "$desc valid hour");
+
+	ok(defined($minute), "$desc has minutes");
+	ok($minute < 60, "$desc valid minutes");
+
+	ok(defined($sec), "$desc has seconds");
+	ok($sec < 60, "$desc valid seconds");
+
+	ok(defined($host), "$desc has host");
+	chomp(my $hostname = lc `hostname`);
+	is($host , $hostname, "$desc valid host");
+
+	ok(defined($tag), "$desc has tag");
+	like($tag, qr'\w+', "$desc valid tag");
+
+	ok(length($msg) > 0, "$desc valid CONTENT");
+}
+
+###############################################################################
+
+sub syslog_daemon {
+	my ($port, $t, $file) = @_;
+
+	my $s = IO::Socket::INET->new(
+		Proto => 'udp',
+		LocalAddr => "127.0.0.1:$port"
+	);
+
+	open my $fh, '>', $t->testdir() . '/' . $file;
+	select $fh; $| = 1;
+
+	while (1) {
+		my $buffer;
+		$s->recv($buffer, 4096);
+		print $fh $buffer . "\n";
+	}
+}
+
+###############################################################################
diff --git a/tests/trailers.t b/tests/trailers.t
new file mode 100644
index 0000000..aa220c4
--- /dev/null
+++ b/tests/trailers.t
@@ -0,0 +1,134 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for trailers in headers filter module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/ $CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy/)->plan(17)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        add_trailer  X-Var $host;
+        add_trailer  X-Always $host always;
+        add_trailer  X-Empty '';
+        add_trailer  X-Sent-HTTP $sent_http_accept_ranges;
+        add_trailer  X-Sent-Trailer $sent_trailer_x_var;
+        add_trailer  X-Complex $host:$host;
+
+        location /t1 {
+        }
+
+        location /nx {
+        }
+
+        location /header {
+            add_header X-Var foo;
+        }
+
+        location /empty {
+            add_trailer X-Var $host;
+        }
+
+        location /not_chunked {
+            chunked_transfer_encoding off;
+        }
+
+        location /proxy {
+            proxy_pass http://127.0.0.1:8080/t1;
+            add_trailer X-Length $upstream_response_length;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('t1', 'SEE-THIS');
+$t->write_file('header', '');
+$t->run();
+
+###############################################################################
+
+my $r;
+
+$r = get('/t1');
+like($r, qr/8${CRLF}SEE-THIS${CRLF}0${CRLF}(.+${CRLF}){5}$CRLF/, 'trailers');
+unlike($r, qr/X-Var.*SEE-THIS/s, 'not in headers');
+like($r, qr/X-Var: localhost/, 'add_trailer');
+like($r, qr/X-Always/, 'add_trailer always');
+like($r, qr/X-Sent-HTTP: bytes/, 'add_trailer sent_http');
+like($r, qr/X-Sent-Trailer: localhost/, 'add_trailer sent_trailer');
+like($r, qr/X-Complex: localhost:localhost/, 'add_trailer complex');
+unlike($r, qr/X-Empty/, 'add_trailer empty');
+
+$r = get('/nx');
+unlike($r, qr/X-Var/, 'add_trailer bad');
+like($r, qr/X-Always/, 'add_trailer bad always');
+
+like(get('/header'), qr/foo.*^0$CRLF.*X-Var: localhost/ms, 'header name');
+
+like(http_get('/t1'), qr/${CRLF}SEE-THIS$/, 'no trailers - http10');
+unlike(get('/not_chunked'), qr/X-Always/, 'no trailers - not chunked');
+unlike(head('/t1'), qr/X-Always/, 'no trailers - head');
+
+unlike(get('/empty'), qr/X-Var/, 'no trailers expected');
+
+$r = get('/proxy');
+like($r, qr/SEE-THIS.*X-Length: 8/ms, 'upstream response variable');
+unlike($r, qr/X-Var/, 'inheritance');
+
+###############################################################################
+
+sub get {
+	my ($uri) = @_;
+	http(<<EOF);
+GET $uri HTTP/1.1
+Host: localhost
+Connection: close
+
+EOF
+}
+
+sub head {
+	my ($uri) = @_;
+	http(<<EOF);
+HEAD $uri HTTP/1.1
+Host: localhost
+Connection: close
+
+EOF
+}
+
+###############################################################################
diff --git a/tests/upstream.t b/tests/upstream.t
new file mode 100644
index 0000000..0d27766
--- /dev/null
+++ b/tests/upstream.t
@@ -0,0 +1,160 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for upstream module and balancers.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy/)->plan(3);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    upstream u {
+        server 127.0.0.1:8081 max_fails=3 fail_timeout=10s;
+        server 127.0.0.1:8082 max_fails=3 fail_timeout=10s;
+    }
+
+    upstream u2 {
+        server 127.0.0.1:8081 max_fails=3 fail_timeout=10s;
+        server 127.0.0.1:8082 max_fails=3 fail_timeout=10s;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            proxy_pass http://u;
+        }
+        location /close2 {
+            proxy_pass http://u2;
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&http_daemon, port(8081));
+$t->run_daemon(\&http_daemon, port(8082));
+$t->run();
+
+$t->waitforsocket('127.0.0.1:' . port(8081));
+$t->waitforsocket('127.0.0.1:' . port(8082));
+
+###############################################################################
+
+my @ports = my ($p1, $p2) = (port(8081), port(8082));
+
+is(many('/', 30), "$p1: 15, $p2: 15", 'balanced');
+
+# from 9 first requests to the first port, only 6 will be successful,
+# 3rd, 6th, and 9th requests will fail; after this the backend
+# will be considered down and won't be used till fail_timeout passes
+
+is(many('/close', 30), "$p1: 6, $p2: 24", 'failures');
+
+SKIP: {
+skip 'long test', 1 unless $ENV{TEST_NGINX_UNSAFE};
+
+# bug: failures counter is reset if first request in a second succeeds
+#
+# delay added to make sure first 9 requests will take more than 1s;
+# note that the test is racy and may unexpectedly succeed
+
+is(many('/close2', 30, delay => 0.2), "$p1: 6, $p2: 24", 'failures delay');
+
+}
+
+###############################################################################
+
+sub many {
+	my ($uri, $count, %opts) = @_;
+	my %ports;
+
+	for (1 .. $count) {
+		if (http_get($uri) =~ /X-Port: (\d+)/) {
+			$ports{$1} = 0 unless defined $ports{$1};
+			$ports{$1}++;
+		}
+
+		select undef, undef, undef, $opts{delay} if $opts{delay};
+	}
+
+	my @keys = map { my $p = $_; grep { $p == $_ } keys %ports } @ports;
+	return join ', ', map { $_ . ": " . $ports{$_} } @keys;
+}
+
+###############################################################################
+
+sub http_daemon {
+	my ($port) = @_;
+	my $count = 1;
+
+	my $server = IO::Socket::INET->new(
+		Proto => 'tcp',
+		LocalHost => '127.0.0.1',
+		LocalPort => $port,
+		Listen => 5,
+		Reuse => 1
+	)
+		or die "Can't create listening socket: $!\n";
+
+	local $SIG{PIPE} = 'IGNORE';
+
+	while (my $client = $server->accept()) {
+		$client->autoflush(1);
+
+		my $headers = '';
+		my $uri = '';
+
+		while (<$client>) {
+			$headers .= $_;
+			last if (/^\x0d?\x0a?$/);
+		}
+
+		$uri = $1 if $headers =~ /^\S+\s+([^ ]+)\s+HTTP/i;
+
+		if ($uri =~ 'close' && $port == port(8081) && $count++ % 3 == 0)
+		{
+			next;
+		}
+
+		print $client <<EOF;
+HTTP/1.1 200 OK
+Connection: close
+X-Port: $port
+
+OK
+EOF
+
+		close $client;
+	}
+}
+
+###############################################################################
diff --git a/tests/upstream_hash.t b/tests/upstream_hash.t
new file mode 100644
index 0000000..8edbe95
--- /dev/null
+++ b/tests/upstream_hash.t
@@ -0,0 +1,261 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for upstream hash balancer module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy rewrite upstream_hash/)->plan(15);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    upstream u {
+        hash $arg_a;
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8082;
+        server 127.0.0.1:8083;
+    }
+
+    upstream u2 {
+        hash $arg_a;
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8083;
+    }
+
+    upstream cw {
+        hash $arg_a consistent;
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8082;
+        server 127.0.0.1:8083 weight=10;
+    }
+
+    upstream cw2 {
+        hash $arg_a consistent;
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8083 weight=10;
+    }
+
+    upstream c {
+        hash $arg_a consistent;
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8082;
+        server 127.0.0.1:8083;
+    }
+
+    upstream c2 {
+        hash $arg_a consistent;
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8083;
+    }
+
+    upstream bad {
+        hash $arg_a;
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8084;
+    }
+
+    upstream cbad {
+        hash $arg_a consistent;
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8084;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            proxy_pass http://u;
+        }
+        location /2 {
+            proxy_pass http://u2;
+        }
+        location /cw {
+            proxy_pass http://cw;
+        }
+        location /cw2 {
+            proxy_pass http://cw2;
+        }
+        location /c {
+            proxy_pass http://c;
+        }
+        location /c2 {
+            proxy_pass http://c2;
+        }
+        location /bad {
+            proxy_pass http://bad;
+        }
+        location /cbad {
+            proxy_pass http://cbad;
+        }
+        location /busy {
+            proxy_pass http://bad/busy;
+            add_header X-IP $upstream_addr always;
+        }
+        location /cbusy {
+            proxy_pass http://cbad/busy;
+            add_header X-IP $upstream_addr always;
+        }
+        location /pnu {
+            proxy_pass http://u/;
+            proxy_next_upstream http_502;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        listen       127.0.0.1:8082;
+        listen       127.0.0.1:8083;
+        server_name  localhost;
+
+        add_header X-Port $server_port;
+
+        location / {
+            return 204;
+        }
+
+        location /502 {
+            if ($server_port = %%PORT_8083%%) {
+                return 502;
+            }
+            return 204;
+        }
+
+        location /busy {
+            return 444;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8084;
+        server_name  localhost;
+        return 444;
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+my @ports = my ($p1, $p2, $p3) = (port(8081), port(8082), port(8083));
+
+# Only requests for absent peer are moved to other peers if hash is consistent.
+# Check this by comparing two upstreams with different number of peers.
+
+ok(!cmp_peers([iter('/', 20)], [iter('/2', 20)], $p2), 'inconsistent');
+ok(cmp_peers([iter('/c', 20)], [iter('/c2', 20)], $p2), 'consistent');
+ok(cmp_peers([iter('/cw', 20)], [iter('/cw2', 20)], $p2), 'consistent weight');
+
+like(many('/?a=1', 10), qr/($p1|$p2|$p3): 10/, 'stable hash');
+like(many('/c?a=1', 10), qr/($p1|$p2|$p3): 10/, 'stable hash - consistent');
+
+# fallback to round-robin
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.17.1');
+
+like(many('/?a=', 6), qr/$p1: 2, $p2: 2, $p3: 2/, 'empty key');
+like(many('/c?a=', 6), qr/$p1: 2, $p2: 2, $p3: 2/, 'empty key - consistent');
+
+}
+
+my @res = iter('/', 10);
+
+is(@res, 10, 'all hashed peers');
+
+@res = grep { $_ != $p3 } @res;
+my @res2 = iter('/502', 10);
+
+is_deeply(\@res, \@res2, 'no proxy_next_upstream');
+isnt(@res2, 10, 'no proxy_next_upstream peers');
+
+is(iter('/pnu/502', 10), 10, 'proxy_next_upstream peers');
+
+@res = grep { $_ == $p1 } iter('/bad', 20);
+is(@res, 20, 'all hashed peers - bad');
+
+@res = grep { $_ == $p1 } iter('/cbad', 20);
+is(@res, 20, 'all hashed peers - bad consistent');
+
+like(http_get('/busy'), qr/X-IP: 127.0.0.1:$p1, bad/,
+	'upstream name - busy');
+like(http_get('/cbusy'), qr/X-IP: 127.0.0.1:$p1, cbad/,
+	'upstream name - busy consistent');
+
+###############################################################################
+
+# Returns true if two arrays follow consistency, i.e., they may only differ
+# by @args present in $p, but absent in $p2, for the same indices.
+
+sub cmp_peers {
+	my ($p, $p2, @args) = @_;
+
+	for my $i (0 .. $#$p) {
+		next if @{$p}[$i] == @{$p2}[$i];
+		next if (grep $_ == @{$p}[$i], @args);
+		return 0;
+	}
+
+	return 1;
+}
+
+# series of requests, each with unique hash key
+
+sub iter {
+	my ($uri, $count) = @_;
+	my @res;
+
+	for my $i (1 .. $count) {
+		if (http_get("$uri/?a=$i") =~ /X-Port: (\d+)/) {
+			push @res, $1 if defined $1;
+		}
+	}
+
+	return @res;
+}
+
+sub many {
+	my ($uri, $count) = @_;
+	my %ports;
+
+	for (1 .. $count) {
+		if (http_get($uri) =~ /X-Port: (\d+)/) {
+			$ports{$1} = 0 unless defined $ports{$1};
+			$ports{$1}++;
+		}
+	}
+
+	my @keys = map { my $p = $_; grep { $p == $_ } keys %ports } @ports;
+	return join ', ', map { $_ . ": " . $ports{$_} } @keys;
+}
+
+###############################################################################
diff --git a/tests/upstream_hash_memcached.t b/tests/upstream_hash_memcached.t
new file mode 100644
index 0000000..994874f
--- /dev/null
+++ b/tests/upstream_hash_memcached.t
@@ -0,0 +1,188 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for upstream hash balancer module distribution consistency
+# with Cache::Memcached and Cache::Memcached::Fast.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require Cache::Memcached; };
+plan(skip_all => 'Cache::Memcached not installed') if $@;
+eval { require Cache::Memcached::Fast; };
+plan(skip_all => 'Cache::Memcached::Fast not installed') if $@;
+
+my $t = Test::Nginx->new()->has(qw/http rewrite memcached upstream_hash/)
+	->has_daemon('memcached')->plan(4);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    upstream memd {
+        hash $arg_a;
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8082;
+        server 127.0.0.1:8083;
+    }
+
+    upstream memd_c {
+        hash $arg_a consistent;
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8082;
+        server 127.0.0.1:8083;
+    }
+
+    upstream memd_w {
+        hash $arg_a;
+        server 127.0.0.1:8081 weight=2;
+        server 127.0.0.1:8082 weight=3;
+        server 127.0.0.1:8083;
+    }
+
+    upstream memd_cw {
+        hash $arg_a consistent;
+        server 127.0.0.1:8081 weight=2;
+        server 127.0.0.1:8082 weight=3;
+        server 127.0.0.1:8083;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        set $memcached_key $arg_a;
+
+        location / {
+            memcached_pass memd;
+        }
+        location /c {
+            memcached_pass memd_c;
+        }
+        location /w {
+            memcached_pass memd_w;
+        }
+        location /cw {
+            memcached_pass memd_cw;
+        }
+    }
+}
+
+EOF
+
+my $memhelp = `memcached -h`;
+my @memopts = ();
+
+if ($memhelp =~ /repcached/) {
+	# repcached patch adds additional listen socket
+	push @memopts, '-X', '0';
+}
+if ($memhelp =~ /-U/) {
+	# UDP port is on by default in memcached 1.2.7+
+	push @memopts, '-U', '0';
+}
+
+$t->run_daemon('memcached', '-l', '127.0.0.1', '-p', port(8081), @memopts);
+$t->run_daemon('memcached', '-l', '127.0.0.1', '-p', port(8082), @memopts);
+$t->run_daemon('memcached', '-l', '127.0.0.1', '-p', port(8083), @memopts);
+$t->run();
+
+$t->waitforsocket('127.0.0.1:' . port(8081)) or die "Can't start memcached";
+$t->waitforsocket('127.0.0.1:' . port(8082)) or die "Can't start memcached";
+$t->waitforsocket('127.0.0.1:' . port(8083)) or die "Can't start memcached";
+
+###############################################################################
+
+my $memd1 = Cache::Memcached->new(servers => [ '127.0.0.1:' . port(8081) ],
+	connect_timeout => 1.0);
+my $memd2 = Cache::Memcached->new(servers => [ '127.0.0.1:' . port(8082) ],
+	connect_timeout => 1.0);
+my $memd3 = Cache::Memcached->new(servers => [ '127.0.0.1:' . port(8083) ],
+	connect_timeout => 1.0);
+
+for my $i (1 .. 20) {
+	$memd1->set($i, port(8081)) or die "can't put value into memcached: $!";
+	$memd2->set($i, port(8082)) or die "can't put value into memcached: $!";
+	$memd3->set($i, port(8083)) or die "can't put value into memcached: $!";
+}
+
+my $memd = new Cache::Memcached(servers => [
+	'127.0.0.1:' . port(8081),
+	'127.0.0.1:' . port(8082),
+	'127.0.0.1:' . port(8083) ]);
+
+is_deeply(ngx('/'), mem($memd), 'cache::memcached');
+
+$memd = new Cache::Memcached::Fast({ ketama_points => 160, servers => [
+	'127.0.0.1:' . port(8081),
+	'127.0.0.1:' . port(8082),
+	'127.0.0.1:' . port(8083)] });
+
+# Cache::Memcached::Fast may be incompatible with recent Perl,
+# see https://github.com/JRaspass/Cache-Memcached-Fast/issues/12
+
+my $cmf_bug = ! keys %{$memd->server_versions};
+
+SKIP: {
+skip 'Cache::Memcached::Fast bug', 1 if $cmf_bug;
+
+is_deeply(ngx('/c'), mem($memd), 'cache::memcached::fast');
+
+}
+
+$memd = new Cache::Memcached(servers => [
+	[ '127.0.0.1:' . port(8081), 2 ],
+	[ '127.0.0.1:' . port(8082), 3 ],
+	[ '127.0.0.1:' . port(8083), 1 ]]);
+
+is_deeply(ngx('/w'), mem($memd), 'cache::memcached weight');
+
+$memd = new Cache::Memcached::Fast({ ketama_points => 160, servers => [
+	{ address => '127.0.0.1:' . port(8081), weight => 2 },
+	{ address => '127.0.0.1:' . port(8082), weight => 3 },
+	{ address => '127.0.0.1:' . port(8083), weight => 1 }] });
+
+SKIP: {
+skip 'Cache::Memcached::Fast bug', 1 if $cmf_bug;
+
+is_deeply(ngx('/cw'), mem($memd), 'cache::memcached::fast weight');
+
+}
+
+###############################################################################
+
+sub ngx {
+	my ($uri) = @_;
+	[ map { http_get("/$uri?a=$_") =~ /^(\d+)/ms && $1; } (1 .. 20) ];
+}
+
+sub mem {
+	my ($memd) = @_;
+	[ map { $memd->get($_); } (1 .. 20) ];
+}
+
+###############################################################################
diff --git a/tests/upstream_ip_hash.t b/tests/upstream_ip_hash.t
new file mode 100644
index 0000000..2516a83
--- /dev/null
+++ b/tests/upstream_ip_hash.t
@@ -0,0 +1,123 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for upstream ip_hash balancer.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy upstream_ip_hash realip rewrite/)
+	->write_file_expand('nginx.conf', <<'EOF')->run();
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    upstream u {
+        ip_hash;
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8082;
+    }
+
+    upstream u2 {
+        ip_hash;
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8082;
+        server 127.0.0.1:8083;
+    }
+
+    upstream s {
+        ip_hash;
+        server 127.0.0.1:8081;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        set_real_ip_from 127.0.0.0/8;
+        add_header X-IP $remote_addr;
+
+        location / {
+            proxy_pass http://u;
+        }
+        location /u2 {
+            proxy_pass http://u2;
+        }
+        location /s {
+            proxy_pass http://s;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        listen       127.0.0.1:8082;
+        listen       127.0.0.1:8083;
+        server_name  localhost;
+
+        location / {
+            add_header X-Port $server_port;
+            return 204;
+        }
+    }
+}
+
+EOF
+
+plan(skip_all => 'no 127.0.0.1 on host')
+	if http_get('/') !~ /X-IP: 127.0.0.1/m;
+
+$t->plan(3);
+
+###############################################################################
+
+my @ports = my ($port1, $port2, $port3) = (port(8081), port(8082), port(8083));
+
+is(many('/', 30), "$port1: 15, $port2: 15", 'ip_hash');
+is(many('/u2', 30), "$port1: 10, $port2: 10, $port3: 10", 'ip_hash 3 peers');
+is(many('/s', 30), "$port1: 30", 'ip_hash single peer');
+
+###############################################################################
+
+sub many {
+	my ($uri, $count) = @_;
+	my %ports;
+
+	for my $i (1 .. $count) {
+		my $req = "GET $uri HTTP/1.0" . CRLF
+			. "X-Real-IP: 127.0.$i.2" . CRLF . CRLF;
+
+		if (http($req) =~ /X-Port: (\d+)/) {
+			$ports{$1} = 0 unless defined $ports{$1};
+			$ports{$1}++;
+		}
+	}
+
+	my @keys = map { my $p = $_; grep { $p == $_ } keys %ports } @ports;
+	return join ', ', map { $_ . ": " . $ports{$_} } @keys;
+}
+
+###############################################################################
diff --git a/tests/upstream_ip_hash_ipv6.t b/tests/upstream_ip_hash_ipv6.t
new file mode 100644
index 0000000..3850229
--- /dev/null
+++ b/tests/upstream_ip_hash_ipv6.t
@@ -0,0 +1,153 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for upstream ip_hash balancer with IPv6 and unix sockets.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy upstream_ip_hash realip unix/)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    upstream u {
+        ip_hash;
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8082;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        add_header X-IP $remote_addr always;
+
+        location / {
+            set_real_ip_from 127.0.0.0/8;
+            proxy_pass http://u;
+        }
+
+        location /unix {
+            proxy_pass http://unix:%%TESTDIR%%/unix.sock;
+            proxy_set_header X-Real-IP $http_x_real_ip;
+        }
+
+        location /ipv6 {
+            proxy_pass http://[::1]:%%PORT_8080%%;
+            proxy_set_header X-Real-IP $http_x_real_ip;
+        }
+    }
+
+    server {
+        listen       unix:%%TESTDIR%%/unix.sock;
+        listen       [::1]:%%PORT_8080%%;
+        server_name  localhost;
+
+        location / {
+            set_real_ip_from unix:;
+            set_real_ip_from ::1;
+            proxy_pass http://u;
+        }
+
+        location /unix/none {
+            proxy_pass http://u;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        listen       127.0.0.1:8082;
+        server_name  localhost;
+
+        location / {
+            add_header X-Port $server_port always;
+        }
+    }
+}
+
+EOF
+
+$t->try_run('no inet6 support');
+
+plan(skip_all => 'no 127.0.0.1 on host')
+	if http_get('/') !~ /X-IP: 127.0.0.1/m;
+
+$t->plan(4);
+
+###############################################################################
+
+my @ports = my ($port1, $port2) = (port(8081), port(8082));
+
+is(many('/unix', 30), "$port1: 15, $port2: 15", 'ip_hash realip via unix');
+is(many('/ipv6', 30), "$port1: 15, $port2: 15", 'ip_hash realip via ipv6');
+
+is(many_ip6('/', 30), "$port1: 15, $port2: 15", 'ip_hash ipv6');
+like(many('/unix/none', 30), qr/($port1|$port2): 30/, 'ip_hash unix');
+
+###############################################################################
+
+sub many {
+	my ($uri, $count) = @_;
+	my %ports;
+
+	for my $i (1 .. $count) {
+		my $req = "GET $uri HTTP/1.0" . CRLF
+			. "X-Real-IP: 127.0.$i.2" . CRLF . CRLF;
+
+		if (http($req) =~ /X-Port: (\d+)/) {
+			$ports{$1} = 0 unless defined $ports{$1};
+			$ports{$1}++;
+		}
+	}
+
+	my @keys = map { my $p = $_; grep { $p == $_ } keys %ports } @ports;
+	return join ', ', map { $_ . ": " . $ports{$_} } @keys;
+}
+
+sub many_ip6 {
+	my ($uri, $count) = @_;
+	my %ports;
+
+	for my $i (1 .. $count) {
+		my $req = "GET $uri HTTP/1.0" . CRLF
+			. "X-Real-IP: ::$i" . CRLF . CRLF;
+
+		if (http($req) =~ /X-Port: (\d+)/) {
+			$ports{$1} = 0 unless defined $ports{$1};
+			$ports{$1}++;
+		}
+	}
+
+	my @keys = map { my $p = $_; grep { $p == $_ } keys %ports } @ports;
+	return join ', ', map { $_ . ": " . $ports{$_} } @keys;
+}
+
+###############################################################################
diff --git a/tests/upstream_keepalive.t b/tests/upstream_keepalive.t
new file mode 100644
index 0000000..5253bf6
--- /dev/null
+++ b/tests/upstream_keepalive.t
@@ -0,0 +1,93 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for upstream keepalive, keepalive_requests and keepalive_timeout.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy upstream_keepalive/)->plan(7)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    upstream backend {
+        server 127.0.0.1:8081;
+        keepalive 1;
+        keepalive_requests 3;
+        keepalive_timeout 2s;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        proxy_http_version 1.1;
+        proxy_set_header Connection $args;
+
+        location / {
+            proxy_pass http://backend;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location / {
+            add_header X-Connection $connection;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('index.html', 'SEE-THIS');
+$t->run();
+
+###############################################################################
+
+my ($r, $n);
+
+# keepalive_requests
+
+like($r = http_get('/'), qr/SEE-THIS/, 'request');
+$r =~ m/X-Connection: (\d+)/; $n = $1;
+like(http_get('/'), qr/X-Connection: $n.*SEE/ms, 'keepalive');
+like(http_get('/'), qr/X-Connection: $n.*SEE/ms, 'keepalive again');
+like(http_get('/'), qr/X-Connection: (?!$n).*SEE/ms, 'keepalive requests');
+http_get('/?close');
+
+# keepalive_timeout
+
+like($r = http_get('/'), qr/SEE-THIS/, 'request timer');
+$r =~ m/X-Connection: (\d+)/; $n = $1;
+like(http_get('/'), qr/X-Connection: $n.*SEE/ms, 'keepalive timer');
+select undef, undef, undef, 2.5;
+like(http_get('/'), qr/X-Connection: (?!$n).*SEE/ms, 'keepalive timeout');
+
+###############################################################################
diff --git a/tests/upstream_least_conn.t b/tests/upstream_least_conn.t
new file mode 100644
index 0000000..4ef5bed
--- /dev/null
+++ b/tests/upstream_least_conn.t
@@ -0,0 +1,141 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for upstream least_conn balancer module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx qw/ :DEFAULT http_end /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy upstream_least_conn/)->plan(2);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    upstream u {
+        least_conn;
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8082;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            proxy_pass http://u;
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&http_daemon, port(8081));
+$t->run_daemon(\&http_daemon, port(8082));
+$t->run();
+
+$t->waitforsocket('127.0.0.1:' . port(8081));
+$t->waitforsocket('127.0.0.1:' . port(8082));
+
+###############################################################################
+
+my @ports = my ($port1, $port2) = (port(8081), port(8082));
+
+is(many('/', 10), "$port1: 5, $port2: 5", 'balanced');
+
+my @sockets;
+push(@sockets, http_get('/w', start => 1));
+push(@sockets, http_get('/w', start => 1));
+
+select undef, undef, undef, 0.2;
+
+is(many('/w', 10), "$port2: 10", 'least conn');
+
+###############################################################################
+
+sub many {
+	my ($uri, $count) = @_;
+	my %ports;
+
+	for (1 .. $count) {
+		if (http_get($uri) =~ /X-Port: (\d+)/) {
+			$ports{$1} = 0 unless defined $ports{$1};
+			$ports{$1}++;
+		}
+	}
+
+	my @keys = map { my $p = $_; grep { $p == $_ } keys %ports } @ports;
+	return join ', ', map { $_ . ": " . $ports{$_} } @keys;
+}
+
+###############################################################################
+
+sub http_daemon {
+	my ($port) = @_;
+
+	my $server = IO::Socket::INET->new(
+		Proto => 'tcp',
+		LocalHost => '127.0.0.1',
+		LocalPort => $port,
+		Listen => 5,
+		Reuse => 1
+	)
+		or die "Can't create listening socket: $!\n";
+
+	local $SIG{PIPE} = 'IGNORE';
+
+	while (my $client = $server->accept()) {
+		$client->autoflush(1);
+
+		my $headers = '';
+		my $uri = '';
+
+		while (<$client>) {
+			$headers .= $_;
+			last if (/^\x0d?\x0a?$/);
+		}
+
+		$uri = $1 if $headers =~ /^\S+\s+([^ ]+)\s+HTTP/i;
+
+		if ($uri eq '/w' && $port == port(8081)) {
+			Test::Nginx::log_core('||', "$port: sleep(2.5)");
+			select undef, undef, undef, 2.5;
+		}
+
+		Test::Nginx::log_core('||', "$port: response, 200");
+		print $client <<EOF;
+HTTP/1.1 200 OK
+Connection: close
+X-Port: $port
+
+OK
+EOF
+
+		close $client;
+	}
+}
+
+###############################################################################
diff --git a/tests/upstream_max_conns.t b/tests/upstream_max_conns.t
new file mode 100644
index 0000000..5c9318c
--- /dev/null
+++ b/tests/upstream_max_conns.t
@@ -0,0 +1,375 @@
+#!/usr/bin/perl
+
+# (C) Nginx, Inc.
+
+# Tests for upstream module with max_conns feature.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use IO::Select;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx qw/ :DEFAULT http_end /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy rewrite upstream_least_conn/)
+	->has(qw/upstream_ip_hash upstream_hash/)->plan(16);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    upstream u_unlim {
+        server 127.0.0.1:8081 max_conns=0;
+        server 127.0.0.1:8082;
+    }
+    upstream u_lim {
+        server 127.0.0.1:8081 max_conns=3;
+    }
+
+    upstream u_backup {
+        server 127.0.0.1:8081 max_conns=2;
+        server 127.0.0.1:8082 backup;
+    }
+    upstream u_backup_lim {
+        server 127.0.0.1:8081 max_conns=2;
+        server 127.0.0.1:8082 backup max_conns=3;
+    }
+
+    upstream u_two {
+        server 127.0.0.1:8081 max_conns=1;
+        server 127.0.0.1:8082 max_conns=1;
+    }
+    upstream u_some {
+        server 127.0.0.1:8081 max_conns=1;
+        server 127.0.0.1:8082;
+    }
+    upstream u_many {
+        server 127.0.0.1:8081 max_conns=1;
+        server 127.0.0.1:8081 max_conns=1;
+        server 127.0.0.1:8082;
+    }
+
+    upstream u_weight {
+        server 127.0.0.1:8081 weight=2 max_conns=1;
+        server 127.0.0.1:8082;
+    }
+
+    upstream u_pnu {
+        # special server to force next upstream
+        server 127.0.0.1:8084;
+
+        server 127.0.0.1:8081 max_conns=1;
+        server 127.0.0.1:8082 max_conns=2;
+    }
+
+    upstream u_lc {
+        least_conn;
+        server 127.0.0.1:8081 max_conns=1;
+        server 127.0.0.1:8082;
+    }
+    upstream u_lc_backup {
+        least_conn;
+        server 127.0.0.1:8081 max_conns=2;
+        server 127.0.0.1:8082 backup;
+    }
+    upstream u_lc_backup_lim {
+        least_conn;
+        server 127.0.0.1:8081 max_conns=2;
+        server 127.0.0.1:8082 backup max_conns=3;
+    }
+
+    upstream u_ih {
+        ip_hash;
+        server 127.0.0.1:8081 max_conns=1;
+        server 127.0.0.1:8082 max_conns=2;
+    }
+
+    upstream u_hash {
+        hash $remote_addr;
+        server 127.0.0.1:8081 max_conns=1;
+        server 127.0.0.1:8082 max_conns=2;
+    }
+    upstream u_chash {
+        hash $remote_addr consistent;
+        server 127.0.0.1:8081 max_conns=1;
+        server 127.0.0.1:8082 max_conns=2;
+    }
+
+    server {
+        listen       127.0.0.1:8084;
+        server_name  localhost;
+
+        location / {
+            return 444;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        proxy_http_version 1.1;
+        proxy_set_header Connection "";
+        proxy_buffering off;
+
+        location /u {
+            proxy_pass http:/$uri;
+        }
+
+        location /close {
+            proxy_pass http://127.0.0.1:8085;
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&http_daemon, port(8081), port(8082), port(8085));
+$t->run();
+
+$t->waitforsocket('127.0.0.1:' . port(8081));
+$t->waitforsocket('127.0.0.1:' . port(8082));
+$t->waitforsocket('127.0.0.1:' . port(8085));
+
+###############################################################################
+
+my @ports = my ($p1, $p2) = (port(8081), port(8082));
+
+# two peers without max_conns
+
+is(parallel('/u_unlim?delay=0', 4), "$p1: 2, $p2: 2", 'unlimited');
+
+# reopen connection to test connection subtraction
+
+my @s = http_get_multi('/u_lim', 2, 1.1);
+http_get('/u_lim/close');
+push @s, http_get_multi('/u_lim', 1, 1.1);
+http_get('/closeall');
+
+is(http_end_multi(\@s), "$p1: 3", 'conn subtraction');
+
+# simple test with limited peer
+
+is(parallel('/u_lim', 4), "$p1: 3", 'single');
+
+# limited peer with backup peer
+
+is(peers('/u_backup', 6), "$p1 $p1 $p2 $p2 $p2 $p2", 'backup');
+
+# peer and backup peer, both limited
+
+is(peers('/u_backup_lim', 6), "$p1 $p1 $p2 $p2 $p2 ", 'backup limited');
+
+# all peers limited
+
+is(parallel('/u_two', 4), "$p1: 1, $p2: 1", 'all peers');
+
+# subset of peers limited
+
+is(parallel('/u_some', 4), "$p1: 1, $p2: 3", 'some peers');
+
+# ensure that peer "weight" does not affect its max_conns limit
+
+is(parallel('/u_weight', 4), "$p1: 1, $p2: 3", 'weight');
+
+# peers with equal server value aggregate max_conns limit
+
+is(parallel('/u_many', 6), "$p1: 2, $p2: 4", 'equal peer');
+
+# connections to peer selected with proxy_next_upstream are counted
+
+is(parallel('/u_pnu', 4), "$p1: 1, $p2: 2", 'proxy_next_upstream');
+
+# least_conn balancer tests
+
+is(parallel('/u_lc', 4), "$p1: 1, $p2: 3", 'least_conn');
+is(peers('/u_lc_backup', 6), "$p1 $p1 $p2 $p2 $p2 $p2", 'least_conn backup');
+is(peers('/u_lc_backup_lim', 6), "$p1 $p1 $p2 $p2 $p2 ",
+	'least_conn backup limited');
+
+# ip_hash balancer tests
+
+is(parallel('/u_ih', 4), "$p1: 1, $p2: 2", 'ip_hash');
+
+# hash balancer tests
+
+is(parallel('/u_hash', 4), "$p1: 1, $p2: 2", 'hash');
+is(parallel('/u_chash', 4), "$p1: 1, $p2: 2", 'hash consistent');
+
+###############################################################################
+
+sub peers {
+	my ($uri, $count) = @_;
+
+	my @sockets = http_get_multi($uri, $count, 1.1);
+	http_get('/closeall');
+
+	join ' ', map { /X-Port: (\d+)/ && $1 }
+		map { http_end $_ } (@sockets);
+}
+
+sub parallel {
+	my ($uri, $count) = @_;
+
+	my @sockets = http_get_multi($uri, $count);
+	for (1 .. 20) {
+		last if IO::Select->new(@sockets)->can_read(3) == $count;
+		select undef, undef, undef, 0.01;
+	}
+	http_get('/closeall');
+	return http_end_multi(\@sockets);
+}
+
+sub http_get_multi {
+	my ($uri, $count, $wait) = @_;
+	my @sockets;
+
+	for (0 .. $count - 1) {
+		$sockets[$_] = http_get($uri, start => 1);
+		IO::Select->new($sockets[$_])->can_read($wait) if $wait;
+	}
+
+	return @sockets;
+}
+
+sub http_end_multi {
+	my ($sockets) = @_;
+	my %ports;
+
+	for my $sock (@$sockets) {
+		if (http_end($sock) =~ /X-Port: (\d+)/) {
+			$ports{$1} = 0 unless defined $ports{$1};
+			$ports{$1}++;
+		}
+		close $sock;
+	}
+
+	my @keys = map { my $p = $_; grep { $p == $_ } keys %ports } @ports;
+	return join ', ', map { $_ . ": " . $ports{$_} } @keys;
+}
+
+###############################################################################
+
+sub http_daemon {
+	my (@ports) = @_;
+	my (@socks, @clients);
+
+	for my $port (@ports) {
+		my $server = IO::Socket::INET->new(
+			Proto => 'tcp',
+			LocalHost => "127.0.0.1:$port",
+			Listen => 42,
+			Reuse => 1
+		)
+			or die "Can't create listening socket: $!\n";
+		push @socks, $server;
+	}
+
+	my $sel = IO::Select->new(@socks);
+	my $skip = 4;
+	my $count = 0;
+
+	local $SIG{PIPE} = 'IGNORE';
+
+OUTER:
+	while (my @ready = $sel->can_read) {
+		foreach my $fh (@ready) {
+			if (grep $_ == $fh, @socks) {
+				my $new = $fh->accept;
+				$new->autoflush(1);
+				$sel->add($new);
+				$count++;
+
+			} else {
+				my @busy = grep { $_->sockport() } @ready;
+
+				# finish other handles
+				if ($fh->sockport() == port(8085) && @busy > 1
+					&& grep $_->sockport() != port(8085),
+					@busy)
+				{
+					next;
+				}
+
+				# late events in other handles
+				if ($fh->sockport() == port(8085) && @busy == 1
+					&& $count > 1 && $skip-- > 0)
+				{
+					select undef, undef, undef, 0.1;
+					next OUTER;
+				}
+
+				my $rv = process_socket($fh, \@clients);
+				if ($rv == 1) {
+					$sel->remove($fh);
+					$fh->close;
+				}
+				if ($rv == 2) {
+					for (@clients) {
+						$sel->remove($_);
+						$_->close;
+					}
+					$sel->remove($fh);
+					$fh->close;
+					$skip = 4;
+				}
+				$count--;
+			}
+		}
+	}
+}
+
+# Returns true to close connection
+
+sub process_socket {
+	my ($client, $saved) = @_;
+	my $port = $client->sockport();
+
+	my $headers = '';
+	my $uri = '';
+
+	while (<$client>) {
+		$headers .= $_;
+		last if (/^\x0d?\x0a?$/);
+	}
+	return 1 if $headers eq '';
+
+	$uri = $1 if $headers =~ /^\S+\s+([^ ]+)\s+HTTP/i;
+	return 1 if $uri eq '';
+
+	Test::Nginx::log_core('||', "$port: response, 200");
+	print $client <<EOF;
+HTTP/1.1 200 OK
+X-Port: $port
+
+OK
+EOF
+
+	return 2 if $uri =~ /closeall/;
+	return 1 if $uri =~ /close/;
+
+	push @$saved, $client;
+	return 0;
+}
+
+###############################################################################
diff --git a/tests/upstream_random.t b/tests/upstream_random.t
new file mode 100644
index 0000000..67e8ddf
--- /dev/null
+++ b/tests/upstream_random.t
@@ -0,0 +1,267 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for upstream random balancer module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx qw/ :DEFAULT http_end /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy upstream_zone upstream_random/)
+	->plan(12)->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+worker_processes 2;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    upstream u {
+        zone z 1m;
+        random;
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8082;
+        server 127.0.0.1:8083 down;
+    }
+
+    upstream lc {
+        zone lc 1m;
+        random two;
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8082;
+    }
+
+    upstream w {
+        zone w 1m;
+        random two least_conn;
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8082 weight=2;
+    }
+
+    upstream mc {
+        zone mc 1m;
+        random;
+        server 127.0.0.1:8081 max_conns=2;
+        server 127.0.0.1:8082 max_conns=1;
+    }
+
+    upstream mc2 {
+        zone mc 1m;
+        random two;
+        server 127.0.0.1:8081 max_conns=2;
+        server 127.0.0.1:8082 max_conns=1;
+    }
+
+    upstream one {
+        random;
+        server 127.0.0.1:8081;
+    }
+
+    upstream two {
+        random two;
+        server 127.0.0.1:8081;
+    }
+
+    upstream zone {
+        zone z 1m;
+        random;
+        server 127.0.0.1:8081;
+    }
+
+    upstream ztwo {
+        zone z 1m;
+        random two;
+        server 127.0.0.1:8081;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            proxy_pass http://u;
+        }
+
+        location /lc/ {
+            proxy_pass http://lc/;
+        }
+
+        location /w {
+            proxy_pass http://w;
+        }
+
+        location /mc/ {
+            proxy_pass http://mc/;
+        }
+
+        location /mc2/ {
+            proxy_pass http://mc2/;
+        }
+
+        location /one {
+            proxy_pass http://one;
+        }
+
+        location /two {
+            proxy_pass http://two;
+        }
+
+        location /zone {
+            proxy_pass http://zone;
+        }
+
+        location /ztwo {
+            proxy_pass http://ztwo;
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&http_daemon, port(8081));
+$t->run_daemon(\&http_daemon, port(8082));
+$t->run();
+
+$t->waitforsocket('127.0.0.1:' . port(8081));
+$t->waitforsocket('127.0.0.1:' . port(8082));
+
+###############################################################################
+
+my @ports = my ($port1, $port2) = (port(8081), port(8082));
+
+like(http_get('/'), qr/X-Port: ($port1|$port2)/, 'random');
+like(http_get('/lc/'), qr/X-Port: ($port1|$port2)/, 'random two');
+
+my $s = http_get('/lc/w', start => 1, sleep => 0.5);
+my $r = http_get('/lc/');
+my ($p) = http_end($s) =~ /X-Port: (\d+)/;
+like($r, qr/X-Port: (?!$p)/, 'random wait');
+
+SKIP: {
+skip 'long test', 3 unless $ENV{TEST_NGINX_UNSAFE};
+
+is(parallel('/w', 3), "$port1: 1, $port2: 2", 'random weight');
+
+is(parallel('/mc/w', 4), "$port1: 2, $port2: 1", 'max_conns');
+is(parallel('/mc2/w', 4), "$port1: 2, $port2: 1", 'max_conns two');
+
+}
+
+# single variants
+
+like(http_get('/one'), qr/X-Port: $port1/, 'single one');
+like(http_get('/two'), qr/X-Port: $port1/, 'single two');
+like(http_get('/zone'), qr/X-Port: $port1/, 'zone one');
+like(http_get('/ztwo'), qr/X-Port: $port1/, 'zone two');
+
+like(many('/close', 10), qr/$port2: 10/, 'failures');
+like(many('/lc/close', 10), qr/$port2: 10/, 'failures two');
+
+###############################################################################
+
+sub many {
+	my ($uri, $count, %opts) = @_;
+	my %ports;
+
+	for (1 .. $count) {
+		if (http_get($uri) =~ /X-Port: (\d+)/) {
+			$ports{$1} = 0 unless defined $ports{$1};
+			$ports{$1}++;
+		}
+
+		select undef, undef, undef, $opts{delay} if $opts{delay};
+	}
+
+	my @keys = map { my $p = $_; grep { $p == $_ } keys %ports } @ports;
+	return join ', ', map { $_ . ": " . $ports{$_} } @keys;
+}
+
+sub parallel {
+	my ($uri, $n) = @_;
+	my %ports;
+
+	my @s = map { http_get($uri, start => 1, sleep => 0.1) } (1 .. $n);
+
+	for (@s) {
+		if (http_end($_) =~ /X-Port: (\d+)/) {
+			$ports{$1} = 0 unless defined $ports{$1};
+			$ports{$1}++;
+		}
+	}
+
+	my @keys = map { my $p = $_; grep { $p == $_ } keys %ports } @ports;
+	return join ', ', map { $_ . ": " . $ports{$_} } @keys;
+}
+
+###############################################################################
+
+sub http_daemon {
+	my ($port) = @_;
+
+	my $server = IO::Socket::INET->new(
+		Proto => 'tcp',
+		LocalHost => '127.0.0.1',
+		LocalPort => $port,
+		Listen => 5,
+		Reuse => 1
+	)
+		or die "Can't create listening socket: $!\n";
+
+	local $SIG{PIPE} = 'IGNORE';
+
+	while (my $client = $server->accept()) {
+		$client->autoflush(1);
+
+		my $headers = '';
+		my $uri = '';
+
+		while (<$client>) {
+			$headers .= $_;
+			last if (/^\x0d?\x0a?$/);
+		}
+
+		$uri = $1 if $headers =~ /^\S+\s+([^ ]+)\s+HTTP/i;
+
+		if ($uri eq '/w') {
+			Test::Nginx::log_core('||', "$port: sleep(2.5)");
+			select undef, undef, undef, 2.5;
+		}
+
+		if ($uri eq '/close' && $port == port(8081)) {
+			next;
+		}
+
+		Test::Nginx::log_core('||', "$port: response, 200");
+		print $client <<EOF;
+HTTP/1.1 200 OK
+Connection: close
+X-Port: $port
+
+OK
+EOF
+
+		close $client;
+	}
+}
+
+###############################################################################
diff --git a/tests/upstream_zone.t b/tests/upstream_zone.t
new file mode 100644
index 0000000..bc45a34
--- /dev/null
+++ b/tests/upstream_zone.t
@@ -0,0 +1,84 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for upstream zone.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy upstream_zone/)->plan(2)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    upstream u {
+        zone u 1m;
+        server 127.0.0.1:8081;
+    }
+
+    upstream u2 {
+        zone u;
+        server 127.0.0.1:8081 down;
+        server 127.0.0.1:8081 backup down;
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location / {}
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        add_header X-Name $upstream_addr always;
+
+        location / {
+            proxy_pass http://u/;
+        }
+
+        location /down {
+            proxy_pass http://u2/;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('index.html', '');
+$t->run();
+
+###############################################################################
+
+my $p = port(8081);
+
+like(http_get('/'), qr/X-Name: 127.0.0.1:$p/, 'upstream name');
+like(http_get('/down'), qr/X-Name: u2/, 'no live upstreams');
+
+###############################################################################
diff --git a/tests/upstream_zone_ssl.t b/tests/upstream_zone_ssl.t
new file mode 100644
index 0000000..b13def8
--- /dev/null
+++ b/tests/upstream_zone_ssl.t
@@ -0,0 +1,125 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for upstream zone with ssl backend.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy http_ssl upstream_zone/)
+	->has_daemon('openssl')->plan(9)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    upstream u {
+        zone u 1m;
+        server 127.0.0.1:8081;
+    }
+
+    upstream u2 {
+        zone u;
+        server 127.0.0.1:8081 backup;
+        server 127.0.0.1:8082 down;
+    }
+
+    server {
+        listen 127.0.0.1:8081 ssl;
+
+        ssl_certificate_key localhost.key;
+        ssl_certificate localhost.crt;
+        ssl_session_cache builtin;
+
+        location / {
+            add_header X-Session $ssl_session_reused;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        proxy_ssl_session_reuse off;
+
+        location /ssl_reuse {
+            proxy_pass https://u/;
+            proxy_ssl_session_reuse on;
+        }
+
+        location /ssl {
+            proxy_pass https://u/;
+        }
+
+        location /backup_reuse {
+            proxy_pass https://u2/;
+            proxy_ssl_session_reuse on;
+        }
+
+        location /backup {
+            proxy_pass https://u2/;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+$t->write_file('index.html', '');
+
+my $d = $t->testdir();
+
+foreach my $name ('localhost') {
+	system('openssl req -x509 -new '
+		. "-config $d/openssl.conf -subj /CN=$name/ "
+		. "-out $d/$name.crt -keyout $d/$name.key "
+		. ">>$d/openssl.out 2>&1") == 0
+		or die "Can't create certificate for $name: $!\n";
+}
+
+$t->run();
+
+###############################################################################
+
+like(http_get('/ssl'), qr/200 OK.*X-Session: \./s, 'ssl');
+like(http_get('/ssl'), qr/200 OK.*X-Session: \./s, 'ssl 2');
+like(http_get('/ssl_reuse'), qr/200 OK.*X-Session: \./s, 'ssl session new');
+like(http_get('/ssl_reuse'), qr/200 OK.*X-Session: r/s, 'ssl session reused');
+like(http_get('/ssl_reuse'), qr/200 OK.*X-Session: r/s, 'ssl session reused 2');
+
+like(http_get('/backup'), qr/200 OK.*X-Session: \./s, 'backup');
+like(http_get('/backup'), qr/200 OK.*X-Session: \./s, 'backup 2');
+like(http_get('/backup_reuse'), qr/200 OK.*X-Session: \./s, 'backup new');
+like(http_get('/backup_reuse'), qr/200 OK.*X-Session: r/s, 'backup reused');
+
+###############################################################################
diff --git a/tests/userid.t b/tests/userid.t
new file mode 100644
index 0000000..163ba71
--- /dev/null
+++ b/tests/userid.t
@@ -0,0 +1,295 @@
+#!/usr/bin/perl
+
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+
+# Tests for userid filter module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Config;
+use MIME::Base64;
+use Time::Local;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http userid map unix/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    map $args $uid_reset {
+        default      0;
+        value        1;
+        log          log;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        listen       [::1]:%%PORT_8080%%;
+        listen       unix:%%TESTDIR%%/unix.sock;
+        server_name  localhost;
+
+        add_header X-Got $uid_got;
+        add_header X-Reset $uid_reset;
+        add_header X-Set $uid_set;
+        userid on;
+
+        location / {
+            error_log %%TESTDIR%%/error.log debug;
+            error_log %%TESTDIR%%/error_reset.log info;
+        }
+
+        location /name {
+            userid_name test;
+        }
+
+        location /path {
+            userid_path /0123456789;
+
+            location /path/r {
+                userid_path /9876543210;
+            }
+        }
+
+        location /domain {
+            userid_domain test.domain;
+        }
+
+        location /mark_off {
+            userid_mark off;
+        }
+        location /mark_eq {
+            userid_mark =;
+        }
+        location /mark_let {
+            userid_mark t;
+        }
+        location /mark_num {
+            userid_mark 9;
+        }
+
+        location /expires_time {
+            add_header X-Msec $msec;
+            userid_expires 100;
+        }
+        location /expires_max {
+            userid_expires max;
+
+            location /expires_max/off {
+                userid_expires off;
+            }
+        }
+        location /expires_off {
+            userid_expires off;
+        }
+
+        location /p3p {
+            userid_p3p policyref="/w3c/p3p.xml";
+        }
+
+        location /service {
+            userid_service 65534;
+        }
+
+        location /cv1 {
+            userid v1;
+            userid_mark t;
+        }
+
+        location /ip6 {
+            userid off;
+            proxy_pass http://[::1]:%%PORT_8080%%/;
+        }
+
+        location /unix {
+            userid off;
+            proxy_pass http://unix:%%TESTDIR%%/unix.sock:/;
+        }
+
+        location /clog {
+            userid log;
+        }
+
+        location /coff {
+            userid off;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('index.html', '');
+$t->write_file('expires_time', '');
+$t->write_file('service', '');
+$t->write_file('cv1', '');
+$t->write_file('clog', '');
+$t->write_file('coff', '');
+$t->try_run('no inet6 support')->plan(35);
+
+###############################################################################
+
+# userid
+
+like(http_get('/'), qr/Set-Cookie:/, 'cookie on');
+like(http_get('/cv1'), qr/Set-Cookie:/, 'cookie v1');
+unlike(http_get('/clog'), qr/Set-Cookie:/, 'cookie log');
+unlike(http_get('/coff'), qr/Set-Cookie:/, 'cookie off');
+
+# default
+
+my %cookie = get_cookie('/');
+isnt($cookie{'uid'}, undef, 'name default');
+is($cookie{'path'}, '/', 'path default');
+is($cookie{'domain'}, undef, 'domain default');
+is($cookie{'expires'}, undef, 'expires default');
+like($cookie{'uid'}, '/\w+={0,2}$/', 'mark default');
+unlike(http_get('/'), qr/^P3P/m, 'p3p default');
+like(http_get('/'), qr/X-Reset: 0/, 'uid reset variable default');
+
+# name, path, domain and p3p
+
+isnt(get_cookie('/name', 'test'), undef, 'name');
+is(get_cookie('/path', 'path'), '/0123456789', 'path');
+is(get_cookie('/domain', 'domain'), 'test.domain', 'domain');
+like(http_get('/p3p'), qr!P3P: policyref="/w3c/p3p.xml"!, 'p3p');
+
+# mark
+
+like(get_cookie('/mark_off', 'uid'), '/\w+={0,2}$/', 'mark off');
+like(get_cookie('/mark_eq', 'uid'), '/==$/', 'mark equal');
+like(get_cookie('/mark_let', 'uid'), '/t=$/', 'mark letter');
+like(get_cookie('/mark_num', 'uid'), '/9=$/', 'mark number');
+
+# expires
+
+my $r = http_get('/expires_time');
+my ($t1) = $r =~ /X-Msec: (\d+)/;
+is(expires2timegm(cookie($r, 'expires')), $t1 + 100, 'expires time');
+is(get_cookie('/expires_max', 'expires'), 'Thu, 31-Dec-37 23:55:55 GMT',
+	'expires max');
+is(get_cookie('/expires_off', 'expires'), undef, 'expires off');
+
+# redefinition
+
+unlike(http_get('/expires_max/off'), qr/expires/, 'redefine expires');
+like(http_get('/path/r'), qr!/9876543210!, 'redefine path');
+
+# requests
+
+$r = http_get('/');
+my ($uid) = uid_set($r);
+isnt($uid, undef, 'uid set variable');
+
+$r = send_uid('/', cookie($r, 'uid'));
+is(uid_got($r), $uid, 'uid got variable');
+unlike($r, qr/Set-Cookie:/, 'same path request');
+
+$r = send_uid('/coff', $uid);
+unlike($r, qr/Set-Cookie:/, 'other path request');
+
+$r = send_uid('/?value', $uid);
+like($r, qr/Set-Cookie:/, 'uid reset variable value');
+
+# service
+
+is(substr(uid_set(http_get('/cv1')), 0, 8), '00000000', 'service default v1');
+
+my $bigendian = $Config{byteorder} =~ '1234' ? 0 : 1;
+my $addr = $bigendian ? "7F000001" : "0100007F";
+is(substr(uid_set(http_get('/')), 0, 8), $addr, 'service default v2');
+
+$addr = $bigendian ? "0000FFFE" : "FEFF0000";
+is(substr(uid_set(http_get('/service')), 0, 8), $addr, 'service custom');
+
+$addr = $bigendian ? "00000001" : "01000000";
+is(substr(uid_set(http_get('/ip6')), 0, 8), $addr, 'service ipv6');
+
+is(substr(uid_set(http_get('/unix')), 0, 8), "00000000", 'service unix');
+
+# reset log
+
+send_uid('/?log', cookie($r, 'uid'));
+
+$t->stop();
+
+like($t->read_file('error_reset.log'),
+	'/userid cookie "uid=\w+" was reset/m', 'uid reset variable log');
+
+###############################################################################
+
+sub cookie {
+	my ($r, $key) = @_;
+	my %cookie;
+
+	$r =~ /(Set-Cookie:[^\x0d]*).*\x0d\x0a?\x0d/ms;
+	if ($1) {
+		%cookie = $1 =~ /(\w+)=([^;]+)/g;
+	}
+
+	return $cookie{$key} if defined $key;
+	return %cookie;
+}
+
+sub get_cookie {
+	my ($url, $key) = @_;
+	return cookie(http_get($url), $key);
+}
+
+sub expires2timegm {
+	my ($e) = @_;
+	my %months = (Jan => 0, Feb => 1, Mar => 2, Apr => 3, May =>4, Jun => 5,
+		Jul => 6, Aug => 7, Sep => 8, Oct => 9, Nov => 10, Dec => 11);
+
+	my ($w, $date, $time) = split(" ", $e);
+	my ($day, $month, $year) = split("-", $date);
+	my ($hour, $min, $sec) = split(":", $time);
+
+	return timegm($sec, $min, $hour, $day, $months{$month}, $year);
+}
+
+sub uid_set {
+	my ($r) = @_;
+	my ($uid) = $r =~ /X-Set: uid=(.*)\n/m;
+	return $uid;
+}
+
+sub uid_got {
+	my ($r) = @_;
+	my ($uid) = $r =~ /X-Got: uid=(.*)\n/m;
+	return $uid;
+}
+
+sub send_uid {
+	my ($url, $uid) = @_;
+	return http(<<EOF);
+GET $url HTTP/1.0
+Host: localhost
+Cookie: uid=$uid
+
+EOF
+}
+
+###############################################################################
diff --git a/tests/uwsgi.t b/tests/uwsgi.t
new file mode 100644
index 0000000..96da7de
--- /dev/null
+++ b/tests/uwsgi.t
@@ -0,0 +1,127 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Test for uwsgi backend.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http uwsgi/)->has_daemon('uwsgi')->plan(5)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    upstream u {
+        server 127.0.0.1:8081;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            uwsgi_pass 127.0.0.1:8081;
+            uwsgi_param SERVER_PROTOCOL $server_protocol;
+            uwsgi_param HTTP_X_BLAH "blah";
+        }
+
+        location /var {
+            uwsgi_pass $arg_b;
+            uwsgi_param SERVER_PROTOCOL $server_protocol;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('uwsgi_test_app.py', <<END);
+
+def application(env, start_response):
+    start_response('200 OK', [('Content-Type','text/plain')])
+    return b"SEE-THIS"
+
+END
+
+my $uwsgihelp = `uwsgi -h`;
+my @uwsgiopts = ();
+
+if ($uwsgihelp !~ /--wsgi-file/) {
+	# uwsgi has no python support, maybe plugin load is necessary
+	push @uwsgiopts, '--plugin', 'python';
+}
+
+$t->run_daemon('uwsgi', '--socket', '127.0.0.1:' . port(8081), @uwsgiopts,
+	'--wsgi-file', $t->testdir() . '/uwsgi_test_app.py',
+	'--logto', $t->testdir() . '/uwsgi_log');
+
+$t->run();
+
+$t->waitforsocket('127.0.0.1:' . port(8081))
+	or die "Can't start uwsgi";
+
+###############################################################################
+
+like(http_get('/'), qr/SEE-THIS/, 'uwsgi request');
+unlike(http_head('/head'), qr/SEE-THIS/, 'no data in HEAD');
+
+like(http_get_headers('/headers'), qr/SEE-THIS/,
+	'uwsgi request with many ignored headers');
+
+like(http_get('/var?b=127.0.0.1:' . port(8081)), qr/SEE-THIS/,
+	'uwsgi with variables');
+like(http_get('/var?b=u'), qr/SEE-THIS/, 'uwsgi with variables to upstream');
+
+###############################################################################
+
+sub http_get_headers {
+	my ($url, %extra) = @_;
+	return http(<<EOF, %extra);
+GET $url HTTP/1.0
+Host: localhost
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+
+EOF
+}
+
+###############################################################################
diff --git a/tests/worker_shutdown_timeout.t b/tests/worker_shutdown_timeout.t
new file mode 100644
index 0000000..9527c11
--- /dev/null
+++ b/tests/worker_shutdown_timeout.t
@@ -0,0 +1,67 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for worker_shutdown_timeout directive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use IO::Select;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http/)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+worker_shutdown_timeout 10ms;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / { }
+    }
+}
+
+EOF
+
+$t->run()->plan(1);
+
+###############################################################################
+
+my $s = http('', start => 1);
+
+select undef, undef, undef, 0.2;
+
+$t->reload();
+
+if (IO::Select->new($s)->can_read(5)) {
+	Test::Nginx::log_core('||', "select: can_read");
+}
+
+is(http_get('/', socket => $s) || '', '', 'worker_shutdown_timeout');
+
+###############################################################################
diff --git a/tests/worker_shutdown_timeout_h2.t b/tests/worker_shutdown_timeout_h2.t
new file mode 100644
index 0000000..7265dd8
--- /dev/null
+++ b/tests/worker_shutdown_timeout_h2.t
@@ -0,0 +1,93 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for worker_shutdown_timeout and HTTP/2 with proxy.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::HTTP2;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http http_v2 proxy/)->plan(2);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+worker_shutdown_timeout 10ms;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080 http2;
+        server_name  localhost;
+
+        location / {
+            proxy_pass http://127.0.0.1:8081;
+            proxy_read_timeout 5s;
+        }
+    }
+}
+EOF
+
+$t->run_daemon(\&http_silent_daemon);
+$t->run()->waitforsocket('127.0.0.1:' . port(8081));
+
+###############################################################################
+
+my $s = Test::Nginx::HTTP2->new();
+ok($s->new_stream(), 'new stream');
+
+$s->h2_ping('SEE-THIS');
+$s->read(all => [{ type => 'PING' }]);
+
+$t->stop();
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.17.4');
+
+like($t->read_file('access.log'), qr/ (?!504)\d{3} /, 'shutdown timeout');
+
+}
+
+$t->todo_alerts() unless $t->has_version('1.17.4');
+
+###############################################################################
+
+sub http_silent_daemon {
+	my $server = IO::Socket::INET->new(
+		Proto => 'tcp',
+		LocalAddr => '127.0.0.1:' . port(8081),
+		Listen => 5,
+		Reuse => 1
+	)
+		or die "Can't create listening socket: $!\n";
+
+	while (my $client = $server->accept()) {
+		$client->autoflush(1);
+
+		while (<$client>) { }
+	}
+}
+
+###############################################################################
diff --git a/tests/worker_shutdown_timeout_mail.t b/tests/worker_shutdown_timeout_mail.t
new file mode 100644
index 0000000..432bbdd
--- /dev/null
+++ b/tests/worker_shutdown_timeout_mail.t
@@ -0,0 +1,92 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for worker_shutdown_timeout directive within the mail module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use MIME::Base64;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::SMTP;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+local $SIG{PIPE} = 'IGNORE';
+
+my $t = Test::Nginx->new()->has(qw/mail imap http rewrite/)->plan(4)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+worker_shutdown_timeout 10ms;
+
+events {
+}
+
+mail {
+    proxy_pass_error_message  on;
+    auth_http  http://127.0.0.1:8080/mail/auth;
+    xclient    off;
+
+    server {
+        listen     127.0.0.1:8025;
+        protocol   smtp;
+    }
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location = /mail/auth {
+            add_header Auth-Status OK;
+            add_header Auth-Server 127.0.0.1;
+            add_header Auth-Port %%PORT_8026%%;
+            add_header Auth-Wait 1;
+            return 204;
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&Test::Nginx::SMTP::smtp_test_daemon);
+$t->run()->waitforsocket('127.0.0.1:' . port(8026));
+
+###############################################################################
+
+my $s = Test::Nginx::SMTP->new();
+$s->check(qr/^220 /, "greeting");
+
+$s->send('EHLO example.com');
+$s->check(qr/^250 /, "ehlo");
+
+$s->send('AUTH PLAIN ' . encode_base64("\0test\@example.com\0secret", ''));
+$s->authok('auth plain');
+
+$t->reload();
+
+ok($s->can_read(), 'mail connection shutdown');
+
+undef $s;
+1;
+
+###############################################################################
diff --git a/tests/worker_shutdown_timeout_proxy_upgrade.t b/tests/worker_shutdown_timeout_proxy_upgrade.t
new file mode 100644
index 0000000..64d1a67
--- /dev/null
+++ b/tests/worker_shutdown_timeout_proxy_upgrade.t
@@ -0,0 +1,121 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for worker_shutdown_timeout directive with http proxy upgrade stub.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use IO::Select;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy/)->plan(2)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+worker_shutdown_timeout 10ms;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            proxy_pass    http://127.0.0.1:8081;
+            proxy_http_version 1.1;
+            proxy_set_header Upgrade foo;
+            proxy_set_header Connection Upgrade;
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&http_daemon);
+$t->run()->waitforsocket('127.0.0.1:' . port(8081));
+
+###############################################################################
+
+my $s = http(<<EOF, start => 1);
+GET / HTTP/1.1
+Host: localhost
+Upgrade: foo
+Connection: Upgrade
+
+EOF
+
+my ($sel, $buf) = IO::Select->new($s);
+if ($sel->can_read(5)) {
+	$s->sysread($buf, 1024);
+	log_in($buf);
+};
+
+like($buf, qr!HTTP/1.1 101!, 'upgraded connection');
+
+$t->reload();
+
+ok($sel->can_read(3), 'upgraded connection shutdown');
+
+undef $s;
+
+###############################################################################
+
+sub http_daemon {
+	my $server = IO::Socket::INET->new(
+		Proto => 'tcp',
+		LocalHost => '127.0.0.1:' . port(8081),
+		Listen => 5,
+		Reuse => 1
+	)
+		or die "Can't create listening socket: $!\n";
+
+	local $SIG{PIPE} = 'IGNORE';
+
+	my $client;
+
+	while ($client = $server->accept()) {
+		$client->autoflush(1);
+
+		my $headers = '';
+		my $uri = '';
+
+		while (<$client>) {
+			$headers .= $_;
+			last if (/^\x0d?\x0a?$/);
+		}
+
+		next if $headers eq '';
+
+		print $client <<'EOF';
+HTTP/1.1 101 Switching
+Upgrade: foo
+Connection: Upgrade
+
+EOF
+
+	}
+}
+
+###############################################################################
diff --git a/tests/worker_shutdown_timeout_stream.t b/tests/worker_shutdown_timeout_stream.t
new file mode 100644
index 0000000..b7d1951
--- /dev/null
+++ b/tests/worker_shutdown_timeout_stream.t
@@ -0,0 +1,66 @@
+#!/usr/bin/perl
+
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for worker_shutdown_timeout directive within the stream module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::SMTP;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+local $SIG{PIPE} = 'IGNORE';
+
+my $t = Test::Nginx->new()->has(qw/stream/)->plan(3)
+	->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+worker_shutdown_timeout 10ms;
+
+events {
+}
+
+stream {
+    server {
+        listen       127.0.0.1:8025;
+        proxy_pass   127.0.0.1:8026;
+    }
+}
+
+EOF
+
+$t->run_daemon(\&Test::Nginx::SMTP::smtp_test_daemon);
+$t->run()->waitforsocket('127.0.0.1:' . port(8026));
+
+###############################################################################
+
+my $s = Test::Nginx::SMTP->new();
+$s->check(qr/^220 /, "greeting");
+
+$s->send('EHLO example.com');
+$s->check(qr/^250 /, "ehlo");
+
+$t->reload();
+
+ok($s->can_read(), 'stream connection shutdown');
+
+undef $s;
+1;
+
+###############################################################################
diff --git a/tests/xslt.t b/tests/xslt.t
new file mode 100644
index 0000000..1516e97
--- /dev/null
+++ b/tests/xslt.t
@@ -0,0 +1,130 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for nginx xslt filter module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http xslt/)->plan(6);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        default_type text/xml;
+
+        location /x1 {
+            xslt_stylesheet %%TESTDIR%%/test.xslt;
+        }
+        location /x2 {
+            xslt_stylesheet %%TESTDIR%%/test.xslt
+                            param1='value1':param2=/root param3='value%33';
+        }
+        location /x3 {
+            xml_entities %%TESTDIR%%/entities.dtd;
+            xslt_stylesheet %%TESTDIR%%/test.xslt;
+        }
+        location /x4 {
+            xslt_stylesheet %%TESTDIR%%/first.xslt;
+            xslt_stylesheet %%TESTDIR%%/test.xslt;
+        }
+        location /x5 {
+            xslt_stylesheet %%TESTDIR%%/test.xslt
+                            param1='$server_name';
+        }
+    }
+}
+
+EOF
+
+$t->write_file('test.xslt', <<'EOF');
+
+<xsl:stylesheet version="1.0"
+                xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
+
+<xsl:output method="html"/>
+
+<xsl:param name="param1"/>
+<xsl:param name="param2"/>
+<xsl:param name="param3"/>
+
+<xsl:template match="/">
+test xslt result
+param1=<xsl:value-of select="$param1"/>
+param2=<xsl:value-of select="$param2"/>
+param3=<xsl:value-of select="$param3"/>
+data=<xsl:value-of select="/root"/>
+</xsl:template>
+
+</xsl:stylesheet>
+
+EOF
+
+$t->write_file('first.xslt', <<'EOF');
+
+<xsl:stylesheet version="1.0"
+                xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
+
+<xsl:template match="/">
+<root>other <xsl:value-of select="/root"/></root>
+</xsl:template>
+
+</xsl:stylesheet>
+
+EOF
+
+$t->write_file('entities.dtd', '<!ENTITY test "test entity">' . "\n");
+$t->write_file('x1', '<empty/>');
+$t->write_file('x2', '<root>data</root>');
+$t->write_file('x3', '<!DOCTYPE root><root>&test;</root>');
+$t->write_file('x4', '<root>data</root>');
+$t->write_file('x5', '<root>data</root>');
+
+$t->run();
+
+###############################################################################
+
+like(http_get("/x1"), qr!200 OK.*test xslt result!ms, 'simple');
+like(http_get("/x1"), qr!200 OK.*Content-Type: text/html!ms, 'content type');
+like(http_get("/x2"), qr!200 OK.*param1=value1.*param2=data.*param3=value3!ms,
+	'params');
+like(http_get("/x3"), qr!200 OK.*data=test entity!ms, 'entities');
+like(http_get("/x4"), qr!200 OK.*data=other data!ms, 'several stylesheets');
+
+TODO: {
+todo_skip 'heap-buffer-overflow', 1 unless $t->has_version('1.17.2')
+	or $ENV{TEST_NGINX_UNSAFE};
+
+like(http_get("/x5"), qr!200 OK.*param1=localhost!ms, 'params variable');
+
+}
+
+###############################################################################
diff --git a/tests/xslt_params.t b/tests/xslt_params.t
new file mode 100644
index 0000000..83493e9
--- /dev/null
+++ b/tests/xslt_params.t
@@ -0,0 +1,106 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+
+# Tests for nginx xslt filter module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http xslt/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        default_type text/xml;
+
+        location /x1 {
+            xslt_stylesheet %%TESTDIR%%/test.xslt
+                            param1='value1':param2=/root param3='value%33';
+        }
+        location /x2 {
+            xslt_stylesheet %%TESTDIR%%/test.xslt;
+            xslt_param param1 "'value1'";
+            xslt_param param2 "/root";
+            xslt_string_param param3 "value3";
+        }
+        location /x3 {
+            xslt_stylesheet %%TESTDIR%%/test.xslt
+                            param1='value1':param2=/root;
+            xslt_string_param param3 "value3";
+        }
+    }
+}
+
+EOF
+
+$t->write_file('test.xslt', <<'EOF');
+
+<xsl:stylesheet version="1.0"
+                xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
+
+<xsl:output method="html"/>
+
+<xsl:param name="param1"/>
+<xsl:param name="param2"/>
+<xsl:param name="param3"/>
+
+<xsl:template match="/">
+param1=<xsl:value-of select="$param1"/>
+param2=<xsl:value-of select="$param2"/>
+param3=<xsl:value-of select="$param3"/>
+</xsl:template>
+
+</xsl:stylesheet>
+
+EOF
+
+$t->write_file('x1', '<root>data</root>');
+$t->write_file('x2', '<root>data</root>');
+$t->write_file('x3', '<root>data</root>');
+
+$t->run()->plan(4);
+
+###############################################################################
+
+like(http_get("/x1"), qr!200 OK.*param1=value1.*param2=data.*param3=value3!ms,
+	'params from xslt_stylesheet');
+
+# before 1.13.7, nginx used to overwrite xslt_stylesheet configuration data
+
+like(http_get("/x1"), qr!200 OK.*param1=value1.*param2=data.*param3=value3!ms,
+	'params from xslt_stylesheet again');
+
+like(http_get("/x2"), qr!200 OK.*param1=value1.*param2=data.*param3=value3!ms,
+	'params from xslt_param/xslt_string_param');
+like(http_get("/x3"), qr!200 OK.*param1=value1.*param2=data.*param3=value3!ms,
+	'mixed');
+
+###############################################################################
-- 
2.39.0

